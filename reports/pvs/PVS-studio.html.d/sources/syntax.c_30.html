
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>syntax.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/*</a>
<a name="ln5"> * syntax.c: code for syntax highlighting</a>
<a name="ln6"> */</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;assert.h&gt;</a>
<a name="ln9">#include &lt;ctype.h&gt;</a>
<a name="ln10">#include &lt;inttypes.h&gt;</a>
<a name="ln11">#include &lt;stdbool.h&gt;</a>
<a name="ln12">#include &lt;string.h&gt;</a>
<a name="ln13">#include &lt;stdlib.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;nvim/vim.h&quot;</a>
<a name="ln16">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln17">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln18">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln19">#include &quot;nvim/charset.h&quot;</a>
<a name="ln20">#include &quot;nvim/cursor_shape.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval.h&quot;</a>
<a name="ln22">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln23">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln24">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln25">#include &quot;nvim/fold.h&quot;</a>
<a name="ln26">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln27">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln28">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln29">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln30">#include &quot;nvim/memline.h&quot;</a>
<a name="ln31">#include &quot;nvim/memory.h&quot;</a>
<a name="ln32">#include &quot;nvim/message.h&quot;</a>
<a name="ln33">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln34">#include &quot;nvim/keymap.h&quot;</a>
<a name="ln35">#include &quot;nvim/garray.h&quot;</a>
<a name="ln36">#include &quot;nvim/option.h&quot;</a>
<a name="ln37">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln38">#include &quot;nvim/path.h&quot;</a>
<a name="ln39">#include &quot;nvim/macros.h&quot;</a>
<a name="ln40">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln41">#include &quot;nvim/screen.h&quot;</a>
<a name="ln42">#include &quot;nvim/sign.h&quot;</a>
<a name="ln43">#include &quot;nvim/strings.h&quot;</a>
<a name="ln44">#include &quot;nvim/syntax_defs.h&quot;</a>
<a name="ln45">#include &quot;nvim/terminal.h&quot;</a>
<a name="ln46">#include &quot;nvim/ui.h&quot;</a>
<a name="ln47">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln48">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln49">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln50"> </a>
<a name="ln51">static bool did_syntax_onoff = false;</a>
<a name="ln52"> </a>
<a name="ln53">/// Structure that stores information about a highlight group.</a>
<a name="ln54">/// The ID of a highlight group is also called group ID.  It is the index in</a>
<a name="ln55">/// the highlight_ga array PLUS ONE.</a>
<a name="ln56">struct hl_group {</a>
<a name="ln57">  char_u      *sg_name;         ///&lt; highlight group name</a>
<a name="ln58">  char_u      *sg_name_u;       ///&lt; uppercase of sg_name</a>
<a name="ln59">  bool sg_cleared;              ///&lt; &quot;hi clear&quot; was used</a>
<a name="ln60">  int sg_attr;                  ///&lt; Screen attr @see ATTR_ENTRY</a>
<a name="ln61">  int sg_link;                  ///&lt; link to this highlight group ID</a>
<a name="ln62">  int sg_deflink;               ///&lt; default link; restored in highlight_clear()</a>
<a name="ln63">  int sg_set;                   ///&lt; combination of flags in \ref SG_SET</a>
<a name="ln64">  sctx_T sg_deflink_sctx;       ///&lt; script where the default link was set</a>
<a name="ln65">  sctx_T sg_script_ctx;         ///&lt; script in which the group was last set</a>
<a name="ln66">  // for terminal UIs</a>
<a name="ln67">  int sg_cterm;                 ///&lt; &quot;cterm=&quot; highlighting attr</a>
<a name="ln68">                                ///&lt; (combination of \ref HlAttrFlags)</a>
<a name="ln69">  int sg_cterm_fg;              ///&lt; terminal fg color number + 1</a>
<a name="ln70">  int sg_cterm_bg;              ///&lt; terminal bg color number + 1</a>
<a name="ln71">  bool sg_cterm_bold;           ///&lt; bold attr was set for light color</a>
<a name="ln72">  // for RGB UIs</a>
<a name="ln73">  int sg_gui;                   ///&lt; &quot;gui=&quot; highlighting attributes</a>
<a name="ln74">                                ///&lt; (combination of \ref HlAttrFlags)</a>
<a name="ln75">  RgbValue sg_rgb_fg;           ///&lt; RGB foreground color</a>
<a name="ln76">  RgbValue sg_rgb_bg;           ///&lt; RGB background color</a>
<a name="ln77">  RgbValue sg_rgb_sp;           ///&lt; RGB special color</a>
<a name="ln78">  char *sg_rgb_fg_name;         ///&lt; RGB foreground color name</a>
<a name="ln79">  char *sg_rgb_bg_name;         ///&lt; RGB background color name</a>
<a name="ln80">  char *sg_rgb_sp_name;         ///&lt; RGB special color name</a>
<a name="ln81"> </a>
<a name="ln82">  int sg_blend;                 ///&lt; blend level (0-100 inclusive), -1 if unset</a>
<a name="ln83">};</a>
<a name="ln84"> </a>
<a name="ln85">/// \addtogroup SG_SET</a>
<a name="ln86">/// @{</a>
<a name="ln87">#define SG_CTERM        2       // cterm has been set</a>
<a name="ln88">#define SG_GUI          4       // gui has been set</a>
<a name="ln89">#define SG_LINK         8       // link has been set</a>
<a name="ln90">/// @}</a>
<a name="ln91"> </a>
<a name="ln92">// builtin |highlight-groups|</a>
<a name="ln93">static garray_T highlight_ga = GA_EMPTY_INIT_VALUE;</a>
<a name="ln94"> </a>
<a name="ln95">static inline struct hl_group * HL_TABLE(void)</a>
<a name="ln96">{</a>
<a name="ln97">  return ((struct hl_group *)((highlight_ga.ga_data)));</a>
<a name="ln98">}</a>
<a name="ln99"> </a>
<a name="ln100">#define MAX_HL_ID       20000   /* maximum value for a highlight ID. */</a>
<a name="ln101"> </a>
<a name="ln102">/* different types of offsets that are possible */</a>
<a name="ln103">#define SPO_MS_OFF      0       /* match  start offset */</a>
<a name="ln104">#define SPO_ME_OFF      1       /* match  end	offset */</a>
<a name="ln105">#define SPO_HS_OFF      2       /* highl. start offset */</a>
<a name="ln106">#define SPO_HE_OFF      3       /* highl. end	offset */</a>
<a name="ln107">#define SPO_RS_OFF      4       /* region start offset */</a>
<a name="ln108">#define SPO_RE_OFF      5       /* region end	offset */</a>
<a name="ln109">#define SPO_LC_OFF      6       /* leading context offset */</a>
<a name="ln110">#define SPO_COUNT       7</a>
<a name="ln111"> </a>
<a name="ln112">/* Flags to indicate an additional string for highlight name completion. */</a>
<a name="ln113">static int include_none = 0;    /* when 1 include &quot;nvim/None&quot; */</a>
<a name="ln114">static int include_default = 0; /* when 1 include &quot;nvim/default&quot; */</a>
<a name="ln115">static int include_link = 0;    /* when 2 include &quot;nvim/link&quot; and &quot;clear&quot; */</a>
<a name="ln116"> </a>
<a name="ln117">/// The &quot;term&quot;, &quot;cterm&quot; and &quot;gui&quot; arguments can be any combination of the</a>
<a name="ln118">/// following names, separated by commas (but no spaces!).</a>
<a name="ln119">static char *(hl_name_table[]) =</a>
<a name="ln120">{ &quot;bold&quot;, &quot;standout&quot;, &quot;underline&quot;, &quot;undercurl&quot;,</a>
<a name="ln121">  &quot;italic&quot;, &quot;reverse&quot;, &quot;inverse&quot;, &quot;strikethrough&quot;, &quot;nocombine&quot;, &quot;NONE&quot; };</a>
<a name="ln122">static int hl_attr_table[] =</a>
<a name="ln123">{ HL_BOLD, HL_STANDOUT, HL_UNDERLINE, HL_UNDERCURL, HL_ITALIC, HL_INVERSE,</a>
<a name="ln124">  HL_INVERSE, HL_STRIKETHROUGH, HL_NOCOMBINE, 0 };</a>
<a name="ln125"> </a>
<a name="ln126">static char e_illegal_arg[] = N_(&quot;E390: Illegal argument: %s&quot;);</a>
<a name="ln127"> </a>
<a name="ln128">// The patterns that are being searched for are stored in a syn_pattern.</a>
<a name="ln129">// A match item consists of one pattern.</a>
<a name="ln130">// A start/end item consists of n start patterns and m end patterns.</a>
<a name="ln131">// A start/skip/end item consists of n start patterns, one skip pattern and m</a>
<a name="ln132">// end patterns.</a>
<a name="ln133">// For the latter two, the patterns are always consecutive: start-skip-end.</a>
<a name="ln134">//</a>
<a name="ln135">// A character offset can be given for the matched text (_m_start and _m_end)</a>
<a name="ln136">// and for the actually highlighted text (_h_start and _h_end).</a>
<a name="ln137">//</a>
<a name="ln138">// Note that ordering of members is optimized to reduce padding.</a>
<a name="ln139">typedef struct syn_pattern {</a>
<a name="ln140">  char sp_type;                         // see SPTYPE_ defines below</a>
<a name="ln141">  bool sp_syncing;                      // this item used for syncing</a>
<a name="ln142">  int16_t sp_syn_match_id;              // highlight group ID of pattern</a>
<a name="ln143">  int16_t sp_off_flags;                 // see below</a>
<a name="ln144">  int sp_offsets[SPO_COUNT];            // offsets</a>
<a name="ln145">  int sp_flags;                         // see HL_ defines below</a>
<a name="ln146">  int sp_cchar;                         // conceal substitute character</a>
<a name="ln147">  int sp_ic;                            // ignore-case flag for sp_prog</a>
<a name="ln148">  int sp_sync_idx;                      // sync item index (syncing only)</a>
<a name="ln149">  int sp_line_id;                       // ID of last line where tried</a>
<a name="ln150">  int sp_startcol;                      // next match in sp_line_id line</a>
<a name="ln151">  int16_t *sp_cont_list;                // cont. group IDs, if non-zero</a>
<a name="ln152">  int16_t *sp_next_list;                // next group IDs, if non-zero</a>
<a name="ln153">  struct sp_syn sp_syn;                 // struct passed to in_id_list()</a>
<a name="ln154">  char_u *sp_pattern;                   // regexp to match, pattern</a>
<a name="ln155">  regprog_T *sp_prog;                   // regexp to match, program</a>
<a name="ln156">  syn_time_T sp_time;</a>
<a name="ln157">} synpat_T;</a>
<a name="ln158"> </a>
<a name="ln159"> </a>
<a name="ln160">typedef struct syn_cluster_S {</a>
<a name="ln161">  char_u *scl_name;         // syntax cluster name</a>
<a name="ln162">  char_u *scl_name_u;       // uppercase of scl_name</a>
<a name="ln163">  int16_t *scl_list;        // IDs in this syntax cluster</a>
<a name="ln164">} syn_cluster_T;</a>
<a name="ln165"> </a>
<a name="ln166">/*</a>
<a name="ln167"> * For the current state we need to remember more than just the idx.</a>
<a name="ln168"> * When si_m_endpos.lnum is 0, the items other than si_idx are unknown.</a>
<a name="ln169"> * (The end positions have the column number of the next char)</a>
<a name="ln170"> */</a>
<a name="ln171">typedef struct state_item {</a>
<a name="ln172">  int si_idx;                           // index of syntax pattern or</a>
<a name="ln173">                                        // KEYWORD_IDX</a>
<a name="ln174">  int si_id;                            // highlight group ID for keywords</a>
<a name="ln175">  int si_trans_id;                      // idem, transparency removed</a>
<a name="ln176">  int si_m_lnum;                        // lnum of the match</a>
<a name="ln177">  int si_m_startcol;                    // starting column of the match</a>
<a name="ln178">  lpos_T si_m_endpos;                   // just after end posn of the match</a>
<a name="ln179">  lpos_T si_h_startpos;                 // start position of the highlighting</a>
<a name="ln180">  lpos_T si_h_endpos;                   // end position of the highlighting</a>
<a name="ln181">  lpos_T si_eoe_pos;                    // end position of end pattern</a>
<a name="ln182">  int si_end_idx;                       // group ID for end pattern or zero</a>
<a name="ln183">  int si_ends;                          // if match ends before si_m_endpos</a>
<a name="ln184">  int si_attr;                          // attributes in this state</a>
<a name="ln185">  long si_flags;                        // HL_HAS_EOL flag in this state, and</a>
<a name="ln186">                                        // HL_SKIP* for si_next_list</a>
<a name="ln187">  int si_seqnr;                         // sequence number</a>
<a name="ln188">  int si_cchar;                         // substitution character for conceal</a>
<a name="ln189">  int16_t *si_cont_list;                // list of contained groups</a>
<a name="ln190">  int16_t *si_next_list;                // nextgroup IDs after this item ends</a>
<a name="ln191">  reg_extmatch_T *si_extmatch;          // \z(...\) matches from start</a>
<a name="ln192">                                        // pattern</a>
<a name="ln193">} stateitem_T;</a>
<a name="ln194"> </a>
<a name="ln195">/*</a>
<a name="ln196"> * Struct to reduce the number of arguments to get_syn_options(), it's used</a>
<a name="ln197"> * very often.</a>
<a name="ln198"> */</a>
<a name="ln199">typedef struct {</a>
<a name="ln200">  int flags;                   // flags for contained and transparent</a>
<a name="ln201">  bool keyword;                // true for &quot;:syn keyword&quot;</a>
<a name="ln202">  int *sync_idx;               // syntax item for &quot;grouphere&quot; argument, NULL</a>
<a name="ln203">                               // if not allowed</a>
<a name="ln204">  bool has_cont_list;          // true if &quot;cont_list&quot; can be used</a>
<a name="ln205">  int16_t *cont_list;          // group IDs for &quot;contains&quot; argument</a>
<a name="ln206">  int16_t *cont_in_list;       // group IDs for &quot;containedin&quot; argument</a>
<a name="ln207">  int16_t *next_list;          // group IDs for &quot;nextgroup&quot; argument</a>
<a name="ln208">} syn_opt_arg_T;</a>
<a name="ln209"> </a>
<a name="ln210">typedef struct {</a>
<a name="ln211">  proftime_T total;</a>
<a name="ln212">  int count;</a>
<a name="ln213">  int match;</a>
<a name="ln214">  proftime_T slowest;</a>
<a name="ln215">  proftime_T average;</a>
<a name="ln216">  int id;</a>
<a name="ln217">  char_u      *pattern;</a>
<a name="ln218">} time_entry_T;</a>
<a name="ln219"> </a>
<a name="ln220">struct name_list {</a>
<a name="ln221">  int flag;</a>
<a name="ln222">  char        *name;</a>
<a name="ln223">};</a>
<a name="ln224"> </a>
<a name="ln225">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln226"># include &quot;syntax.c.generated.h&quot;</a>
<a name="ln227">#endif</a>
<a name="ln228"> </a>
<a name="ln229">static char *(spo_name_tab[SPO_COUNT]) =</a>
<a name="ln230">{&quot;ms=&quot;, &quot;me=&quot;, &quot;hs=&quot;, &quot;he=&quot;, &quot;rs=&quot;, &quot;re=&quot;, &quot;lc=&quot;};</a>
<a name="ln231"> </a>
<a name="ln232">/* The sp_off_flags are computed like this:</a>
<a name="ln233"> * offset from the start of the matched text: (1 &lt;&lt; SPO_XX_OFF)</a>
<a name="ln234"> * offset from the end	 of the matched text: (1 &lt;&lt; (SPO_XX_OFF + SPO_COUNT))</a>
<a name="ln235"> * When both are present, only one is used.</a>
<a name="ln236"> */</a>
<a name="ln237"> </a>
<a name="ln238">#define SPTYPE_MATCH    1       /* match keyword with this group ID */</a>
<a name="ln239">#define SPTYPE_START    2       /* match a regexp, start of item */</a>
<a name="ln240">#define SPTYPE_END      3       /* match a regexp, end of item */</a>
<a name="ln241">#define SPTYPE_SKIP     4       /* match a regexp, skip within item */</a>
<a name="ln242"> </a>
<a name="ln243"> </a>
<a name="ln244">#define SYN_ITEMS(buf)  ((synpat_T *)((buf)-&gt;b_syn_patterns.ga_data))</a>
<a name="ln245"> </a>
<a name="ln246">#define NONE_IDX        -2      /* value of sp_sync_idx for &quot;NONE&quot; */</a>
<a name="ln247"> </a>
<a name="ln248">/*</a>
<a name="ln249"> * Flags for b_syn_sync_flags:</a>
<a name="ln250"> */</a>
<a name="ln251">#define SF_CCOMMENT     0x01    /* sync on a C-style comment */</a>
<a name="ln252">#define SF_MATCH        0x02    /* sync by matching a pattern */</a>
<a name="ln253"> </a>
<a name="ln254">#define SYN_STATE_P(ssp)    ((bufstate_T *)((ssp)-&gt;ga_data))</a>
<a name="ln255"> </a>
<a name="ln256">#define MAXKEYWLEN      80          /* maximum length of a keyword */</a>
<a name="ln257"> </a>
<a name="ln258">/*</a>
<a name="ln259"> * The attributes of the syntax item that has been recognized.</a>
<a name="ln260"> */</a>
<a name="ln261">static int current_attr = 0;        /* attr of current syntax word */</a>
<a name="ln262">static int current_id = 0;          /* ID of current char for syn_get_id() */</a>
<a name="ln263">static int current_trans_id = 0;    /* idem, transparency removed */</a>
<a name="ln264">static int current_flags = 0;</a>
<a name="ln265">static int current_seqnr = 0;</a>
<a name="ln266">static int current_sub_char = 0;</a>
<a name="ln267"> </a>
<a name="ln268">/*</a>
<a name="ln269"> * Methods of combining two clusters</a>
<a name="ln270"> */</a>
<a name="ln271">#define CLUSTER_REPLACE     1   /* replace first list with second */</a>
<a name="ln272">#define CLUSTER_ADD         2   /* add second list to first */</a>
<a name="ln273">#define CLUSTER_SUBTRACT    3   /* subtract second list from first */</a>
<a name="ln274"> </a>
<a name="ln275">#define SYN_CLSTR(buf)  ((syn_cluster_T *)((buf)-&gt;b_syn_clusters.ga_data))</a>
<a name="ln276"> </a>
<a name="ln277">/*</a>
<a name="ln278"> * Syntax group IDs have different types:</a>
<a name="ln279"> *     0 - 19999  normal syntax groups</a>
<a name="ln280"> * 20000 - 20999  ALLBUT indicator (current_syn_inc_tag added)</a>
<a name="ln281"> * 21000 - 21999  TOP indicator (current_syn_inc_tag added)</a>
<a name="ln282"> * 22000 - 22999  CONTAINED indicator (current_syn_inc_tag added)</a>
<a name="ln283"> * 23000 - 32767  cluster IDs (subtract SYNID_CLUSTER for the cluster ID)</a>
<a name="ln284"> */</a>
<a name="ln285">#define SYNID_ALLBUT    MAX_HL_ID   /* syntax group ID for contains=ALLBUT */</a>
<a name="ln286">#define SYNID_TOP       21000       /* syntax group ID for contains=TOP */</a>
<a name="ln287">#define SYNID_CONTAINED 22000       /* syntax group ID for contains=CONTAINED */</a>
<a name="ln288">#define SYNID_CLUSTER   23000       /* first syntax group ID for clusters */</a>
<a name="ln289"> </a>
<a name="ln290">#define MAX_SYN_INC_TAG 999         /* maximum before the above overflow */</a>
<a name="ln291">#define MAX_CLUSTER_ID  (32767 - SYNID_CLUSTER)</a>
<a name="ln292"> </a>
<a name="ln293">/*</a>
<a name="ln294"> * Annoying Hack(TM):  &quot;:syn include&quot; needs this pointer to pass to</a>
<a name="ln295"> * expand_filename().  Most of the other syntax commands don't need it, so</a>
<a name="ln296"> * instead of passing it to them, we stow it here.</a>
<a name="ln297"> */</a>
<a name="ln298">static char_u **syn_cmdlinep;</a>
<a name="ln299"> </a>
<a name="ln300">/*</a>
<a name="ln301"> * Another Annoying Hack(TM):  To prevent rules from other &quot;:syn include&quot;'d</a>
<a name="ln302"> * files from leaking into ALLBUT lists, we assign a unique ID to the</a>
<a name="ln303"> * rules in each &quot;:syn include&quot;'d file.</a>
<a name="ln304"> */</a>
<a name="ln305">static int current_syn_inc_tag = 0;</a>
<a name="ln306">static int running_syn_inc_tag = 0;</a>
<a name="ln307"> </a>
<a name="ln308">/*</a>
<a name="ln309"> * In a hashtable item &quot;hi_key&quot; points to &quot;keyword&quot; in a keyentry.</a>
<a name="ln310"> * This avoids adding a pointer to the hashtable item.</a>
<a name="ln311"> * KE2HIKEY() converts a var pointer to a hashitem key pointer.</a>
<a name="ln312"> * HIKEY2KE() converts a hashitem key pointer to a var pointer.</a>
<a name="ln313"> * HI2KE() converts a hashitem pointer to a var pointer.</a>
<a name="ln314"> */</a>
<a name="ln315">static keyentry_T dumkey;</a>
<a name="ln316">#define KE2HIKEY(kp)  ((kp)-&gt;keyword)</a>
<a name="ln317">#define HIKEY2KE(p)   ((keyentry_T *)((p) - (dumkey.keyword - (char_u *)&amp;dumkey)))</a>
<a name="ln318">#define HI2KE(hi)      HIKEY2KE((hi)-&gt;hi_key)</a>
<a name="ln319"> </a>
<a name="ln320">// -V:HI2KE:782</a>
<a name="ln321"> </a>
<a name="ln322">/*</a>
<a name="ln323"> * To reduce the time spent in keepend(), remember at which level in the state</a>
<a name="ln324"> * stack the first item with &quot;keepend&quot; is present.  When &quot;-1&quot;, there is no</a>
<a name="ln325"> * &quot;keepend&quot; on the stack.</a>
<a name="ln326"> */</a>
<a name="ln327">static int keepend_level = -1;</a>
<a name="ln328"> </a>
<a name="ln329">static char msg_no_items[] = N_(&quot;No Syntax items defined for this buffer&quot;);</a>
<a name="ln330"> </a>
<a name="ln331">// value of si_idx for keywords</a>
<a name="ln332">#define KEYWORD_IDX     -1</a>
<a name="ln333">// valid of si_cont_list for containing all but contained groups</a>
<a name="ln334">#define ID_LIST_ALL     (int16_t *)-1</a>
<a name="ln335"> </a>
<a name="ln336">static int next_seqnr = 1;              /* value to use for si_seqnr */</a>
<a name="ln337"> </a>
<a name="ln338">/*</a>
<a name="ln339"> * The next possible match in the current line for any pattern is remembered,</a>
<a name="ln340"> * to avoid having to try for a match in each column.</a>
<a name="ln341"> * If next_match_idx == -1, not tried (in this line) yet.</a>
<a name="ln342"> * If next_match_col == MAXCOL, no match found in this line.</a>
<a name="ln343"> * (All end positions have the column of the char after the end)</a>
<a name="ln344"> */</a>
<a name="ln345">static int next_match_col;              /* column for start of next match */</a>
<a name="ln346">static lpos_T next_match_m_endpos;      /* position for end of next match */</a>
<a name="ln347">static lpos_T next_match_h_startpos;  /* pos. for highl. start of next match */</a>
<a name="ln348">static lpos_T next_match_h_endpos;      /* pos. for highl. end of next match */</a>
<a name="ln349">static int next_match_idx;              /* index of matched item */</a>
<a name="ln350">static long next_match_flags;           /* flags for next match */</a>
<a name="ln351">static lpos_T next_match_eos_pos;       /* end of start pattn (start region) */</a>
<a name="ln352">static lpos_T next_match_eoe_pos;       /* pos. for end of end pattern */</a>
<a name="ln353">static int next_match_end_idx;          /* ID of group for end pattn or zero */</a>
<a name="ln354">static reg_extmatch_T *next_match_extmatch = NULL;</a>
<a name="ln355"> </a>
<a name="ln356">/*</a>
<a name="ln357"> * A state stack is an array of integers or stateitem_T, stored in a</a>
<a name="ln358"> * garray_T.  A state stack is invalid if its itemsize entry is zero.</a>
<a name="ln359"> */</a>
<a name="ln360">#define INVALID_STATE(ssp)  ((ssp)-&gt;ga_itemsize == 0)</a>
<a name="ln361">#define VALID_STATE(ssp)    ((ssp)-&gt;ga_itemsize != 0)</a>
<a name="ln362"> </a>
<a name="ln363">/*</a>
<a name="ln364"> * The current state (within the line) of the recognition engine.</a>
<a name="ln365"> * When current_state.ga_itemsize is 0 the current state is invalid.</a>
<a name="ln366"> */</a>
<a name="ln367">static win_T    *syn_win;               // current window for highlighting</a>
<a name="ln368">static buf_T    *syn_buf;               // current buffer for highlighting</a>
<a name="ln369">static synblock_T *syn_block;           // current buffer for highlighting</a>
<a name="ln370">static proftime_T *syn_tm;              // timeout limit</a>
<a name="ln371">static linenr_T current_lnum = 0;       // lnum of current state</a>
<a name="ln372">static colnr_T current_col = 0;         // column of current state</a>
<a name="ln373">static int current_state_stored = 0;    // TRUE if stored current state</a>
<a name="ln374">                                        // after setting current_finished</a>
<a name="ln375">static int current_finished = 0;        // current line has been finished</a>
<a name="ln376">static garray_T current_state           // current stack of state_items</a>
<a name="ln377">  = GA_EMPTY_INIT_VALUE;</a>
<a name="ln378">static int16_t *current_next_list = NULL;   // when non-zero, nextgroup list</a>
<a name="ln379">static int current_next_flags = 0;          // flags for current_next_list</a>
<a name="ln380">static int current_line_id = 0;             // unique number for current line</a>
<a name="ln381"> </a>
<a name="ln382">#define CUR_STATE(idx)  ((stateitem_T *)(current_state.ga_data))[idx]</a>
<a name="ln383"> </a>
<a name="ln384">static int syn_time_on = FALSE;</a>
<a name="ln385"># define IF_SYN_TIME(p) (p)</a>
<a name="ln386"> </a>
<a name="ln387">// Set the timeout used for syntax highlighting.</a>
<a name="ln388">// Use NULL to reset, no timeout.</a>
<a name="ln389">void syn_set_timeout(proftime_T *tm)</a>
<a name="ln390">{</a>
<a name="ln391">  syn_tm = tm;</a>
<a name="ln392">}</a>
<a name="ln393"> </a>
<a name="ln394">/*</a>
<a name="ln395"> * Start the syntax recognition for a line.  This function is normally called</a>
<a name="ln396"> * from the screen updating, once for each displayed line.</a>
<a name="ln397"> * The buffer is remembered in syn_buf, because get_syntax_attr() doesn't get</a>
<a name="ln398"> * it.	Careful: curbuf and curwin are likely to point to another buffer and</a>
<a name="ln399"> * window.</a>
<a name="ln400"> */</a>
<a name="ln401">void syntax_start(win_T *wp, linenr_T lnum)</a>
<a name="ln402">{</a>
<a name="ln403">  synstate_T  *p;</a>
<a name="ln404">  synstate_T  *last_valid = NULL;</a>
<a name="ln405">  synstate_T  *last_min_valid = NULL;</a>
<a name="ln406">  synstate_T  *sp, *prev = NULL;</a>
<a name="ln407">  linenr_T parsed_lnum;</a>
<a name="ln408">  linenr_T first_stored;</a>
<a name="ln409">  int dist;</a>
<a name="ln410">  static int changedtick = 0;           /* remember the last change ID */</a>
<a name="ln411"> </a>
<a name="ln412">  current_sub_char = NUL;</a>
<a name="ln413"> </a>
<a name="ln414">  /*</a>
<a name="ln415">   * After switching buffers, invalidate current_state.</a>
<a name="ln416">   * Also do this when a change was made, the current state may be invalid</a>
<a name="ln417">   * then.</a>
<a name="ln418">   */</a>
<a name="ln419">  if (syn_block != wp-&gt;w_s</a>
<a name="ln420">      || syn_buf != wp-&gt;w_buffer</a>
<a name="ln421">      || changedtick != buf_get_changedtick(syn_buf)) {</a>
<a name="ln422">    invalidate_current_state();</a>
<a name="ln423">    syn_buf = wp-&gt;w_buffer;</a>
<a name="ln424">    syn_block = wp-&gt;w_s;</a>
<a name="ln425">  }</a>
<a name="ln426">  changedtick = buf_get_changedtick(syn_buf);</a>
<a name="ln427">  syn_win = wp;</a>
<a name="ln428"> </a>
<a name="ln429">  /*</a>
<a name="ln430">   * Allocate syntax stack when needed.</a>
<a name="ln431">   */</a>
<a name="ln432">  syn_stack_alloc();</a>
<a name="ln433">  if (syn_block-&gt;b_sst_array == NULL)</a>
<a name="ln434">    return;             /* out of memory */</a>
<a name="ln435">  syn_block-&gt;b_sst_lasttick = display_tick;</a>
<a name="ln436"> </a>
<a name="ln437">  /*</a>
<a name="ln438">   * If the state of the end of the previous line is useful, store it.</a>
<a name="ln439">   */</a>
<a name="ln440">  if (VALID_STATE(&amp;current_state)</a>
<a name="ln441">      &amp;&amp; current_lnum &lt; lnum</a>
<a name="ln442">      &amp;&amp; current_lnum &lt; syn_buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln443">    (void)syn_finish_line(false);</a>
<a name="ln444">    if (!current_state_stored) {</a>
<a name="ln445">      ++current_lnum;</a>
<a name="ln446">      (void)store_current_state();</a>
<a name="ln447">    }</a>
<a name="ln448"> </a>
<a name="ln449">    /*</a>
<a name="ln450">     * If the current_lnum is now the same as &quot;lnum&quot;, keep the current</a>
<a name="ln451">     * state (this happens very often!).  Otherwise invalidate</a>
<a name="ln452">     * current_state and figure it out below.</a>
<a name="ln453">     */</a>
<a name="ln454">    if (current_lnum != lnum)</a>
<a name="ln455">      invalidate_current_state();</a>
<a name="ln456">  } else</a>
<a name="ln457">    invalidate_current_state();</a>
<a name="ln458"> </a>
<a name="ln459">  /*</a>
<a name="ln460">   * Try to synchronize from a saved state in b_sst_array[].</a>
<a name="ln461">   * Only do this if lnum is not before and not to far beyond a saved state.</a>
<a name="ln462">   */</a>
<a name="ln463">  if (INVALID_STATE(&amp;current_state) &amp;&amp; syn_block-&gt;b_sst_array != NULL) {</a>
<a name="ln464">    /* Find last valid saved state before start_lnum. */</a>
<a name="ln465">    for (p = syn_block-&gt;b_sst_first; p != NULL; p = p-&gt;sst_next) {</a>
<a name="ln466">      if (p-&gt;sst_lnum &gt; lnum) {</a>
<a name="ln467">        break;</a>
<a name="ln468">      }</a>
<a name="ln469">      if (p-&gt;sst_change_lnum == 0) {</a>
<a name="ln470">        last_valid = p;</a>
<a name="ln471">        if (p-&gt;sst_lnum &gt;= lnum - syn_block-&gt;b_syn_sync_minlines)</a>
<a name="ln472">          last_min_valid = p;</a>
<a name="ln473">      }</a>
<a name="ln474">    }</a>
<a name="ln475">    if (last_min_valid != NULL)</a>
<a name="ln476">      load_current_state(last_min_valid);</a>
<a name="ln477">  }</a>
<a name="ln478"> </a>
<a name="ln479">  /*</a>
<a name="ln480">   * If &quot;lnum&quot; is before or far beyond a line with a saved state, need to</a>
<a name="ln481">   * re-synchronize.</a>
<a name="ln482">   */</a>
<a name="ln483">  if (INVALID_STATE(&amp;current_state)) {</a>
<a name="ln484">    syn_sync(wp, lnum, last_valid);</a>
<a name="ln485">    if (current_lnum == 1)</a>
<a name="ln486">      /* First line is always valid, no matter &quot;minlines&quot;. */</a>
<a name="ln487">      first_stored = 1;</a>
<a name="ln488">    else</a>
<a name="ln489">      /* Need to parse &quot;minlines&quot; lines before state can be considered</a>
<a name="ln490">       * valid to store. */</a>
<a name="ln491">      first_stored = current_lnum + syn_block-&gt;b_syn_sync_minlines;</a>
<a name="ln492">  } else</a>
<a name="ln493">    first_stored = current_lnum;</a>
<a name="ln494"> </a>
<a name="ln495">  /*</a>
<a name="ln496">   * Advance from the sync point or saved state until the current line.</a>
<a name="ln497">   * Save some entries for syncing with later on.</a>
<a name="ln498">   */</a>
<a name="ln499">  if (syn_block-&gt;b_sst_len &lt;= Rows)</a>
<a name="ln500">    dist = 999999;</a>
<a name="ln501">  else</a>
<a name="ln502">    dist = syn_buf-&gt;b_ml.ml_line_count / (syn_block-&gt;b_sst_len - Rows) + 1;</a>
<a name="ln503">  while (current_lnum &lt; lnum) {</a>
<a name="ln504">    syn_start_line();</a>
<a name="ln505">    (void)syn_finish_line(false);</a>
<a name="ln506">    current_lnum++;</a>
<a name="ln507"> </a>
<a name="ln508">    /* If we parsed at least &quot;minlines&quot; lines or started at a valid</a>
<a name="ln509">     * state, the current state is considered valid. */</a>
<a name="ln510">    if (current_lnum &gt;= first_stored) {</a>
<a name="ln511">      /* Check if the saved state entry is for the current line and is</a>
<a name="ln512">       * equal to the current state.  If so, then validate all saved</a>
<a name="ln513">       * states that depended on a change before the parsed line. */</a>
<a name="ln514">      if (prev == NULL)</a>
<a name="ln515">        prev = syn_stack_find_entry(current_lnum - 1);</a>
<a name="ln516">      if (prev == NULL)</a>
<a name="ln517">        sp = syn_block-&gt;b_sst_first;</a>
<a name="ln518">      else</a>
<a name="ln519">        sp = prev;</a>
<a name="ln520">      while (sp != NULL &amp;&amp; sp-&gt;sst_lnum &lt; current_lnum)</a>
<a name="ln521">        sp = sp-&gt;sst_next;</a>
<a name="ln522">      if (sp != NULL</a>
<a name="ln523">          &amp;&amp; sp-&gt;sst_lnum == current_lnum</a>
<a name="ln524">          &amp;&amp; syn_stack_equal(sp)) {</a>
<a name="ln525">        parsed_lnum = current_lnum;</a>
<a name="ln526">        prev = sp;</a>
<a name="ln527">        while (sp != NULL &amp;&amp; sp-&gt;sst_change_lnum &lt;= parsed_lnum) {</a>
<a name="ln528">          if (sp-&gt;sst_lnum &lt;= lnum)</a>
<a name="ln529">            /* valid state before desired line, use this one */</a>
<a name="ln530">            prev = sp;</a>
<a name="ln531">          else if (sp-&gt;sst_change_lnum == 0)</a>
<a name="ln532">            /* past saved states depending on change, break here. */</a>
<a name="ln533">            break;</a>
<a name="ln534">          sp-&gt;sst_change_lnum = 0;</a>
<a name="ln535">          sp = sp-&gt;sst_next;</a>
<a name="ln536">        }</a>
<a name="ln537">        load_current_state(prev);</a>
<a name="ln538">      }</a>
<a name="ln539">      /* Store the state at this line when it's the first one, the line</a>
<a name="ln540">       * where we start parsing, or some distance from the previously</a>
<a name="ln541">       * saved state.  But only when parsed at least 'minlines'. */</a>
<a name="ln542">      else if (prev == NULL</a>
<a name="ln543">               || current_lnum == lnum</a>
<a name="ln544">               || current_lnum &gt;= prev-&gt;sst_lnum + dist)</a>
<a name="ln545">        prev = store_current_state();</a>
<a name="ln546">    }</a>
<a name="ln547"> </a>
<a name="ln548">    /* This can take a long time: break when CTRL-C pressed.  The current</a>
<a name="ln549">     * state will be wrong then. */</a>
<a name="ln550">    line_breakcheck();</a>
<a name="ln551">    if (got_int) {</a>
<a name="ln552">      current_lnum = lnum;</a>
<a name="ln553">      break;</a>
<a name="ln554">    }</a>
<a name="ln555">  }</a>
<a name="ln556"> </a>
<a name="ln557">  syn_start_line();</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560">/*</a>
<a name="ln561"> * We cannot simply discard growarrays full of state_items or buf_states; we</a>
<a name="ln562"> * have to manually release their extmatch pointers first.</a>
<a name="ln563"> */</a>
<a name="ln564">static void clear_syn_state(synstate_T *p)</a>
<a name="ln565">{</a>
<a name="ln566">  if (p-&gt;sst_stacksize &gt; SST_FIX_STATES) {</a>
<a name="ln567">#   define UNREF_BUFSTATE_EXTMATCH(bs) unref_extmatch((bs)-&gt;bs_extmatch)</a>
<a name="ln568">    GA_DEEP_CLEAR(&amp;(p-&gt;sst_union.sst_ga), bufstate_T, UNREF_BUFSTATE_EXTMATCH);</a>
<a name="ln569">  } else {</a>
<a name="ln570">    for (int i = 0; i &lt; p-&gt;sst_stacksize; i++) {</a>
<a name="ln571">      unref_extmatch(p-&gt;sst_union.sst_stack[i].bs_extmatch);</a>
<a name="ln572">    }</a>
<a name="ln573">  }</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">/*</a>
<a name="ln577"> * Cleanup the current_state stack.</a>
<a name="ln578"> */</a>
<a name="ln579">static void clear_current_state(void)</a>
<a name="ln580">{</a>
<a name="ln581"># define UNREF_STATEITEM_EXTMATCH(si) unref_extmatch((si)-&gt;si_extmatch)</a>
<a name="ln582">  GA_DEEP_CLEAR(&amp;current_state, stateitem_T, UNREF_STATEITEM_EXTMATCH);</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585">/*</a>
<a name="ln586"> * Try to find a synchronisation point for line &quot;lnum&quot;.</a>
<a name="ln587"> *</a>
<a name="ln588"> * This sets current_lnum and the current state.  One of three methods is</a>
<a name="ln589"> * used:</a>
<a name="ln590"> * 1. Search backwards for the end of a C-comment.</a>
<a name="ln591"> * 2. Search backwards for given sync patterns.</a>
<a name="ln592"> * 3. Simply start on a given number of lines above &quot;lnum&quot;.</a>
<a name="ln593"> */</a>
<a name="ln594">static void syn_sync(win_T *wp, linenr_T start_lnum, synstate_T *last_valid)</a>
<a name="ln595">{</a>
<a name="ln596">  buf_T       *curbuf_save;</a>
<a name="ln597">  win_T       *curwin_save;</a>
<a name="ln598">  pos_T cursor_save;</a>
<a name="ln599">  int idx;</a>
<a name="ln600">  linenr_T lnum;</a>
<a name="ln601">  linenr_T end_lnum;</a>
<a name="ln602">  linenr_T break_lnum;</a>
<a name="ln603">  bool had_sync_point;</a>
<a name="ln604">  stateitem_T *cur_si;</a>
<a name="ln605">  synpat_T    *spp;</a>
<a name="ln606">  char_u      *line;</a>
<a name="ln607">  int found_flags = 0;</a>
<a name="ln608">  int found_match_idx = 0;</a>
<a name="ln609">  linenr_T found_current_lnum = 0;</a>
<a name="ln610">  int found_current_col= 0;</a>
<a name="ln611">  lpos_T found_m_endpos;</a>
<a name="ln612">  colnr_T prev_current_col;</a>
<a name="ln613"> </a>
<a name="ln614">  /*</a>
<a name="ln615">   * Clear any current state that might be hanging around.</a>
<a name="ln616">   */</a>
<a name="ln617">  invalidate_current_state();</a>
<a name="ln618"> </a>
<a name="ln619">  /*</a>
<a name="ln620">   * Start at least &quot;minlines&quot; back.  Default starting point for parsing is</a>
<a name="ln621">   * there.</a>
<a name="ln622">   * Start further back, to avoid that scrolling backwards will result in</a>
<a name="ln623">   * resyncing for every line.  Now it resyncs only one out of N lines,</a>
<a name="ln624">   * where N is minlines * 1.5, or minlines * 2 if minlines is small.</a>
<a name="ln625">   * Watch out for overflow when minlines is MAXLNUM.</a>
<a name="ln626">   */</a>
<a name="ln627">  if (syn_block-&gt;b_syn_sync_minlines &gt; start_lnum)</a>
<a name="ln628">    start_lnum = 1;</a>
<a name="ln629">  else {</a>
<a name="ln630">    if (syn_block-&gt;b_syn_sync_minlines == 1)</a>
<a name="ln631">      lnum = 1;</a>
<a name="ln632">    else if (syn_block-&gt;b_syn_sync_minlines &lt; 10)</a>
<a name="ln633">      lnum = syn_block-&gt;b_syn_sync_minlines * 2;</a>
<a name="ln634">    else</a>
<a name="ln635">      lnum = syn_block-&gt;b_syn_sync_minlines * 3 / 2;</a>
<a name="ln636">    if (syn_block-&gt;b_syn_sync_maxlines != 0</a>
<a name="ln637">        &amp;&amp; lnum &gt; syn_block-&gt;b_syn_sync_maxlines)</a>
<a name="ln638">      lnum = syn_block-&gt;b_syn_sync_maxlines;</a>
<a name="ln639">    if (lnum &gt;= start_lnum)</a>
<a name="ln640">      start_lnum = 1;</a>
<a name="ln641">    else</a>
<a name="ln642">      start_lnum -= lnum;</a>
<a name="ln643">  }</a>
<a name="ln644">  current_lnum = start_lnum;</a>
<a name="ln645"> </a>
<a name="ln646">  /*</a>
<a name="ln647">   * 1. Search backwards for the end of a C-style comment.</a>
<a name="ln648">   */</a>
<a name="ln649">  if (syn_block-&gt;b_syn_sync_flags &amp; SF_CCOMMENT) {</a>
<a name="ln650">    /* Need to make syn_buf the current buffer for a moment, to be able to</a>
<a name="ln651">     * use find_start_comment(). */</a>
<a name="ln652">    curwin_save = curwin;</a>
<a name="ln653">    curwin = wp;</a>
<a name="ln654">    curbuf_save = curbuf;</a>
<a name="ln655">    curbuf = syn_buf;</a>
<a name="ln656"> </a>
<a name="ln657">    /*</a>
<a name="ln658">     * Skip lines that end in a backslash.</a>
<a name="ln659">     */</a>
<a name="ln660">    for (; start_lnum &gt; 1; --start_lnum) {</a>
<a name="ln661">      line = ml_get(start_lnum - 1);</a>
<a name="ln662">      if (*line == NUL || *(line + STRLEN(line) - 1) != '\\')</a>
<a name="ln663">        break;</a>
<a name="ln664">    }</a>
<a name="ln665">    current_lnum = start_lnum;</a>
<a name="ln666"> </a>
<a name="ln667">    /* set cursor to start of search */</a>
<a name="ln668">    cursor_save = wp-&gt;w_cursor;</a>
<a name="ln669">    wp-&gt;w_cursor.lnum = start_lnum;</a>
<a name="ln670">    wp-&gt;w_cursor.col = 0;</a>
<a name="ln671"> </a>
<a name="ln672">    /*</a>
<a name="ln673">     * If the line is inside a comment, need to find the syntax item that</a>
<a name="ln674">     * defines the comment.</a>
<a name="ln675">     * Restrict the search for the end of a comment to b_syn_sync_maxlines.</a>
<a name="ln676">     */</a>
<a name="ln677">    if (find_start_comment((int)syn_block-&gt;b_syn_sync_maxlines) != NULL) {</a>
<a name="ln678">      for (idx = syn_block-&gt;b_syn_patterns.ga_len; --idx &gt;= 0; )</a>
<a name="ln679">        if (SYN_ITEMS(syn_block)[idx].sp_syn.id</a>
<a name="ln680">            == syn_block-&gt;b_syn_sync_id</a>
<a name="ln681">            &amp;&amp; SYN_ITEMS(syn_block)[idx].sp_type == SPTYPE_START) {</a>
<a name="ln682">          validate_current_state();</a>
<a name="ln683">          push_current_state(idx);</a>
<a name="ln684">          update_si_attr(current_state.ga_len - 1);</a>
<a name="ln685">          break;</a>
<a name="ln686">        }</a>
<a name="ln687">    }</a>
<a name="ln688"> </a>
<a name="ln689">    /* restore cursor and buffer */</a>
<a name="ln690">    wp-&gt;w_cursor = cursor_save;</a>
<a name="ln691">    curwin = curwin_save;</a>
<a name="ln692">    curbuf = curbuf_save;</a>
<a name="ln693">  }</a>
<a name="ln694">  /*</a>
<a name="ln695">   * 2. Search backwards for given sync patterns.</a>
<a name="ln696">   */</a>
<a name="ln697">  else if (syn_block-&gt;b_syn_sync_flags &amp; SF_MATCH) {</a>
<a name="ln698">    if (syn_block-&gt;b_syn_sync_maxlines != 0</a>
<a name="ln699">        &amp;&amp; start_lnum &gt; syn_block-&gt;b_syn_sync_maxlines)</a>
<a name="ln700">      break_lnum = start_lnum - syn_block-&gt;b_syn_sync_maxlines;</a>
<a name="ln701">    else</a>
<a name="ln702">      break_lnum = 0;</a>
<a name="ln703"> </a>
<a name="ln704">    found_m_endpos.lnum = 0;</a>
<a name="ln705">    found_m_endpos.col = 0;</a>
<a name="ln706">    end_lnum = start_lnum;</a>
<a name="ln707">    lnum = start_lnum;</a>
<a name="ln708">    while (--lnum &gt; break_lnum) {</a>
<a name="ln709">      /* This can take a long time: break when CTRL-C pressed. */</a>
<a name="ln710">      line_breakcheck();</a>
<a name="ln711">      if (got_int) {</a>
<a name="ln712">        invalidate_current_state();</a>
<a name="ln713">        current_lnum = start_lnum;</a>
<a name="ln714">        break;</a>
<a name="ln715">      }</a>
<a name="ln716"> </a>
<a name="ln717">      /* Check if we have run into a valid saved state stack now. */</a>
<a name="ln718">      if (last_valid != NULL &amp;&amp; lnum == last_valid-&gt;sst_lnum) {</a>
<a name="ln719">        load_current_state(last_valid);</a>
<a name="ln720">        break;</a>
<a name="ln721">      }</a>
<a name="ln722"> </a>
<a name="ln723">      /*</a>
<a name="ln724">       * Check if the previous line has the line-continuation pattern.</a>
<a name="ln725">       */</a>
<a name="ln726">      if (lnum &gt; 1 &amp;&amp; syn_match_linecont(lnum - 1))</a>
<a name="ln727">        continue;</a>
<a name="ln728"> </a>
<a name="ln729">      /*</a>
<a name="ln730">       * Start with nothing on the state stack</a>
<a name="ln731">       */</a>
<a name="ln732">      validate_current_state();</a>
<a name="ln733"> </a>
<a name="ln734">      for (current_lnum = lnum; current_lnum &lt; end_lnum; ++current_lnum) {</a>
<a name="ln735">        syn_start_line();</a>
<a name="ln736">        for (;; ) {</a>
<a name="ln737">          had_sync_point = syn_finish_line(true);</a>
<a name="ln738">          // When a sync point has been found, remember where, and</a>
<a name="ln739">          // continue to look for another one, further on in the line.</a>
<a name="ln740">          if (had_sync_point &amp;&amp; current_state.ga_len) {</a>
<a name="ln741">            cur_si = &amp;CUR_STATE(current_state.ga_len - 1);</a>
<a name="ln742">            if (cur_si-&gt;si_m_endpos.lnum &gt; start_lnum) {</a>
<a name="ln743">              /* ignore match that goes to after where started */</a>
<a name="ln744">              current_lnum = end_lnum;</a>
<a name="ln745">              break;</a>
<a name="ln746">            }</a>
<a name="ln747">            if (cur_si-&gt;si_idx &lt; 0) {</a>
<a name="ln748">              /* Cannot happen? */</a>
<a name="ln749">              found_flags = 0;</a>
<a name="ln750">              found_match_idx = KEYWORD_IDX;</a>
<a name="ln751">            } else {</a>
<a name="ln752">              spp = &amp;(SYN_ITEMS(syn_block)[cur_si-&gt;si_idx]);</a>
<a name="ln753">              found_flags = spp-&gt;sp_flags;</a>
<a name="ln754">              found_match_idx = spp-&gt;sp_sync_idx;</a>
<a name="ln755">            }</a>
<a name="ln756">            found_current_lnum = current_lnum;</a>
<a name="ln757">            found_current_col = current_col;</a>
<a name="ln758">            found_m_endpos = cur_si-&gt;si_m_endpos;</a>
<a name="ln759">            /*</a>
<a name="ln760">             * Continue after the match (be aware of a zero-length</a>
<a name="ln761">             * match).</a>
<a name="ln762">             */</a>
<a name="ln763">            if (found_m_endpos.lnum &gt; current_lnum) {</a>
<a name="ln764">              current_lnum = found_m_endpos.lnum;</a>
<a name="ln765">              current_col = found_m_endpos.col;</a>
<a name="ln766">              if (current_lnum &gt;= end_lnum)</a>
<a name="ln767">                break;</a>
<a name="ln768">            } else if (found_m_endpos.col &gt; current_col)</a>
<a name="ln769">              current_col = found_m_endpos.col;</a>
<a name="ln770">            else</a>
<a name="ln771">              ++current_col;</a>
<a name="ln772"> </a>
<a name="ln773">            /* syn_current_attr() will have skipped the check for</a>
<a name="ln774">             * an item that ends here, need to do that now.  Be</a>
<a name="ln775">             * careful not to go past the NUL. */</a>
<a name="ln776">            prev_current_col = current_col;</a>
<a name="ln777">            if (syn_getcurline()[current_col] != NUL)</a>
<a name="ln778">              ++current_col;</a>
<a name="ln779">            check_state_ends();</a>
<a name="ln780">            current_col = prev_current_col;</a>
<a name="ln781">          } else</a>
<a name="ln782">            break;</a>
<a name="ln783">        }</a>
<a name="ln784">      }</a>
<a name="ln785"> </a>
<a name="ln786">      /*</a>
<a name="ln787">       * If a sync point was encountered, break here.</a>
<a name="ln788">       */</a>
<a name="ln789">      if (found_flags) {</a>
<a name="ln790">        /*</a>
<a name="ln791">         * Put the item that was specified by the sync point on the</a>
<a name="ln792">         * state stack.  If there was no item specified, make the</a>
<a name="ln793">         * state stack empty.</a>
<a name="ln794">         */</a>
<a name="ln795">        clear_current_state();</a>
<a name="ln796">        if (found_match_idx &gt;= 0) {</a>
<a name="ln797">          push_current_state(found_match_idx);</a>
<a name="ln798">          update_si_attr(current_state.ga_len - 1);</a>
<a name="ln799">        }</a>
<a name="ln800"> </a>
<a name="ln801">        /*</a>
<a name="ln802">         * When using &quot;grouphere&quot;, continue from the sync point</a>
<a name="ln803">         * match, until the end of the line.  Parsing starts at</a>
<a name="ln804">         * the next line.</a>
<a name="ln805">         * For &quot;groupthere&quot; the parsing starts at start_lnum.</a>
<a name="ln806">         */</a>
<a name="ln807">        if (found_flags &amp; HL_SYNC_HERE) {</a>
<a name="ln808">          if (!GA_EMPTY(&amp;current_state)) {</a>
<a name="ln809">            cur_si = &amp;CUR_STATE(current_state.ga_len - 1);</a>
<a name="ln810">            cur_si-&gt;si_h_startpos.lnum = found_current_lnum;</a>
<a name="ln811">            cur_si-&gt;si_h_startpos.col = found_current_col;</a>
<a name="ln812">            update_si_end(cur_si, (int)current_col, TRUE);</a>
<a name="ln813">            check_keepend();</a>
<a name="ln814">          }</a>
<a name="ln815">          current_col = found_m_endpos.col;</a>
<a name="ln816">          current_lnum = found_m_endpos.lnum;</a>
<a name="ln817">          (void)syn_finish_line(false);</a>
<a name="ln818">          current_lnum++;</a>
<a name="ln819">        } else {</a>
<a name="ln820">          current_lnum = start_lnum;</a>
<a name="ln821">        }</a>
<a name="ln822"> </a>
<a name="ln823">        break;</a>
<a name="ln824">      }</a>
<a name="ln825"> </a>
<a name="ln826">      end_lnum = lnum;</a>
<a name="ln827">      invalidate_current_state();</a>
<a name="ln828">    }</a>
<a name="ln829"> </a>
<a name="ln830">    /* Ran into start of the file or exceeded maximum number of lines */</a>
<a name="ln831">    if (lnum &lt;= break_lnum) {</a>
<a name="ln832">      invalidate_current_state();</a>
<a name="ln833">      current_lnum = break_lnum + 1;</a>
<a name="ln834">    }</a>
<a name="ln835">  }</a>
<a name="ln836"> </a>
<a name="ln837">  validate_current_state();</a>
<a name="ln838">}</a>
<a name="ln839"> </a>
<a name="ln840">static void save_chartab(char_u *chartab)</a>
<a name="ln841">{</a>
<a name="ln842">  if (syn_block-&gt;b_syn_isk != empty_option) {</a>
<a name="ln843">    memmove(chartab, syn_buf-&gt;b_chartab, (size_t)32);</a>
<a name="ln844">    memmove(syn_buf-&gt;b_chartab, syn_win-&gt;w_s-&gt;b_syn_chartab, (size_t)32);</a>
<a name="ln845">  }</a>
<a name="ln846">}</a>
<a name="ln847"> </a>
<a name="ln848">static void restore_chartab(char_u *chartab)</a>
<a name="ln849">{</a>
<a name="ln850">  if (syn_win-&gt;w_s-&gt;b_syn_isk != empty_option) {</a>
<a name="ln851">    memmove(syn_buf-&gt;b_chartab, chartab, (size_t)32);</a>
<a name="ln852">  }</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855">/*</a>
<a name="ln856"> * Return TRUE if the line-continuation pattern matches in line &quot;lnum&quot;.</a>
<a name="ln857"> */</a>
<a name="ln858">static int syn_match_linecont(linenr_T lnum)</a>
<a name="ln859">{</a>
<a name="ln860">  if (syn_block-&gt;b_syn_linecont_prog != NULL) {</a>
<a name="ln861">    regmmatch_T regmatch;</a>
<a name="ln862">    // chartab array for syn iskeyword</a>
<a name="ln863">    char_u buf_chartab[32];</a>
<a name="ln864">    save_chartab(buf_chartab);</a>
<a name="ln865"> </a>
<a name="ln866">    regmatch.rmm_ic = syn_block-&gt;b_syn_linecont_ic;</a>
<a name="ln867">    regmatch.regprog = syn_block-&gt;b_syn_linecont_prog;</a>
<a name="ln868">    int r = syn_regexec(&amp;regmatch, lnum, (colnr_T)0,</a>
<a name="ln869">                        IF_SYN_TIME(&amp;syn_block-&gt;b_syn_linecont_time));</a>
<a name="ln870">    syn_block-&gt;b_syn_linecont_prog = regmatch.regprog;</a>
<a name="ln871"> </a>
<a name="ln872">    restore_chartab(buf_chartab);</a>
<a name="ln873">    return r;</a>
<a name="ln874">  }</a>
<a name="ln875">  return FALSE;</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878">/*</a>
<a name="ln879"> * Prepare the current state for the start of a line.</a>
<a name="ln880"> */</a>
<a name="ln881">static void syn_start_line(void)</a>
<a name="ln882">{</a>
<a name="ln883">  current_finished = FALSE;</a>
<a name="ln884">  current_col = 0;</a>
<a name="ln885"> </a>
<a name="ln886">  /*</a>
<a name="ln887">   * Need to update the end of a start/skip/end that continues from the</a>
<a name="ln888">   * previous line and regions that have &quot;keepend&quot;.</a>
<a name="ln889">   */</a>
<a name="ln890">  if (!GA_EMPTY(&amp;current_state)) {</a>
<a name="ln891">    syn_update_ends(TRUE);</a>
<a name="ln892">    check_state_ends();</a>
<a name="ln893">  }</a>
<a name="ln894"> </a>
<a name="ln895">  next_match_idx = -1;</a>
<a name="ln896">  current_line_id++;</a>
<a name="ln897">  next_seqnr = 1;</a>
<a name="ln898">}</a>
<a name="ln899"> </a>
<a name="ln900">/*</a>
<a name="ln901"> * Check for items in the stack that need their end updated.</a>
<a name="ln902"> * When &quot;startofline&quot; is TRUE the last item is always updated.</a>
<a name="ln903"> * When &quot;startofline&quot; is FALSE the item with &quot;keepend&quot; is forcefully updated.</a>
<a name="ln904"> */</a>
<a name="ln905">static void syn_update_ends(int startofline)</a>
<a name="ln906">{</a>
<a name="ln907">  stateitem_T *cur_si;</a>
<a name="ln908">  int seen_keepend;</a>
<a name="ln909"> </a>
<a name="ln910">  if (startofline) {</a>
<a name="ln911">    /* Check for a match carried over from a previous line with a</a>
<a name="ln912">     * contained region.  The match ends as soon as the region ends. */</a>
<a name="ln913">    for (int i = 0; i &lt; current_state.ga_len; ++i) {</a>
<a name="ln914">      cur_si = &amp;CUR_STATE(i);</a>
<a name="ln915">      if (cur_si-&gt;si_idx &gt;= 0</a>
<a name="ln916">          &amp;&amp; (SYN_ITEMS(syn_block)[cur_si-&gt;si_idx]).sp_type</a>
<a name="ln917">          == SPTYPE_MATCH</a>
<a name="ln918">          &amp;&amp; cur_si-&gt;si_m_endpos.lnum &lt; current_lnum) {</a>
<a name="ln919">        cur_si-&gt;si_flags |= HL_MATCHCONT;</a>
<a name="ln920">        cur_si-&gt;si_m_endpos.lnum = 0;</a>
<a name="ln921">        cur_si-&gt;si_m_endpos.col = 0;</a>
<a name="ln922">        cur_si-&gt;si_h_endpos = cur_si-&gt;si_m_endpos;</a>
<a name="ln923">        cur_si-&gt;si_ends = TRUE;</a>
<a name="ln924">      }</a>
<a name="ln925">    }</a>
<a name="ln926">  }</a>
<a name="ln927"> </a>
<a name="ln928">  /*</a>
<a name="ln929">   * Need to update the end of a start/skip/end that continues from the</a>
<a name="ln930">   * previous line.  And regions that have &quot;keepend&quot;, because they may</a>
<a name="ln931">   * influence contained items.  If we've just removed &quot;extend&quot;</a>
<a name="ln932">   * (startofline == 0) then we should update ends of normal regions</a>
<a name="ln933">   * contained inside &quot;keepend&quot; because &quot;extend&quot; could have extended</a>
<a name="ln934">   * these &quot;keepend&quot; regions as well as contained normal regions.</a>
<a name="ln935">   * Then check for items ending in column 0.</a>
<a name="ln936">   */</a>
<a name="ln937">  int i = current_state.ga_len - 1;</a>
<a name="ln938">  if (keepend_level &gt;= 0)</a>
<a name="ln939">    for (; i &gt; keepend_level; --i)</a>
<a name="ln940">      if (CUR_STATE(i).si_flags &amp; HL_EXTEND)</a>
<a name="ln941">        break;</a>
<a name="ln942"> </a>
<a name="ln943">  seen_keepend = FALSE;</a>
<a name="ln944">  for (; i &lt; current_state.ga_len; ++i) {</a>
<a name="ln945">    cur_si = &amp;CUR_STATE(i);</a>
<a name="ln946">    if ((cur_si-&gt;si_flags &amp; HL_KEEPEND)</a>
<a name="ln947">        || (seen_keepend &amp;&amp; !startofline)</a>
<a name="ln948">        || (i == current_state.ga_len - 1 &amp;&amp; startofline)) {</a>
<a name="ln949">      cur_si-&gt;si_h_startpos.col = 0;            /* start highl. in col 0 */</a>
<a name="ln950">      cur_si-&gt;si_h_startpos.lnum = current_lnum;</a>
<a name="ln951"> </a>
<a name="ln952">      if (!(cur_si-&gt;si_flags &amp; HL_MATCHCONT))</a>
<a name="ln953">        update_si_end(cur_si, (int)current_col, !startofline);</a>
<a name="ln954"> </a>
<a name="ln955">      if (!startofline &amp;&amp; (cur_si-&gt;si_flags &amp; HL_KEEPEND))</a>
<a name="ln956">        seen_keepend = TRUE;</a>
<a name="ln957">    }</a>
<a name="ln958">  }</a>
<a name="ln959">  check_keepend();</a>
<a name="ln960">}</a>
<a name="ln961"> </a>
<a name="ln962">/****************************************</a>
<a name="ln963"> * Handling of the state stack cache.</a>
<a name="ln964"> */</a>
<a name="ln965"> </a>
<a name="ln966">/*</a>
<a name="ln967"> * EXPLANATION OF THE SYNTAX STATE STACK CACHE</a>
<a name="ln968"> *</a>
<a name="ln969"> * To speed up syntax highlighting, the state stack for the start of some</a>
<a name="ln970"> * lines is cached.  These entries can be used to start parsing at that point.</a>
<a name="ln971"> *</a>
<a name="ln972"> * The stack is kept in b_sst_array[] for each buffer.  There is a list of</a>
<a name="ln973"> * valid entries.  b_sst_first points to the first one, then follow sst_next.</a>
<a name="ln974"> * The entries are sorted on line number.  The first entry is often for line 2</a>
<a name="ln975"> * (line 1 always starts with an empty stack).</a>
<a name="ln976"> * There is also a list for free entries.  This construction is used to avoid</a>
<a name="ln977"> * having to allocate and free memory blocks too often.</a>
<a name="ln978"> *</a>
<a name="ln979"> * When making changes to the buffer, this is logged in b_mod_*.  When calling</a>
<a name="ln980"> * update_screen() to update the display, it will call</a>
<a name="ln981"> * syn_stack_apply_changes() for each displayed buffer to adjust the cached</a>
<a name="ln982"> * entries.  The entries which are inside the changed area are removed,</a>
<a name="ln983"> * because they must be recomputed.  Entries below the changed have their line</a>
<a name="ln984"> * number adjusted for deleted/inserted lines, and have their sst_change_lnum</a>
<a name="ln985"> * set to indicate that a check must be made if the changed lines would change</a>
<a name="ln986"> * the cached entry.</a>
<a name="ln987"> *</a>
<a name="ln988"> * When later displaying lines, an entry is stored for each line.  Displayed</a>
<a name="ln989"> * lines are likely to be displayed again, in which case the state at the</a>
<a name="ln990"> * start of the line is needed.</a>
<a name="ln991"> * For not displayed lines, an entry is stored for every so many lines.  These</a>
<a name="ln992"> * entries will be used e.g., when scrolling backwards.  The distance between</a>
<a name="ln993"> * entries depends on the number of lines in the buffer.  For small buffers</a>
<a name="ln994"> * the distance is fixed at SST_DIST, for large buffers there is a fixed</a>
<a name="ln995"> * number of entries SST_MAX_ENTRIES, and the distance is computed.</a>
<a name="ln996"> */</a>
<a name="ln997"> </a>
<a name="ln998">static void syn_stack_free_block(synblock_T *block)</a>
<a name="ln999">{</a>
<a name="ln1000">  synstate_T  *p;</a>
<a name="ln1001"> </a>
<a name="ln1002">  if (block-&gt;b_sst_array != NULL) {</a>
<a name="ln1003">    for (p = block-&gt;b_sst_first; p != NULL; p = p-&gt;sst_next) {</a>
<a name="ln1004">      clear_syn_state(p);</a>
<a name="ln1005">    }</a>
<a name="ln1006">    XFREE_CLEAR(block-&gt;b_sst_array);</a>
<a name="ln1007">    block-&gt;b_sst_first = NULL;</a>
<a name="ln1008">    block-&gt;b_sst_len = 0;</a>
<a name="ln1009">  }</a>
<a name="ln1010">}</a>
<a name="ln1011">/*</a>
<a name="ln1012"> * Free b_sst_array[] for buffer &quot;buf&quot;.</a>
<a name="ln1013"> * Used when syntax items changed to force resyncing everywhere.</a>
<a name="ln1014"> */</a>
<a name="ln1015">void syn_stack_free_all(synblock_T *block)</a>
<a name="ln1016">{</a>
<a name="ln1017">  syn_stack_free_block(block);</a>
<a name="ln1018"> </a>
<a name="ln1019">  /* When using &quot;syntax&quot; fold method, must update all folds. */</a>
<a name="ln1020">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln1021">    if (wp-&gt;w_s == block &amp;&amp; foldmethodIsSyntax(wp)) {</a>
<a name="ln1022">      foldUpdateAll(wp);</a>
<a name="ln1023">    }</a>
<a name="ln1024">  }</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027">/*</a>
<a name="ln1028"> * Allocate the syntax state stack for syn_buf when needed.</a>
<a name="ln1029"> * If the number of entries in b_sst_array[] is much too big or a bit too</a>
<a name="ln1030"> * small, reallocate it.</a>
<a name="ln1031"> * Also used to allocate b_sst_array[] for the first time.</a>
<a name="ln1032"> */</a>
<a name="ln1033">static void syn_stack_alloc(void)</a>
<a name="ln1034">{</a>
<a name="ln1035">  long len;</a>
<a name="ln1036">  synstate_T  *to, *from;</a>
<a name="ln1037">  synstate_T  *sstp;</a>
<a name="ln1038"> </a>
<a name="ln1039">  len = syn_buf-&gt;b_ml.ml_line_count / SST_DIST + Rows * 2;</a>
<a name="ln1040">  if (len &lt; SST_MIN_ENTRIES)</a>
<a name="ln1041">    len = SST_MIN_ENTRIES;</a>
<a name="ln1042">  else if (len &gt; SST_MAX_ENTRIES)</a>
<a name="ln1043">    len = SST_MAX_ENTRIES;</a>
<a name="ln1044">  if (syn_block-&gt;b_sst_len &gt; len * 2 || syn_block-&gt;b_sst_len &lt; len) {</a>
<a name="ln1045">    /* Allocate 50% too much, to avoid reallocating too often. */</a>
<a name="ln1046">    len = syn_buf-&gt;b_ml.ml_line_count;</a>
<a name="ln1047">    len = (len + len / 2) / SST_DIST + Rows * 2;</a>
<a name="ln1048">    if (len &lt; SST_MIN_ENTRIES)</a>
<a name="ln1049">      len = SST_MIN_ENTRIES;</a>
<a name="ln1050">    else if (len &gt; SST_MAX_ENTRIES)</a>
<a name="ln1051">      len = SST_MAX_ENTRIES;</a>
<a name="ln1052"> </a>
<a name="ln1053">    if (syn_block-&gt;b_sst_array != NULL) {</a>
<a name="ln1054">      /* When shrinking the array, cleanup the existing stack.</a>
<a name="ln1055">       * Make sure that all valid entries fit in the new array. */</a>
<a name="ln1056">      while (syn_block-&gt;b_sst_len - syn_block-&gt;b_sst_freecount + 2 &gt; len</a>
<a name="ln1057">             &amp;&amp; syn_stack_cleanup())</a>
<a name="ln1058">        ;</a>
<a name="ln1059">      if (len &lt; syn_block-&gt;b_sst_len - syn_block-&gt;b_sst_freecount + 2)</a>
<a name="ln1060">        len = syn_block-&gt;b_sst_len - syn_block-&gt;b_sst_freecount + 2;</a>
<a name="ln1061">    }</a>
<a name="ln1062"> </a>
<a name="ln1063">    assert(len &gt;= 0);</a>
<a name="ln1064">    sstp = xcalloc(len, sizeof(synstate_T));</a>
<a name="ln1065"> </a>
<a name="ln1066">    to = sstp - 1;</a>
<a name="ln1067">    if (syn_block-&gt;b_sst_array != NULL) {</a>
<a name="ln1068">      /* Move the states from the old array to the new one. */</a>
<a name="ln1069">      for (from = syn_block-&gt;b_sst_first; from != NULL;</a>
<a name="ln1070">           from = from-&gt;sst_next) {</a>
<a name="ln1071">        ++to;</a>
<a name="ln1072">        *to = *from;</a>
<a name="ln1073">        to-&gt;sst_next = to + 1;</a>
<a name="ln1074">      }</a>
<a name="ln1075">    }</a>
<a name="ln1076">    if (to != sstp - 1) {</a>
<a name="ln1077">      to-&gt;sst_next = NULL;</a>
<a name="ln1078">      syn_block-&gt;b_sst_first = sstp;</a>
<a name="ln1079">      syn_block-&gt;b_sst_freecount = len - (int)(to - sstp) - 1;</a>
<a name="ln1080">    } else {</a>
<a name="ln1081">      syn_block-&gt;b_sst_first = NULL;</a>
<a name="ln1082">      syn_block-&gt;b_sst_freecount = len;</a>
<a name="ln1083">    }</a>
<a name="ln1084"> </a>
<a name="ln1085">    /* Create the list of free entries. */</a>
<a name="ln1086">    syn_block-&gt;b_sst_firstfree = to + 1;</a>
<a name="ln1087">    while (++to &lt; sstp + len)</a>
<a name="ln1088">      to-&gt;sst_next = to + 1;</a>
<a name="ln1089">    (sstp + len - 1)-&gt;sst_next = NULL;</a>
<a name="ln1090"> </a>
<a name="ln1091">    xfree(syn_block-&gt;b_sst_array);</a>
<a name="ln1092">    syn_block-&gt;b_sst_array = sstp;</a>
<a name="ln1093">    syn_block-&gt;b_sst_len = len;</a>
<a name="ln1094">  }</a>
<a name="ln1095">}</a>
<a name="ln1096"> </a>
<a name="ln1097">/*</a>
<a name="ln1098"> * Check for changes in a buffer to affect stored syntax states.  Uses the</a>
<a name="ln1099"> * b_mod_* fields.</a>
<a name="ln1100"> * Called from update_screen(), before screen is being updated, once for each</a>
<a name="ln1101"> * displayed buffer.</a>
<a name="ln1102"> */</a>
<a name="ln1103">void syn_stack_apply_changes(buf_T *buf)</a>
<a name="ln1104">{</a>
<a name="ln1105">  syn_stack_apply_changes_block(&amp;buf-&gt;b_s, buf);</a>
<a name="ln1106"> </a>
<a name="ln1107">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln1108">    if ((wp-&gt;w_buffer == buf) &amp;&amp; (wp-&gt;w_s != &amp;buf-&gt;b_s)) {</a>
<a name="ln1109">      syn_stack_apply_changes_block(wp-&gt;w_s, buf);</a>
<a name="ln1110">    }</a>
<a name="ln1111">  }</a>
<a name="ln1112">}</a>
<a name="ln1113"> </a>
<a name="ln1114">static void syn_stack_apply_changes_block(synblock_T *block, buf_T *buf)</a>
<a name="ln1115">{</a>
<a name="ln1116">  synstate_T  *p, *prev, *np;</a>
<a name="ln1117">  linenr_T n;</a>
<a name="ln1118"> </a>
<a name="ln1119">  prev = NULL;</a>
<a name="ln1120">  for (p = block-&gt;b_sst_first; p != NULL; ) {</a>
<a name="ln1121">    if (p-&gt;sst_lnum + block-&gt;b_syn_sync_linebreaks &gt; buf-&gt;b_mod_top) {</a>
<a name="ln1122">      n = p-&gt;sst_lnum + buf-&gt;b_mod_xlines;</a>
<a name="ln1123">      if (n &lt;= buf-&gt;b_mod_bot) {</a>
<a name="ln1124">        /* this state is inside the changed area, remove it */</a>
<a name="ln1125">        np = p-&gt;sst_next;</a>
<a name="ln1126">        if (prev == NULL)</a>
<a name="ln1127">          block-&gt;b_sst_first = np;</a>
<a name="ln1128">        else</a>
<a name="ln1129">          prev-&gt;sst_next = np;</a>
<a name="ln1130">        syn_stack_free_entry(block, p);</a>
<a name="ln1131">        p = np;</a>
<a name="ln1132">        continue;</a>
<a name="ln1133">      }</a>
<a name="ln1134">      /* This state is below the changed area.  Remember the line</a>
<a name="ln1135">       * that needs to be parsed before this entry can be made valid</a>
<a name="ln1136">       * again. */</a>
<a name="ln1137">      if (p-&gt;sst_change_lnum != 0 &amp;&amp; p-&gt;sst_change_lnum &gt; buf-&gt;b_mod_top) {</a>
<a name="ln1138">        if (p-&gt;sst_change_lnum + buf-&gt;b_mod_xlines &gt; buf-&gt;b_mod_top)</a>
<a name="ln1139">          p-&gt;sst_change_lnum += buf-&gt;b_mod_xlines;</a>
<a name="ln1140">        else</a>
<a name="ln1141">          p-&gt;sst_change_lnum = buf-&gt;b_mod_top;</a>
<a name="ln1142">      }</a>
<a name="ln1143">      if (p-&gt;sst_change_lnum == 0</a>
<a name="ln1144">          || p-&gt;sst_change_lnum &lt; buf-&gt;b_mod_bot)</a>
<a name="ln1145">        p-&gt;sst_change_lnum = buf-&gt;b_mod_bot;</a>
<a name="ln1146"> </a>
<a name="ln1147">      p-&gt;sst_lnum = n;</a>
<a name="ln1148">    }</a>
<a name="ln1149">    prev = p;</a>
<a name="ln1150">    p = p-&gt;sst_next;</a>
<a name="ln1151">  }</a>
<a name="ln1152">}</a>
<a name="ln1153"> </a>
<a name="ln1154">/*</a>
<a name="ln1155"> * Reduce the number of entries in the state stack for syn_buf.</a>
<a name="ln1156"> * Returns TRUE if at least one entry was freed.</a>
<a name="ln1157"> */</a>
<a name="ln1158">static int syn_stack_cleanup(void)</a>
<a name="ln1159">{</a>
<a name="ln1160">  synstate_T  *p, *prev;</a>
<a name="ln1161">  disptick_T tick;</a>
<a name="ln1162">  int above;</a>
<a name="ln1163">  int dist;</a>
<a name="ln1164">  int retval = FALSE;</a>
<a name="ln1165"> </a>
<a name="ln1166">  if (syn_block-&gt;b_sst_first == NULL) {</a>
<a name="ln1167">    return retval;</a>
<a name="ln1168">  }</a>
<a name="ln1169"> </a>
<a name="ln1170">  /* Compute normal distance between non-displayed entries. */</a>
<a name="ln1171">  if (syn_block-&gt;b_sst_len &lt;= Rows)</a>
<a name="ln1172">    dist = 999999;</a>
<a name="ln1173">  else</a>
<a name="ln1174">    dist = syn_buf-&gt;b_ml.ml_line_count / (syn_block-&gt;b_sst_len - Rows) + 1;</a>
<a name="ln1175"> </a>
<a name="ln1176">  /*</a>
<a name="ln1177">   * Go through the list to find the &quot;tick&quot; for the oldest entry that can</a>
<a name="ln1178">   * be removed.  Set &quot;above&quot; when the &quot;tick&quot; for the oldest entry is above</a>
<a name="ln1179">   * &quot;b_sst_lasttick&quot; (the display tick wraps around).</a>
<a name="ln1180">   */</a>
<a name="ln1181">  tick = syn_block-&gt;b_sst_lasttick;</a>
<a name="ln1182">  above = FALSE;</a>
<a name="ln1183">  prev = syn_block-&gt;b_sst_first;</a>
<a name="ln1184">  for (p = prev-&gt;sst_next; p != NULL; prev = p, p = p-&gt;sst_next) {</a>
<a name="ln1185">    if (prev-&gt;sst_lnum + dist &gt; p-&gt;sst_lnum) {</a>
<a name="ln1186">      if (p-&gt;sst_tick &gt; syn_block-&gt;b_sst_lasttick) {</a>
<a name="ln1187">        if (!above || p-&gt;sst_tick &lt; tick)</a>
<a name="ln1188">          tick = p-&gt;sst_tick;</a>
<a name="ln1189">        above = TRUE;</a>
<a name="ln1190">      } else if (!above &amp;&amp; p-&gt;sst_tick &lt; tick)</a>
<a name="ln1191">        tick = p-&gt;sst_tick;</a>
<a name="ln1192">    }</a>
<a name="ln1193">  }</a>
<a name="ln1194"> </a>
<a name="ln1195">  /*</a>
<a name="ln1196">   * Go through the list to make the entries for the oldest tick at an</a>
<a name="ln1197">   * interval of several lines.</a>
<a name="ln1198">   */</a>
<a name="ln1199">  prev = syn_block-&gt;b_sst_first;</a>
<a name="ln1200">  for (p = prev-&gt;sst_next; p != NULL; prev = p, p = p-&gt;sst_next) {</a>
<a name="ln1201">    if (p-&gt;sst_tick == tick &amp;&amp; prev-&gt;sst_lnum + dist &gt; p-&gt;sst_lnum) {</a>
<a name="ln1202">      /* Move this entry from used list to free list */</a>
<a name="ln1203">      prev-&gt;sst_next = p-&gt;sst_next;</a>
<a name="ln1204">      syn_stack_free_entry(syn_block, p);</a>
<a name="ln1205">      p = prev;</a>
<a name="ln1206">      retval = TRUE;</a>
<a name="ln1207">    }</a>
<a name="ln1208">  }</a>
<a name="ln1209">  return retval;</a>
<a name="ln1210">}</a>
<a name="ln1211"> </a>
<a name="ln1212">/*</a>
<a name="ln1213"> * Free the allocated memory for a syn_state item.</a>
<a name="ln1214"> * Move the entry into the free list.</a>
<a name="ln1215"> */</a>
<a name="ln1216">static void syn_stack_free_entry(synblock_T *block, synstate_T *p)</a>
<a name="ln1217">{</a>
<a name="ln1218">  clear_syn_state(p);</a>
<a name="ln1219">  p-&gt;sst_next = block-&gt;b_sst_firstfree;</a>
<a name="ln1220">  block-&gt;b_sst_firstfree = p;</a>
<a name="ln1221">  ++block-&gt;b_sst_freecount;</a>
<a name="ln1222">}</a>
<a name="ln1223"> </a>
<a name="ln1224">/*</a>
<a name="ln1225"> * Find an entry in the list of state stacks at or before &quot;lnum&quot;.</a>
<a name="ln1226"> * Returns NULL when there is no entry or the first entry is after &quot;lnum&quot;.</a>
<a name="ln1227"> */</a>
<a name="ln1228">static synstate_T *syn_stack_find_entry(linenr_T lnum)</a>
<a name="ln1229">{</a>
<a name="ln1230">  synstate_T  *p, *prev;</a>
<a name="ln1231"> </a>
<a name="ln1232">  prev = NULL;</a>
<a name="ln1233">  for (p = syn_block-&gt;b_sst_first; p != NULL; prev = p, p = p-&gt;sst_next) {</a>
<a name="ln1234">    if (p-&gt;sst_lnum == lnum)</a>
<a name="ln1235">      return p;</a>
<a name="ln1236">    if (p-&gt;sst_lnum &gt; lnum)</a>
<a name="ln1237">      break;</a>
<a name="ln1238">  }</a>
<a name="ln1239">  return prev;</a>
<a name="ln1240">}</a>
<a name="ln1241"> </a>
<a name="ln1242">/*</a>
<a name="ln1243"> * Try saving the current state in b_sst_array[].</a>
<a name="ln1244"> * The current state must be valid for the start of the current_lnum line!</a>
<a name="ln1245"> */</a>
<a name="ln1246">static synstate_T *store_current_state(void)</a>
<a name="ln1247">{</a>
<a name="ln1248">  int i;</a>
<a name="ln1249">  synstate_T  *p;</a>
<a name="ln1250">  bufstate_T  *bp;</a>
<a name="ln1251">  stateitem_T *cur_si;</a>
<a name="ln1252">  synstate_T  *sp = syn_stack_find_entry(current_lnum);</a>
<a name="ln1253"> </a>
<a name="ln1254">  /*</a>
<a name="ln1255">   * If the current state contains a start or end pattern that continues</a>
<a name="ln1256">   * from the previous line, we can't use it.  Don't store it then.</a>
<a name="ln1257">   */</a>
<a name="ln1258">  for (i = current_state.ga_len - 1; i &gt;= 0; --i) {</a>
<a name="ln1259">    cur_si = &amp;CUR_STATE(i);</a>
<a name="ln1260">    if (cur_si-&gt;si_h_startpos.lnum &gt;= current_lnum</a>
<a name="ln1261">        || cur_si-&gt;si_m_endpos.lnum &gt;= current_lnum</a>
<a name="ln1262">        || cur_si-&gt;si_h_endpos.lnum &gt;= current_lnum</a>
<a name="ln1263">        || (cur_si-&gt;si_end_idx</a>
<a name="ln1264">            &amp;&amp; cur_si-&gt;si_eoe_pos.lnum &gt;= current_lnum))</a>
<a name="ln1265">      break;</a>
<a name="ln1266">  }</a>
<a name="ln1267">  if (i &gt;= 0) {</a>
<a name="ln1268">    if (sp != NULL) {</a>
<a name="ln1269">      /* find &quot;sp&quot; in the list and remove it */</a>
<a name="ln1270">      if (syn_block-&gt;b_sst_first == sp)</a>
<a name="ln1271">        /* it's the first entry */</a>
<a name="ln1272">        syn_block-&gt;b_sst_first = sp-&gt;sst_next;</a>
<a name="ln1273">      else {</a>
<a name="ln1274">        /* find the entry just before this one to adjust sst_next */</a>
<a name="ln1275">        for (p = syn_block-&gt;b_sst_first; p != NULL; p = p-&gt;sst_next)</a>
<a name="ln1276">          if (p-&gt;sst_next == sp)</a>
<a name="ln1277">            break;</a>
<a name="ln1278">        if (p != NULL)          /* just in case */</a>
<a name="ln1279">          p-&gt;sst_next = sp-&gt;sst_next;</a>
<a name="ln1280">      }</a>
<a name="ln1281">      syn_stack_free_entry(syn_block, sp);</a>
<a name="ln1282">      sp = NULL;</a>
<a name="ln1283">    }</a>
<a name="ln1284">  } else if (sp == NULL || sp-&gt;sst_lnum != current_lnum)   {</a>
<a name="ln1285">    /*</a>
<a name="ln1286">     * Add a new entry</a>
<a name="ln1287">     */</a>
<a name="ln1288">    /* If no free items, cleanup the array first. */</a>
<a name="ln1289">    if (syn_block-&gt;b_sst_freecount == 0) {</a>
<a name="ln1290">      (void)syn_stack_cleanup();</a>
<a name="ln1291">      /* &quot;sp&quot; may have been moved to the freelist now */</a>
<a name="ln1292">      sp = syn_stack_find_entry(current_lnum);</a>
<a name="ln1293">    }</a>
<a name="ln1294">    /* Still no free items?  Must be a strange problem... */</a>
<a name="ln1295">    if (syn_block-&gt;b_sst_freecount == 0)</a>
<a name="ln1296">      sp = NULL;</a>
<a name="ln1297">    else {</a>
<a name="ln1298">      /* Take the first item from the free list and put it in the used</a>
<a name="ln1299">       * list, after *sp */</a>
<a name="ln1300">      p = syn_block-&gt;b_sst_firstfree;</a>
<a name="ln1301">      syn_block-&gt;b_sst_firstfree = p-&gt;sst_next;</a>
<a name="ln1302">      --syn_block-&gt;b_sst_freecount;</a>
<a name="ln1303">      if (sp == NULL) {</a>
<a name="ln1304">        /* Insert in front of the list */</a>
<a name="ln1305">        p-&gt;sst_next = syn_block-&gt;b_sst_first;</a>
<a name="ln1306">        syn_block-&gt;b_sst_first = p;</a>
<a name="ln1307">      } else {</a>
<a name="ln1308">        /* insert in list after *sp */</a>
<a name="ln1309">        p-&gt;sst_next = sp-&gt;sst_next;</a>
<a name="ln1310">        sp-&gt;sst_next = p;</a>
<a name="ln1311">      }</a>
<a name="ln1312">      sp = p;</a>
<a name="ln1313">      sp-&gt;sst_stacksize = 0;</a>
<a name="ln1314">      sp-&gt;sst_lnum = current_lnum;</a>
<a name="ln1315">    }</a>
<a name="ln1316">  }</a>
<a name="ln1317">  if (sp != NULL) {</a>
<a name="ln1318">    /* When overwriting an existing state stack, clear it first */</a>
<a name="ln1319">    clear_syn_state(sp);</a>
<a name="ln1320">    sp-&gt;sst_stacksize = current_state.ga_len;</a>
<a name="ln1321">    if (current_state.ga_len &gt; SST_FIX_STATES) {</a>
<a name="ln1322">      /* Need to clear it, might be something remaining from when the</a>
<a name="ln1323">       * length was less than SST_FIX_STATES. */</a>
<a name="ln1324">      ga_init(&amp;sp-&gt;sst_union.sst_ga, (int)sizeof(bufstate_T), 1);</a>
<a name="ln1325">      ga_grow(&amp;sp-&gt;sst_union.sst_ga, current_state.ga_len);</a>
<a name="ln1326">      sp-&gt;sst_union.sst_ga.ga_len = current_state.ga_len;</a>
<a name="ln1327">      bp = SYN_STATE_P(&amp;(sp-&gt;sst_union.sst_ga));</a>
<a name="ln1328">    } else</a>
<a name="ln1329">      bp = sp-&gt;sst_union.sst_stack;</a>
<a name="ln1330">    for (i = 0; i &lt; sp-&gt;sst_stacksize; ++i) {</a>
<a name="ln1331">      bp[i].bs_idx = CUR_STATE(i).si_idx;</a>
<a name="ln1332">      bp[i].bs_flags = CUR_STATE(i).si_flags;</a>
<a name="ln1333">      bp[i].bs_seqnr = CUR_STATE(i).si_seqnr;</a>
<a name="ln1334">      bp[i].bs_cchar = CUR_STATE(i).si_cchar;</a>
<a name="ln1335">      bp[i].bs_extmatch = ref_extmatch(CUR_STATE(i).si_extmatch);</a>
<a name="ln1336">    }</a>
<a name="ln1337">    sp-&gt;sst_next_flags = current_next_flags;</a>
<a name="ln1338">    sp-&gt;sst_next_list = current_next_list;</a>
<a name="ln1339">    sp-&gt;sst_tick = display_tick;</a>
<a name="ln1340">    sp-&gt;sst_change_lnum = 0;</a>
<a name="ln1341">  }</a>
<a name="ln1342">  current_state_stored = TRUE;</a>
<a name="ln1343">  return sp;</a>
<a name="ln1344">}</a>
<a name="ln1345"> </a>
<a name="ln1346">/*</a>
<a name="ln1347"> * Copy a state stack from &quot;from&quot; in b_sst_array[] to current_state;</a>
<a name="ln1348"> */</a>
<a name="ln1349">static void load_current_state(synstate_T *from)</a>
<a name="ln1350">{</a>
<a name="ln1351">  int i;</a>
<a name="ln1352">  bufstate_T  *bp;</a>
<a name="ln1353"> </a>
<a name="ln1354">  clear_current_state();</a>
<a name="ln1355">  validate_current_state();</a>
<a name="ln1356">  keepend_level = -1;</a>
<a name="ln1357">  if (from-&gt;sst_stacksize) {</a>
<a name="ln1358">    ga_grow(&amp;current_state, from-&gt;sst_stacksize);</a>
<a name="ln1359">    if (from-&gt;sst_stacksize &gt; SST_FIX_STATES)</a>
<a name="ln1360">      bp = SYN_STATE_P(&amp;(from-&gt;sst_union.sst_ga));</a>
<a name="ln1361">    else</a>
<a name="ln1362">      bp = from-&gt;sst_union.sst_stack;</a>
<a name="ln1363">    for (i = 0; i &lt; from-&gt;sst_stacksize; ++i) {</a>
<a name="ln1364">      CUR_STATE(i).si_idx = bp[i].bs_idx;</a>
<a name="ln1365">      CUR_STATE(i).si_flags = bp[i].bs_flags;</a>
<a name="ln1366">      CUR_STATE(i).si_seqnr = bp[i].bs_seqnr;</a>
<a name="ln1367">      CUR_STATE(i).si_cchar = bp[i].bs_cchar;</a>
<a name="ln1368">      CUR_STATE(i).si_extmatch = ref_extmatch(bp[i].bs_extmatch);</a>
<a name="ln1369">      if (keepend_level &lt; 0 &amp;&amp; (CUR_STATE(i).si_flags &amp; HL_KEEPEND))</a>
<a name="ln1370">        keepend_level = i;</a>
<a name="ln1371">      CUR_STATE(i).si_ends = FALSE;</a>
<a name="ln1372">      CUR_STATE(i).si_m_lnum = 0;</a>
<a name="ln1373">      if (CUR_STATE(i).si_idx &gt;= 0)</a>
<a name="ln1374">        CUR_STATE(i).si_next_list =</a>
<a name="ln1375">          (SYN_ITEMS(syn_block)[CUR_STATE(i).si_idx]).sp_next_list;</a>
<a name="ln1376">      else</a>
<a name="ln1377">        CUR_STATE(i).si_next_list = NULL;</a>
<a name="ln1378">      update_si_attr(i);</a>
<a name="ln1379">    }</a>
<a name="ln1380">    current_state.ga_len = from-&gt;sst_stacksize;</a>
<a name="ln1381">  }</a>
<a name="ln1382">  current_next_list = from-&gt;sst_next_list;</a>
<a name="ln1383">  current_next_flags = from-&gt;sst_next_flags;</a>
<a name="ln1384">  current_lnum = from-&gt;sst_lnum;</a>
<a name="ln1385">}</a>
<a name="ln1386"> </a>
<a name="ln1387">/*</a>
<a name="ln1388"> * Compare saved state stack &quot;*sp&quot; with the current state.</a>
<a name="ln1389"> * Return TRUE when they are equal.</a>
<a name="ln1390"> */</a>
<a name="ln1391">static int syn_stack_equal(synstate_T *sp)</a>
<a name="ln1392">{</a>
<a name="ln1393">  bufstate_T  *bp;</a>
<a name="ln1394">  reg_extmatch_T      *six, *bsx;</a>
<a name="ln1395"> </a>
<a name="ln1396">  /* First a quick check if the stacks have the same size end nextlist. */</a>
<a name="ln1397">  if (sp-&gt;sst_stacksize != current_state.ga_len</a>
<a name="ln1398">      || sp-&gt;sst_next_list != current_next_list) {</a>
<a name="ln1399">    return FALSE;</a>
<a name="ln1400">  }</a>
<a name="ln1401"> </a>
<a name="ln1402">  /* Need to compare all states on both stacks. */</a>
<a name="ln1403">  if (sp-&gt;sst_stacksize &gt; SST_FIX_STATES)</a>
<a name="ln1404">    bp = SYN_STATE_P(&amp;(sp-&gt;sst_union.sst_ga));</a>
<a name="ln1405">  else</a>
<a name="ln1406">    bp = sp-&gt;sst_union.sst_stack;</a>
<a name="ln1407"> </a>
<a name="ln1408">  int i;</a>
<a name="ln1409">  for (i = current_state.ga_len; --i &gt;= 0; ) {</a>
<a name="ln1410">    /* If the item has another index the state is different. */</a>
<a name="ln1411">    if (bp[i].bs_idx != CUR_STATE(i).si_idx)</a>
<a name="ln1412">      break;</a>
<a name="ln1413">    if (bp[i].bs_extmatch == CUR_STATE(i).si_extmatch) {</a>
<a name="ln1414">      continue;</a>
<a name="ln1415">    }</a>
<a name="ln1416">    /* When the extmatch pointers are different, the strings in</a>
<a name="ln1417">     * them can still be the same.  Check if the extmatch</a>
<a name="ln1418">     * references are equal. */</a>
<a name="ln1419">    bsx = bp[i].bs_extmatch;</a>
<a name="ln1420">    six = CUR_STATE(i).si_extmatch;</a>
<a name="ln1421">    /* If one of the extmatch pointers is NULL the states are</a>
<a name="ln1422">     * different. */</a>
<a name="ln1423">    if (bsx == NULL || six == NULL)</a>
<a name="ln1424">      break;</a>
<a name="ln1425">    int j;</a>
<a name="ln1426">    for (j = 0; j &lt; NSUBEXP; ++j) {</a>
<a name="ln1427">      /* Check each referenced match string. They must all be</a>
<a name="ln1428">       * equal. */</a>
<a name="ln1429">      if (bsx-&gt;matches[j] != six-&gt;matches[j]) {</a>
<a name="ln1430">        /* If the pointer is different it can still be the</a>
<a name="ln1431">         * same text.  Compare the strings, ignore case when</a>
<a name="ln1432">         * the start item has the sp_ic flag set. */</a>
<a name="ln1433">        if (bsx-&gt;matches[j] == NULL || six-&gt;matches[j] == NULL) {</a>
<a name="ln1434">          break;</a>
<a name="ln1435">        }</a>
<a name="ln1436">        if (mb_strcmp_ic((SYN_ITEMS(syn_block)[CUR_STATE(i).si_idx]).sp_ic,</a>
<a name="ln1437">                         (const char *)bsx-&gt;matches[j],</a>
<a name="ln1438">                         (const char *)six-&gt;matches[j]) != 0) {</a>
<a name="ln1439">          break;</a>
<a name="ln1440">        }</a>
<a name="ln1441">      }</a>
<a name="ln1442">    }</a>
<a name="ln1443">    if (j != NSUBEXP)</a>
<a name="ln1444">      break;</a>
<a name="ln1445">  }</a>
<a name="ln1446">  if (i &lt; 0)</a>
<a name="ln1447">    return TRUE;</a>
<a name="ln1448"> </a>
<a name="ln1449">  return FALSE;</a>
<a name="ln1450">}</a>
<a name="ln1451"> </a>
<a name="ln1452">/*</a>
<a name="ln1453"> * We stop parsing syntax above line &quot;lnum&quot;.  If the stored state at or below</a>
<a name="ln1454"> * this line depended on a change before it, it now depends on the line below</a>
<a name="ln1455"> * the last parsed line.</a>
<a name="ln1456"> * The window looks like this:</a>
<a name="ln1457"> *	    line which changed</a>
<a name="ln1458"> *	    displayed line</a>
<a name="ln1459"> *	    displayed line</a>
<a name="ln1460"> * lnum -&gt;  line below window</a>
<a name="ln1461"> */</a>
<a name="ln1462">void syntax_end_parsing(linenr_T lnum)</a>
<a name="ln1463">{</a>
<a name="ln1464">  synstate_T  *sp;</a>
<a name="ln1465"> </a>
<a name="ln1466">  sp = syn_stack_find_entry(lnum);</a>
<a name="ln1467">  if (sp != NULL &amp;&amp; sp-&gt;sst_lnum &lt; lnum)</a>
<a name="ln1468">    sp = sp-&gt;sst_next;</a>
<a name="ln1469"> </a>
<a name="ln1470">  if (sp != NULL &amp;&amp; sp-&gt;sst_change_lnum != 0)</a>
<a name="ln1471">    sp-&gt;sst_change_lnum = lnum;</a>
<a name="ln1472">}</a>
<a name="ln1473"> </a>
<a name="ln1474">/*</a>
<a name="ln1475"> * End of handling of the state stack.</a>
<a name="ln1476"> ****************************************/</a>
<a name="ln1477"> </a>
<a name="ln1478">static void invalidate_current_state(void)</a>
<a name="ln1479">{</a>
<a name="ln1480">  clear_current_state();</a>
<a name="ln1481">  current_state.ga_itemsize = 0;        /* mark current_state invalid */</a>
<a name="ln1482">  current_next_list = NULL;</a>
<a name="ln1483">  keepend_level = -1;</a>
<a name="ln1484">}</a>
<a name="ln1485"> </a>
<a name="ln1486">static void validate_current_state(void)</a>
<a name="ln1487">{</a>
<a name="ln1488">  current_state.ga_itemsize = sizeof(stateitem_T);</a>
<a name="ln1489">  ga_set_growsize(&amp;current_state, 3);</a>
<a name="ln1490">}</a>
<a name="ln1491"> </a>
<a name="ln1492">/*</a>
<a name="ln1493"> * Return TRUE if the syntax at start of lnum changed since last time.</a>
<a name="ln1494"> * This will only be called just after get_syntax_attr() for the previous</a>
<a name="ln1495"> * line, to check if the next line needs to be redrawn too.</a>
<a name="ln1496"> */</a>
<a name="ln1497">int syntax_check_changed(linenr_T lnum)</a>
<a name="ln1498">{</a>
<a name="ln1499">  int retval = TRUE;</a>
<a name="ln1500">  synstate_T  *sp;</a>
<a name="ln1501"> </a>
<a name="ln1502">  /*</a>
<a name="ln1503">   * Check the state stack when:</a>
<a name="ln1504">   * - lnum is just below the previously syntaxed line.</a>
<a name="ln1505">   * - lnum is not before the lines with saved states.</a>
<a name="ln1506">   * - lnum is not past the lines with saved states.</a>
<a name="ln1507">   * - lnum is at or before the last changed line.</a>
<a name="ln1508">   */</a>
<a name="ln1509">  if (VALID_STATE(&amp;current_state) &amp;&amp; lnum == current_lnum + 1) {</a>
<a name="ln1510">    sp = syn_stack_find_entry(lnum);</a>
<a name="ln1511">    if (sp != NULL &amp;&amp; sp-&gt;sst_lnum == lnum) {</a>
<a name="ln1512">      /*</a>
<a name="ln1513">       * finish the previous line (needed when not all of the line was</a>
<a name="ln1514">       * drawn)</a>
<a name="ln1515">       */</a>
<a name="ln1516">      (void)syn_finish_line(false);</a>
<a name="ln1517"> </a>
<a name="ln1518">      /*</a>
<a name="ln1519">       * Compare the current state with the previously saved state of</a>
<a name="ln1520">       * the line.</a>
<a name="ln1521">       */</a>
<a name="ln1522">      if (syn_stack_equal(sp))</a>
<a name="ln1523">        retval = FALSE;</a>
<a name="ln1524"> </a>
<a name="ln1525">      /*</a>
<a name="ln1526">       * Store the current state in b_sst_array[] for later use.</a>
<a name="ln1527">       */</a>
<a name="ln1528">      ++current_lnum;</a>
<a name="ln1529">      (void)store_current_state();</a>
<a name="ln1530">    }</a>
<a name="ln1531">  }</a>
<a name="ln1532"> </a>
<a name="ln1533">  return retval;</a>
<a name="ln1534">}</a>
<a name="ln1535"> </a>
<a name="ln1536">/*</a>
<a name="ln1537"> * Finish the current line.</a>
<a name="ln1538"> * This doesn't return any attributes, it only gets the state at the end of</a>
<a name="ln1539"> * the line.  It can start anywhere in the line, as long as the current state</a>
<a name="ln1540"> * is valid.</a>
<a name="ln1541"> */</a>
<a name="ln1542">static bool</a>
<a name="ln1543">syn_finish_line(</a>
<a name="ln1544">    const bool syncing            // called for syncing</a>
<a name="ln1545">)</a>
<a name="ln1546">{</a>
<a name="ln1547">  while (!current_finished) {</a>
<a name="ln1548">    (void)syn_current_attr(syncing, false, NULL, false);</a>
<a name="ln1549"> </a>
<a name="ln1550">    // When syncing, and found some item, need to check the item.</a>
<a name="ln1551">    if (syncing &amp;&amp; current_state.ga_len) {</a>
<a name="ln1552">      // Check for match with sync item.</a>
<a name="ln1553">      const stateitem_T *const cur_si = &amp;CUR_STATE(current_state.ga_len - 1);</a>
<a name="ln1554">      if (cur_si-&gt;si_idx &gt;= 0</a>
<a name="ln1555">          &amp;&amp; (SYN_ITEMS(syn_block)[cur_si-&gt;si_idx].sp_flags</a>
<a name="ln1556">              &amp; (HL_SYNC_HERE|HL_SYNC_THERE))) {</a>
<a name="ln1557">        return true;</a>
<a name="ln1558">      }</a>
<a name="ln1559"> </a>
<a name="ln1560">      // syn_current_attr() will have skipped the check for an item</a>
<a name="ln1561">      // that ends here, need to do that now.  Be careful not to go</a>
<a name="ln1562">      // past the NUL.</a>
<a name="ln1563">      const colnr_T prev_current_col = current_col;</a>
<a name="ln1564">      if (syn_getcurline()[current_col] != NUL) {</a>
<a name="ln1565">        current_col++;</a>
<a name="ln1566">      }</a>
<a name="ln1567">      check_state_ends();</a>
<a name="ln1568">      current_col = prev_current_col;</a>
<a name="ln1569">    }</a>
<a name="ln1570">    current_col++;</a>
<a name="ln1571">  }</a>
<a name="ln1572">  return false;</a>
<a name="ln1573">}</a>
<a name="ln1574"> </a>
<a name="ln1575">/*</a>
<a name="ln1576"> * Return highlight attributes for next character.</a>
<a name="ln1577"> * Must first call syntax_start() once for the line.</a>
<a name="ln1578"> * &quot;col&quot; is normally 0 for the first use in a line, and increments by one each</a>
<a name="ln1579"> * time.  It's allowed to skip characters and to stop before the end of the</a>
<a name="ln1580"> * line.  But only a &quot;col&quot; after a previously used column is allowed.</a>
<a name="ln1581"> * When &quot;can_spell&quot; is not NULL set it to TRUE when spell-checking should be</a>
<a name="ln1582"> * done.</a>
<a name="ln1583"> */</a>
<a name="ln1584">int</a>
<a name="ln1585">get_syntax_attr(</a>
<a name="ln1586">    const colnr_T col,</a>
<a name="ln1587">    bool *const can_spell,</a>
<a name="ln1588">    const bool keep_state           // keep state of char at &quot;col&quot;</a>
<a name="ln1589">)</a>
<a name="ln1590">{</a>
<a name="ln1591">  int attr = 0;</a>
<a name="ln1592"> </a>
<a name="ln1593">  if (can_spell != NULL)</a>
<a name="ln1594">    /* Default: Only do spelling when there is no @Spell cluster or when</a>
<a name="ln1595">     * &quot;:syn spell toplevel&quot; was used. */</a>
<a name="ln1596">    *can_spell = syn_block-&gt;b_syn_spell == SYNSPL_DEFAULT</a>
<a name="ln1597">                 ? (syn_block-&gt;b_spell_cluster_id == 0)</a>
<a name="ln1598">                 : (syn_block-&gt;b_syn_spell == SYNSPL_TOP);</a>
<a name="ln1599"> </a>
<a name="ln1600">  /* check for out of memory situation */</a>
<a name="ln1601">  if (syn_block-&gt;b_sst_array == NULL)</a>
<a name="ln1602">    return 0;</a>
<a name="ln1603"> </a>
<a name="ln1604">  /* After 'synmaxcol' the attribute is always zero. */</a>
<a name="ln1605">  if (syn_buf-&gt;b_p_smc &gt; 0 &amp;&amp; col &gt;= (colnr_T)syn_buf-&gt;b_p_smc) {</a>
<a name="ln1606">    clear_current_state();</a>
<a name="ln1607">    current_id = 0;</a>
<a name="ln1608">    current_trans_id = 0;</a>
<a name="ln1609">    current_flags = 0;</a>
<a name="ln1610">    current_seqnr = 0;</a>
<a name="ln1611">    return 0;</a>
<a name="ln1612">  }</a>
<a name="ln1613"> </a>
<a name="ln1614">  /* Make sure current_state is valid */</a>
<a name="ln1615">  if (INVALID_STATE(&amp;current_state))</a>
<a name="ln1616">    validate_current_state();</a>
<a name="ln1617"> </a>
<a name="ln1618">  /*</a>
<a name="ln1619">   * Skip from the current column to &quot;col&quot;, get the attributes for &quot;col&quot;.</a>
<a name="ln1620">   */</a>
<a name="ln1621">  while (current_col &lt;= col) {</a>
<a name="ln1622">    attr = syn_current_attr(false, true, can_spell,</a>
<a name="ln1623">                            current_col == col ? keep_state : false);</a>
<a name="ln1624">    current_col++;</a>
<a name="ln1625">  }</a>
<a name="ln1626"> </a>
<a name="ln1627">  return attr;</a>
<a name="ln1628">}</a>
<a name="ln1629"> </a>
<a name="ln1630">/*</a>
<a name="ln1631"> * Get syntax attributes for current_lnum, current_col.</a>
<a name="ln1632"> */</a>
<a name="ln1633">static int syn_current_attr(</a>
<a name="ln1634">    const bool syncing,                   // When true: called for syncing</a>
<a name="ln1635">    const bool displaying,                // result will be displayed</a>
<a name="ln1636">    bool *const can_spell,                // return: do spell checking</a>
<a name="ln1637">    const bool keep_state                 // keep syntax stack afterwards</a>
<a name="ln1638">)</a>
<a name="ln1639">{</a>
<a name="ln1640">  lpos_T endpos;                // was: char_u *endp;</a>
<a name="ln1641">  lpos_T hl_startpos;           // was: int hl_startcol;</a>
<a name="ln1642">  lpos_T hl_endpos;</a>
<a name="ln1643">  lpos_T eos_pos;               // end-of-start match (start region)</a>
<a name="ln1644">  lpos_T eoe_pos;               // end-of-end pattern</a>
<a name="ln1645">  int end_idx;                  // group ID for end pattern</a>
<a name="ln1646">  stateitem_T *cur_si, *sip = NULL;</a>
<a name="ln1647">  int startcol;</a>
<a name="ln1648">  int endcol;</a>
<a name="ln1649">  long flags;</a>
<a name="ln1650">  int cchar;</a>
<a name="ln1651">  int16_t *next_list;</a>
<a name="ln1652">  bool found_match;                         // found usable match</a>
<a name="ln1653">  static bool try_next_column = false;      // must try in next col</a>
<a name="ln1654">  regmmatch_T regmatch;</a>
<a name="ln1655">  lpos_T pos;</a>
<a name="ln1656">  reg_extmatch_T *cur_extmatch = NULL;</a>
<a name="ln1657">  char_u      buf_chartab[32];  // chartab array for syn iskeyword</a>
<a name="ln1658">  char_u      *line;            // current line.  NOTE: becomes invalid after</a>
<a name="ln1659">                                // looking for a pattern match!</a>
<a name="ln1660"> </a>
<a name="ln1661">  // variables for zero-width matches that have a &quot;nextgroup&quot; argument</a>
<a name="ln1662">  bool keep_next_list;</a>
<a name="ln1663">  bool zero_width_next_list = false;</a>
<a name="ln1664">  garray_T zero_width_next_ga;</a>
<a name="ln1665"> </a>
<a name="ln1666">  /*</a>
<a name="ln1667">   * No character, no attributes!  Past end of line?</a>
<a name="ln1668">   * Do try matching with an empty line (could be the start of a region).</a>
<a name="ln1669">   */</a>
<a name="ln1670">  line = syn_getcurline();</a>
<a name="ln1671">  if (line[current_col] == NUL &amp;&amp; current_col != 0) {</a>
<a name="ln1672">    /*</a>
<a name="ln1673">     * If we found a match after the last column, use it.</a>
<a name="ln1674">     */</a>
<a name="ln1675">    if (next_match_idx &gt;= 0 &amp;&amp; next_match_col &gt;= (int)current_col</a>
<a name="ln1676">        &amp;&amp; next_match_col != MAXCOL) {</a>
<a name="ln1677">      (void)push_next_match();</a>
<a name="ln1678">    }</a>
<a name="ln1679"> </a>
<a name="ln1680">    current_finished = TRUE;</a>
<a name="ln1681">    current_state_stored = FALSE;</a>
<a name="ln1682">    return 0;</a>
<a name="ln1683">  }</a>
<a name="ln1684"> </a>
<a name="ln1685">  /* if the current or next character is NUL, we will finish the line now */</a>
<a name="ln1686">  if (line[current_col] == NUL || line[current_col + 1] == NUL) {</a>
<a name="ln1687">    current_finished = TRUE;</a>
<a name="ln1688">    current_state_stored = FALSE;</a>
<a name="ln1689">  }</a>
<a name="ln1690"> </a>
<a name="ln1691">  /*</a>
<a name="ln1692">   * When in the previous column there was a match but it could not be used</a>
<a name="ln1693">   * (empty match or already matched in this column) need to try again in</a>
<a name="ln1694">   * the next column.</a>
<a name="ln1695">   */</a>
<a name="ln1696">  if (try_next_column) {</a>
<a name="ln1697">    next_match_idx = -1;</a>
<a name="ln1698">    try_next_column = false;</a>
<a name="ln1699">  }</a>
<a name="ln1700"> </a>
<a name="ln1701">  // Only check for keywords when not syncing and there are some.</a>
<a name="ln1702">  const bool do_keywords = !syncing</a>
<a name="ln1703">      &amp;&amp; (syn_block-&gt;b_keywtab.ht_used &gt; 0</a>
<a name="ln1704">          || syn_block-&gt;b_keywtab_ic.ht_used &gt; 0);</a>
<a name="ln1705"> </a>
<a name="ln1706">  /* Init the list of zero-width matches with a nextlist.  This is used to</a>
<a name="ln1707">   * avoid matching the same item in the same position twice. */</a>
<a name="ln1708">  ga_init(&amp;zero_width_next_ga, (int)sizeof(int), 10);</a>
<a name="ln1709"> </a>
<a name="ln1710">  // use syntax iskeyword option</a>
<a name="ln1711">  save_chartab(buf_chartab);</a>
<a name="ln1712"> </a>
<a name="ln1713">  /*</a>
<a name="ln1714">   * Repeat matching keywords and patterns, to find contained items at the</a>
<a name="ln1715">   * same column.  This stops when there are no extra matches at the current</a>
<a name="ln1716">   * column.</a>
<a name="ln1717">   */</a>
<a name="ln1718">  do {</a>
<a name="ln1719">    found_match = false;</a>
<a name="ln1720">    keep_next_list = false;</a>
<a name="ln1721">    int syn_id = 0;</a>
<a name="ln1722"> </a>
<a name="ln1723">    /*</a>
<a name="ln1724">     * 1. Check for a current state.</a>
<a name="ln1725">     *    Only when there is no current state, or if the current state may</a>
<a name="ln1726">     *    contain other things, we need to check for keywords and patterns.</a>
<a name="ln1727">     *    Always need to check for contained items if some item has the</a>
<a name="ln1728">     *    &quot;containedin&quot; argument (takes extra time!).</a>
<a name="ln1729">     */</a>
<a name="ln1730">    if (current_state.ga_len)</a>
<a name="ln1731">      cur_si = &amp;CUR_STATE(current_state.ga_len - 1);</a>
<a name="ln1732">    else</a>
<a name="ln1733">      cur_si = NULL;</a>
<a name="ln1734"> </a>
<a name="ln1735">    if (syn_block-&gt;b_syn_containedin || cur_si == NULL</a>
<a name="ln1736">        || cur_si-&gt;si_cont_list != NULL) {</a>
<a name="ln1737">      /*</a>
<a name="ln1738">       * 2. Check for keywords, if on a keyword char after a non-keyword</a>
<a name="ln1739">       *	  char.  Don't do this when syncing.</a>
<a name="ln1740">       */</a>
<a name="ln1741">      if (do_keywords) {</a>
<a name="ln1742">        line = syn_getcurline();</a>
<a name="ln1743">        const char_u *cur_pos = line + current_col;</a>
<a name="ln1744">        if (vim_iswordp_buf(cur_pos, syn_buf)</a>
<a name="ln1745">            &amp;&amp; (current_col == 0 || !vim_iswordp_buf(</a>
<a name="ln1746">                cur_pos - 1 - utf_head_off(line, cur_pos - 1), syn_buf))) {</a>
<a name="ln1747">          syn_id = check_keyword_id(line, (int)current_col, &amp;endcol, &amp;flags,</a>
<a name="ln1748">                                    &amp;next_list, cur_si, &amp;cchar);</a>
<a name="ln1749">          if (syn_id != 0) {</a>
<a name="ln1750">            push_current_state(KEYWORD_IDX);</a>
<a name="ln1751">            {</a>
<a name="ln1752">              cur_si = &amp;CUR_STATE(current_state.ga_len - 1);</a>
<a name="ln1753">              cur_si-&gt;si_m_startcol = current_col;</a>
<a name="ln1754">              cur_si-&gt;si_h_startpos.lnum = current_lnum;</a>
<a name="ln1755">              cur_si-&gt;si_h_startpos.col = 0;            /* starts right away */</a>
<a name="ln1756">              cur_si-&gt;si_m_endpos.lnum = current_lnum;</a>
<a name="ln1757">              cur_si-&gt;si_m_endpos.col = endcol;</a>
<a name="ln1758">              cur_si-&gt;si_h_endpos.lnum = current_lnum;</a>
<a name="ln1759">              cur_si-&gt;si_h_endpos.col = endcol;</a>
<a name="ln1760">              cur_si-&gt;si_ends = TRUE;</a>
<a name="ln1761">              cur_si-&gt;si_end_idx = 0;</a>
<a name="ln1762">              cur_si-&gt;si_flags = flags;</a>
<a name="ln1763">              cur_si-&gt;si_seqnr = next_seqnr++;</a>
<a name="ln1764">              cur_si-&gt;si_cchar = cchar;</a>
<a name="ln1765">              if (current_state.ga_len &gt; 1)</a>
<a name="ln1766">                cur_si-&gt;si_flags |=</a>
<a name="ln1767">                  CUR_STATE(current_state.ga_len - 2).si_flags</a>
<a name="ln1768">                  &amp; HL_CONCEAL;</a>
<a name="ln1769">              cur_si-&gt;si_id = syn_id;</a>
<a name="ln1770">              cur_si-&gt;si_trans_id = syn_id;</a>
<a name="ln1771">              if (flags &amp; HL_TRANSP) {</a>
<a name="ln1772">                if (current_state.ga_len &lt; 2) {</a>
<a name="ln1773">                  cur_si-&gt;si_attr = 0;</a>
<a name="ln1774">                  cur_si-&gt;si_trans_id = 0;</a>
<a name="ln1775">                } else {</a>
<a name="ln1776">                  cur_si-&gt;si_attr = CUR_STATE(</a>
<a name="ln1777">                      current_state.ga_len - 2).si_attr;</a>
<a name="ln1778">                  cur_si-&gt;si_trans_id = CUR_STATE(</a>
<a name="ln1779">                      current_state.ga_len - 2).si_trans_id;</a>
<a name="ln1780">                }</a>
<a name="ln1781">              } else {</a>
<a name="ln1782">                cur_si-&gt;si_attr = syn_id2attr(syn_id);</a>
<a name="ln1783">              }</a>
<a name="ln1784">              cur_si-&gt;si_cont_list = NULL;</a>
<a name="ln1785">              cur_si-&gt;si_next_list = next_list;</a>
<a name="ln1786">              check_keepend();</a>
<a name="ln1787">            }</a>
<a name="ln1788">          }</a>
<a name="ln1789">        }</a>
<a name="ln1790">      }</a>
<a name="ln1791"> </a>
<a name="ln1792">      /*</a>
<a name="ln1793">       * 3. Check for patterns (only if no keyword found).</a>
<a name="ln1794">       */</a>
<a name="ln1795">      if (syn_id == 0 &amp;&amp; syn_block-&gt;b_syn_patterns.ga_len) {</a>
<a name="ln1796">        /*</a>
<a name="ln1797">         * If we didn't check for a match yet, or we are past it, check</a>
<a name="ln1798">         * for any match with a pattern.</a>
<a name="ln1799">         */</a>
<a name="ln1800">        if (next_match_idx &lt; 0 || next_match_col &lt; (int)current_col) {</a>
<a name="ln1801">          /*</a>
<a name="ln1802">           * Check all relevant patterns for a match at this</a>
<a name="ln1803">           * position.  This is complicated, because matching with a</a>
<a name="ln1804">           * pattern takes quite a bit of time, thus we want to</a>
<a name="ln1805">           * avoid doing it when it's not needed.</a>
<a name="ln1806">           */</a>
<a name="ln1807">          next_match_idx = 0;                   /* no match in this line yet */</a>
<a name="ln1808">          next_match_col = MAXCOL;</a>
<a name="ln1809">          for (int idx = syn_block-&gt;b_syn_patterns.ga_len; --idx &gt;= 0; ) {</a>
<a name="ln1810">            synpat_T *const spp = &amp;(SYN_ITEMS(syn_block)[idx]);</a>
<a name="ln1811">            if (       spp-&gt;sp_syncing == syncing</a>
<a name="ln1812">                       &amp;&amp; (displaying || !(spp-&gt;sp_flags &amp; HL_DISPLAY))</a>
<a name="ln1813">                       &amp;&amp; (spp-&gt;sp_type == SPTYPE_MATCH</a>
<a name="ln1814">                           || spp-&gt;sp_type == SPTYPE_START)</a>
<a name="ln1815">                       &amp;&amp; (current_next_list != NULL</a>
<a name="ln1816">                           ? in_id_list(NULL, current_next_list,</a>
<a name="ln1817">                               &amp;spp-&gt;sp_syn, 0)</a>
<a name="ln1818">                           : (cur_si == NULL</a>
<a name="ln1819">                              ? !(spp-&gt;sp_flags &amp; HL_CONTAINED)</a>
<a name="ln1820">                              : in_id_list(cur_si,</a>
<a name="ln1821">                                  cur_si-&gt;si_cont_list, &amp;spp-&gt;sp_syn,</a>
<a name="ln1822">                                  spp-&gt;sp_flags &amp; HL_CONTAINED)))) {</a>
<a name="ln1823">              /* If we already tried matching in this line, and</a>
<a name="ln1824">               * there isn't a match before next_match_col, skip</a>
<a name="ln1825">               * this item. */</a>
<a name="ln1826">              if (spp-&gt;sp_line_id == current_line_id</a>
<a name="ln1827">                  &amp;&amp; spp-&gt;sp_startcol &gt;= next_match_col)</a>
<a name="ln1828">                continue;</a>
<a name="ln1829">              spp-&gt;sp_line_id = current_line_id;</a>
<a name="ln1830"> </a>
<a name="ln1831">              colnr_T lc_col = current_col - spp-&gt;sp_offsets[SPO_LC_OFF];</a>
<a name="ln1832">              if (lc_col &lt; 0) {</a>
<a name="ln1833">                lc_col = 0;</a>
<a name="ln1834">              }</a>
<a name="ln1835"> </a>
<a name="ln1836">              regmatch.rmm_ic = spp-&gt;sp_ic;</a>
<a name="ln1837">              regmatch.regprog = spp-&gt;sp_prog;</a>
<a name="ln1838">              int r = syn_regexec(&amp;regmatch, current_lnum, lc_col,</a>
<a name="ln1839">                                  IF_SYN_TIME(&amp;spp-&gt;sp_time));</a>
<a name="ln1840">              spp-&gt;sp_prog = regmatch.regprog;</a>
<a name="ln1841">              if (!r) {</a>
<a name="ln1842">                /* no match in this line, try another one */</a>
<a name="ln1843">                spp-&gt;sp_startcol = MAXCOL;</a>
<a name="ln1844">                continue;</a>
<a name="ln1845">              }</a>
<a name="ln1846"> </a>
<a name="ln1847">              /*</a>
<a name="ln1848">               * Compute the first column of the match.</a>
<a name="ln1849">               */</a>
<a name="ln1850">              syn_add_start_off(&amp;pos, &amp;regmatch,</a>
<a name="ln1851">                  spp, SPO_MS_OFF, -1);</a>
<a name="ln1852">              if (pos.lnum &gt; current_lnum) {</a>
<a name="ln1853">                /* must have used end of match in a next line,</a>
<a name="ln1854">                 * we can't handle that */</a>
<a name="ln1855">                spp-&gt;sp_startcol = MAXCOL;</a>
<a name="ln1856">                continue;</a>
<a name="ln1857">              }</a>
<a name="ln1858">              startcol = pos.col;</a>
<a name="ln1859"> </a>
<a name="ln1860">              /* remember the next column where this pattern</a>
<a name="ln1861">               * matches in the current line */</a>
<a name="ln1862">              spp-&gt;sp_startcol = startcol;</a>
<a name="ln1863"> </a>
<a name="ln1864">              /*</a>
<a name="ln1865">               * If a previously found match starts at a lower</a>
<a name="ln1866">               * column number, don't use this one.</a>
<a name="ln1867">               */</a>
<a name="ln1868">              if (startcol &gt;= next_match_col)</a>
<a name="ln1869">                continue;</a>
<a name="ln1870"> </a>
<a name="ln1871">              /*</a>
<a name="ln1872">               * If we matched this pattern at this position</a>
<a name="ln1873">               * before, skip it.  Must retry in the next</a>
<a name="ln1874">               * column, because it may match from there.</a>
<a name="ln1875">               */</a>
<a name="ln1876">              if (did_match_already(idx, &amp;zero_width_next_ga)) {</a>
<a name="ln1877">                try_next_column = true;</a>
<a name="ln1878">                continue;</a>
<a name="ln1879">              }</a>
<a name="ln1880"> </a>
<a name="ln1881">              endpos.lnum = regmatch.endpos[0].lnum;</a>
<a name="ln1882">              endpos.col = regmatch.endpos[0].col;</a>
<a name="ln1883"> </a>
<a name="ln1884">              /* Compute the highlight start. */</a>
<a name="ln1885">              syn_add_start_off(&amp;hl_startpos, &amp;regmatch,</a>
<a name="ln1886">                  spp, SPO_HS_OFF, -1);</a>
<a name="ln1887"> </a>
<a name="ln1888">              /* Compute the region start. */</a>
<a name="ln1889">              /* Default is to use the end of the match. */</a>
<a name="ln1890">              syn_add_end_off(&amp;eos_pos, &amp;regmatch,</a>
<a name="ln1891">                  spp, SPO_RS_OFF, 0);</a>
<a name="ln1892"> </a>
<a name="ln1893">              /*</a>
<a name="ln1894">               * Grab the external submatches before they get</a>
<a name="ln1895">               * overwritten.  Reference count doesn't change.</a>
<a name="ln1896">               */</a>
<a name="ln1897">              unref_extmatch(cur_extmatch);</a>
<a name="ln1898">              cur_extmatch = re_extmatch_out;</a>
<a name="ln1899">              re_extmatch_out = NULL;</a>
<a name="ln1900"> </a>
<a name="ln1901">              flags = 0;</a>
<a name="ln1902">              eoe_pos.lnum = 0;                 /* avoid warning */</a>
<a name="ln1903">              eoe_pos.col = 0;</a>
<a name="ln1904">              end_idx = 0;</a>
<a name="ln1905">              hl_endpos.lnum = 0;</a>
<a name="ln1906"> </a>
<a name="ln1907">              /*</a>
<a name="ln1908">               * For a &quot;oneline&quot; the end must be found in the</a>
<a name="ln1909">               * same line too.  Search for it after the end of</a>
<a name="ln1910">               * the match with the start pattern.  Set the</a>
<a name="ln1911">               * resulting end positions at the same time.</a>
<a name="ln1912">               */</a>
<a name="ln1913">              if (spp-&gt;sp_type == SPTYPE_START</a>
<a name="ln1914">                  &amp;&amp; (spp-&gt;sp_flags &amp; HL_ONELINE)) {</a>
<a name="ln1915">                lpos_T startpos;</a>
<a name="ln1916"> </a>
<a name="ln1917">                startpos = endpos;</a>
<a name="ln1918">                find_endpos(idx, &amp;startpos, &amp;endpos, &amp;hl_endpos,</a>
<a name="ln1919">                    &amp;flags, &amp;eoe_pos, &amp;end_idx, cur_extmatch);</a>
<a name="ln1920">                if (endpos.lnum == 0)</a>
<a name="ln1921">                  continue;                         /* not found */</a>
<a name="ln1922">              }</a>
<a name="ln1923">              /*</a>
<a name="ln1924">               * For a &quot;match&quot; the size must be &gt; 0 after the</a>
<a name="ln1925">               * end offset needs has been added.  Except when</a>
<a name="ln1926">               * syncing.</a>
<a name="ln1927">               */</a>
<a name="ln1928">              else if (spp-&gt;sp_type == SPTYPE_MATCH) {</a>
<a name="ln1929">                syn_add_end_off(&amp;hl_endpos, &amp;regmatch, spp,</a>
<a name="ln1930">                    SPO_HE_OFF, 0);</a>
<a name="ln1931">                syn_add_end_off(&amp;endpos, &amp;regmatch, spp,</a>
<a name="ln1932">                    SPO_ME_OFF, 0);</a>
<a name="ln1933">                if (endpos.lnum == current_lnum</a>
<a name="ln1934">                    &amp;&amp; (int)endpos.col + syncing &lt; startcol) {</a>
<a name="ln1935">                  /*</a>
<a name="ln1936">                   * If an empty string is matched, may need</a>
<a name="ln1937">                   * to try matching again at next column.</a>
<a name="ln1938">                   */</a>
<a name="ln1939">                  if (regmatch.startpos[0].col == regmatch.endpos[0].col) {</a>
<a name="ln1940">                    try_next_column = true;</a>
<a name="ln1941">                  }</a>
<a name="ln1942">                  continue;</a>
<a name="ln1943">                }</a>
<a name="ln1944">              }</a>
<a name="ln1945"> </a>
<a name="ln1946">              /*</a>
<a name="ln1947">               * keep the best match so far in next_match_*</a>
<a name="ln1948">               */</a>
<a name="ln1949">              /* Highlighting must start after startpos and end</a>
<a name="ln1950">               * before endpos. */</a>
<a name="ln1951">              if (hl_startpos.lnum == current_lnum</a>
<a name="ln1952">                  &amp;&amp; (int)hl_startpos.col &lt; startcol)</a>
<a name="ln1953">                hl_startpos.col = startcol;</a>
<a name="ln1954">              limit_pos_zero(&amp;hl_endpos, &amp;endpos);</a>
<a name="ln1955"> </a>
<a name="ln1956">              next_match_idx = idx;</a>
<a name="ln1957">              next_match_col = startcol;</a>
<a name="ln1958">              next_match_m_endpos = endpos;</a>
<a name="ln1959">              next_match_h_endpos = hl_endpos;</a>
<a name="ln1960">              next_match_h_startpos = hl_startpos;</a>
<a name="ln1961">              next_match_flags = flags;</a>
<a name="ln1962">              next_match_eos_pos = eos_pos;</a>
<a name="ln1963">              next_match_eoe_pos = eoe_pos;</a>
<a name="ln1964">              next_match_end_idx = end_idx;</a>
<a name="ln1965">              unref_extmatch(next_match_extmatch);</a>
<a name="ln1966">              next_match_extmatch = cur_extmatch;</a>
<a name="ln1967">              cur_extmatch = NULL;</a>
<a name="ln1968">            }</a>
<a name="ln1969">          }</a>
<a name="ln1970">        }</a>
<a name="ln1971"> </a>
<a name="ln1972">        /*</a>
<a name="ln1973">         * If we found a match at the current column, use it.</a>
<a name="ln1974">         */</a>
<a name="ln1975">        if (next_match_idx &gt;= 0 &amp;&amp; next_match_col == (int)current_col) {</a>
<a name="ln1976">          synpat_T    *lspp;</a>
<a name="ln1977"> </a>
<a name="ln1978">          /* When a zero-width item matched which has a nextgroup,</a>
<a name="ln1979">           * don't push the item but set nextgroup. */</a>
<a name="ln1980">          lspp = &amp;(SYN_ITEMS(syn_block)[next_match_idx]);</a>
<a name="ln1981">          if (next_match_m_endpos.lnum == current_lnum</a>
<a name="ln1982">              &amp;&amp; next_match_m_endpos.col == current_col</a>
<a name="ln1983">              &amp;&amp; lspp-&gt;sp_next_list != NULL) {</a>
<a name="ln1984">            current_next_list = lspp-&gt;sp_next_list;</a>
<a name="ln1985">            current_next_flags = lspp-&gt;sp_flags;</a>
<a name="ln1986">            keep_next_list = true;</a>
<a name="ln1987">            zero_width_next_list = true;</a>
<a name="ln1988"> </a>
<a name="ln1989">            /* Add the index to a list, so that we can check</a>
<a name="ln1990">             * later that we don't match it again (and cause an</a>
<a name="ln1991">             * endless loop). */</a>
<a name="ln1992">            GA_APPEND(int, &amp;zero_width_next_ga, next_match_idx);</a>
<a name="ln1993">            next_match_idx = -1;</a>
<a name="ln1994">          } else {</a>
<a name="ln1995">            cur_si = push_next_match();</a>
<a name="ln1996">          }</a>
<a name="ln1997">          found_match = true;</a>
<a name="ln1998">        }</a>
<a name="ln1999">      }</a>
<a name="ln2000">    }</a>
<a name="ln2001"> </a>
<a name="ln2002">    /*</a>
<a name="ln2003">     * Handle searching for nextgroup match.</a>
<a name="ln2004">     */</a>
<a name="ln2005">    if (current_next_list != NULL &amp;&amp; !keep_next_list) {</a>
<a name="ln2006">      /*</a>
<a name="ln2007">       * If a nextgroup was not found, continue looking for one if:</a>
<a name="ln2008">       * - this is an empty line and the &quot;skipempty&quot; option was given</a>
<a name="ln2009">       * - we are on white space and the &quot;skipwhite&quot; option was given</a>
<a name="ln2010">       */</a>
<a name="ln2011">      if (!found_match) {</a>
<a name="ln2012">        line = syn_getcurline();</a>
<a name="ln2013">        if (((current_next_flags &amp; HL_SKIPWHITE)</a>
<a name="ln2014">             &amp;&amp; ascii_iswhite(line[current_col]))</a>
<a name="ln2015">            || ((current_next_flags &amp; HL_SKIPEMPTY)</a>
<a name="ln2016">                &amp;&amp; *line == NUL))</a>
<a name="ln2017">          break;</a>
<a name="ln2018">      }</a>
<a name="ln2019"> </a>
<a name="ln2020">      /*</a>
<a name="ln2021">       * If a nextgroup was found: Use it, and continue looking for</a>
<a name="ln2022">       * contained matches.</a>
<a name="ln2023">       * If a nextgroup was not found: Continue looking for a normal</a>
<a name="ln2024">       * match.</a>
<a name="ln2025">       * When did set current_next_list for a zero-width item and no</a>
<a name="ln2026">       * match was found don't loop (would get stuck).</a>
<a name="ln2027">       */</a>
<a name="ln2028">      current_next_list = NULL;</a>
<a name="ln2029">      next_match_idx = -1;</a>
<a name="ln2030">      if (!zero_width_next_list) {</a>
<a name="ln2031">        found_match = true;</a>
<a name="ln2032">      }</a>
<a name="ln2033">    }</a>
<a name="ln2034"> </a>
<a name="ln2035">  } while (found_match);</a>
<a name="ln2036"> </a>
<a name="ln2037">  restore_chartab(buf_chartab);</a>
<a name="ln2038"> </a>
<a name="ln2039">  /*</a>
<a name="ln2040">   * Use attributes from the current state, if within its highlighting.</a>
<a name="ln2041">   * If not, use attributes from the current-but-one state, etc.</a>
<a name="ln2042">   */</a>
<a name="ln2043">  current_attr = 0;</a>
<a name="ln2044">  current_id = 0;</a>
<a name="ln2045">  current_trans_id = 0;</a>
<a name="ln2046">  current_flags = 0;</a>
<a name="ln2047">  current_seqnr = 0;</a>
<a name="ln2048">  if (cur_si != NULL) {</a>
<a name="ln2049">    for (int idx = current_state.ga_len - 1; idx &gt;= 0; --idx) {</a>
<a name="ln2050">      sip = &amp;CUR_STATE(idx);</a>
<a name="ln2051">      if ((current_lnum &gt; sip-&gt;si_h_startpos.lnum</a>
<a name="ln2052">           || (current_lnum == sip-&gt;si_h_startpos.lnum</a>
<a name="ln2053">               &amp;&amp; current_col &gt;= sip-&gt;si_h_startpos.col))</a>
<a name="ln2054">          &amp;&amp; (sip-&gt;si_h_endpos.lnum == 0</a>
<a name="ln2055">              || current_lnum &lt; sip-&gt;si_h_endpos.lnum</a>
<a name="ln2056">              || (current_lnum == sip-&gt;si_h_endpos.lnum</a>
<a name="ln2057">                  &amp;&amp; current_col &lt; sip-&gt;si_h_endpos.col))) {</a>
<a name="ln2058">        current_attr = sip-&gt;si_attr;</a>
<a name="ln2059">        current_id = sip-&gt;si_id;</a>
<a name="ln2060">        current_trans_id = sip-&gt;si_trans_id;</a>
<a name="ln2061">        current_flags = sip-&gt;si_flags;</a>
<a name="ln2062">        current_seqnr = sip-&gt;si_seqnr;</a>
<a name="ln2063">        current_sub_char = sip-&gt;si_cchar;</a>
<a name="ln2064">        break;</a>
<a name="ln2065">      }</a>
<a name="ln2066">    }</a>
<a name="ln2067"> </a>
<a name="ln2068">    if (can_spell != NULL) {</a>
<a name="ln2069">      struct sp_syn sps;</a>
<a name="ln2070"> </a>
<a name="ln2071">      /*</a>
<a name="ln2072">       * set &quot;can_spell&quot; to TRUE if spell checking is supposed to be</a>
<a name="ln2073">       * done in the current item.</a>
<a name="ln2074">       */</a>
<a name="ln2075">      if (syn_block-&gt;b_spell_cluster_id == 0) {</a>
<a name="ln2076">        /* There is no @Spell cluster: Do spelling for items without</a>
<a name="ln2077">         * @NoSpell cluster. */</a>
<a name="ln2078">        if (syn_block-&gt;b_nospell_cluster_id == 0</a>
<a name="ln2079">            || current_trans_id == 0)</a>
<a name="ln2080">          *can_spell = (syn_block-&gt;b_syn_spell != SYNSPL_NOTOP);</a>
<a name="ln2081">        else {</a>
<a name="ln2082">          sps.inc_tag = 0;</a>
<a name="ln2083">          sps.id = syn_block-&gt;b_nospell_cluster_id;</a>
<a name="ln2084">          sps.cont_in_list = NULL;</a>
<a name="ln2085">          *can_spell = !in_id_list(sip, sip-&gt;si_cont_list, &amp;sps, 0);</a>
<a name="ln2086">        }</a>
<a name="ln2087">      } else {</a>
<a name="ln2088">        /* The @Spell cluster is defined: Do spelling in items with</a>
<a name="ln2089">         * the @Spell cluster.  But not when @NoSpell is also there.</a>
<a name="ln2090">         * At the toplevel only spell check when &quot;:syn spell toplevel&quot;</a>
<a name="ln2091">         * was used. */</a>
<a name="ln2092">        if (current_trans_id == 0)</a>
<a name="ln2093">          *can_spell = (syn_block-&gt;b_syn_spell == SYNSPL_TOP);</a>
<a name="ln2094">        else {</a>
<a name="ln2095">          sps.inc_tag = 0;</a>
<a name="ln2096">          sps.id = syn_block-&gt;b_spell_cluster_id;</a>
<a name="ln2097">          sps.cont_in_list = NULL;</a>
<a name="ln2098">          *can_spell = in_id_list(sip, sip-&gt;si_cont_list, &amp;sps, 0);</a>
<a name="ln2099"> </a>
<a name="ln2100">          if (syn_block-&gt;b_nospell_cluster_id != 0) {</a>
<a name="ln2101">            sps.id = syn_block-&gt;b_nospell_cluster_id;</a>
<a name="ln2102">            if (in_id_list(sip, sip-&gt;si_cont_list, &amp;sps, 0))</a>
<a name="ln2103">              *can_spell = false;</a>
<a name="ln2104">          }</a>
<a name="ln2105">        }</a>
<a name="ln2106">      }</a>
<a name="ln2107">    }</a>
<a name="ln2108"> </a>
<a name="ln2109"> </a>
<a name="ln2110">    /*</a>
<a name="ln2111">     * Check for end of current state (and the states before it) at the</a>
<a name="ln2112">     * next column.  Don't do this for syncing, because we would miss a</a>
<a name="ln2113">     * single character match.</a>
<a name="ln2114">     * First check if the current state ends at the current column.  It</a>
<a name="ln2115">     * may be for an empty match and a containing item might end in the</a>
<a name="ln2116">     * current column.</a>
<a name="ln2117">     */</a>
<a name="ln2118">    if (!syncing &amp;&amp; !keep_state) {</a>
<a name="ln2119">      check_state_ends();</a>
<a name="ln2120">      if (!GA_EMPTY(&amp;current_state)</a>
<a name="ln2121">          &amp;&amp; syn_getcurline()[current_col] != NUL) {</a>
<a name="ln2122">        ++current_col;</a>
<a name="ln2123">        check_state_ends();</a>
<a name="ln2124">        --current_col;</a>
<a name="ln2125">      }</a>
<a name="ln2126">    }</a>
<a name="ln2127">  } else if (can_spell != NULL)</a>
<a name="ln2128">    /* Default: Only do spelling when there is no @Spell cluster or when</a>
<a name="ln2129">     * &quot;:syn spell toplevel&quot; was used. */</a>
<a name="ln2130">    *can_spell = syn_block-&gt;b_syn_spell == SYNSPL_DEFAULT</a>
<a name="ln2131">                 ? (syn_block-&gt;b_spell_cluster_id == 0)</a>
<a name="ln2132">                 : (syn_block-&gt;b_syn_spell == SYNSPL_TOP);</a>
<a name="ln2133"> </a>
<a name="ln2134">  /* nextgroup ends at end of line, unless &quot;skipnl&quot; or &quot;skipempty&quot; present */</a>
<a name="ln2135">  if (current_next_list != NULL</a>
<a name="ln2136">      &amp;&amp; (line = syn_getcurline())[current_col] != NUL</a>
<a name="ln2137">      &amp;&amp; line[current_col + 1] == NUL</a>
<a name="ln2138">      &amp;&amp; !(current_next_flags &amp; (HL_SKIPNL | HL_SKIPEMPTY))) {</a>
<a name="ln2139">    current_next_list = NULL;</a>
<a name="ln2140">  }</a>
<a name="ln2141"> </a>
<a name="ln2142">  if (!GA_EMPTY(&amp;zero_width_next_ga))</a>
<a name="ln2143">    ga_clear(&amp;zero_width_next_ga);</a>
<a name="ln2144"> </a>
<a name="ln2145">  /* No longer need external matches.  But keep next_match_extmatch. */</a>
<a name="ln2146">  unref_extmatch(re_extmatch_out);</a>
<a name="ln2147">  re_extmatch_out = NULL;</a>
<a name="ln2148">  unref_extmatch(cur_extmatch);</a>
<a name="ln2149"> </a>
<a name="ln2150">  return current_attr;</a>
<a name="ln2151">}</a>
<a name="ln2152"> </a>
<a name="ln2153"> </a>
<a name="ln2154">/*</a>
<a name="ln2155"> * Check if we already matched pattern &quot;idx&quot; at the current column.</a>
<a name="ln2156"> */</a>
<a name="ln2157">static int did_match_already(int idx, garray_T *gap)</a>
<a name="ln2158">{</a>
<a name="ln2159">  for (int i = current_state.ga_len; --i &gt;= 0; ) {</a>
<a name="ln2160">    if (CUR_STATE(i).si_m_startcol == (int)current_col</a>
<a name="ln2161">        &amp;&amp; CUR_STATE(i).si_m_lnum == (int)current_lnum</a>
<a name="ln2162">        &amp;&amp; CUR_STATE(i).si_idx == idx) {</a>
<a name="ln2163">      return TRUE;</a>
<a name="ln2164">    }</a>
<a name="ln2165">  }</a>
<a name="ln2166"> </a>
<a name="ln2167">  /* Zero-width matches with a nextgroup argument are not put on the syntax</a>
<a name="ln2168">   * stack, and can only be matched once anyway. */</a>
<a name="ln2169">  for (int i = gap-&gt;ga_len; --i &gt;= 0; ) {</a>
<a name="ln2170">    if (((int *)(gap-&gt;ga_data))[i] == idx) {</a>
<a name="ln2171">      return TRUE;</a>
<a name="ln2172">    }</a>
<a name="ln2173">  }</a>
<a name="ln2174"> </a>
<a name="ln2175">  return FALSE;</a>
<a name="ln2176">}</a>
<a name="ln2177"> </a>
<a name="ln2178">/*</a>
<a name="ln2179"> * Push the next match onto the stack.</a>
<a name="ln2180"> */</a>
<a name="ln2181">static stateitem_T *push_next_match(void)</a>
<a name="ln2182">{</a>
<a name="ln2183">  stateitem_T *cur_si;</a>
<a name="ln2184">  synpat_T *spp;</a>
<a name="ln2185">  int save_flags;</a>
<a name="ln2186"> </a>
<a name="ln2187">  spp = &amp;(SYN_ITEMS(syn_block)[next_match_idx]);</a>
<a name="ln2188"> </a>
<a name="ln2189">  /*</a>
<a name="ln2190">   * Push the item in current_state stack;</a>
<a name="ln2191">   */</a>
<a name="ln2192">  push_current_state(next_match_idx);</a>
<a name="ln2193">  {</a>
<a name="ln2194">    /*</a>
<a name="ln2195">     * If it's a start-skip-end type that crosses lines, figure out how</a>
<a name="ln2196">     * much it continues in this line.  Otherwise just fill in the length.</a>
<a name="ln2197">     */</a>
<a name="ln2198">    cur_si = &amp;CUR_STATE(current_state.ga_len - 1);</a>
<a name="ln2199">    cur_si-&gt;si_h_startpos = next_match_h_startpos;</a>
<a name="ln2200">    cur_si-&gt;si_m_startcol = current_col;</a>
<a name="ln2201">    cur_si-&gt;si_m_lnum = current_lnum;</a>
<a name="ln2202">    cur_si-&gt;si_flags = spp-&gt;sp_flags;</a>
<a name="ln2203">    cur_si-&gt;si_seqnr = next_seqnr++;</a>
<a name="ln2204">    cur_si-&gt;si_cchar = spp-&gt;sp_cchar;</a>
<a name="ln2205">    if (current_state.ga_len &gt; 1)</a>
<a name="ln2206">      cur_si-&gt;si_flags |=</a>
<a name="ln2207">        CUR_STATE(current_state.ga_len - 2).si_flags &amp; HL_CONCEAL;</a>
<a name="ln2208">    cur_si-&gt;si_next_list = spp-&gt;sp_next_list;</a>
<a name="ln2209">    cur_si-&gt;si_extmatch = ref_extmatch(next_match_extmatch);</a>
<a name="ln2210">    if (spp-&gt;sp_type == SPTYPE_START &amp;&amp; !(spp-&gt;sp_flags &amp; HL_ONELINE)) {</a>
<a name="ln2211">      /* Try to find the end pattern in the current line */</a>
<a name="ln2212">      update_si_end(cur_si, (int)(next_match_m_endpos.col), TRUE);</a>
<a name="ln2213">      check_keepend();</a>
<a name="ln2214">    } else {</a>
<a name="ln2215">      cur_si-&gt;si_m_endpos = next_match_m_endpos;</a>
<a name="ln2216">      cur_si-&gt;si_h_endpos = next_match_h_endpos;</a>
<a name="ln2217">      cur_si-&gt;si_ends = TRUE;</a>
<a name="ln2218">      cur_si-&gt;si_flags |= next_match_flags;</a>
<a name="ln2219">      cur_si-&gt;si_eoe_pos = next_match_eoe_pos;</a>
<a name="ln2220">      cur_si-&gt;si_end_idx = next_match_end_idx;</a>
<a name="ln2221">    }</a>
<a name="ln2222">    if (keepend_level &lt; 0 &amp;&amp; (cur_si-&gt;si_flags &amp; HL_KEEPEND))</a>
<a name="ln2223">      keepend_level = current_state.ga_len - 1;</a>
<a name="ln2224">    check_keepend();</a>
<a name="ln2225">    update_si_attr(current_state.ga_len - 1);</a>
<a name="ln2226"> </a>
<a name="ln2227">    save_flags = cur_si-&gt;si_flags &amp; (HL_CONCEAL | HL_CONCEALENDS);</a>
<a name="ln2228">    /*</a>
<a name="ln2229">     * If the start pattern has another highlight group, push another item</a>
<a name="ln2230">     * on the stack for the start pattern.</a>
<a name="ln2231">     */</a>
<a name="ln2232">    if (spp-&gt;sp_type == SPTYPE_START &amp;&amp; spp-&gt;sp_syn_match_id != 0) {</a>
<a name="ln2233">      push_current_state(next_match_idx);</a>
<a name="ln2234">      cur_si = &amp;CUR_STATE(current_state.ga_len - 1);</a>
<a name="ln2235">      cur_si-&gt;si_h_startpos = next_match_h_startpos;</a>
<a name="ln2236">      cur_si-&gt;si_m_startcol = current_col;</a>
<a name="ln2237">      cur_si-&gt;si_m_lnum = current_lnum;</a>
<a name="ln2238">      cur_si-&gt;si_m_endpos = next_match_eos_pos;</a>
<a name="ln2239">      cur_si-&gt;si_h_endpos = next_match_eos_pos;</a>
<a name="ln2240">      cur_si-&gt;si_ends = TRUE;</a>
<a name="ln2241">      cur_si-&gt;si_end_idx = 0;</a>
<a name="ln2242">      cur_si-&gt;si_flags = HL_MATCH;</a>
<a name="ln2243">      cur_si-&gt;si_seqnr = next_seqnr++;</a>
<a name="ln2244">      cur_si-&gt;si_flags |= save_flags;</a>
<a name="ln2245">      if (cur_si-&gt;si_flags &amp; HL_CONCEALENDS)</a>
<a name="ln2246">        cur_si-&gt;si_flags |= HL_CONCEAL;</a>
<a name="ln2247">      cur_si-&gt;si_next_list = NULL;</a>
<a name="ln2248">      check_keepend();</a>
<a name="ln2249">      update_si_attr(current_state.ga_len - 1);</a>
<a name="ln2250">    }</a>
<a name="ln2251">  }</a>
<a name="ln2252"> </a>
<a name="ln2253">  next_match_idx = -1;          /* try other match next time */</a>
<a name="ln2254"> </a>
<a name="ln2255">  return cur_si;</a>
<a name="ln2256">}</a>
<a name="ln2257"> </a>
<a name="ln2258">/*</a>
<a name="ln2259"> * Check for end of current state (and the states before it).</a>
<a name="ln2260"> */</a>
<a name="ln2261">static void check_state_ends(void)</a>
<a name="ln2262">{</a>
<a name="ln2263">  stateitem_T *cur_si;</a>
<a name="ln2264">  int had_extend;</a>
<a name="ln2265"> </a>
<a name="ln2266">  cur_si = &amp;CUR_STATE(current_state.ga_len - 1);</a>
<a name="ln2267">  for (;; ) {</a>
<a name="ln2268">    if (cur_si-&gt;si_ends</a>
<a name="ln2269">        &amp;&amp; (cur_si-&gt;si_m_endpos.lnum &lt; current_lnum</a>
<a name="ln2270">            || (cur_si-&gt;si_m_endpos.lnum == current_lnum</a>
<a name="ln2271">                &amp;&amp; cur_si-&gt;si_m_endpos.col &lt;= current_col))) {</a>
<a name="ln2272">      /*</a>
<a name="ln2273">       * If there is an end pattern group ID, highlight the end pattern</a>
<a name="ln2274">       * now.  No need to pop the current item from the stack.</a>
<a name="ln2275">       * Only do this if the end pattern continues beyond the current</a>
<a name="ln2276">       * position.</a>
<a name="ln2277">       */</a>
<a name="ln2278">      if (cur_si-&gt;si_end_idx</a>
<a name="ln2279">          &amp;&amp; (cur_si-&gt;si_eoe_pos.lnum &gt; current_lnum</a>
<a name="ln2280">              || (cur_si-&gt;si_eoe_pos.lnum == current_lnum</a>
<a name="ln2281">                  &amp;&amp; cur_si-&gt;si_eoe_pos.col &gt; current_col))) {</a>
<a name="ln2282">        cur_si-&gt;si_idx = cur_si-&gt;si_end_idx;</a>
<a name="ln2283">        cur_si-&gt;si_end_idx = 0;</a>
<a name="ln2284">        cur_si-&gt;si_m_endpos = cur_si-&gt;si_eoe_pos;</a>
<a name="ln2285">        cur_si-&gt;si_h_endpos = cur_si-&gt;si_eoe_pos;</a>
<a name="ln2286">        cur_si-&gt;si_flags |= HL_MATCH;</a>
<a name="ln2287">        cur_si-&gt;si_seqnr = next_seqnr++;</a>
<a name="ln2288">        if (cur_si-&gt;si_flags &amp; HL_CONCEALENDS)</a>
<a name="ln2289">          cur_si-&gt;si_flags |= HL_CONCEAL;</a>
<a name="ln2290">        update_si_attr(current_state.ga_len - 1);</a>
<a name="ln2291"> </a>
<a name="ln2292">        /* nextgroup= should not match in the end pattern */</a>
<a name="ln2293">        current_next_list = NULL;</a>
<a name="ln2294"> </a>
<a name="ln2295">        /* what matches next may be different now, clear it */</a>
<a name="ln2296">        next_match_idx = 0;</a>
<a name="ln2297">        next_match_col = MAXCOL;</a>
<a name="ln2298">        break;</a>
<a name="ln2299">      } else {</a>
<a name="ln2300">        /* handle next_list, unless at end of line and no &quot;skipnl&quot; or</a>
<a name="ln2301">         * &quot;skipempty&quot; */</a>
<a name="ln2302">        current_next_list = cur_si-&gt;si_next_list;</a>
<a name="ln2303">        current_next_flags = cur_si-&gt;si_flags;</a>
<a name="ln2304">        if (!(current_next_flags &amp; (HL_SKIPNL | HL_SKIPEMPTY))</a>
<a name="ln2305">            &amp;&amp; syn_getcurline()[current_col] == NUL)</a>
<a name="ln2306">          current_next_list = NULL;</a>
<a name="ln2307"> </a>
<a name="ln2308">        /* When the ended item has &quot;extend&quot;, another item with</a>
<a name="ln2309">         * &quot;keepend&quot; now needs to check for its end. */</a>
<a name="ln2310">        had_extend = (cur_si-&gt;si_flags &amp; HL_EXTEND);</a>
<a name="ln2311"> </a>
<a name="ln2312">        pop_current_state();</a>
<a name="ln2313"> </a>
<a name="ln2314">        if (GA_EMPTY(&amp;current_state))</a>
<a name="ln2315">          break;</a>
<a name="ln2316"> </a>
<a name="ln2317">        if (had_extend &amp;&amp; keepend_level &gt;= 0) {</a>
<a name="ln2318">          syn_update_ends(FALSE);</a>
<a name="ln2319">          if (GA_EMPTY(&amp;current_state))</a>
<a name="ln2320">            break;</a>
<a name="ln2321">        }</a>
<a name="ln2322"> </a>
<a name="ln2323">        cur_si = &amp;CUR_STATE(current_state.ga_len - 1);</a>
<a name="ln2324"> </a>
<a name="ln2325">        /*</a>
<a name="ln2326">         * Only for a region the search for the end continues after</a>
<a name="ln2327">         * the end of the contained item.  If the contained match</a>
<a name="ln2328">         * included the end-of-line, break here, the region continues.</a>
<a name="ln2329">         * Don't do this when:</a>
<a name="ln2330">         * - &quot;keepend&quot; is used for the contained item</a>
<a name="ln2331">         * - not at the end of the line (could be end=&quot;x$&quot;me=e-1).</a>
<a name="ln2332">         * - &quot;excludenl&quot; is used (HL_HAS_EOL won't be set)</a>
<a name="ln2333">         */</a>
<a name="ln2334">        if (cur_si-&gt;si_idx &gt;= 0</a>
<a name="ln2335">            &amp;&amp; SYN_ITEMS(syn_block)[cur_si-&gt;si_idx].sp_type</a>
<a name="ln2336">            == SPTYPE_START</a>
<a name="ln2337">            &amp;&amp; !(cur_si-&gt;si_flags &amp; (HL_MATCH | HL_KEEPEND))) {</a>
<a name="ln2338">          update_si_end(cur_si, (int)current_col, TRUE);</a>
<a name="ln2339">          check_keepend();</a>
<a name="ln2340">          if ((current_next_flags &amp; HL_HAS_EOL)</a>
<a name="ln2341">              &amp;&amp; keepend_level &lt; 0</a>
<a name="ln2342">              &amp;&amp; syn_getcurline()[current_col] == NUL)</a>
<a name="ln2343">            break;</a>
<a name="ln2344">        }</a>
<a name="ln2345">      }</a>
<a name="ln2346">    } else</a>
<a name="ln2347">      break;</a>
<a name="ln2348">  }</a>
<a name="ln2349">}</a>
<a name="ln2350"> </a>
<a name="ln2351">/*</a>
<a name="ln2352"> * Update an entry in the current_state stack for a match or region.  This</a>
<a name="ln2353"> * fills in si_attr, si_next_list and si_cont_list.</a>
<a name="ln2354"> */</a>
<a name="ln2355">static void update_si_attr(int idx)</a>
<a name="ln2356">{</a>
<a name="ln2357">  stateitem_T *sip = &amp;CUR_STATE(idx);</a>
<a name="ln2358">  synpat_T    *spp;</a>
<a name="ln2359"> </a>
<a name="ln2360">  /* This should not happen... */</a>
<a name="ln2361">  if (sip-&gt;si_idx &lt; 0)</a>
<a name="ln2362">    return;</a>
<a name="ln2363"> </a>
<a name="ln2364">  spp = &amp;(SYN_ITEMS(syn_block)[sip-&gt;si_idx]);</a>
<a name="ln2365">  if (sip-&gt;si_flags &amp; HL_MATCH)</a>
<a name="ln2366">    sip-&gt;si_id = spp-&gt;sp_syn_match_id;</a>
<a name="ln2367">  else</a>
<a name="ln2368">    sip-&gt;si_id = spp-&gt;sp_syn.id;</a>
<a name="ln2369">  sip-&gt;si_attr = syn_id2attr(sip-&gt;si_id);</a>
<a name="ln2370">  sip-&gt;si_trans_id = sip-&gt;si_id;</a>
<a name="ln2371">  if (sip-&gt;si_flags &amp; HL_MATCH)</a>
<a name="ln2372">    sip-&gt;si_cont_list = NULL;</a>
<a name="ln2373">  else</a>
<a name="ln2374">    sip-&gt;si_cont_list = spp-&gt;sp_cont_list;</a>
<a name="ln2375"> </a>
<a name="ln2376">  /*</a>
<a name="ln2377">   * For transparent items, take attr from outer item.</a>
<a name="ln2378">   * Also take cont_list, if there is none.</a>
<a name="ln2379">   * Don't do this for the matchgroup of a start or end pattern.</a>
<a name="ln2380">   */</a>
<a name="ln2381">  if ((spp-&gt;sp_flags &amp; HL_TRANSP) &amp;&amp; !(sip-&gt;si_flags &amp; HL_MATCH)) {</a>
<a name="ln2382">    if (idx == 0) {</a>
<a name="ln2383">      sip-&gt;si_attr = 0;</a>
<a name="ln2384">      sip-&gt;si_trans_id = 0;</a>
<a name="ln2385">      if (sip-&gt;si_cont_list == NULL)</a>
<a name="ln2386">        sip-&gt;si_cont_list = ID_LIST_ALL;</a>
<a name="ln2387">    } else {</a>
<a name="ln2388">      sip-&gt;si_attr = CUR_STATE(idx - 1).si_attr;</a>
<a name="ln2389">      sip-&gt;si_trans_id = CUR_STATE(idx - 1).si_trans_id;</a>
<a name="ln2390">      sip-&gt;si_h_startpos = CUR_STATE(idx - 1).si_h_startpos;</a>
<a name="ln2391">      sip-&gt;si_h_endpos = CUR_STATE(idx - 1).si_h_endpos;</a>
<a name="ln2392">      if (sip-&gt;si_cont_list == NULL) {</a>
<a name="ln2393">        sip-&gt;si_flags |= HL_TRANS_CONT;</a>
<a name="ln2394">        sip-&gt;si_cont_list = CUR_STATE(idx - 1).si_cont_list;</a>
<a name="ln2395">      }</a>
<a name="ln2396">    }</a>
<a name="ln2397">  }</a>
<a name="ln2398">}</a>
<a name="ln2399"> </a>
<a name="ln2400">/*</a>
<a name="ln2401"> * Check the current stack for patterns with &quot;keepend&quot; flag.</a>
<a name="ln2402"> * Propagate the match-end to contained items, until a &quot;skipend&quot; item is found.</a>
<a name="ln2403"> */</a>
<a name="ln2404">static void check_keepend(void)</a>
<a name="ln2405">{</a>
<a name="ln2406">  int i;</a>
<a name="ln2407">  lpos_T maxpos;</a>
<a name="ln2408">  lpos_T maxpos_h;</a>
<a name="ln2409">  stateitem_T *sip;</a>
<a name="ln2410"> </a>
<a name="ln2411">  /*</a>
<a name="ln2412">   * This check can consume a lot of time; only do it from the level where</a>
<a name="ln2413">   * there really is a keepend.</a>
<a name="ln2414">   */</a>
<a name="ln2415">  if (keepend_level &lt; 0)</a>
<a name="ln2416">    return;</a>
<a name="ln2417"> </a>
<a name="ln2418">  /*</a>
<a name="ln2419">   * Find the last index of an &quot;extend&quot; item.  &quot;keepend&quot; items before that</a>
<a name="ln2420">   * won't do anything.  If there is no &quot;extend&quot; item &quot;i&quot; will be</a>
<a name="ln2421">   * &quot;keepend_level&quot; and all &quot;keepend&quot; items will work normally.</a>
<a name="ln2422">   */</a>
<a name="ln2423">  for (i = current_state.ga_len - 1; i &gt; keepend_level; --i)</a>
<a name="ln2424">    if (CUR_STATE(i).si_flags &amp; HL_EXTEND)</a>
<a name="ln2425">      break;</a>
<a name="ln2426"> </a>
<a name="ln2427">  maxpos.lnum = 0;</a>
<a name="ln2428">  maxpos.col = 0;</a>
<a name="ln2429">  maxpos_h.lnum = 0;</a>
<a name="ln2430">  maxpos_h.col = 0;</a>
<a name="ln2431">  for (; i &lt; current_state.ga_len; ++i) {</a>
<a name="ln2432">    sip = &amp;CUR_STATE(i);</a>
<a name="ln2433">    if (maxpos.lnum != 0) {</a>
<a name="ln2434">      limit_pos_zero(&amp;sip-&gt;si_m_endpos, &amp;maxpos);</a>
<a name="ln2435">      limit_pos_zero(&amp;sip-&gt;si_h_endpos, &amp;maxpos_h);</a>
<a name="ln2436">      limit_pos_zero(&amp;sip-&gt;si_eoe_pos, &amp;maxpos);</a>
<a name="ln2437">      sip-&gt;si_ends = TRUE;</a>
<a name="ln2438">    }</a>
<a name="ln2439">    if (sip-&gt;si_ends &amp;&amp; (sip-&gt;si_flags &amp; HL_KEEPEND)) {</a>
<a name="ln2440">      if (maxpos.lnum == 0</a>
<a name="ln2441">          || maxpos.lnum &gt; sip-&gt;si_m_endpos.lnum</a>
<a name="ln2442">          || (maxpos.lnum == sip-&gt;si_m_endpos.lnum</a>
<a name="ln2443">              &amp;&amp; maxpos.col &gt; sip-&gt;si_m_endpos.col))</a>
<a name="ln2444">        maxpos = sip-&gt;si_m_endpos;</a>
<a name="ln2445">      if (maxpos_h.lnum == 0</a>
<a name="ln2446">          || maxpos_h.lnum &gt; sip-&gt;si_h_endpos.lnum</a>
<a name="ln2447">          || (maxpos_h.lnum == sip-&gt;si_h_endpos.lnum</a>
<a name="ln2448">              &amp;&amp; maxpos_h.col &gt; sip-&gt;si_h_endpos.col))</a>
<a name="ln2449">        maxpos_h = sip-&gt;si_h_endpos;</a>
<a name="ln2450">    }</a>
<a name="ln2451">  }</a>
<a name="ln2452">}</a>
<a name="ln2453"> </a>
<a name="ln2454">/*</a>
<a name="ln2455"> * Update an entry in the current_state stack for a start-skip-end pattern.</a>
<a name="ln2456"> * This finds the end of the current item, if it's in the current line.</a>
<a name="ln2457"> *</a>
<a name="ln2458"> * Return the flags for the matched END.</a>
<a name="ln2459"> */</a>
<a name="ln2460">static void</a>
<a name="ln2461">update_si_end(</a>
<a name="ln2462">    stateitem_T *sip,</a>
<a name="ln2463">    int startcol,               /* where to start searching for the end */</a>
<a name="ln2464">    int force                  /* when TRUE overrule a previous end */</a>
<a name="ln2465">)</a>
<a name="ln2466">{</a>
<a name="ln2467">  lpos_T hl_endpos;</a>
<a name="ln2468">  lpos_T end_endpos;</a>
<a name="ln2469"> </a>
<a name="ln2470">  /* return quickly for a keyword */</a>
<a name="ln2471">  if (sip-&gt;si_idx &lt; 0)</a>
<a name="ln2472">    return;</a>
<a name="ln2473"> </a>
<a name="ln2474">  /* Don't update when it's already done.  Can be a match of an end pattern</a>
<a name="ln2475">   * that started in a previous line.  Watch out: can also be a &quot;keepend&quot;</a>
<a name="ln2476">   * from a containing item. */</a>
<a name="ln2477">  if (!force &amp;&amp; sip-&gt;si_m_endpos.lnum &gt;= current_lnum)</a>
<a name="ln2478">    return;</a>
<a name="ln2479"> </a>
<a name="ln2480">  /*</a>
<a name="ln2481">   * We need to find the end of the region.  It may continue in the next</a>
<a name="ln2482">   * line.</a>
<a name="ln2483">   */</a>
<a name="ln2484">  int end_idx = 0;</a>
<a name="ln2485">  lpos_T startpos = {</a>
<a name="ln2486">    .lnum = current_lnum,</a>
<a name="ln2487">    .col = startcol,</a>
<a name="ln2488">  };</a>
<a name="ln2489">  lpos_T endpos = { 0 };</a>
<a name="ln2490">  find_endpos(sip-&gt;si_idx, &amp;startpos, &amp;endpos, &amp;hl_endpos,</a>
<a name="ln2491">      &amp;(sip-&gt;si_flags), &amp;end_endpos, &amp;end_idx, sip-&gt;si_extmatch);</a>
<a name="ln2492"> </a>
<a name="ln2493">  if (endpos.lnum == 0) {</a>
<a name="ln2494">    /* No end pattern matched. */</a>
<a name="ln2495">    if (SYN_ITEMS(syn_block)[sip-&gt;si_idx].sp_flags &amp; HL_ONELINE) {</a>
<a name="ln2496">      /* a &quot;oneline&quot; never continues in the next line */</a>
<a name="ln2497">      sip-&gt;si_ends = TRUE;</a>
<a name="ln2498">      sip-&gt;si_m_endpos.lnum = current_lnum;</a>
<a name="ln2499">      sip-&gt;si_m_endpos.col = (colnr_T)STRLEN(syn_getcurline());</a>
<a name="ln2500">    } else {</a>
<a name="ln2501">      /* continues in the next line */</a>
<a name="ln2502">      sip-&gt;si_ends = FALSE;</a>
<a name="ln2503">      sip-&gt;si_m_endpos.lnum = 0;</a>
<a name="ln2504">    }</a>
<a name="ln2505">    sip-&gt;si_h_endpos = sip-&gt;si_m_endpos;</a>
<a name="ln2506">  } else {</a>
<a name="ln2507">    /* match within this line */</a>
<a name="ln2508">    sip-&gt;si_m_endpos = endpos;</a>
<a name="ln2509">    sip-&gt;si_h_endpos = hl_endpos;</a>
<a name="ln2510">    sip-&gt;si_eoe_pos = end_endpos;</a>
<a name="ln2511">    sip-&gt;si_ends = TRUE;</a>
<a name="ln2512">    sip-&gt;si_end_idx = end_idx;</a>
<a name="ln2513">  }</a>
<a name="ln2514">}</a>
<a name="ln2515"> </a>
<a name="ln2516">/*</a>
<a name="ln2517"> * Add a new state to the current state stack.</a>
<a name="ln2518"> * It is cleared and the index set to &quot;idx&quot;.</a>
<a name="ln2519"> */</a>
<a name="ln2520">static void push_current_state(int idx)</a>
<a name="ln2521">{</a>
<a name="ln2522">  stateitem_T *p = GA_APPEND_VIA_PTR(stateitem_T, &amp;current_state);</a>
<a name="ln2523">  memset(p, 0, sizeof(*p));</a>
<a name="ln2524">  p-&gt;si_idx = idx;</a>
<a name="ln2525">}</a>
<a name="ln2526"> </a>
<a name="ln2527">/*</a>
<a name="ln2528"> * Remove a state from the current_state stack.</a>
<a name="ln2529"> */</a>
<a name="ln2530">static void pop_current_state(void)</a>
<a name="ln2531">{</a>
<a name="ln2532">  if (!GA_EMPTY(&amp;current_state)) {</a>
<a name="ln2533">    unref_extmatch(CUR_STATE(current_state.ga_len - 1).si_extmatch);</a>
<a name="ln2534">    --current_state.ga_len;</a>
<a name="ln2535">  }</a>
<a name="ln2536">  /* after the end of a pattern, try matching a keyword or pattern */</a>
<a name="ln2537">  next_match_idx = -1;</a>
<a name="ln2538"> </a>
<a name="ln2539">  /* if first state with &quot;keepend&quot; is popped, reset keepend_level */</a>
<a name="ln2540">  if (keepend_level &gt;= current_state.ga_len)</a>
<a name="ln2541">    keepend_level = -1;</a>
<a name="ln2542">}</a>
<a name="ln2543"> </a>
<a name="ln2544">/*</a>
<a name="ln2545"> * Find the end of a start/skip/end syntax region after &quot;startpos&quot;.</a>
<a name="ln2546"> * Only checks one line.</a>
<a name="ln2547"> * Also handles a match item that continued from a previous line.</a>
<a name="ln2548"> * If not found, the syntax item continues in the next line.  m_endpos-&gt;lnum</a>
<a name="ln2549"> * will be 0.</a>
<a name="ln2550"> * If found, the end of the region and the end of the highlighting is</a>
<a name="ln2551"> * computed.</a>
<a name="ln2552"> */</a>
<a name="ln2553">static void</a>
<a name="ln2554">find_endpos(</a>
<a name="ln2555">    int idx,                    // index of the pattern</a>
<a name="ln2556">    lpos_T *startpos,           // where to start looking for an END match</a>
<a name="ln2557">    lpos_T *m_endpos,           // return: end of match</a>
<a name="ln2558">    lpos_T *hl_endpos,          // return: end of highlighting</a>
<a name="ln2559">    long *flagsp,               // return: flags of matching END</a>
<a name="ln2560">    lpos_T *end_endpos,         // return: end of end pattern match</a>
<a name="ln2561">    int *end_idx,               // return: group ID for end pat. match, or 0</a>
<a name="ln2562">    reg_extmatch_T *start_ext   // submatches from the start pattern</a>
<a name="ln2563">)</a>
<a name="ln2564">{</a>
<a name="ln2565">  colnr_T matchcol;</a>
<a name="ln2566">  synpat_T    *spp, *spp_skip;</a>
<a name="ln2567">  int start_idx;</a>
<a name="ln2568">  int best_idx;</a>
<a name="ln2569">  regmmatch_T regmatch;</a>
<a name="ln2570">  regmmatch_T best_regmatch;        /* startpos/endpos of best match */</a>
<a name="ln2571">  lpos_T pos;</a>
<a name="ln2572">  char_u      *line;</a>
<a name="ln2573">  int had_match = false;</a>
<a name="ln2574">  char_u buf_chartab[32];  // chartab array for syn option iskeyword</a>
<a name="ln2575"> </a>
<a name="ln2576">  /* just in case we are invoked for a keyword */</a>
<a name="ln2577">  if (idx &lt; 0)</a>
<a name="ln2578">    return;</a>
<a name="ln2579"> </a>
<a name="ln2580">  /*</a>
<a name="ln2581">   * Check for being called with a START pattern.</a>
<a name="ln2582">   * Can happen with a match that continues to the next line, because it</a>
<a name="ln2583">   * contained a region.</a>
<a name="ln2584">   */</a>
<a name="ln2585">  spp = &amp;(SYN_ITEMS(syn_block)[idx]);</a>
<a name="ln2586">  if (spp-&gt;sp_type != SPTYPE_START) {</a>
<a name="ln2587">    *hl_endpos = *startpos;</a>
<a name="ln2588">    return;</a>
<a name="ln2589">  }</a>
<a name="ln2590"> </a>
<a name="ln2591">  /*</a>
<a name="ln2592">   * Find the SKIP or first END pattern after the last START pattern.</a>
<a name="ln2593">   */</a>
<a name="ln2594">  for (;; ) {</a>
<a name="ln2595">    spp = &amp;(SYN_ITEMS(syn_block)[idx]);</a>
<a name="ln2596">    if (spp-&gt;sp_type != SPTYPE_START)</a>
<a name="ln2597">      break;</a>
<a name="ln2598">    ++idx;</a>
<a name="ln2599">  }</a>
<a name="ln2600"> </a>
<a name="ln2601">  /*</a>
<a name="ln2602">   *	Lookup the SKIP pattern (if present)</a>
<a name="ln2603">   */</a>
<a name="ln2604">  if (spp-&gt;sp_type == SPTYPE_SKIP) {</a>
<a name="ln2605">    spp_skip = spp;</a>
<a name="ln2606">    ++idx;</a>
<a name="ln2607">  } else</a>
<a name="ln2608">    spp_skip = NULL;</a>
<a name="ln2609"> </a>
<a name="ln2610">  /* Setup external matches for syn_regexec(). */</a>
<a name="ln2611">  unref_extmatch(re_extmatch_in);</a>
<a name="ln2612">  re_extmatch_in = ref_extmatch(start_ext);</a>
<a name="ln2613"> </a>
<a name="ln2614">  matchcol = startpos-&gt;col;     // start looking for a match at sstart</a>
<a name="ln2615">  start_idx = idx;              // remember the first END pattern.</a>
<a name="ln2616">  best_regmatch.startpos[0].col = 0;            // avoid compiler warning</a>
<a name="ln2617"> </a>
<a name="ln2618">  // use syntax iskeyword option</a>
<a name="ln2619">  save_chartab(buf_chartab);</a>
<a name="ln2620"> </a>
<a name="ln2621">  for (;; ) {</a>
<a name="ln2622">    /*</a>
<a name="ln2623">     * Find end pattern that matches first after &quot;matchcol&quot;.</a>
<a name="ln2624">     */</a>
<a name="ln2625">    best_idx = -1;</a>
<a name="ln2626">    for (idx = start_idx; idx &lt; syn_block-&gt;b_syn_patterns.ga_len; ++idx) {</a>
<a name="ln2627">      int lc_col = matchcol;</a>
<a name="ln2628"> </a>
<a name="ln2629">      spp = &amp;(SYN_ITEMS(syn_block)[idx]);</a>
<a name="ln2630">      if (spp-&gt;sp_type != SPTYPE_END)           /* past last END pattern */</a>
<a name="ln2631">        break;</a>
<a name="ln2632">      lc_col -= spp-&gt;sp_offsets[SPO_LC_OFF];</a>
<a name="ln2633">      if (lc_col &lt; 0)</a>
<a name="ln2634">        lc_col = 0;</a>
<a name="ln2635"> </a>
<a name="ln2636">      regmatch.rmm_ic = spp-&gt;sp_ic;</a>
<a name="ln2637">      regmatch.regprog = spp-&gt;sp_prog;</a>
<a name="ln2638">      int r = syn_regexec(&amp;regmatch, startpos-&gt;lnum, lc_col,</a>
<a name="ln2639">                          IF_SYN_TIME(&amp;spp-&gt;sp_time));</a>
<a name="ln2640">      spp-&gt;sp_prog = regmatch.regprog;</a>
<a name="ln2641">      if (r) {</a>
<a name="ln2642">        if (best_idx == -1 || regmatch.startpos[0].col</a>
<a name="ln2643">            &lt; best_regmatch.startpos[0].col) {</a>
<a name="ln2644">          best_idx = idx;</a>
<a name="ln2645">          best_regmatch.startpos[0] = regmatch.startpos[0];</a>
<a name="ln2646">          best_regmatch.endpos[0] = regmatch.endpos[0];</a>
<a name="ln2647">        }</a>
<a name="ln2648">      }</a>
<a name="ln2649">    }</a>
<a name="ln2650"> </a>
<a name="ln2651">    /*</a>
<a name="ln2652">     * If all end patterns have been tried, and there is no match, the</a>
<a name="ln2653">     * item continues until end-of-line.</a>
<a name="ln2654">     */</a>
<a name="ln2655">    if (best_idx == -1)</a>
<a name="ln2656">      break;</a>
<a name="ln2657"> </a>
<a name="ln2658">    /*</a>
<a name="ln2659">     * If the skip pattern matches before the end pattern,</a>
<a name="ln2660">     * continue searching after the skip pattern.</a>
<a name="ln2661">     */</a>
<a name="ln2662">    if (spp_skip != NULL) {</a>
<a name="ln2663">      int lc_col = matchcol - spp_skip-&gt;sp_offsets[SPO_LC_OFF];</a>
<a name="ln2664"> </a>
<a name="ln2665">      if (lc_col &lt; 0)</a>
<a name="ln2666">        lc_col = 0;</a>
<a name="ln2667">      regmatch.rmm_ic = spp_skip-&gt;sp_ic;</a>
<a name="ln2668">      regmatch.regprog = spp_skip-&gt;sp_prog;</a>
<a name="ln2669">      int r = syn_regexec(&amp;regmatch, startpos-&gt;lnum, lc_col,</a>
<a name="ln2670">                          IF_SYN_TIME(&amp;spp_skip-&gt;sp_time));</a>
<a name="ln2671">      spp_skip-&gt;sp_prog = regmatch.regprog;</a>
<a name="ln2672">      if (r &amp;&amp; regmatch.startpos[0].col &lt;= best_regmatch.startpos[0].col) {</a>
<a name="ln2673">        // Add offset to skip pattern match</a>
<a name="ln2674">        syn_add_end_off(&amp;pos, &amp;regmatch, spp_skip, SPO_ME_OFF, 1);</a>
<a name="ln2675"> </a>
<a name="ln2676">        // If the skip pattern goes on to the next line, there is no</a>
<a name="ln2677">        // match with an end pattern in this line.</a>
<a name="ln2678">        if (pos.lnum &gt; startpos-&gt;lnum) {</a>
<a name="ln2679">          break;</a>
<a name="ln2680">        }</a>
<a name="ln2681"> </a>
<a name="ln2682">        line = ml_get_buf(syn_buf, startpos-&gt;lnum, false);</a>
<a name="ln2683">        int line_len = (int)STRLEN(line);</a>
<a name="ln2684"> </a>
<a name="ln2685">        // take care of an empty match or negative offset</a>
<a name="ln2686">        if (pos.col &lt;= matchcol) {</a>
<a name="ln2687">          matchcol++;</a>
<a name="ln2688">        } else if (pos.col &lt;= regmatch.endpos[0].col) {</a>
<a name="ln2689">          matchcol = pos.col;</a>
<a name="ln2690">        } else {</a>
<a name="ln2691">          // Be careful not to jump over the NUL at the end-of-line</a>
<a name="ln2692">          for (matchcol = regmatch.endpos[0].col;</a>
<a name="ln2693">               matchcol &lt; line_len &amp;&amp; matchcol &lt; pos.col;</a>
<a name="ln2694">               matchcol++) {</a>
<a name="ln2695">          }</a>
<a name="ln2696">        }</a>
<a name="ln2697"> </a>
<a name="ln2698">        // if the skip pattern includes end-of-line, break here</a>
<a name="ln2699">        if (matchcol &gt;= line_len) {</a>
<a name="ln2700">          break;</a>
<a name="ln2701">        }</a>
<a name="ln2702"> </a>
<a name="ln2703">        continue;  // start with first end pattern again</a>
<a name="ln2704">      }</a>
<a name="ln2705">    }</a>
<a name="ln2706"> </a>
<a name="ln2707">    /*</a>
<a name="ln2708">     * Match from start pattern to end pattern.</a>
<a name="ln2709">     * Correct for match and highlight offset of end pattern.</a>
<a name="ln2710">     */</a>
<a name="ln2711">    spp = &amp;(SYN_ITEMS(syn_block)[best_idx]);</a>
<a name="ln2712">    syn_add_end_off(m_endpos, &amp;best_regmatch, spp, SPO_ME_OFF, 1);</a>
<a name="ln2713">    /* can't end before the start */</a>
<a name="ln2714">    if (m_endpos-&gt;lnum == startpos-&gt;lnum &amp;&amp; m_endpos-&gt;col &lt; startpos-&gt;col)</a>
<a name="ln2715">      m_endpos-&gt;col = startpos-&gt;col;</a>
<a name="ln2716"> </a>
<a name="ln2717">    syn_add_end_off(end_endpos, &amp;best_regmatch, spp, SPO_HE_OFF, 1);</a>
<a name="ln2718">    /* can't end before the start */</a>
<a name="ln2719">    if (end_endpos-&gt;lnum == startpos-&gt;lnum</a>
<a name="ln2720">        &amp;&amp; end_endpos-&gt;col &lt; startpos-&gt;col)</a>
<a name="ln2721">      end_endpos-&gt;col = startpos-&gt;col;</a>
<a name="ln2722">    /* can't end after the match */</a>
<a name="ln2723">    limit_pos(end_endpos, m_endpos);</a>
<a name="ln2724"> </a>
<a name="ln2725">    /*</a>
<a name="ln2726">     * If the end group is highlighted differently, adjust the pointers.</a>
<a name="ln2727">     */</a>
<a name="ln2728">    if (spp-&gt;sp_syn_match_id != spp-&gt;sp_syn.id &amp;&amp; spp-&gt;sp_syn_match_id != 0) {</a>
<a name="ln2729">      *end_idx = best_idx;</a>
<a name="ln2730">      if (spp-&gt;sp_off_flags &amp; (1 &lt;&lt; (SPO_RE_OFF + SPO_COUNT))) {</a>
<a name="ln2731">        hl_endpos-&gt;lnum = best_regmatch.endpos[0].lnum;</a>
<a name="ln2732">        hl_endpos-&gt;col = best_regmatch.endpos[0].col;</a>
<a name="ln2733">      } else {</a>
<a name="ln2734">        hl_endpos-&gt;lnum = best_regmatch.startpos[0].lnum;</a>
<a name="ln2735">        hl_endpos-&gt;col = best_regmatch.startpos[0].col;</a>
<a name="ln2736">      }</a>
<a name="ln2737">      hl_endpos-&gt;col += spp-&gt;sp_offsets[SPO_RE_OFF];</a>
<a name="ln2738"> </a>
<a name="ln2739">      /* can't end before the start */</a>
<a name="ln2740">      if (hl_endpos-&gt;lnum == startpos-&gt;lnum</a>
<a name="ln2741">          &amp;&amp; hl_endpos-&gt;col &lt; startpos-&gt;col)</a>
<a name="ln2742">        hl_endpos-&gt;col = startpos-&gt;col;</a>
<a name="ln2743">      limit_pos(hl_endpos, m_endpos);</a>
<a name="ln2744"> </a>
<a name="ln2745">      /* now the match ends where the highlighting ends, it is turned</a>
<a name="ln2746">       * into the matchgroup for the end */</a>
<a name="ln2747">      *m_endpos = *hl_endpos;</a>
<a name="ln2748">    } else {</a>
<a name="ln2749">      *end_idx = 0;</a>
<a name="ln2750">      *hl_endpos = *end_endpos;</a>
<a name="ln2751">    }</a>
<a name="ln2752"> </a>
<a name="ln2753">    *flagsp = spp-&gt;sp_flags;</a>
<a name="ln2754"> </a>
<a name="ln2755">    had_match = TRUE;</a>
<a name="ln2756">    break;</a>
<a name="ln2757">  }</a>
<a name="ln2758"> </a>
<a name="ln2759">  /* no match for an END pattern in this line */</a>
<a name="ln2760">  if (!had_match)</a>
<a name="ln2761">    m_endpos-&gt;lnum = 0;</a>
<a name="ln2762"> </a>
<a name="ln2763">  restore_chartab(buf_chartab);</a>
<a name="ln2764"> </a>
<a name="ln2765">  /* Remove external matches. */</a>
<a name="ln2766">  unref_extmatch(re_extmatch_in);</a>
<a name="ln2767">  re_extmatch_in = NULL;</a>
<a name="ln2768">}</a>
<a name="ln2769"> </a>
<a name="ln2770">/*</a>
<a name="ln2771"> * Limit &quot;pos&quot; not to be after &quot;limit&quot;.</a>
<a name="ln2772"> */</a>
<a name="ln2773">static void limit_pos(lpos_T *pos, lpos_T *limit)</a>
<a name="ln2774">{</a>
<a name="ln2775">  if (pos-&gt;lnum &gt; limit-&gt;lnum)</a>
<a name="ln2776">    *pos = *limit;</a>
<a name="ln2777">  else if (pos-&gt;lnum == limit-&gt;lnum &amp;&amp; pos-&gt;col &gt; limit-&gt;col)</a>
<a name="ln2778">    pos-&gt;col = limit-&gt;col;</a>
<a name="ln2779">}</a>
<a name="ln2780"> </a>
<a name="ln2781">/*</a>
<a name="ln2782"> * Limit &quot;pos&quot; not to be after &quot;limit&quot;, unless pos-&gt;lnum is zero.</a>
<a name="ln2783"> */</a>
<a name="ln2784">static void limit_pos_zero(lpos_T *pos, lpos_T *limit)</a>
<a name="ln2785">{</a>
<a name="ln2786">  if (pos-&gt;lnum == 0)</a>
<a name="ln2787">    *pos = *limit;</a>
<a name="ln2788">  else</a>
<a name="ln2789">    limit_pos(pos, limit);</a>
<a name="ln2790">}</a>
<a name="ln2791"> </a>
<a name="ln2792">/*</a>
<a name="ln2793"> * Add offset to matched text for end of match or highlight.</a>
<a name="ln2794"> */</a>
<a name="ln2795">static void</a>
<a name="ln2796">syn_add_end_off(</a>
<a name="ln2797">    lpos_T *result,           // returned position</a>
<a name="ln2798">    regmmatch_T *regmatch,    // start/end of match</a>
<a name="ln2799">    synpat_T *spp,            // matched pattern</a>
<a name="ln2800">    int idx,                  // index of offset</a>
<a name="ln2801">    int extra                 // extra chars for offset to start</a>
<a name="ln2802">)</a>
<a name="ln2803">{</a>
<a name="ln2804">  int col;</a>
<a name="ln2805">  int off;</a>
<a name="ln2806">  char_u      *base;</a>
<a name="ln2807">  char_u      *p;</a>
<a name="ln2808"> </a>
<a name="ln2809">  if (spp-&gt;sp_off_flags &amp; (1 &lt;&lt; idx)) {</a>
<a name="ln2810">    result-&gt;lnum = regmatch-&gt;startpos[0].lnum;</a>
<a name="ln2811">    col = regmatch-&gt;startpos[0].col;</a>
<a name="ln2812">    off = spp-&gt;sp_offsets[idx] + extra;</a>
<a name="ln2813">  } else {</a>
<a name="ln2814">    result-&gt;lnum = regmatch-&gt;endpos[0].lnum;</a>
<a name="ln2815">    col = regmatch-&gt;endpos[0].col;</a>
<a name="ln2816">    off = spp-&gt;sp_offsets[idx];</a>
<a name="ln2817">  }</a>
<a name="ln2818">  /* Don't go past the end of the line.  Matters for &quot;rs=e+2&quot; when there</a>
<a name="ln2819">   * is a matchgroup. Watch out for match with last NL in the buffer. */</a>
<a name="ln2820">  if (result-&gt;lnum &gt; syn_buf-&gt;b_ml.ml_line_count)</a>
<a name="ln2821">    col = 0;</a>
<a name="ln2822">  else if (off != 0) {</a>
<a name="ln2823">    base = ml_get_buf(syn_buf, result-&gt;lnum, FALSE);</a>
<a name="ln2824">    p = base + col;</a>
<a name="ln2825">    if (off &gt; 0) {</a>
<a name="ln2826">      while (off-- &gt; 0 &amp;&amp; *p != NUL) {</a>
<a name="ln2827">        MB_PTR_ADV(p);</a>
<a name="ln2828">      }</a>
<a name="ln2829">    } else {</a>
<a name="ln2830">      while (off++ &lt; 0 &amp;&amp; base &lt; p) {</a>
<a name="ln2831">        MB_PTR_BACK(base, p);</a>
<a name="ln2832">      }</a>
<a name="ln2833">    }</a>
<a name="ln2834">    col = (int)(p - base);</a>
<a name="ln2835">  }</a>
<a name="ln2836">  result-&gt;col = col;</a>
<a name="ln2837">}</a>
<a name="ln2838"> </a>
<a name="ln2839">/*</a>
<a name="ln2840"> * Add offset to matched text for start of match or highlight.</a>
<a name="ln2841"> * Avoid resulting column to become negative.</a>
<a name="ln2842"> */</a>
<a name="ln2843">static void</a>
<a name="ln2844">syn_add_start_off(</a>
<a name="ln2845">    lpos_T *result,           // returned position</a>
<a name="ln2846">    regmmatch_T *regmatch,    // start/end of match</a>
<a name="ln2847">    synpat_T *spp,</a>
<a name="ln2848">    int idx,</a>
<a name="ln2849">    int extra                 // extra chars for offset to end</a>
<a name="ln2850">)</a>
<a name="ln2851">{</a>
<a name="ln2852">  int col;</a>
<a name="ln2853">  int off;</a>
<a name="ln2854">  char_u      *base;</a>
<a name="ln2855">  char_u      *p;</a>
<a name="ln2856"> </a>
<a name="ln2857">  if (spp-&gt;sp_off_flags &amp; (1 &lt;&lt; (idx + SPO_COUNT))) {</a>
<a name="ln2858">    result-&gt;lnum = regmatch-&gt;endpos[0].lnum;</a>
<a name="ln2859">    col = regmatch-&gt;endpos[0].col;</a>
<a name="ln2860">    off = spp-&gt;sp_offsets[idx] + extra;</a>
<a name="ln2861">  } else {</a>
<a name="ln2862">    result-&gt;lnum = regmatch-&gt;startpos[0].lnum;</a>
<a name="ln2863">    col = regmatch-&gt;startpos[0].col;</a>
<a name="ln2864">    off = spp-&gt;sp_offsets[idx];</a>
<a name="ln2865">  }</a>
<a name="ln2866">  if (result-&gt;lnum &gt; syn_buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2867">    /* a &quot;\n&quot; at the end of the pattern may take us below the last line */</a>
<a name="ln2868">    result-&gt;lnum = syn_buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2869">    col = (int)STRLEN(ml_get_buf(syn_buf, result-&gt;lnum, FALSE));</a>
<a name="ln2870">  }</a>
<a name="ln2871">  if (off != 0) {</a>
<a name="ln2872">    base = ml_get_buf(syn_buf, result-&gt;lnum, FALSE);</a>
<a name="ln2873">    p = base + col;</a>
<a name="ln2874">    if (off &gt; 0) {</a>
<a name="ln2875">      while (off-- &amp;&amp; *p != NUL) {</a>
<a name="ln2876">        MB_PTR_ADV(p);</a>
<a name="ln2877">      }</a>
<a name="ln2878">    } else {</a>
<a name="ln2879">      while (off++ &amp;&amp; base &lt; p) {</a>
<a name="ln2880">        MB_PTR_BACK(base, p);</a>
<a name="ln2881">      }</a>
<a name="ln2882">    }</a>
<a name="ln2883">    col = (int)(p - base);</a>
<a name="ln2884">  }</a>
<a name="ln2885">  result-&gt;col = col;</a>
<a name="ln2886">}</a>
<a name="ln2887"> </a>
<a name="ln2888">/*</a>
<a name="ln2889"> * Get current line in syntax buffer.</a>
<a name="ln2890"> */</a>
<a name="ln2891">static char_u *syn_getcurline(void)</a>
<a name="ln2892">{</a>
<a name="ln2893">  return ml_get_buf(syn_buf, current_lnum, FALSE);</a>
<a name="ln2894">}</a>
<a name="ln2895"> </a>
<a name="ln2896">/*</a>
<a name="ln2897"> * Call vim_regexec() to find a match with &quot;rmp&quot; in &quot;syn_buf&quot;.</a>
<a name="ln2898"> * Returns TRUE when there is a match.</a>
<a name="ln2899"> */</a>
<a name="ln2900">static int syn_regexec(regmmatch_T *rmp, linenr_T lnum, colnr_T col, syn_time_T *st)</a>
<a name="ln2901">{</a>
<a name="ln2902">  int r;</a>
<a name="ln2903">  int timed_out = 0;</a>
<a name="ln2904">  proftime_T pt;</a>
<a name="ln2905">  const int l_syn_time_on = syn_time_on;</a>
<a name="ln2906"> </a>
<a name="ln2907">  if (l_syn_time_on) {</a>
<a name="ln2908">    pt = profile_start();</a>
<a name="ln2909">  }</a>
<a name="ln2910"> </a>
<a name="ln2911">  if (rmp-&gt;regprog == NULL) {</a>
<a name="ln2912">    // This can happen if a previous call to vim_regexec_multi() tried to</a>
<a name="ln2913">    // use the NFA engine, which resulted in NFA_TOO_EXPENSIVE, and</a>
<a name="ln2914">    // compiling the pattern with the other engine fails.</a>
<a name="ln2915">    return false;</a>
<a name="ln2916">  }</a>
<a name="ln2917"> </a>
<a name="ln2918">  rmp-&gt;rmm_maxcol = syn_buf-&gt;b_p_smc;</a>
<a name="ln2919">  r = vim_regexec_multi(rmp, syn_win, syn_buf, lnum, col,</a>
<a name="ln2920">                        syn_tm, &amp;timed_out);</a>
<a name="ln2921"> </a>
<a name="ln2922">  if (l_syn_time_on) {</a>
<a name="ln2923">    pt = profile_end(pt);</a>
<a name="ln2924">    st-&gt;total = profile_add(st-&gt;total, pt);</a>
<a name="ln2925">    if (profile_cmp(pt, st-&gt;slowest) &lt; 0) {</a>
<a name="ln2926">      st-&gt;slowest = pt;</a>
<a name="ln2927">    }</a>
<a name="ln2928">    ++st-&gt;count;</a>
<a name="ln2929">    if (r &gt; 0)</a>
<a name="ln2930">      ++st-&gt;match;</a>
<a name="ln2931">  }</a>
<a name="ln2932">  if (timed_out &amp;&amp; !syn_win-&gt;w_s-&gt;b_syn_slow) {</a>
<a name="ln2933">    syn_win-&gt;w_s-&gt;b_syn_slow = true;</a>
<a name="ln2934">    MSG(_(&quot;'redrawtime' exceeded, syntax highlighting disabled&quot;));</a>
<a name="ln2935">  }</a>
<a name="ln2936"> </a>
<a name="ln2937">  if (r &gt; 0) {</a>
<a name="ln2938">    rmp-&gt;startpos[0].lnum += lnum;</a>
<a name="ln2939">    rmp-&gt;endpos[0].lnum += lnum;</a>
<a name="ln2940">    return TRUE;</a>
<a name="ln2941">  }</a>
<a name="ln2942">  return FALSE;</a>
<a name="ln2943">}</a>
<a name="ln2944"> </a>
<a name="ln2945">/*</a>
<a name="ln2946"> * Check one position in a line for a matching keyword.</a>
<a name="ln2947"> * The caller must check if a keyword can start at startcol.</a>
<a name="ln2948"> * Return its ID if found, 0 otherwise.</a>
<a name="ln2949"> */</a>
<a name="ln2950">static int check_keyword_id(</a>
<a name="ln2951">    char_u *const line,</a>
<a name="ln2952">    const int startcol,           // position in line to check for keyword</a>
<a name="ln2953">    int *const endcolp,           // return: character after found keyword</a>
<a name="ln2954">    long *const flagsp,           // return: flags of matching keyword</a>
<a name="ln2955">    int16_t **const next_listp,   // return: next_list of matching keyword</a>
<a name="ln2956">    stateitem_T *const cur_si,    // item at the top of the stack</a>
<a name="ln2957">    int *const ccharp             // conceal substitution char</a>
<a name="ln2958">)</a>
<a name="ln2959">{</a>
<a name="ln2960">  // Find first character after the keyword.  First character was already</a>
<a name="ln2961">  // checked.</a>
<a name="ln2962">  char_u *const kwp = line + startcol;</a>
<a name="ln2963">  int kwlen = 0;</a>
<a name="ln2964">  do {</a>
<a name="ln2965">    kwlen += utfc_ptr2len(kwp + kwlen);</a>
<a name="ln2966">  } while (vim_iswordp_buf(kwp + kwlen, syn_buf));</a>
<a name="ln2967"> </a>
<a name="ln2968">  if (kwlen &gt; MAXKEYWLEN) {</a>
<a name="ln2969">    return 0;</a>
<a name="ln2970">  }</a>
<a name="ln2971"> </a>
<a name="ln2972">  // Must make a copy of the keyword, so we can add a NUL and make it</a>
<a name="ln2973">  // lowercase.</a>
<a name="ln2974">  char_u keyword[MAXKEYWLEN + 1];         // assume max. keyword len is 80</a>
<a name="ln2975">  STRLCPY(keyword, kwp, kwlen + 1);</a>
<a name="ln2976"> </a>
<a name="ln2977">  keyentry_T *kp = NULL;</a>
<a name="ln2978"> </a>
<a name="ln2979">  // matching case</a>
<a name="ln2980">  if (syn_block-&gt;b_keywtab.ht_used != 0) {</a>
<a name="ln2981">    kp = match_keyword(keyword, &amp;syn_block-&gt;b_keywtab, cur_si);</a>
<a name="ln2982">  }</a>
<a name="ln2983"> </a>
<a name="ln2984">  // ignoring case</a>
<a name="ln2985">  if (kp == NULL &amp;&amp; syn_block-&gt;b_keywtab_ic.ht_used != 0) {</a>
<a name="ln2986">    str_foldcase(kwp, kwlen, keyword, MAXKEYWLEN + 1);</a>
<a name="ln2987">    kp = match_keyword(keyword, &amp;syn_block-&gt;b_keywtab_ic, cur_si);</a>
<a name="ln2988">  }</a>
<a name="ln2989"> </a>
<a name="ln2990">  if (kp != NULL) {</a>
<a name="ln2991">    *endcolp = startcol + kwlen;</a>
<a name="ln2992">    *flagsp = kp-&gt;flags;</a>
<a name="ln2993">    *next_listp = kp-&gt;next_list;</a>
<a name="ln2994">    *ccharp = kp-&gt;k_char;</a>
<a name="ln2995">    return kp-&gt;k_syn.id;</a>
<a name="ln2996">  }</a>
<a name="ln2997"> </a>
<a name="ln2998">  return 0;</a>
<a name="ln2999">}</a>
<a name="ln3000"> </a>
<a name="ln3001">/// Find keywords that match.  There can be several with different</a>
<a name="ln3002">/// attributes.</a>
<a name="ln3003">/// When current_next_list is non-zero accept only that group, otherwise:</a>
<a name="ln3004">///  Accept a not-contained keyword at toplevel.</a>
<a name="ln3005">///  Accept a keyword at other levels only if it is in the contains list.</a>
<a name="ln3006">static keyentry_T *match_keyword(char_u *keyword, hashtab_T *ht,</a>
<a name="ln3007">                                 stateitem_T *cur_si)</a>
<a name="ln3008">{</a>
<a name="ln3009">  hashitem_T *hi = hash_find(ht, keyword);</a>
<a name="ln3010">  if (!HASHITEM_EMPTY(hi))</a>
<a name="ln3011">    for (keyentry_T *kp = HI2KE(hi); kp != NULL; kp = kp-&gt;ke_next) {</a>
<a name="ln3012">      if (current_next_list != 0</a>
<a name="ln3013">          ? in_id_list(NULL, current_next_list, &amp;kp-&gt;k_syn, 0)</a>
<a name="ln3014">          : (cur_si == NULL</a>
<a name="ln3015">            ? !(kp-&gt;flags &amp; HL_CONTAINED)</a>
<a name="ln3016">            : in_id_list(cur_si, cur_si-&gt;si_cont_list,</a>
<a name="ln3017">                         &amp;kp-&gt;k_syn, kp-&gt;flags &amp; HL_CONTAINED))) {</a>
<a name="ln3018">        return kp;</a>
<a name="ln3019">      }</a>
<a name="ln3020">    }</a>
<a name="ln3021">  return NULL;</a>
<a name="ln3022">}</a>
<a name="ln3023"> </a>
<a name="ln3024">/*</a>
<a name="ln3025"> * Handle &quot;:syntax conceal&quot; command.</a>
<a name="ln3026"> */</a>
<a name="ln3027">static void syn_cmd_conceal(exarg_T *eap, int syncing)</a>
<a name="ln3028">{</a>
<a name="ln3029">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln3030">  char_u      *next;</a>
<a name="ln3031"> </a>
<a name="ln3032">  eap-&gt;nextcmd = find_nextcmd(arg);</a>
<a name="ln3033">  if (eap-&gt;skip)</a>
<a name="ln3034">    return;</a>
<a name="ln3035"> </a>
<a name="ln3036">  next = skiptowhite(arg);</a>
<a name="ln3037">  if (*arg == NUL) {</a>
<a name="ln3038">    if (curwin-&gt;w_s-&gt;b_syn_conceal) {</a>
<a name="ln3039">      MSG(_(&quot;syntax conceal on&quot;));</a>
<a name="ln3040">    } else {</a>
<a name="ln3041">      MSG(_(&quot;syntax conceal off&quot;));</a>
<a name="ln3042">    }</a>
<a name="ln3043">  } else if (STRNICMP(arg, &quot;on&quot;, 2) == 0 &amp;&amp; next - arg == 2) {</a>
<a name="ln3044">    curwin-&gt;w_s-&gt;b_syn_conceal = true;</a>
<a name="ln3045">  } else if (STRNICMP(arg, &quot;off&quot;, 3) == 0 &amp;&amp; next - arg == 3) {</a>
<a name="ln3046">    curwin-&gt;w_s-&gt;b_syn_conceal = false;</a>
<a name="ln3047">  } else {</a>
<a name="ln3048">    EMSG2(_(e_illegal_arg), arg);</a>
<a name="ln3049">  }</a>
<a name="ln3050">}</a>
<a name="ln3051"> </a>
<a name="ln3052">/*</a>
<a name="ln3053"> * Handle &quot;:syntax case&quot; command.</a>
<a name="ln3054"> */</a>
<a name="ln3055">static void syn_cmd_case(exarg_T *eap, int syncing)</a>
<a name="ln3056">{</a>
<a name="ln3057">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln3058">  char_u      *next;</a>
<a name="ln3059"> </a>
<a name="ln3060">  eap-&gt;nextcmd = find_nextcmd(arg);</a>
<a name="ln3061">  if (eap-&gt;skip)</a>
<a name="ln3062">    return;</a>
<a name="ln3063"> </a>
<a name="ln3064">  next = skiptowhite(arg);</a>
<a name="ln3065">  if (*arg == NUL) {</a>
<a name="ln3066">    if (curwin-&gt;w_s-&gt;b_syn_ic) {</a>
<a name="ln3067">      MSG(_(&quot;syntax case ignore&quot;));</a>
<a name="ln3068">    } else {</a>
<a name="ln3069">      MSG(_(&quot;syntax case match&quot;));</a>
<a name="ln3070">    }</a>
<a name="ln3071">  } else if (STRNICMP(arg, &quot;match&quot;, 5) == 0 &amp;&amp; next - arg == 5) {</a>
<a name="ln3072">    curwin-&gt;w_s-&gt;b_syn_ic = false;</a>
<a name="ln3073">  } else if (STRNICMP(arg, &quot;ignore&quot;, 6) == 0 &amp;&amp; next - arg == 6) {</a>
<a name="ln3074">    curwin-&gt;w_s-&gt;b_syn_ic = true;</a>
<a name="ln3075">  } else {</a>
<a name="ln3076">    EMSG2(_(e_illegal_arg), arg);</a>
<a name="ln3077">  }</a>
<a name="ln3078">}</a>
<a name="ln3079"> </a>
<a name="ln3080">/// Handle &quot;:syntax foldlevel&quot; command.</a>
<a name="ln3081">static void syn_cmd_foldlevel(exarg_T *eap, int syncing)</a>
<a name="ln3082">{</a>
<a name="ln3083">  char_u *arg = eap-&gt;arg;</a>
<a name="ln3084">  char_u *arg_end;</a>
<a name="ln3085"> </a>
<a name="ln3086">  eap-&gt;nextcmd = find_nextcmd(arg);</a>
<a name="ln3087">  if (eap-&gt;skip)</a>
<a name="ln3088">    return;</a>
<a name="ln3089"> </a>
<a name="ln3090">  if (*arg == NUL) {</a>
<a name="ln3091">    switch (curwin-&gt;w_s-&gt;b_syn_foldlevel) {</a>
<a name="ln3092">    case SYNFLD_START:   MSG(_(&quot;syntax foldlevel start&quot;));   break;</a>
<a name="ln3093">    case SYNFLD_MINIMUM: MSG(_(&quot;syntax foldlevel minimum&quot;)); break;</a>
<a name="ln3094">    default: break;</a>
<a name="ln3095">    }</a>
<a name="ln3096">    return;</a>
<a name="ln3097">  }</a>
<a name="ln3098"> </a>
<a name="ln3099">  arg_end = skiptowhite(arg);</a>
<a name="ln3100">  if (STRNICMP(arg, &quot;start&quot;, 5) == 0 &amp;&amp; arg_end - arg == 5) {</a>
<a name="ln3101">    curwin-&gt;w_s-&gt;b_syn_foldlevel = SYNFLD_START;</a>
<a name="ln3102">  } else if (STRNICMP(arg, &quot;minimum&quot;, 7) == 0 &amp;&amp; arg_end - arg == 7) {</a>
<a name="ln3103">    curwin-&gt;w_s-&gt;b_syn_foldlevel = SYNFLD_MINIMUM;</a>
<a name="ln3104">  } else {</a>
<a name="ln3105">    EMSG2(_(e_illegal_arg), arg);</a>
<a name="ln3106">    return;</a>
<a name="ln3107">  }</a>
<a name="ln3108"> </a>
<a name="ln3109">  arg = skipwhite(arg_end);</a>
<a name="ln3110">  if (*arg != NUL) {</a>
<a name="ln3111">    EMSG2(_(e_illegal_arg), arg);</a>
<a name="ln3112">  }</a>
<a name="ln3113">}</a>
<a name="ln3114"> </a>
<a name="ln3115">/*</a>
<a name="ln3116"> * Handle &quot;:syntax spell&quot; command.</a>
<a name="ln3117"> */</a>
<a name="ln3118">static void syn_cmd_spell(exarg_T *eap, int syncing)</a>
<a name="ln3119">{</a>
<a name="ln3120">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln3121">  char_u      *next;</a>
<a name="ln3122"> </a>
<a name="ln3123">  eap-&gt;nextcmd = find_nextcmd(arg);</a>
<a name="ln3124">  if (eap-&gt;skip)</a>
<a name="ln3125">    return;</a>
<a name="ln3126"> </a>
<a name="ln3127">  next = skiptowhite(arg);</a>
<a name="ln3128">  if (*arg == NUL) {</a>
<a name="ln3129">    if (curwin-&gt;w_s-&gt;b_syn_spell == SYNSPL_TOP) {</a>
<a name="ln3130">      MSG(_(&quot;syntax spell toplevel&quot;));</a>
<a name="ln3131">    } else if (curwin-&gt;w_s-&gt;b_syn_spell == SYNSPL_NOTOP) {</a>
<a name="ln3132">      MSG(_(&quot;syntax spell notoplevel&quot;));</a>
<a name="ln3133">    } else {</a>
<a name="ln3134">      MSG(_(&quot;syntax spell default&quot;));</a>
<a name="ln3135">    }</a>
<a name="ln3136">  } else if (STRNICMP(arg, &quot;toplevel&quot;, 8) == 0 &amp;&amp; next - arg == 8) {</a>
<a name="ln3137">    curwin-&gt;w_s-&gt;b_syn_spell = SYNSPL_TOP;</a>
<a name="ln3138">  } else if (STRNICMP(arg, &quot;notoplevel&quot;, 10) == 0 &amp;&amp; next - arg == 10) {</a>
<a name="ln3139">    curwin-&gt;w_s-&gt;b_syn_spell = SYNSPL_NOTOP;</a>
<a name="ln3140">  } else if (STRNICMP(arg, &quot;default&quot;, 7) == 0 &amp;&amp; next - arg == 7) {</a>
<a name="ln3141">    curwin-&gt;w_s-&gt;b_syn_spell = SYNSPL_DEFAULT;</a>
<a name="ln3142">  } else {</a>
<a name="ln3143">    EMSG2(_(e_illegal_arg), arg);</a>
<a name="ln3144">    return;</a>
<a name="ln3145">  }</a>
<a name="ln3146"> </a>
<a name="ln3147">  // assume spell checking changed, force a redraw</a>
<a name="ln3148">  redraw_later(curwin, NOT_VALID);</a>
<a name="ln3149">}</a>
<a name="ln3150"> </a>
<a name="ln3151">/// Handle &quot;:syntax iskeyword&quot; command.</a>
<a name="ln3152">static void syn_cmd_iskeyword(exarg_T *eap, int syncing)</a>
<a name="ln3153">{</a>
<a name="ln3154">  char_u *arg = eap-&gt;arg;</a>
<a name="ln3155">  char_u save_chartab[32];</a>
<a name="ln3156">  char_u *save_isk;</a>
<a name="ln3157"> </a>
<a name="ln3158">  if (eap-&gt;skip) {</a>
<a name="ln3159">    return;</a>
<a name="ln3160">  }</a>
<a name="ln3161"> </a>
<a name="ln3162">  arg = skipwhite(arg);</a>
<a name="ln3163">  if (*arg == NUL) {</a>
<a name="ln3164">    MSG_PUTS(&quot;\n&quot;);</a>
<a name="ln3165">    if (curwin-&gt;w_s-&gt;b_syn_isk != empty_option) {</a>
<a name="ln3166">      MSG_PUTS(_(&quot;syntax iskeyword &quot;));</a>
<a name="ln3167">      msg_outtrans(curwin-&gt;w_s-&gt;b_syn_isk);</a>
<a name="ln3168">    } else {</a>
<a name="ln3169">      msg_outtrans((char_u *)_(&quot;syntax iskeyword not set&quot;));</a>
<a name="ln3170">    }</a>
<a name="ln3171">  } else {</a>
<a name="ln3172">    if (STRNICMP(arg, &quot;clear&quot;, 5) == 0) {</a>
<a name="ln3173">      memmove(curwin-&gt;w_s-&gt;b_syn_chartab, curbuf-&gt;b_chartab, (size_t)32);</a>
<a name="ln3174">      clear_string_option(&amp;curwin-&gt;w_s-&gt;b_syn_isk);</a>
<a name="ln3175">    } else {</a>
<a name="ln3176">      memmove(save_chartab, curbuf-&gt;b_chartab, (size_t)32);</a>
<a name="ln3177">      save_isk = curbuf-&gt;b_p_isk;</a>
<a name="ln3178">      curbuf-&gt;b_p_isk = vim_strsave(arg);</a>
<a name="ln3179"> </a>
<a name="ln3180">      buf_init_chartab(curbuf, false);</a>
<a name="ln3181">      memmove(curwin-&gt;w_s-&gt;b_syn_chartab, curbuf-&gt;b_chartab, (size_t)32);</a>
<a name="ln3182">      memmove(curbuf-&gt;b_chartab, save_chartab, (size_t)32);</a>
<a name="ln3183">      clear_string_option(&amp;curwin-&gt;w_s-&gt;b_syn_isk);</a>
<a name="ln3184">      curwin-&gt;w_s-&gt;b_syn_isk = curbuf-&gt;b_p_isk;</a>
<a name="ln3185">      curbuf-&gt;b_p_isk = save_isk;</a>
<a name="ln3186">    }</a>
<a name="ln3187">  }</a>
<a name="ln3188">  redraw_later(curwin, NOT_VALID);</a>
<a name="ln3189">}</a>
<a name="ln3190"> </a>
<a name="ln3191">/*</a>
<a name="ln3192"> * Clear all syntax info for one buffer.</a>
<a name="ln3193"> */</a>
<a name="ln3194">void syntax_clear(synblock_T *block)</a>
<a name="ln3195">{</a>
<a name="ln3196">  block-&gt;b_syn_error = false;           // clear previous error</a>
<a name="ln3197">  block-&gt;b_syn_slow = false;            // clear previous timeout</a>
<a name="ln3198">  block-&gt;b_syn_ic = false;              // Use case, by default</a>
<a name="ln3199">  block-&gt;b_syn_foldlevel = SYNFLD_START;</a>
<a name="ln3200">  block-&gt;b_syn_spell = SYNSPL_DEFAULT;  // default spell checking</a>
<a name="ln3201">  block-&gt;b_syn_containedin = false;</a>
<a name="ln3202">  block-&gt;b_syn_conceal = false;</a>
<a name="ln3203"> </a>
<a name="ln3204">  /* free the keywords */</a>
<a name="ln3205">  clear_keywtab(&amp;block-&gt;b_keywtab);</a>
<a name="ln3206">  clear_keywtab(&amp;block-&gt;b_keywtab_ic);</a>
<a name="ln3207"> </a>
<a name="ln3208">  /* free the syntax patterns */</a>
<a name="ln3209">  for (int i = block-&gt;b_syn_patterns.ga_len; --i &gt;= 0; ) {</a>
<a name="ln3210">    syn_clear_pattern(block, i);</a>
<a name="ln3211">  }</a>
<a name="ln3212">  ga_clear(&amp;block-&gt;b_syn_patterns);</a>
<a name="ln3213"> </a>
<a name="ln3214">  /* free the syntax clusters */</a>
<a name="ln3215">  for (int i = block-&gt;b_syn_clusters.ga_len; --i &gt;= 0; ) {</a>
<a name="ln3216">    syn_clear_cluster(block, i);</a>
<a name="ln3217">  }</a>
<a name="ln3218">  ga_clear(&amp;block-&gt;b_syn_clusters);</a>
<a name="ln3219">  block-&gt;b_spell_cluster_id = 0;</a>
<a name="ln3220">  block-&gt;b_nospell_cluster_id = 0;</a>
<a name="ln3221"> </a>
<a name="ln3222">  block-&gt;b_syn_sync_flags = 0;</a>
<a name="ln3223">  block-&gt;b_syn_sync_minlines = 0;</a>
<a name="ln3224">  block-&gt;b_syn_sync_maxlines = 0;</a>
<a name="ln3225">  block-&gt;b_syn_sync_linebreaks = 0;</a>
<a name="ln3226"> </a>
<a name="ln3227">  vim_regfree(block-&gt;b_syn_linecont_prog);</a>
<a name="ln3228">  block-&gt;b_syn_linecont_prog = NULL;</a>
<a name="ln3229">  XFREE_CLEAR(block-&gt;b_syn_linecont_pat);</a>
<a name="ln3230">  block-&gt;b_syn_folditems = 0;</a>
<a name="ln3231">  clear_string_option(&amp;block-&gt;b_syn_isk);</a>
<a name="ln3232"> </a>
<a name="ln3233">  /* free the stored states */</a>
<a name="ln3234">  syn_stack_free_all(block);</a>
<a name="ln3235">  invalidate_current_state();</a>
<a name="ln3236"> </a>
<a name="ln3237">  /* Reset the counter for &quot;:syn include&quot; */</a>
<a name="ln3238">  running_syn_inc_tag = 0;</a>
<a name="ln3239">}</a>
<a name="ln3240"> </a>
<a name="ln3241">/*</a>
<a name="ln3242"> * Get rid of ownsyntax for window &quot;wp&quot;.</a>
<a name="ln3243"> */</a>
<a name="ln3244">void reset_synblock(win_T *wp)</a>
<a name="ln3245">{</a>
<a name="ln3246">  if (wp-&gt;w_s != &amp;wp-&gt;w_buffer-&gt;b_s) {</a>
<a name="ln3247">    syntax_clear(wp-&gt;w_s);</a>
<a name="ln3248">    xfree(wp-&gt;w_s);</a>
<a name="ln3249">    wp-&gt;w_s = &amp;wp-&gt;w_buffer-&gt;b_s;</a>
<a name="ln3250">  }</a>
<a name="ln3251">}</a>
<a name="ln3252"> </a>
<a name="ln3253">/*</a>
<a name="ln3254"> * Clear syncing info for one buffer.</a>
<a name="ln3255"> */</a>
<a name="ln3256">static void syntax_sync_clear(void)</a>
<a name="ln3257">{</a>
<a name="ln3258">  /* free the syntax patterns */</a>
<a name="ln3259">  for (int i = curwin-&gt;w_s-&gt;b_syn_patterns.ga_len; --i &gt;= 0; ) {</a>
<a name="ln3260">    if (SYN_ITEMS(curwin-&gt;w_s)[i].sp_syncing) {</a>
<a name="ln3261">      syn_remove_pattern(curwin-&gt;w_s, i);</a>
<a name="ln3262">    }</a>
<a name="ln3263">  }</a>
<a name="ln3264"> </a>
<a name="ln3265">  curwin-&gt;w_s-&gt;b_syn_sync_flags = 0;</a>
<a name="ln3266">  curwin-&gt;w_s-&gt;b_syn_sync_minlines = 0;</a>
<a name="ln3267">  curwin-&gt;w_s-&gt;b_syn_sync_maxlines = 0;</a>
<a name="ln3268">  curwin-&gt;w_s-&gt;b_syn_sync_linebreaks = 0;</a>
<a name="ln3269"> </a>
<a name="ln3270">  vim_regfree(curwin-&gt;w_s-&gt;b_syn_linecont_prog);</a>
<a name="ln3271">  curwin-&gt;w_s-&gt;b_syn_linecont_prog = NULL;</a>
<a name="ln3272">  XFREE_CLEAR(curwin-&gt;w_s-&gt;b_syn_linecont_pat);</a>
<a name="ln3273">  clear_string_option(&amp;curwin-&gt;w_s-&gt;b_syn_isk);</a>
<a name="ln3274"> </a>
<a name="ln3275">  syn_stack_free_all(curwin-&gt;w_s);              /* Need to recompute all syntax. */</a>
<a name="ln3276">}</a>
<a name="ln3277"> </a>
<a name="ln3278">/*</a>
<a name="ln3279"> * Remove one pattern from the buffer's pattern list.</a>
<a name="ln3280"> */</a>
<a name="ln3281">static void syn_remove_pattern(synblock_T *block, int idx)</a>
<a name="ln3282">{</a>
<a name="ln3283">  synpat_T    *spp;</a>
<a name="ln3284"> </a>
<a name="ln3285">  spp = &amp;(SYN_ITEMS(block)[idx]);</a>
<a name="ln3286">  if (spp-&gt;sp_flags &amp; HL_FOLD)</a>
<a name="ln3287">    --block-&gt;b_syn_folditems;</a>
<a name="ln3288">  syn_clear_pattern(block, idx);</a>
<a name="ln3289">  memmove(spp, spp + 1,</a>
<a name="ln3290">      sizeof(synpat_T) * (block-&gt;b_syn_patterns.ga_len - idx - 1));</a>
<a name="ln3291">  --block-&gt;b_syn_patterns.ga_len;</a>
<a name="ln3292">}</a>
<a name="ln3293"> </a>
<a name="ln3294">/*</a>
<a name="ln3295"> * Clear and free one syntax pattern.  When clearing all, must be called from</a>
<a name="ln3296"> * last to first!</a>
<a name="ln3297"> */</a>
<a name="ln3298">static void syn_clear_pattern(synblock_T *block, int i)</a>
<a name="ln3299">{</a>
<a name="ln3300">  xfree(SYN_ITEMS(block)[i].sp_pattern);</a>
<a name="ln3301">  vim_regfree(SYN_ITEMS(block)[i].sp_prog);</a>
<a name="ln3302">  /* Only free sp_cont_list and sp_next_list of first start pattern */</a>
<a name="ln3303">  if (i == 0 || SYN_ITEMS(block)[i - 1].sp_type != SPTYPE_START) {</a>
<a name="ln3304">    xfree(SYN_ITEMS(block)[i].sp_cont_list);</a>
<a name="ln3305">    xfree(SYN_ITEMS(block)[i].sp_next_list);</a>
<a name="ln3306">    xfree(SYN_ITEMS(block)[i].sp_syn.cont_in_list);</a>
<a name="ln3307">  }</a>
<a name="ln3308">}</a>
<a name="ln3309"> </a>
<a name="ln3310">/*</a>
<a name="ln3311"> * Clear and free one syntax cluster.</a>
<a name="ln3312"> */</a>
<a name="ln3313">static void syn_clear_cluster(synblock_T *block, int i)</a>
<a name="ln3314">{</a>
<a name="ln3315">  xfree(SYN_CLSTR(block)[i].scl_name);</a>
<a name="ln3316">  xfree(SYN_CLSTR(block)[i].scl_name_u);</a>
<a name="ln3317">  xfree(SYN_CLSTR(block)[i].scl_list);</a>
<a name="ln3318">}</a>
<a name="ln3319"> </a>
<a name="ln3320">/*</a>
<a name="ln3321"> * Handle &quot;:syntax clear&quot; command.</a>
<a name="ln3322"> */</a>
<a name="ln3323">static void syn_cmd_clear(exarg_T *eap, int syncing)</a>
<a name="ln3324">{</a>
<a name="ln3325">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln3326">  char_u      *arg_end;</a>
<a name="ln3327">  int id;</a>
<a name="ln3328"> </a>
<a name="ln3329">  eap-&gt;nextcmd = find_nextcmd(arg);</a>
<a name="ln3330">  if (eap-&gt;skip)</a>
<a name="ln3331">    return;</a>
<a name="ln3332"> </a>
<a name="ln3333">  /*</a>
<a name="ln3334">   * We have to disable this within &quot;:syn include @group filename&quot;,</a>
<a name="ln3335">   * because otherwise @group would get deleted.</a>
<a name="ln3336">   * Only required for Vim 5.x syntax files, 6.0 ones don't contain &quot;:syn</a>
<a name="ln3337">   * clear&quot;.</a>
<a name="ln3338">   */</a>
<a name="ln3339">  if (curwin-&gt;w_s-&gt;b_syn_topgrp != 0)</a>
<a name="ln3340">    return;</a>
<a name="ln3341"> </a>
<a name="ln3342">  if (ends_excmd(*arg)) {</a>
<a name="ln3343">    /*</a>
<a name="ln3344">     * No argument: Clear all syntax items.</a>
<a name="ln3345">     */</a>
<a name="ln3346">    if (syncing)</a>
<a name="ln3347">      syntax_sync_clear();</a>
<a name="ln3348">    else {</a>
<a name="ln3349">      syntax_clear(curwin-&gt;w_s);</a>
<a name="ln3350">      if (curwin-&gt;w_s == &amp;curwin-&gt;w_buffer-&gt;b_s) {</a>
<a name="ln3351">        do_unlet(S_LEN(&quot;b:current_syntax&quot;), true);</a>
<a name="ln3352">      }</a>
<a name="ln3353">      do_unlet(S_LEN(&quot;w:current_syntax&quot;), true);</a>
<a name="ln3354">    }</a>
<a name="ln3355">  } else {</a>
<a name="ln3356">    /*</a>
<a name="ln3357">     * Clear the group IDs that are in the argument.</a>
<a name="ln3358">     */</a>
<a name="ln3359">    while (!ends_excmd(*arg)) {</a>
<a name="ln3360">      arg_end = skiptowhite(arg);</a>
<a name="ln3361">      if (*arg == '@') {</a>
<a name="ln3362">        id = syn_scl_namen2id(arg + 1, (int)(arg_end - arg - 1));</a>
<a name="ln3363">        if (id == 0) {</a>
<a name="ln3364">          EMSG2(_(&quot;E391: No such syntax cluster: %s&quot;), arg);</a>
<a name="ln3365">          break;</a>
<a name="ln3366">        } else {</a>
<a name="ln3367">          // We can't physically delete a cluster without changing</a>
<a name="ln3368">          // the IDs of other clusters, so we do the next best thing</a>
<a name="ln3369">          // and make it empty.</a>
<a name="ln3370">          int scl_id = id - SYNID_CLUSTER;</a>
<a name="ln3371"> </a>
<a name="ln3372">          XFREE_CLEAR(SYN_CLSTR(curwin-&gt;w_s)[scl_id].scl_list);</a>
<a name="ln3373">        }</a>
<a name="ln3374">      } else {</a>
<a name="ln3375">        id = syn_namen2id(arg, (int)(arg_end - arg));</a>
<a name="ln3376">        if (id == 0) {</a>
<a name="ln3377">          EMSG2(_(e_nogroup), arg);</a>
<a name="ln3378">          break;</a>
<a name="ln3379">        } else</a>
<a name="ln3380">          syn_clear_one(id, syncing);</a>
<a name="ln3381">      }</a>
<a name="ln3382">      arg = skipwhite(arg_end);</a>
<a name="ln3383">    }</a>
<a name="ln3384">  }</a>
<a name="ln3385">  redraw_curbuf_later(SOME_VALID);</a>
<a name="ln3386">  syn_stack_free_all(curwin-&gt;w_s);              /* Need to recompute all syntax. */</a>
<a name="ln3387">}</a>
<a name="ln3388"> </a>
<a name="ln3389">/*</a>
<a name="ln3390"> * Clear one syntax group for the current buffer.</a>
<a name="ln3391"> */</a>
<a name="ln3392">static void syn_clear_one(const int id, const bool syncing)</a>
<a name="ln3393">{</a>
<a name="ln3394">  synpat_T    *spp;</a>
<a name="ln3395"> </a>
<a name="ln3396">  /* Clear keywords only when not &quot;:syn sync clear group-name&quot; */</a>
<a name="ln3397">  if (!syncing) {</a>
<a name="ln3398">    syn_clear_keyword(id, &amp;curwin-&gt;w_s-&gt;b_keywtab);</a>
<a name="ln3399">    syn_clear_keyword(id, &amp;curwin-&gt;w_s-&gt;b_keywtab_ic);</a>
<a name="ln3400">  }</a>
<a name="ln3401"> </a>
<a name="ln3402">  /* clear the patterns for &quot;id&quot; */</a>
<a name="ln3403">  for (int idx = curwin-&gt;w_s-&gt;b_syn_patterns.ga_len; --idx &gt;= 0; ) {</a>
<a name="ln3404">    spp = &amp;(SYN_ITEMS(curwin-&gt;w_s)[idx]);</a>
<a name="ln3405">    if (spp-&gt;sp_syn.id != id || spp-&gt;sp_syncing != syncing)</a>
<a name="ln3406">      continue;</a>
<a name="ln3407">    syn_remove_pattern(curwin-&gt;w_s, idx);</a>
<a name="ln3408">  }</a>
<a name="ln3409">}</a>
<a name="ln3410"> </a>
<a name="ln3411">/*</a>
<a name="ln3412"> * Handle &quot;:syntax on&quot; command.</a>
<a name="ln3413"> */</a>
<a name="ln3414">static void syn_cmd_on(exarg_T *eap, int syncing)</a>
<a name="ln3415">{</a>
<a name="ln3416">  syn_cmd_onoff(eap, &quot;syntax&quot;);</a>
<a name="ln3417">}</a>
<a name="ln3418"> </a>
<a name="ln3419">/*</a>
<a name="ln3420"> * Handle &quot;:syntax enable&quot; command.</a>
<a name="ln3421"> */</a>
<a name="ln3422">static void syn_cmd_enable(exarg_T *eap, int syncing)</a>
<a name="ln3423">{</a>
<a name="ln3424">  set_internal_string_var(&quot;syntax_cmd&quot;, (char_u *)&quot;enable&quot;);</a>
<a name="ln3425">  syn_cmd_onoff(eap, &quot;syntax&quot;);</a>
<a name="ln3426">  do_unlet(S_LEN(&quot;g:syntax_cmd&quot;), true);</a>
<a name="ln3427">}</a>
<a name="ln3428"> </a>
<a name="ln3429">/*</a>
<a name="ln3430"> * Handle &quot;:syntax reset&quot; command.</a>
<a name="ln3431"> * It actually resets highlighting, not syntax.</a>
<a name="ln3432"> */</a>
<a name="ln3433">static void syn_cmd_reset(exarg_T *eap, int syncing)</a>
<a name="ln3434">{</a>
<a name="ln3435">  eap-&gt;nextcmd = check_nextcmd(eap-&gt;arg);</a>
<a name="ln3436">  if (!eap-&gt;skip) {</a>
<a name="ln3437">    set_internal_string_var(&quot;syntax_cmd&quot;, (char_u *)&quot;reset&quot;);</a>
<a name="ln3438">    do_cmdline_cmd(&quot;runtime! syntax/syncolor.vim&quot;);</a>
<a name="ln3439">    do_unlet(S_LEN(&quot;g:syntax_cmd&quot;), true);</a>
<a name="ln3440">  }</a>
<a name="ln3441">}</a>
<a name="ln3442"> </a>
<a name="ln3443">/*</a>
<a name="ln3444"> * Handle &quot;:syntax manual&quot; command.</a>
<a name="ln3445"> */</a>
<a name="ln3446">static void syn_cmd_manual(exarg_T *eap, int syncing)</a>
<a name="ln3447">{</a>
<a name="ln3448">  syn_cmd_onoff(eap, &quot;manual&quot;);</a>
<a name="ln3449">}</a>
<a name="ln3450"> </a>
<a name="ln3451">/*</a>
<a name="ln3452"> * Handle &quot;:syntax off&quot; command.</a>
<a name="ln3453"> */</a>
<a name="ln3454">static void syn_cmd_off(exarg_T *eap, int syncing)</a>
<a name="ln3455">{</a>
<a name="ln3456">  syn_cmd_onoff(eap, &quot;nosyntax&quot;);</a>
<a name="ln3457">}</a>
<a name="ln3458"> </a>
<a name="ln3459">static void syn_cmd_onoff(exarg_T *eap, char *name)</a>
<a name="ln3460">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3461">{</a>
<a name="ln3462">  eap-&gt;nextcmd = check_nextcmd(eap-&gt;arg);</a>
<a name="ln3463">  if (!eap-&gt;skip) {</a>
<a name="ln3464">    did_syntax_onoff = true;</a>
<a name="ln3465">    char buf[100];</a>
<a name="ln3466">    memcpy(buf, &quot;so &quot;, 4);</a>
<a name="ln3467">    vim_snprintf(buf + 3, sizeof(buf) - 3, SYNTAX_FNAME, name);</a>
<a name="ln3468">    do_cmdline_cmd(buf);</a>
<a name="ln3469">  }</a>
<a name="ln3470">}</a>
<a name="ln3471"> </a>
<a name="ln3472">void syn_maybe_on(void)</a>
<a name="ln3473">{</a>
<a name="ln3474">  if (!did_syntax_onoff) {</a>
<a name="ln3475">    exarg_T ea;</a>
<a name="ln3476">    ea.arg = (char_u *)&quot;&quot;;</a>
<a name="ln3477">    ea.skip = false;</a>
<a name="ln3478">    syn_cmd_onoff(&amp;ea, &quot;syntax&quot;);</a>
<a name="ln3479">  }</a>
<a name="ln3480">}</a>
<a name="ln3481"> </a>
<a name="ln3482">/*</a>
<a name="ln3483"> * Handle &quot;:syntax [list]&quot; command: list current syntax words.</a>
<a name="ln3484"> */</a>
<a name="ln3485">static void</a>
<a name="ln3486">syn_cmd_list(</a>
<a name="ln3487">    exarg_T *eap,</a>
<a name="ln3488">    int syncing                        /* when TRUE: list syncing items */</a>
<a name="ln3489">)</a>
<a name="ln3490">{</a>
<a name="ln3491">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln3492">  char_u      *arg_end;</a>
<a name="ln3493"> </a>
<a name="ln3494">  eap-&gt;nextcmd = find_nextcmd(arg);</a>
<a name="ln3495">  if (eap-&gt;skip)</a>
<a name="ln3496">    return;</a>
<a name="ln3497"> </a>
<a name="ln3498">  if (!syntax_present(curwin)) {</a>
<a name="ln3499">    MSG(_(msg_no_items));</a>
<a name="ln3500">    return;</a>
<a name="ln3501">  }</a>
<a name="ln3502"> </a>
<a name="ln3503">  if (syncing) {</a>
<a name="ln3504">    if (curwin-&gt;w_s-&gt;b_syn_sync_flags &amp; SF_CCOMMENT) {</a>
<a name="ln3505">      MSG_PUTS(_(&quot;syncing on C-style comments&quot;));</a>
<a name="ln3506">      syn_lines_msg();</a>
<a name="ln3507">      syn_match_msg();</a>
<a name="ln3508">      return;</a>
<a name="ln3509">    } else if (!(curwin-&gt;w_s-&gt;b_syn_sync_flags &amp; SF_MATCH))   {</a>
<a name="ln3510">      if (curwin-&gt;w_s-&gt;b_syn_sync_minlines == 0) {</a>
<a name="ln3511">        MSG_PUTS(_(&quot;no syncing&quot;));</a>
<a name="ln3512">      } else {</a>
<a name="ln3513">        if (curwin-&gt;w_s-&gt;b_syn_sync_minlines == MAXLNUM) {</a>
<a name="ln3514">          MSG_PUTS(_(&quot;syncing starts at the first line&quot;));</a>
<a name="ln3515">        } else {</a>
<a name="ln3516">          MSG_PUTS(_(&quot;syncing starts &quot;));</a>
<a name="ln3517">          msg_outnum(curwin-&gt;w_s-&gt;b_syn_sync_minlines);</a>
<a name="ln3518">          MSG_PUTS(_(&quot; lines before top line&quot;));</a>
<a name="ln3519">        }</a>
<a name="ln3520">        syn_match_msg();</a>
<a name="ln3521">      }</a>
<a name="ln3522">      return;</a>
<a name="ln3523">    }</a>
<a name="ln3524">    MSG_PUTS_TITLE(_(&quot;\n--- Syntax sync items ---&quot;));</a>
<a name="ln3525">    if (curwin-&gt;w_s-&gt;b_syn_sync_minlines &gt; 0</a>
<a name="ln3526">        || curwin-&gt;w_s-&gt;b_syn_sync_maxlines &gt; 0</a>
<a name="ln3527">        || curwin-&gt;w_s-&gt;b_syn_sync_linebreaks &gt; 0) {</a>
<a name="ln3528">      MSG_PUTS(_(&quot;\nsyncing on items&quot;));</a>
<a name="ln3529">      syn_lines_msg();</a>
<a name="ln3530">      syn_match_msg();</a>
<a name="ln3531">    }</a>
<a name="ln3532">  } else</a>
<a name="ln3533">    MSG_PUTS_TITLE(_(&quot;\n--- Syntax items ---&quot;));</a>
<a name="ln3534">  if (ends_excmd(*arg)) {</a>
<a name="ln3535">    /*</a>
<a name="ln3536">     * No argument: List all group IDs and all syntax clusters.</a>
<a name="ln3537">     */</a>
<a name="ln3538">    for (int id = 1; id &lt;= highlight_ga.ga_len &amp;&amp; !got_int; id++) {</a>
<a name="ln3539">      syn_list_one(id, syncing, false);</a>
<a name="ln3540">    }</a>
<a name="ln3541">    for (int id = 0; id &lt; curwin-&gt;w_s-&gt;b_syn_clusters.ga_len &amp;&amp; !got_int; ++id) {</a>
<a name="ln3542">      syn_list_cluster(id);</a>
<a name="ln3543">    }</a>
<a name="ln3544">  } else {</a>
<a name="ln3545">    /*</a>
<a name="ln3546">     * List the group IDs and syntax clusters that are in the argument.</a>
<a name="ln3547">     */</a>
<a name="ln3548">    while (!ends_excmd(*arg) &amp;&amp; !got_int) {</a>
<a name="ln3549">      arg_end = skiptowhite(arg);</a>
<a name="ln3550">      if (*arg == '@') {</a>
<a name="ln3551">        int id = syn_scl_namen2id(arg + 1, (int)(arg_end - arg - 1));</a>
<a name="ln3552">        if (id == 0)</a>
<a name="ln3553">          EMSG2(_(&quot;E392: No such syntax cluster: %s&quot;), arg);</a>
<a name="ln3554">        else</a>
<a name="ln3555">          syn_list_cluster(id - SYNID_CLUSTER);</a>
<a name="ln3556">      } else {</a>
<a name="ln3557">        int id = syn_namen2id(arg, (int)(arg_end - arg));</a>
<a name="ln3558">        if (id == 0) {</a>
<a name="ln3559">          EMSG2(_(e_nogroup), arg);</a>
<a name="ln3560">        } else {</a>
<a name="ln3561">          syn_list_one(id, syncing, true);</a>
<a name="ln3562">        }</a>
<a name="ln3563">      }</a>
<a name="ln3564">      arg = skipwhite(arg_end);</a>
<a name="ln3565">    }</a>
<a name="ln3566">  }</a>
<a name="ln3567">  eap-&gt;nextcmd = check_nextcmd(arg);</a>
<a name="ln3568">}</a>
<a name="ln3569"> </a>
<a name="ln3570">static void syn_lines_msg(void)</a>
<a name="ln3571">{</a>
<a name="ln3572">  if (curwin-&gt;w_s-&gt;b_syn_sync_maxlines &gt; 0</a>
<a name="ln3573">      || curwin-&gt;w_s-&gt;b_syn_sync_minlines &gt; 0) {</a>
<a name="ln3574">    MSG_PUTS(&quot;; &quot;);</a>
<a name="ln3575">    if (curwin-&gt;w_s-&gt;b_syn_sync_minlines == MAXLNUM) {</a>
<a name="ln3576">      MSG_PUTS(_(&quot;from the first line&quot;));</a>
<a name="ln3577">    } else {</a>
<a name="ln3578">      if (curwin-&gt;w_s-&gt;b_syn_sync_minlines &gt; 0) {</a>
<a name="ln3579">        MSG_PUTS(_(&quot;minimal &quot;));</a>
<a name="ln3580">        msg_outnum(curwin-&gt;w_s-&gt;b_syn_sync_minlines);</a>
<a name="ln3581">        if (curwin-&gt;w_s-&gt;b_syn_sync_maxlines) {</a>
<a name="ln3582">          MSG_PUTS(&quot;, &quot;);</a>
<a name="ln3583">        }</a>
<a name="ln3584">      }</a>
<a name="ln3585">      if (curwin-&gt;w_s-&gt;b_syn_sync_maxlines &gt; 0) {</a>
<a name="ln3586">        MSG_PUTS(_(&quot;maximal &quot;));</a>
<a name="ln3587">        msg_outnum(curwin-&gt;w_s-&gt;b_syn_sync_maxlines);</a>
<a name="ln3588">      }</a>
<a name="ln3589">      MSG_PUTS(_(&quot; lines before top line&quot;));</a>
<a name="ln3590">    }</a>
<a name="ln3591">  }</a>
<a name="ln3592">}</a>
<a name="ln3593"> </a>
<a name="ln3594">static void syn_match_msg(void)</a>
<a name="ln3595">{</a>
<a name="ln3596">  if (curwin-&gt;w_s-&gt;b_syn_sync_linebreaks &gt; 0) {</a>
<a name="ln3597">    MSG_PUTS(_(&quot;; match &quot;));</a>
<a name="ln3598">    msg_outnum(curwin-&gt;w_s-&gt;b_syn_sync_linebreaks);</a>
<a name="ln3599">    MSG_PUTS(_(&quot; line breaks&quot;));</a>
<a name="ln3600">  }</a>
<a name="ln3601">}</a>
<a name="ln3602"> </a>
<a name="ln3603">static int last_matchgroup;</a>
<a name="ln3604"> </a>
<a name="ln3605"> </a>
<a name="ln3606">/*</a>
<a name="ln3607"> * List one syntax item, for &quot;:syntax&quot; or &quot;syntax list syntax_name&quot;.</a>
<a name="ln3608"> */</a>
<a name="ln3609">static void</a>
<a name="ln3610">syn_list_one(</a>
<a name="ln3611">    const int id,</a>
<a name="ln3612">    const bool syncing,                 // when true: list syncing items</a>
<a name="ln3613">    const bool link_only                // when true; list link-only too</a>
<a name="ln3614">)</a>
<a name="ln3615">{</a>
<a name="ln3616">  bool did_header = false;</a>
<a name="ln3617">  static struct name_list namelist1[] =</a>
<a name="ln3618">  {</a>
<a name="ln3619">    {HL_DISPLAY, &quot;display&quot;},</a>
<a name="ln3620">    {HL_CONTAINED, &quot;contained&quot;},</a>
<a name="ln3621">    {HL_ONELINE, &quot;oneline&quot;},</a>
<a name="ln3622">    {HL_KEEPEND, &quot;keepend&quot;},</a>
<a name="ln3623">    {HL_EXTEND, &quot;extend&quot;},</a>
<a name="ln3624">    {HL_EXCLUDENL, &quot;excludenl&quot;},</a>
<a name="ln3625">    {HL_TRANSP, &quot;transparent&quot;},</a>
<a name="ln3626">    {HL_FOLD, &quot;fold&quot;},</a>
<a name="ln3627">    {HL_CONCEAL, &quot;conceal&quot;},</a>
<a name="ln3628">    {HL_CONCEALENDS, &quot;concealends&quot;},</a>
<a name="ln3629">    {0, NULL}</a>
<a name="ln3630">  };</a>
<a name="ln3631">  static struct name_list namelist2[] =</a>
<a name="ln3632">  {</a>
<a name="ln3633">    {HL_SKIPWHITE, &quot;skipwhite&quot;},</a>
<a name="ln3634">    {HL_SKIPNL, &quot;skipnl&quot;},</a>
<a name="ln3635">    {HL_SKIPEMPTY, &quot;skipempty&quot;},</a>
<a name="ln3636">    {0, NULL}</a>
<a name="ln3637">  };</a>
<a name="ln3638"> </a>
<a name="ln3639">  const int attr = HL_ATTR(HLF_D);      // highlight like directories</a>
<a name="ln3640"> </a>
<a name="ln3641">  // list the keywords for &quot;id&quot;</a>
<a name="ln3642">  if (!syncing) {</a>
<a name="ln3643">    did_header = syn_list_keywords(id, &amp;curwin-&gt;w_s-&gt;b_keywtab, false, attr);</a>
<a name="ln3644">    did_header = syn_list_keywords(id, &amp;curwin-&gt;w_s-&gt;b_keywtab_ic,</a>
<a name="ln3645">                                   did_header, attr);</a>
<a name="ln3646">  }</a>
<a name="ln3647"> </a>
<a name="ln3648">  // list the patterns for &quot;id&quot;</a>
<a name="ln3649">  for (int idx = 0;</a>
<a name="ln3650">       idx &lt; curwin-&gt;w_s-&gt;b_syn_patterns.ga_len &amp;&amp; !got_int;</a>
<a name="ln3651">       idx++) {</a>
<a name="ln3652">    const synpat_T *const spp = &amp;(SYN_ITEMS(curwin-&gt;w_s)[idx]);</a>
<a name="ln3653">    if (spp-&gt;sp_syn.id != id || spp-&gt;sp_syncing != syncing) {</a>
<a name="ln3654">      continue;</a>
<a name="ln3655">    }</a>
<a name="ln3656"> </a>
<a name="ln3657">    (void)syn_list_header(did_header, 0, id, true);</a>
<a name="ln3658">    did_header = true;</a>
<a name="ln3659">    last_matchgroup = 0;</a>
<a name="ln3660">    if (spp-&gt;sp_type == SPTYPE_MATCH) {</a>
<a name="ln3661">      put_pattern(&quot;match&quot;, ' ', spp, attr);</a>
<a name="ln3662">      msg_putchar(' ');</a>
<a name="ln3663">    } else if (spp-&gt;sp_type == SPTYPE_START)   {</a>
<a name="ln3664">      while (SYN_ITEMS(curwin-&gt;w_s)[idx].sp_type == SPTYPE_START)</a>
<a name="ln3665">        put_pattern(&quot;start&quot;, '=', &amp;SYN_ITEMS(curwin-&gt;w_s)[idx++], attr);</a>
<a name="ln3666">      if (SYN_ITEMS(curwin-&gt;w_s)[idx].sp_type == SPTYPE_SKIP)</a>
<a name="ln3667">        put_pattern(&quot;skip&quot;, '=', &amp;SYN_ITEMS(curwin-&gt;w_s)[idx++], attr);</a>
<a name="ln3668">      while (idx &lt; curwin-&gt;w_s-&gt;b_syn_patterns.ga_len</a>
<a name="ln3669">             &amp;&amp; SYN_ITEMS(curwin-&gt;w_s)[idx].sp_type == SPTYPE_END)</a>
<a name="ln3670">        put_pattern(&quot;end&quot;, '=', &amp;SYN_ITEMS(curwin-&gt;w_s)[idx++], attr);</a>
<a name="ln3671">      --idx;</a>
<a name="ln3672">      msg_putchar(' ');</a>
<a name="ln3673">    }</a>
<a name="ln3674">    syn_list_flags(namelist1, spp-&gt;sp_flags, attr);</a>
<a name="ln3675"> </a>
<a name="ln3676">    if (spp-&gt;sp_cont_list != NULL) {</a>
<a name="ln3677">      put_id_list(&quot;contains&quot;, spp-&gt;sp_cont_list, attr);</a>
<a name="ln3678">    }</a>
<a name="ln3679"> </a>
<a name="ln3680">    if (spp-&gt;sp_syn.cont_in_list != NULL) {</a>
<a name="ln3681">      put_id_list(&quot;containedin&quot;, spp-&gt;sp_syn.cont_in_list, attr);</a>
<a name="ln3682">    }</a>
<a name="ln3683"> </a>
<a name="ln3684">    if (spp-&gt;sp_next_list != NULL) {</a>
<a name="ln3685">      put_id_list(&quot;nextgroup&quot;, spp-&gt;sp_next_list, attr);</a>
<a name="ln3686">      syn_list_flags(namelist2, spp-&gt;sp_flags, attr);</a>
<a name="ln3687">    }</a>
<a name="ln3688">    if (spp-&gt;sp_flags &amp; (HL_SYNC_HERE|HL_SYNC_THERE)) {</a>
<a name="ln3689">      if (spp-&gt;sp_flags &amp; HL_SYNC_HERE) {</a>
<a name="ln3690">        msg_puts_attr(&quot;grouphere&quot;, attr);</a>
<a name="ln3691">      } else {</a>
<a name="ln3692">        msg_puts_attr(&quot;groupthere&quot;, attr);</a>
<a name="ln3693">      }</a>
<a name="ln3694">      msg_putchar(' ');</a>
<a name="ln3695">      if (spp-&gt;sp_sync_idx &gt;= 0)</a>
<a name="ln3696">        msg_outtrans(HL_TABLE()[SYN_ITEMS(curwin-&gt;w_s)</a>
<a name="ln3697">                                [spp-&gt;sp_sync_idx].sp_syn.id - 1].sg_name);</a>
<a name="ln3698">      else</a>
<a name="ln3699">        MSG_PUTS(&quot;NONE&quot;);</a>
<a name="ln3700">      msg_putchar(' ');</a>
<a name="ln3701">    }</a>
<a name="ln3702">  }</a>
<a name="ln3703"> </a>
<a name="ln3704">  /* list the link, if there is one */</a>
<a name="ln3705">  if (HL_TABLE()[id - 1].sg_link &amp;&amp; (did_header || link_only) &amp;&amp; !got_int) {</a>
<a name="ln3706">    (void)syn_list_header(did_header, 0, id, true);</a>
<a name="ln3707">    msg_puts_attr(&quot;links to&quot;, attr);</a>
<a name="ln3708">    msg_putchar(' ');</a>
<a name="ln3709">    msg_outtrans(HL_TABLE()[HL_TABLE()[id - 1].sg_link - 1].sg_name);</a>
<a name="ln3710">  }</a>
<a name="ln3711">}</a>
<a name="ln3712"> </a>
<a name="ln3713">static void syn_list_flags(struct name_list *nlist, int flags, int attr)</a>
<a name="ln3714">{</a>
<a name="ln3715">  int i;</a>
<a name="ln3716"> </a>
<a name="ln3717">  for (i = 0; nlist[i].flag != 0; ++i)</a>
<a name="ln3718">    if (flags &amp; nlist[i].flag) {</a>
<a name="ln3719">      msg_puts_attr(nlist[i].name, attr);</a>
<a name="ln3720">      msg_putchar(' ');</a>
<a name="ln3721">    }</a>
<a name="ln3722">}</a>
<a name="ln3723"> </a>
<a name="ln3724">/*</a>
<a name="ln3725"> * List one syntax cluster, for &quot;:syntax&quot; or &quot;syntax list syntax_name&quot;.</a>
<a name="ln3726"> */</a>
<a name="ln3727">static void syn_list_cluster(int id)</a>
<a name="ln3728">{</a>
<a name="ln3729">  int endcol = 15;</a>
<a name="ln3730"> </a>
<a name="ln3731">  /* slight hack:  roughly duplicate the guts of syn_list_header() */</a>
<a name="ln3732">  msg_putchar('\n');</a>
<a name="ln3733">  msg_outtrans(SYN_CLSTR(curwin-&gt;w_s)[id].scl_name);</a>
<a name="ln3734"> </a>
<a name="ln3735">  if (msg_col &gt;= endcol)        /* output at least one space */</a>
<a name="ln3736">    endcol = msg_col + 1;</a>
<a name="ln3737">  if (Columns &lt;= endcol)        /* avoid hang for tiny window */</a>
<a name="ln3738">    endcol = Columns - 1;</a>
<a name="ln3739"> </a>
<a name="ln3740">  msg_advance(endcol);</a>
<a name="ln3741">  if (SYN_CLSTR(curwin-&gt;w_s)[id].scl_list != NULL) {</a>
<a name="ln3742">    put_id_list(&quot;cluster&quot;, SYN_CLSTR(curwin-&gt;w_s)[id].scl_list, HL_ATTR(HLF_D));</a>
<a name="ln3743">  } else {</a>
<a name="ln3744">    msg_puts_attr(&quot;cluster&quot;, HL_ATTR(HLF_D));</a>
<a name="ln3745">    msg_puts(&quot;=NONE&quot;);</a>
<a name="ln3746">  }</a>
<a name="ln3747">}</a>
<a name="ln3748"> </a>
<a name="ln3749">static void put_id_list(const char *const name,</a>
<a name="ln3750">                        const int16_t *const list,</a>
<a name="ln3751">                        const int attr)</a>
<a name="ln3752">{</a>
<a name="ln3753">  msg_puts_attr(name, attr);</a>
<a name="ln3754">  msg_putchar('=');</a>
<a name="ln3755">  for (const int16_t *p = list; *p; p++) {</a>
<a name="ln3756">    if (*p &gt;= SYNID_ALLBUT &amp;&amp; *p &lt; SYNID_TOP) {</a>
<a name="ln3757">      if (p[1]) {</a>
<a name="ln3758">        msg_puts(&quot;ALLBUT&quot;);</a>
<a name="ln3759">      } else {</a>
<a name="ln3760">        msg_puts(&quot;ALL&quot;);</a>
<a name="ln3761">      }</a>
<a name="ln3762">    } else if (*p &gt;= SYNID_TOP &amp;&amp; *p &lt; SYNID_CONTAINED)   {</a>
<a name="ln3763">      msg_puts(&quot;TOP&quot;);</a>
<a name="ln3764">    } else if (*p &gt;= SYNID_CONTAINED &amp;&amp; *p &lt; SYNID_CLUSTER)   {</a>
<a name="ln3765">      msg_puts(&quot;CONTAINED&quot;);</a>
<a name="ln3766">    } else if (*p &gt;= SYNID_CLUSTER)   {</a>
<a name="ln3767">      int scl_id = *p - SYNID_CLUSTER;</a>
<a name="ln3768"> </a>
<a name="ln3769">      msg_putchar('@');</a>
<a name="ln3770">      msg_outtrans(SYN_CLSTR(curwin-&gt;w_s)[scl_id].scl_name);</a>
<a name="ln3771">    } else</a>
<a name="ln3772">      msg_outtrans(HL_TABLE()[*p - 1].sg_name);</a>
<a name="ln3773">    if (p[1])</a>
<a name="ln3774">      msg_putchar(',');</a>
<a name="ln3775">  }</a>
<a name="ln3776">  msg_putchar(' ');</a>
<a name="ln3777">}</a>
<a name="ln3778"> </a>
<a name="ln3779">static void put_pattern(const char *const s, const int c,</a>
<a name="ln3780">                        const synpat_T *const spp, const int attr)</a>
<a name="ln3781">{</a>
<a name="ln3782">  static const char *const sepchars = &quot;/+=-#@\&quot;|'^&amp;&quot;;</a>
<a name="ln3783">  int i;</a>
<a name="ln3784"> </a>
<a name="ln3785">  /* May have to write &quot;matchgroup=group&quot; */</a>
<a name="ln3786">  if (last_matchgroup != spp-&gt;sp_syn_match_id) {</a>
<a name="ln3787">    last_matchgroup = spp-&gt;sp_syn_match_id;</a>
<a name="ln3788">    msg_puts_attr(&quot;matchgroup&quot;, attr);</a>
<a name="ln3789">    msg_putchar('=');</a>
<a name="ln3790">    if (last_matchgroup == 0)</a>
<a name="ln3791">      msg_outtrans((char_u *)&quot;NONE&quot;);</a>
<a name="ln3792">    else</a>
<a name="ln3793">      msg_outtrans(HL_TABLE()[last_matchgroup - 1].sg_name);</a>
<a name="ln3794">    msg_putchar(' ');</a>
<a name="ln3795">  }</a>
<a name="ln3796"> </a>
<a name="ln3797">  // Output the name of the pattern and an '=' or ' '.</a>
<a name="ln3798">  msg_puts_attr(s, attr);</a>
<a name="ln3799">  msg_putchar(c);</a>
<a name="ln3800"> </a>
<a name="ln3801">  /* output the pattern, in between a char that is not in the pattern */</a>
<a name="ln3802">  for (i = 0; vim_strchr(spp-&gt;sp_pattern, sepchars[i]) != NULL; )</a>
<a name="ln3803">    if (sepchars[++i] == NUL) {</a>
<a name="ln3804">      i = 0;            /* no good char found, just use the first one */</a>
<a name="ln3805">      break;</a>
<a name="ln3806">    }</a>
<a name="ln3807">  msg_putchar(sepchars[i]);</a>
<a name="ln3808">  msg_outtrans(spp-&gt;sp_pattern);</a>
<a name="ln3809">  msg_putchar(sepchars[i]);</a>
<a name="ln3810"> </a>
<a name="ln3811">  // output any pattern options</a>
<a name="ln3812">  bool first = true;</a>
<a name="ln3813">  for (i = 0; i &lt; SPO_COUNT; i++) {</a>
<a name="ln3814">    const int mask = (1 &lt;&lt; i);</a>
<a name="ln3815">    if (!(spp-&gt;sp_off_flags &amp; (mask + (mask &lt;&lt; SPO_COUNT)))) {</a>
<a name="ln3816">      continue;</a>
<a name="ln3817">    }</a>
<a name="ln3818">    if (!first) {</a>
<a name="ln3819">      msg_putchar(',');  // Separate with commas.</a>
<a name="ln3820">    }</a>
<a name="ln3821">    msg_puts(spo_name_tab[i]);</a>
<a name="ln3822">    const long n = spp-&gt;sp_offsets[i];</a>
<a name="ln3823">    if (i != SPO_LC_OFF) {</a>
<a name="ln3824">      if (spp-&gt;sp_off_flags &amp; mask)</a>
<a name="ln3825">        msg_putchar('s');</a>
<a name="ln3826">      else</a>
<a name="ln3827">        msg_putchar('e');</a>
<a name="ln3828">      if (n &gt; 0)</a>
<a name="ln3829">        msg_putchar('+');</a>
<a name="ln3830">    }</a>
<a name="ln3831">    if (n || i == SPO_LC_OFF) {</a>
<a name="ln3832">      msg_outnum(n);</a>
<a name="ln3833">    }</a>
<a name="ln3834">    first = false;</a>
<a name="ln3835">  }</a>
<a name="ln3836">  msg_putchar(' ');</a>
<a name="ln3837">}</a>
<a name="ln3838"> </a>
<a name="ln3839">// List or clear the keywords for one syntax group.</a>
<a name="ln3840">// Return true if the header has been printed.</a>
<a name="ln3841">static bool syn_list_keywords(</a>
<a name="ln3842">    const int id,</a>
<a name="ln3843">    const hashtab_T *const ht,</a>
<a name="ln3844">    bool did_header,                        // header has already been printed</a>
<a name="ln3845">    const int attr</a>
<a name="ln3846">)</a>
<a name="ln3847">{</a>
<a name="ln3848">  int prev_contained = 0;</a>
<a name="ln3849">  const int16_t *prev_next_list = NULL;</a>
<a name="ln3850">  const int16_t *prev_cont_in_list = NULL;</a>
<a name="ln3851">  int prev_skipnl = 0;</a>
<a name="ln3852">  int prev_skipwhite = 0;</a>
<a name="ln3853">  int prev_skipempty = 0;</a>
<a name="ln3854"> </a>
<a name="ln3855">  // Unfortunately, this list of keywords is not sorted on alphabet but on</a>
<a name="ln3856">  // hash value...</a>
<a name="ln3857">  size_t todo = ht-&gt;ht_used;</a>
<a name="ln3858">  for (const hashitem_T *hi = ht-&gt;ht_array; todo &gt; 0 &amp;&amp; !got_int; hi++) {</a>
<a name="ln3859">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln3860">      continue;</a>
<a name="ln3861">    }</a>
<a name="ln3862">    todo--;</a>
<a name="ln3863">    for (keyentry_T *kp = HI2KE(hi); kp != NULL &amp;&amp; !got_int; kp = kp-&gt;ke_next) {</a>
<a name="ln3864">      if (kp-&gt;k_syn.id == id) {</a>
<a name="ln3865">        int outlen = 0;</a>
<a name="ln3866">        bool force_newline = false;</a>
<a name="ln3867">        if (prev_contained != (kp-&gt;flags &amp; HL_CONTAINED)</a>
<a name="ln3868">            || prev_skipnl != (kp-&gt;flags &amp; HL_SKIPNL)</a>
<a name="ln3869">            || prev_skipwhite != (kp-&gt;flags &amp; HL_SKIPWHITE)</a>
<a name="ln3870">            || prev_skipempty != (kp-&gt;flags &amp; HL_SKIPEMPTY)</a>
<a name="ln3871">            || prev_cont_in_list != kp-&gt;k_syn.cont_in_list</a>
<a name="ln3872">            || prev_next_list != kp-&gt;next_list) {</a>
<a name="ln3873">            force_newline = true;</a>
<a name="ln3874">        } else {</a>
<a name="ln3875">          outlen = (int)STRLEN(kp-&gt;keyword);</a>
<a name="ln3876">        }</a>
<a name="ln3877">        // output &quot;contained&quot; and &quot;nextgroup&quot; on each line</a>
<a name="ln3878">        if (syn_list_header(did_header, outlen, id, force_newline)) {</a>
<a name="ln3879">          prev_contained = 0;</a>
<a name="ln3880">          prev_next_list = NULL;</a>
<a name="ln3881">          prev_cont_in_list = NULL;</a>
<a name="ln3882">          prev_skipnl = 0;</a>
<a name="ln3883">          prev_skipwhite = 0;</a>
<a name="ln3884">          prev_skipempty = 0;</a>
<a name="ln3885">        }</a>
<a name="ln3886">        did_header = true;</a>
<a name="ln3887">        if (prev_contained != (kp-&gt;flags &amp; HL_CONTAINED)) {</a>
<a name="ln3888">          msg_puts_attr(&quot;contained&quot;, attr);</a>
<a name="ln3889">          msg_putchar(' ');</a>
<a name="ln3890">          prev_contained = (kp-&gt;flags &amp; HL_CONTAINED);</a>
<a name="ln3891">        }</a>
<a name="ln3892">        if (kp-&gt;k_syn.cont_in_list != prev_cont_in_list) {</a>
<a name="ln3893">          put_id_list(&quot;containedin&quot;, kp-&gt;k_syn.cont_in_list, attr);</a>
<a name="ln3894">          msg_putchar(' ');</a>
<a name="ln3895">          prev_cont_in_list = kp-&gt;k_syn.cont_in_list;</a>
<a name="ln3896">        }</a>
<a name="ln3897">        if (kp-&gt;next_list != prev_next_list) {</a>
<a name="ln3898">          put_id_list(&quot;nextgroup&quot;, kp-&gt;next_list, attr);</a>
<a name="ln3899">          msg_putchar(' ');</a>
<a name="ln3900">          prev_next_list = kp-&gt;next_list;</a>
<a name="ln3901">          if (kp-&gt;flags &amp; HL_SKIPNL) {</a>
<a name="ln3902">            msg_puts_attr(&quot;skipnl&quot;, attr);</a>
<a name="ln3903">            msg_putchar(' ');</a>
<a name="ln3904">            prev_skipnl = (kp-&gt;flags &amp; HL_SKIPNL);</a>
<a name="ln3905">          }</a>
<a name="ln3906">          if (kp-&gt;flags &amp; HL_SKIPWHITE) {</a>
<a name="ln3907">            msg_puts_attr(&quot;skipwhite&quot;, attr);</a>
<a name="ln3908">            msg_putchar(' ');</a>
<a name="ln3909">            prev_skipwhite = (kp-&gt;flags &amp; HL_SKIPWHITE);</a>
<a name="ln3910">          }</a>
<a name="ln3911">          if (kp-&gt;flags &amp; HL_SKIPEMPTY) {</a>
<a name="ln3912">            msg_puts_attr(&quot;skipempty&quot;, attr);</a>
<a name="ln3913">            msg_putchar(' ');</a>
<a name="ln3914">            prev_skipempty = (kp-&gt;flags &amp; HL_SKIPEMPTY);</a>
<a name="ln3915">          }</a>
<a name="ln3916">        }</a>
<a name="ln3917">        msg_outtrans(kp-&gt;keyword);</a>
<a name="ln3918">      }</a>
<a name="ln3919">    }</a>
<a name="ln3920">  }</a>
<a name="ln3921"> </a>
<a name="ln3922">  return did_header;</a>
<a name="ln3923">}</a>
<a name="ln3924"> </a>
<a name="ln3925">static void syn_clear_keyword(int id, hashtab_T *ht)</a>
<a name="ln3926">{</a>
<a name="ln3927">  hashitem_T  *hi;</a>
<a name="ln3928">  keyentry_T  *kp;</a>
<a name="ln3929">  keyentry_T  *kp_prev;</a>
<a name="ln3930">  keyentry_T  *kp_next;</a>
<a name="ln3931">  int todo;</a>
<a name="ln3932"> </a>
<a name="ln3933">  hash_lock(ht);</a>
<a name="ln3934">  todo = (int)ht-&gt;ht_used;</a>
<a name="ln3935">  for (hi = ht-&gt;ht_array; todo &gt; 0; ++hi) {</a>
<a name="ln3936">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln3937">      continue;</a>
<a name="ln3938">    }</a>
<a name="ln3939">    --todo;</a>
<a name="ln3940">    kp_prev = NULL;</a>
<a name="ln3941">    for (kp = HI2KE(hi); kp != NULL; ) {</a>
<a name="ln3942">      if (kp-&gt;k_syn.id == id) {</a>
<a name="ln3943">        kp_next = kp-&gt;ke_next;</a>
<a name="ln3944">        if (kp_prev == NULL) {</a>
<a name="ln3945">          if (kp_next == NULL)</a>
<a name="ln3946">            hash_remove(ht, hi);</a>
<a name="ln3947">          else</a>
<a name="ln3948">            hi-&gt;hi_key = KE2HIKEY(kp_next);</a>
<a name="ln3949">        } else</a>
<a name="ln3950">          kp_prev-&gt;ke_next = kp_next;</a>
<a name="ln3951">        xfree(kp-&gt;next_list);</a>
<a name="ln3952">        xfree(kp-&gt;k_syn.cont_in_list);</a>
<a name="ln3953">        xfree(kp);</a>
<a name="ln3954">        kp = kp_next;</a>
<a name="ln3955">      } else {</a>
<a name="ln3956">        kp_prev = kp;</a>
<a name="ln3957">        kp = kp-&gt;ke_next;</a>
<a name="ln3958">      }</a>
<a name="ln3959">    }</a>
<a name="ln3960">  }</a>
<a name="ln3961">  hash_unlock(ht);</a>
<a name="ln3962">}</a>
<a name="ln3963"> </a>
<a name="ln3964">/*</a>
<a name="ln3965"> * Clear a whole keyword table.</a>
<a name="ln3966"> */</a>
<a name="ln3967">static void clear_keywtab(hashtab_T *ht)</a>
<a name="ln3968">{</a>
<a name="ln3969">  hashitem_T  *hi;</a>
<a name="ln3970">  int todo;</a>
<a name="ln3971">  keyentry_T  *kp;</a>
<a name="ln3972">  keyentry_T  *kp_next;</a>
<a name="ln3973"> </a>
<a name="ln3974">  todo = (int)ht-&gt;ht_used;</a>
<a name="ln3975">  for (hi = ht-&gt;ht_array; todo &gt; 0; ++hi) {</a>
<a name="ln3976">    if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln3977">      --todo;</a>
<a name="ln3978">      for (kp = HI2KE(hi); kp != NULL; kp = kp_next) {</a>
<a name="ln3979">        kp_next = kp-&gt;ke_next;</a>
<a name="ln3980">        xfree(kp-&gt;next_list);</a>
<a name="ln3981">        xfree(kp-&gt;k_syn.cont_in_list);</a>
<a name="ln3982">        xfree(kp);</a>
<a name="ln3983">      }</a>
<a name="ln3984">    }</a>
<a name="ln3985">  }</a>
<a name="ln3986">  hash_clear(ht);</a>
<a name="ln3987">  hash_init(ht);</a>
<a name="ln3988">}</a>
<a name="ln3989"> </a>
<a name="ln3990">/// Add a keyword to the list of keywords.</a>
<a name="ln3991">///</a>
<a name="ln3992">/// @param name name of keyword</a>
<a name="ln3993">/// @param id group ID for this keyword</a>
<a name="ln3994">/// @param flags flags for this keyword</a>
<a name="ln3995">/// @param cont_in_list containedin for this keyword</a>
<a name="ln3996">/// @param next_list nextgroup for this keyword</a>
<a name="ln3997">static void add_keyword(char_u *const name,</a>
<a name="ln3998">                        const int id,</a>
<a name="ln3999">                        const int flags,</a>
<a name="ln4000">                        int16_t *const cont_in_list,</a>
<a name="ln4001">                        int16_t *const next_list,</a>
<a name="ln4002">                        const int conceal_char)</a>
<a name="ln4003">{</a>
<a name="ln4004">  char_u name_folded[MAXKEYWLEN + 1];</a>
<a name="ln4005">  const char_u *const name_ic = (curwin-&gt;w_s-&gt;b_syn_ic)</a>
<a name="ln4006">      ? str_foldcase(name, (int)STRLEN(name), name_folded, sizeof(name_folded))</a>
<a name="ln4007">      : name;</a>
<a name="ln4008"> </a>
<a name="ln4009">  keyentry_T *const kp = xmalloc(sizeof(keyentry_T) + STRLEN(name_ic));</a>
<a name="ln4010">  STRCPY(kp-&gt;keyword, name_ic);</a>
<a name="ln4011">  kp-&gt;k_syn.id = id;</a>
<a name="ln4012">  kp-&gt;k_syn.inc_tag = current_syn_inc_tag;</a>
<a name="ln4013">  kp-&gt;flags = flags;</a>
<a name="ln4014">  kp-&gt;k_char = conceal_char;</a>
<a name="ln4015">  kp-&gt;k_syn.cont_in_list = copy_id_list(cont_in_list);</a>
<a name="ln4016">  if (cont_in_list != NULL) {</a>
<a name="ln4017">    curwin-&gt;w_s-&gt;b_syn_containedin = TRUE;</a>
<a name="ln4018">  }</a>
<a name="ln4019">  kp-&gt;next_list = copy_id_list(next_list);</a>
<a name="ln4020"> </a>
<a name="ln4021">  const hash_T hash = hash_hash(kp-&gt;keyword);</a>
<a name="ln4022">  hashtab_T *const ht = (curwin-&gt;w_s-&gt;b_syn_ic)</a>
<a name="ln4023">      ? &amp;curwin-&gt;w_s-&gt;b_keywtab_ic</a>
<a name="ln4024">      : &amp;curwin-&gt;w_s-&gt;b_keywtab;</a>
<a name="ln4025">  hashitem_T *const hi = hash_lookup(ht, (const char *)kp-&gt;keyword,</a>
<a name="ln4026">                                     STRLEN(kp-&gt;keyword), hash);</a>
<a name="ln4027"> </a>
<a name="ln4028">  // even though it looks like only the kp-&gt;keyword member is</a>
<a name="ln4029">  // being used here, vim uses some pointer trickery to get the original</a>
<a name="ln4030">  // struct again later by using knowledge of the offset of the keyword</a>
<a name="ln4031">  // field in the struct. See the definition of the HI2KE macro.</a>
<a name="ln4032">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln4033">    // new keyword, add to hashtable</a>
<a name="ln4034">    kp-&gt;ke_next = NULL;</a>
<a name="ln4035">    hash_add_item(ht, hi, kp-&gt;keyword, hash);</a>
<a name="ln4036">  } else {</a>
<a name="ln4037">    // keyword already exists, prepend to list</a>
<a name="ln4038">    kp-&gt;ke_next = HI2KE(hi);</a>
<a name="ln4039">    hi-&gt;hi_key = KE2HIKEY(kp);</a>
<a name="ln4040">  }</a>
<a name="ln4041">}</a>
<a name="ln4042"> </a>
<a name="ln4043">/*</a>
<a name="ln4044"> * Get the start and end of the group name argument.</a>
<a name="ln4045"> * Return a pointer to the first argument.</a>
<a name="ln4046"> * Return NULL if the end of the command was found instead of further args.</a>
<a name="ln4047"> */</a>
<a name="ln4048">static char_u *</a>
<a name="ln4049">get_group_name (</a>
<a name="ln4050">    char_u *arg,               /* start of the argument */</a>
<a name="ln4051">    char_u **name_end         /* pointer to end of the name */</a>
<a name="ln4052">)</a>
<a name="ln4053">{</a>
<a name="ln4054">  char_u      *rest;</a>
<a name="ln4055"> </a>
<a name="ln4056">  *name_end = skiptowhite(arg);</a>
<a name="ln4057">  rest = skipwhite(*name_end);</a>
<a name="ln4058"> </a>
<a name="ln4059">  /*</a>
<a name="ln4060">   * Check if there are enough arguments.  The first argument may be a</a>
<a name="ln4061">   * pattern, where '|' is allowed, so only check for NUL.</a>
<a name="ln4062">   */</a>
<a name="ln4063">  if (ends_excmd(*arg) || *rest == NUL)</a>
<a name="ln4064">    return NULL;</a>
<a name="ln4065">  return rest;</a>
<a name="ln4066">}</a>
<a name="ln4067"> </a>
<a name="ln4068">/*</a>
<a name="ln4069"> * Check for syntax command option arguments.</a>
<a name="ln4070"> * This can be called at any place in the list of arguments, and just picks</a>
<a name="ln4071"> * out the arguments that are known.  Can be called several times in a row to</a>
<a name="ln4072"> * collect all options in between other arguments.</a>
<a name="ln4073"> * Return a pointer to the next argument (which isn't an option).</a>
<a name="ln4074"> * Return NULL for any error;</a>
<a name="ln4075"> */</a>
<a name="ln4076">static char_u *</a>
<a name="ln4077">get_syn_options(</a>
<a name="ln4078">    char_u *arg,            // next argument to be checked</a>
<a name="ln4079">    syn_opt_arg_T *opt,     // various things</a>
<a name="ln4080">    int *conceal_char,</a>
<a name="ln4081">    int skip                // TRUE if skipping over command</a>
<a name="ln4082">)</a>
<a name="ln4083">{</a>
<a name="ln4084">  char_u      *gname_start, *gname;</a>
<a name="ln4085">  int syn_id;</a>
<a name="ln4086">  int len = 0;</a>
<a name="ln4087">  char        *p;</a>
<a name="ln4088">  int fidx;</a>
<a name="ln4089">  static const struct flag {</a>
<a name="ln4090">    char    *name;</a>
<a name="ln4091">    int argtype;</a>
<a name="ln4092">    int flags;</a>
<a name="ln4093">  } flagtab[] = { {&quot;cCoOnNtTaAiInNeEdD&quot;,      0,      HL_CONTAINED},</a>
<a name="ln4094">                  {&quot;oOnNeElLiInNeE&quot;,          0,      HL_ONELINE},</a>
<a name="ln4095">                  {&quot;kKeEeEpPeEnNdD&quot;,          0,      HL_KEEPEND},</a>
<a name="ln4096">                  {&quot;eExXtTeEnNdD&quot;,            0,      HL_EXTEND},</a>
<a name="ln4097">                  {&quot;eExXcClLuUdDeEnNlL&quot;,      0,      HL_EXCLUDENL},</a>
<a name="ln4098">                  {&quot;tTrRaAnNsSpPaArReEnNtT&quot;,  0,      HL_TRANSP},</a>
<a name="ln4099">                  {&quot;sSkKiIpPnNlL&quot;,            0,      HL_SKIPNL},</a>
<a name="ln4100">                  {&quot;sSkKiIpPwWhHiItTeE&quot;,      0,      HL_SKIPWHITE},</a>
<a name="ln4101">                  {&quot;sSkKiIpPeEmMpPtTyY&quot;,      0,      HL_SKIPEMPTY},</a>
<a name="ln4102">                  {&quot;gGrRoOuUpPhHeErReE&quot;,      0,      HL_SYNC_HERE},</a>
<a name="ln4103">                  {&quot;gGrRoOuUpPtThHeErReE&quot;,    0,      HL_SYNC_THERE},</a>
<a name="ln4104">                  {&quot;dDiIsSpPlLaAyY&quot;,          0,      HL_DISPLAY},</a>
<a name="ln4105">                  {&quot;fFoOlLdD&quot;,                0,      HL_FOLD},</a>
<a name="ln4106">                  {&quot;cCoOnNcCeEaAlL&quot;,          0,      HL_CONCEAL},</a>
<a name="ln4107">                  {&quot;cCoOnNcCeEaAlLeEnNdDsS&quot;,  0,      HL_CONCEALENDS},</a>
<a name="ln4108">                  {&quot;cCcChHaArR&quot;,              11,     0},</a>
<a name="ln4109">                  {&quot;cCoOnNtTaAiInNsS&quot;,        1,      0},</a>
<a name="ln4110">                  {&quot;cCoOnNtTaAiInNeEdDiInN&quot;,  2,      0},</a>
<a name="ln4111">                  {&quot;nNeExXtTgGrRoOuUpP&quot;,      3,      0},};</a>
<a name="ln4112">  static const char *const first_letters = &quot;cCoOkKeEtTsSgGdDfFnN&quot;;</a>
<a name="ln4113"> </a>
<a name="ln4114">  if (arg == NULL)              /* already detected error */</a>
<a name="ln4115">    return NULL;</a>
<a name="ln4116"> </a>
<a name="ln4117">  if (curwin-&gt;w_s-&gt;b_syn_conceal)</a>
<a name="ln4118">    opt-&gt;flags |= HL_CONCEAL;</a>
<a name="ln4119"> </a>
<a name="ln4120">  for (;; ) {</a>
<a name="ln4121">    /*</a>
<a name="ln4122">     * This is used very often when a large number of keywords is defined.</a>
<a name="ln4123">     * Need to skip quickly when no option name is found.</a>
<a name="ln4124">     * Also avoid tolower(), it's slow.</a>
<a name="ln4125">     */</a>
<a name="ln4126">    if (strchr(first_letters, *arg) == NULL)</a>
<a name="ln4127">      break;</a>
<a name="ln4128"> </a>
<a name="ln4129">    for (fidx = ARRAY_SIZE(flagtab); --fidx &gt;= 0; ) {</a>
<a name="ln4130">      p = flagtab[fidx].name;</a>
<a name="ln4131">      int i;</a>
<a name="ln4132">      for (i = 0, len = 0; p[i] != NUL; i += 2, ++len) {</a>
<a name="ln4133">        if (arg[len] != p[i] &amp;&amp; arg[len] != p[i + 1])</a>
<a name="ln4134">          break;</a>
<a name="ln4135">      }</a>
<a name="ln4136">      if (p[i] == NUL &amp;&amp; (ascii_iswhite(arg[len])</a>
<a name="ln4137">                          || (flagtab[fidx].argtype &gt; 0</a>
<a name="ln4138">                              ? arg[len] == '='</a>
<a name="ln4139">                              : ends_excmd(arg[len])))) {</a>
<a name="ln4140">        if (opt-&gt;keyword</a>
<a name="ln4141">            &amp;&amp; (flagtab[fidx].flags == HL_DISPLAY</a>
<a name="ln4142">                || flagtab[fidx].flags == HL_FOLD</a>
<a name="ln4143">                || flagtab[fidx].flags == HL_EXTEND))</a>
<a name="ln4144">          /* treat &quot;display&quot;, &quot;fold&quot; and &quot;extend&quot; as a keyword */</a>
<a name="ln4145">          fidx = -1;</a>
<a name="ln4146">        break;</a>
<a name="ln4147">      }</a>
<a name="ln4148">    }</a>
<a name="ln4149">    if (fidx &lt; 0)           /* no match found */</a>
<a name="ln4150">      break;</a>
<a name="ln4151"> </a>
<a name="ln4152">    if (flagtab[fidx].argtype == 1) {</a>
<a name="ln4153">      if (!opt-&gt;has_cont_list) {</a>
<a name="ln4154">        EMSG(_(&quot;E395: contains argument not accepted here&quot;));</a>
<a name="ln4155">        return NULL;</a>
<a name="ln4156">      }</a>
<a name="ln4157">      if (get_id_list(&amp;arg, 8, &amp;opt-&gt;cont_list, skip) == FAIL) {</a>
<a name="ln4158">        return NULL;</a>
<a name="ln4159">      }</a>
<a name="ln4160">    } else if (flagtab[fidx].argtype == 2)   {</a>
<a name="ln4161">      if (get_id_list(&amp;arg, 11, &amp;opt-&gt;cont_in_list, skip) == FAIL) {</a>
<a name="ln4162">        return NULL;</a>
<a name="ln4163">      }</a>
<a name="ln4164">    } else if (flagtab[fidx].argtype == 3)   {</a>
<a name="ln4165">      if (get_id_list(&amp;arg, 9, &amp;opt-&gt;next_list, skip) == FAIL) {</a>
<a name="ln4166">        return NULL;</a>
<a name="ln4167">      }</a>
<a name="ln4168">    } else if (flagtab[fidx].argtype == 11 &amp;&amp; arg[5] == '=')   {</a>
<a name="ln4169">      // cchar=?</a>
<a name="ln4170">      *conceal_char = utf_ptr2char(arg + 6);</a>
<a name="ln4171">      arg += mb_ptr2len(arg + 6) - 1;</a>
<a name="ln4172">      if (!vim_isprintc_strict(*conceal_char)) {</a>
<a name="ln4173">        EMSG(_(&quot;E844: invalid cchar value&quot;));</a>
<a name="ln4174">        return NULL;</a>
<a name="ln4175">      }</a>
<a name="ln4176">      arg = skipwhite(arg + 7);</a>
<a name="ln4177">    } else {</a>
<a name="ln4178">      opt-&gt;flags |= flagtab[fidx].flags;</a>
<a name="ln4179">      arg = skipwhite(arg + len);</a>
<a name="ln4180"> </a>
<a name="ln4181">      if (flagtab[fidx].flags == HL_SYNC_HERE</a>
<a name="ln4182">          || flagtab[fidx].flags == HL_SYNC_THERE) {</a>
<a name="ln4183">        if (opt-&gt;sync_idx == NULL) {</a>
<a name="ln4184">          EMSG(_(&quot;E393: group[t]here not accepted here&quot;));</a>
<a name="ln4185">          return NULL;</a>
<a name="ln4186">        }</a>
<a name="ln4187">        gname_start = arg;</a>
<a name="ln4188">        arg = skiptowhite(arg);</a>
<a name="ln4189">        if (gname_start == arg)</a>
<a name="ln4190">          return NULL;</a>
<a name="ln4191">        gname = vim_strnsave(gname_start, arg - gname_start);</a>
<a name="ln4192">        if (STRCMP(gname, &quot;NONE&quot;) == 0) {</a>
<a name="ln4193">          *opt-&gt;sync_idx = NONE_IDX;</a>
<a name="ln4194">        } else {</a>
<a name="ln4195">          syn_id = syn_name2id(gname);</a>
<a name="ln4196">          int i;</a>
<a name="ln4197">          for (i = curwin-&gt;w_s-&gt;b_syn_patterns.ga_len; --i &gt;= 0; )</a>
<a name="ln4198">            if (SYN_ITEMS(curwin-&gt;w_s)[i].sp_syn.id == syn_id</a>
<a name="ln4199">                &amp;&amp; SYN_ITEMS(curwin-&gt;w_s)[i].sp_type == SPTYPE_START) {</a>
<a name="ln4200">              *opt-&gt;sync_idx = i;</a>
<a name="ln4201">              break;</a>
<a name="ln4202">            }</a>
<a name="ln4203">          if (i &lt; 0) {</a>
<a name="ln4204">            EMSG2(_(&quot;E394: Didn't find region item for %s&quot;), gname);</a>
<a name="ln4205">            xfree(gname);</a>
<a name="ln4206">            return NULL;</a>
<a name="ln4207">          }</a>
<a name="ln4208">        }</a>
<a name="ln4209"> </a>
<a name="ln4210">        xfree(gname);</a>
<a name="ln4211">        arg = skipwhite(arg);</a>
<a name="ln4212">      } else if (flagtab[fidx].flags == HL_FOLD</a>
<a name="ln4213">                 &amp;&amp; foldmethodIsSyntax(curwin))</a>
<a name="ln4214">        /* Need to update folds later. */</a>
<a name="ln4215">        foldUpdateAll(curwin);</a>
<a name="ln4216">    }</a>
<a name="ln4217">  }</a>
<a name="ln4218"> </a>
<a name="ln4219">  return arg;</a>
<a name="ln4220">}</a>
<a name="ln4221"> </a>
<a name="ln4222">/*</a>
<a name="ln4223"> * Adjustments to syntax item when declared in a &quot;:syn include&quot;'d file.</a>
<a name="ln4224"> * Set the contained flag, and if the item is not already contained, add it</a>
<a name="ln4225"> * to the specified top-level group, if any.</a>
<a name="ln4226"> */</a>
<a name="ln4227">static void syn_incl_toplevel(int id, int *flagsp)</a>
<a name="ln4228">{</a>
<a name="ln4229">  if ((*flagsp &amp; HL_CONTAINED) || curwin-&gt;w_s-&gt;b_syn_topgrp == 0)</a>
<a name="ln4230">    return;</a>
<a name="ln4231">  *flagsp |= HL_CONTAINED;</a>
<a name="ln4232">  if (curwin-&gt;w_s-&gt;b_syn_topgrp &gt;= SYNID_CLUSTER) {</a>
<a name="ln4233">    // We have to alloc this, because syn_combine_list() will free it.</a>
<a name="ln4234">    int16_t *grp_list = xmalloc(2 * sizeof(*grp_list));</a>
<a name="ln4235">    int tlg_id = curwin-&gt;w_s-&gt;b_syn_topgrp - SYNID_CLUSTER;</a>
<a name="ln4236"> </a>
<a name="ln4237">    grp_list[0] = id;</a>
<a name="ln4238">    grp_list[1] = 0;</a>
<a name="ln4239">    syn_combine_list(&amp;SYN_CLSTR(curwin-&gt;w_s)[tlg_id].scl_list, &amp;grp_list,</a>
<a name="ln4240">        CLUSTER_ADD);</a>
<a name="ln4241">  }</a>
<a name="ln4242">}</a>
<a name="ln4243"> </a>
<a name="ln4244">/*</a>
<a name="ln4245"> * Handle &quot;:syntax include [@{group-name}] filename&quot; command.</a>
<a name="ln4246"> */</a>
<a name="ln4247">static void syn_cmd_include(exarg_T *eap, int syncing)</a>
<a name="ln4248">{</a>
<a name="ln4249">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln4250">  int sgl_id = 1;</a>
<a name="ln4251">  char_u      *group_name_end;</a>
<a name="ln4252">  char_u      *rest;</a>
<a name="ln4253">  char_u      *errormsg = NULL;</a>
<a name="ln4254">  int prev_toplvl_grp;</a>
<a name="ln4255">  int prev_syn_inc_tag;</a>
<a name="ln4256">  int source = FALSE;</a>
<a name="ln4257"> </a>
<a name="ln4258">  eap-&gt;nextcmd = find_nextcmd(arg);</a>
<a name="ln4259">  if (eap-&gt;skip)</a>
<a name="ln4260">    return;</a>
<a name="ln4261"> </a>
<a name="ln4262">  if (arg[0] == '@') {</a>
<a name="ln4263">    ++arg;</a>
<a name="ln4264">    rest = get_group_name(arg, &amp;group_name_end);</a>
<a name="ln4265">    if (rest == NULL) {</a>
<a name="ln4266">      EMSG((char_u *)_(&quot;E397: Filename required&quot;));</a>
<a name="ln4267">      return;</a>
<a name="ln4268">    }</a>
<a name="ln4269">    sgl_id = syn_check_cluster(arg, (int)(group_name_end - arg));</a>
<a name="ln4270">    if (sgl_id == 0)</a>
<a name="ln4271">      return;</a>
<a name="ln4272">    /* separate_nextcmd() and expand_filename() depend on this */</a>
<a name="ln4273">    eap-&gt;arg = rest;</a>
<a name="ln4274">  }</a>
<a name="ln4275"> </a>
<a name="ln4276">  /*</a>
<a name="ln4277">   * Everything that's left, up to the next command, should be the</a>
<a name="ln4278">   * filename to include.</a>
<a name="ln4279">   */</a>
<a name="ln4280">  eap-&gt;argt |= (EX_XFILE | EX_NOSPC);</a>
<a name="ln4281">  separate_nextcmd(eap);</a>
<a name="ln4282">  if (*eap-&gt;arg == '&lt;' || *eap-&gt;arg == '$' || path_is_absolute(eap-&gt;arg)) {</a>
<a name="ln4283">    // For an absolute path, &quot;$VIM/...&quot; or &quot;&lt;sfile&gt;..&quot; we &quot;:source&quot; the</a>
<a name="ln4284">    // file.  Need to expand the file name first.  In other cases</a>
<a name="ln4285">    // &quot;:runtime!&quot; is used.</a>
<a name="ln4286">    source = true;</a>
<a name="ln4287">    if (expand_filename(eap, syn_cmdlinep, &amp;errormsg) == FAIL) {</a>
<a name="ln4288">      if (errormsg != NULL)</a>
<a name="ln4289">        EMSG(errormsg);</a>
<a name="ln4290">      return;</a>
<a name="ln4291">    }</a>
<a name="ln4292">  }</a>
<a name="ln4293"> </a>
<a name="ln4294">  /*</a>
<a name="ln4295">   * Save and restore the existing top-level grouplist id and &quot;:syn</a>
<a name="ln4296">   * include&quot; tag around the actual inclusion.</a>
<a name="ln4297">   */</a>
<a name="ln4298">  if (running_syn_inc_tag &gt;= MAX_SYN_INC_TAG) {</a>
<a name="ln4299">    EMSG((char_u *)_(&quot;E847: Too many syntax includes&quot;));</a>
<a name="ln4300">    return;</a>
<a name="ln4301">  }</a>
<a name="ln4302">  prev_syn_inc_tag = current_syn_inc_tag;</a>
<a name="ln4303">  current_syn_inc_tag = ++running_syn_inc_tag;</a>
<a name="ln4304">  prev_toplvl_grp = curwin-&gt;w_s-&gt;b_syn_topgrp;</a>
<a name="ln4305">  curwin-&gt;w_s-&gt;b_syn_topgrp = sgl_id;</a>
<a name="ln4306">  if (source</a>
<a name="ln4307">      ? do_source(eap-&gt;arg, false, DOSO_NONE) == FAIL</a>
<a name="ln4308">      : source_in_path(p_rtp, eap-&gt;arg, DIP_ALL) == FAIL) {</a>
<a name="ln4309">    EMSG2(_(e_notopen), eap-&gt;arg);</a>
<a name="ln4310">  }</a>
<a name="ln4311">  curwin-&gt;w_s-&gt;b_syn_topgrp = prev_toplvl_grp;</a>
<a name="ln4312">  current_syn_inc_tag = prev_syn_inc_tag;</a>
<a name="ln4313">}</a>
<a name="ln4314"> </a>
<a name="ln4315">/*</a>
<a name="ln4316"> * Handle &quot;:syntax keyword {group-name} [{option}] keyword ..&quot; command.</a>
<a name="ln4317"> */</a>
<a name="ln4318">static void syn_cmd_keyword(exarg_T *eap, int syncing)</a>
<a name="ln4319">{</a>
<a name="ln4320">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln4321">  char_u      *group_name_end;</a>
<a name="ln4322">  int syn_id;</a>
<a name="ln4323">  char_u      *rest;</a>
<a name="ln4324">  char_u      *keyword_copy = NULL;</a>
<a name="ln4325">  char_u      *p;</a>
<a name="ln4326">  char_u      *kw;</a>
<a name="ln4327">  syn_opt_arg_T syn_opt_arg;</a>
<a name="ln4328">  int cnt;</a>
<a name="ln4329">  int conceal_char = NUL;</a>
<a name="ln4330"> </a>
<a name="ln4331">  rest = get_group_name(arg, &amp;group_name_end);</a>
<a name="ln4332"> </a>
<a name="ln4333">  if (rest != NULL) {</a>
<a name="ln4334">    if (eap-&gt;skip) {</a>
<a name="ln4335">      syn_id = -1;</a>
<a name="ln4336">    } else {</a>
<a name="ln4337">      syn_id = syn_check_group(arg, (int)(group_name_end - arg));</a>
<a name="ln4338">    }</a>
<a name="ln4339">    if (syn_id != 0) {</a>
<a name="ln4340">      // Allocate a buffer, for removing backslashes in the keyword.</a>
<a name="ln4341">      keyword_copy = xmalloc(STRLEN(rest) + 1);</a>
<a name="ln4342">    }</a>
<a name="ln4343">    if (keyword_copy != NULL) {</a>
<a name="ln4344">      syn_opt_arg.flags = 0;</a>
<a name="ln4345">      syn_opt_arg.keyword = true;</a>
<a name="ln4346">      syn_opt_arg.sync_idx = NULL;</a>
<a name="ln4347">      syn_opt_arg.has_cont_list = false;</a>
<a name="ln4348">      syn_opt_arg.cont_in_list = NULL;</a>
<a name="ln4349">      syn_opt_arg.next_list = NULL;</a>
<a name="ln4350"> </a>
<a name="ln4351">      // The options given apply to ALL keywords, so all options must be</a>
<a name="ln4352">      // found before keywords can be created.</a>
<a name="ln4353">      // 1: collect the options and copy the keywords to keyword_copy.</a>
<a name="ln4354">      cnt = 0;</a>
<a name="ln4355">      p = keyword_copy;</a>
<a name="ln4356">      for (; rest != NULL &amp;&amp; !ends_excmd(*rest); rest = skipwhite(rest)) {</a>
<a name="ln4357">        rest = get_syn_options(rest, &amp;syn_opt_arg, &amp;conceal_char, eap-&gt;skip);</a>
<a name="ln4358">        if (rest == NULL || ends_excmd(*rest)) {</a>
<a name="ln4359">          break;</a>
<a name="ln4360">        }</a>
<a name="ln4361">        // Copy the keyword, removing backslashes, and add a NUL.</a>
<a name="ln4362">        while (*rest != NUL &amp;&amp; !ascii_iswhite(*rest)) {</a>
<a name="ln4363">          if (*rest == '\\' &amp;&amp; rest[1] != NUL) {</a>
<a name="ln4364">            rest++;</a>
<a name="ln4365">          }</a>
<a name="ln4366">          *p++ = *rest++;</a>
<a name="ln4367">        }</a>
<a name="ln4368">        *p++ = NUL;</a>
<a name="ln4369">        cnt++;</a>
<a name="ln4370">      }</a>
<a name="ln4371"> </a>
<a name="ln4372">      if (!eap-&gt;skip) {</a>
<a name="ln4373">        // Adjust flags for use of &quot;:syn include&quot;.</a>
<a name="ln4374">        syn_incl_toplevel(syn_id, &amp;syn_opt_arg.flags);</a>
<a name="ln4375"> </a>
<a name="ln4376">        // 2: Add an entry for each keyword.</a>
<a name="ln4377">        for (kw = keyword_copy; --cnt &gt;= 0; kw += STRLEN(kw) + 1) {</a>
<a name="ln4378">          for (p = vim_strchr(kw, '[');; ) {</a>
<a name="ln4379">            if (p != NULL) {</a>
<a name="ln4380">              *p = NUL;</a>
<a name="ln4381">            }</a>
<a name="ln4382">            add_keyword(kw, syn_id, syn_opt_arg.flags,</a>
<a name="ln4383">                        syn_opt_arg.cont_in_list,</a>
<a name="ln4384">                        syn_opt_arg.next_list, conceal_char);</a>
<a name="ln4385">            if (p == NULL) {</a>
<a name="ln4386">              break;</a>
<a name="ln4387">            }</a>
<a name="ln4388">            if (p[1] == NUL) {</a>
<a name="ln4389">              emsgf(_(&quot;E789: Missing ']': %s&quot;), kw);</a>
<a name="ln4390">              goto error;</a>
<a name="ln4391">            }</a>
<a name="ln4392">            if (p[1] == ']') {</a>
<a name="ln4393">              if (p[2] != NUL) {</a>
<a name="ln4394">                emsgf(_(&quot;E890: trailing char after ']': %s]%s&quot;),</a>
<a name="ln4395">                      kw, &amp;p[2]);</a>
<a name="ln4396">                goto error;</a>
<a name="ln4397">              }</a>
<a name="ln4398">              kw = p + 1;</a>
<a name="ln4399">              break;   // skip over the &quot;]&quot;</a>
<a name="ln4400">            }</a>
<a name="ln4401">            const int l = (*mb_ptr2len)(p + 1);</a>
<a name="ln4402"> </a>
<a name="ln4403">            memmove(p, p + 1, l);</a>
<a name="ln4404">            p += l;</a>
<a name="ln4405">          }</a>
<a name="ln4406">        }</a>
<a name="ln4407">      }</a>
<a name="ln4408"> </a>
<a name="ln4409">error:</a>
<a name="ln4410">      xfree(keyword_copy);</a>
<a name="ln4411">      xfree(syn_opt_arg.cont_in_list);</a>
<a name="ln4412">      xfree(syn_opt_arg.next_list);</a>
<a name="ln4413">    }</a>
<a name="ln4414">  }</a>
<a name="ln4415"> </a>
<a name="ln4416">  if (rest != NULL)</a>
<a name="ln4417">    eap-&gt;nextcmd = check_nextcmd(rest);</a>
<a name="ln4418">  else</a>
<a name="ln4419">    EMSG2(_(e_invarg2), arg);</a>
<a name="ln4420"> </a>
<a name="ln4421">  redraw_curbuf_later(SOME_VALID);</a>
<a name="ln4422">  syn_stack_free_all(curwin-&gt;w_s);              /* Need to recompute all syntax. */</a>
<a name="ln4423">}</a>
<a name="ln4424"> </a>
<a name="ln4425">/*</a>
<a name="ln4426"> * Handle &quot;:syntax match {name} [{options}] {pattern} [{options}]&quot;.</a>
<a name="ln4427"> *</a>
<a name="ln4428"> * Also &quot;:syntax sync match {name} [[grouphere | groupthere] {group-name}] ..&quot;</a>
<a name="ln4429"> */</a>
<a name="ln4430">static void</a>
<a name="ln4431">syn_cmd_match(</a>
<a name="ln4432">    exarg_T *eap,</a>
<a name="ln4433">    int syncing                        /* TRUE for &quot;:syntax sync match .. &quot; */</a>
<a name="ln4434">)</a>
<a name="ln4435">{</a>
<a name="ln4436">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln4437">  char_u      *group_name_end;</a>
<a name="ln4438">  char_u      *rest;</a>
<a name="ln4439">  synpat_T item;                /* the item found in the line */</a>
<a name="ln4440">  int syn_id;</a>
<a name="ln4441">  syn_opt_arg_T syn_opt_arg;</a>
<a name="ln4442">  int sync_idx = 0;</a>
<a name="ln4443">  int conceal_char = NUL;</a>
<a name="ln4444"> </a>
<a name="ln4445">  /* Isolate the group name, check for validity */</a>
<a name="ln4446">  rest = get_group_name(arg, &amp;group_name_end);</a>
<a name="ln4447"> </a>
<a name="ln4448">  /* Get options before the pattern */</a>
<a name="ln4449">  syn_opt_arg.flags = 0;</a>
<a name="ln4450">  syn_opt_arg.keyword = false;</a>
<a name="ln4451">  syn_opt_arg.sync_idx = syncing ? &amp;sync_idx : NULL;</a>
<a name="ln4452">  syn_opt_arg.has_cont_list = true;</a>
<a name="ln4453">  syn_opt_arg.cont_list = NULL;</a>
<a name="ln4454">  syn_opt_arg.cont_in_list = NULL;</a>
<a name="ln4455">  syn_opt_arg.next_list = NULL;</a>
<a name="ln4456">  rest = get_syn_options(rest, &amp;syn_opt_arg, &amp;conceal_char, eap-&gt;skip);</a>
<a name="ln4457"> </a>
<a name="ln4458">  /* get the pattern. */</a>
<a name="ln4459">  init_syn_patterns();</a>
<a name="ln4460">  memset(&amp;item, 0, sizeof(item));</a>
<a name="ln4461">  rest = get_syn_pattern(rest, &amp;item);</a>
<a name="ln4462">  if (vim_regcomp_had_eol() &amp;&amp; !(syn_opt_arg.flags &amp; HL_EXCLUDENL)) {</a>
<a name="ln4463">    syn_opt_arg.flags |= HL_HAS_EOL;</a>
<a name="ln4464">  }</a>
<a name="ln4465"> </a>
<a name="ln4466">  // Get options after the pattern</a>
<a name="ln4467">  rest = get_syn_options(rest, &amp;syn_opt_arg, &amp;conceal_char, eap-&gt;skip);</a>
<a name="ln4468"> </a>
<a name="ln4469">  if (rest != NULL) {           /* all arguments are valid */</a>
<a name="ln4470">    /*</a>
<a name="ln4471">     * Check for trailing command and illegal trailing arguments.</a>
<a name="ln4472">     */</a>
<a name="ln4473">    eap-&gt;nextcmd = check_nextcmd(rest);</a>
<a name="ln4474">    if (!ends_excmd(*rest) || eap-&gt;skip)</a>
<a name="ln4475">      rest = NULL;</a>
<a name="ln4476">    else {</a>
<a name="ln4477">      if ((syn_id = syn_check_group(arg, (int)(group_name_end - arg))) != 0) {</a>
<a name="ln4478">        syn_incl_toplevel(syn_id, &amp;syn_opt_arg.flags);</a>
<a name="ln4479">        /*</a>
<a name="ln4480">         * Store the pattern in the syn_items list</a>
<a name="ln4481">         */</a>
<a name="ln4482">        synpat_T *spp = GA_APPEND_VIA_PTR(synpat_T,</a>
<a name="ln4483">                                          &amp;curwin-&gt;w_s-&gt;b_syn_patterns);</a>
<a name="ln4484">        *spp = item;</a>
<a name="ln4485">        spp-&gt;sp_syncing = syncing;</a>
<a name="ln4486">        spp-&gt;sp_type = SPTYPE_MATCH;</a>
<a name="ln4487">        spp-&gt;sp_syn.id = syn_id;</a>
<a name="ln4488">        spp-&gt;sp_syn.inc_tag = current_syn_inc_tag;</a>
<a name="ln4489">        spp-&gt;sp_flags = syn_opt_arg.flags;</a>
<a name="ln4490">        spp-&gt;sp_sync_idx = sync_idx;</a>
<a name="ln4491">        spp-&gt;sp_cont_list = syn_opt_arg.cont_list;</a>
<a name="ln4492">        spp-&gt;sp_syn.cont_in_list = syn_opt_arg.cont_in_list;</a>
<a name="ln4493">        spp-&gt;sp_cchar = conceal_char;</a>
<a name="ln4494">        if (syn_opt_arg.cont_in_list != NULL)</a>
<a name="ln4495">          curwin-&gt;w_s-&gt;b_syn_containedin = TRUE;</a>
<a name="ln4496">        spp-&gt;sp_next_list = syn_opt_arg.next_list;</a>
<a name="ln4497"> </a>
<a name="ln4498">        /* remember that we found a match for syncing on */</a>
<a name="ln4499">        if (syn_opt_arg.flags &amp; (HL_SYNC_HERE|HL_SYNC_THERE))</a>
<a name="ln4500">          curwin-&gt;w_s-&gt;b_syn_sync_flags |= SF_MATCH;</a>
<a name="ln4501">        if (syn_opt_arg.flags &amp; HL_FOLD)</a>
<a name="ln4502">          ++curwin-&gt;w_s-&gt;b_syn_folditems;</a>
<a name="ln4503"> </a>
<a name="ln4504">        redraw_curbuf_later(SOME_VALID);</a>
<a name="ln4505">        syn_stack_free_all(curwin-&gt;w_s);          /* Need to recompute all syntax. */</a>
<a name="ln4506">        return;           /* don't free the progs and patterns now */</a>
<a name="ln4507">      }</a>
<a name="ln4508">    }</a>
<a name="ln4509">  }</a>
<a name="ln4510"> </a>
<a name="ln4511">  /*</a>
<a name="ln4512">   * Something failed, free the allocated memory.</a>
<a name="ln4513">   */</a>
<a name="ln4514">  vim_regfree(item.sp_prog);</a>
<a name="ln4515">  xfree(item.sp_pattern);</a>
<a name="ln4516">  xfree(syn_opt_arg.cont_list);</a>
<a name="ln4517">  xfree(syn_opt_arg.cont_in_list);</a>
<a name="ln4518">  xfree(syn_opt_arg.next_list);</a>
<a name="ln4519"> </a>
<a name="ln4520">  if (rest == NULL)</a>
<a name="ln4521">    EMSG2(_(e_invarg2), arg);</a>
<a name="ln4522">}</a>
<a name="ln4523"> </a>
<a name="ln4524">/*</a>
<a name="ln4525"> * Handle &quot;:syntax region {group-name} [matchgroup={group-name}]</a>
<a name="ln4526"> *		start {start} .. [skip {skip}] end {end} .. [{options}]&quot;.</a>
<a name="ln4527"> */</a>
<a name="ln4528">static void</a>
<a name="ln4529">syn_cmd_region(</a>
<a name="ln4530">    exarg_T *eap,</a>
<a name="ln4531">    int syncing                        /* TRUE for &quot;:syntax sync region ..&quot; */</a>
<a name="ln4532">)</a>
<a name="ln4533">{</a>
<a name="ln4534">  char_u              *arg = eap-&gt;arg;</a>
<a name="ln4535">  char_u              *group_name_end;</a>
<a name="ln4536">  char_u              *rest;                    /* next arg, NULL on error */</a>
<a name="ln4537">  char_u              *key_end;</a>
<a name="ln4538">  char_u              *key = NULL;</a>
<a name="ln4539">  char_u              *p;</a>
<a name="ln4540">  int item;</a>
<a name="ln4541">#define ITEM_START          0</a>
<a name="ln4542">#define ITEM_SKIP           1</a>
<a name="ln4543">#define ITEM_END            2</a>
<a name="ln4544">#define ITEM_MATCHGROUP     3</a>
<a name="ln4545">  struct pat_ptr {</a>
<a name="ln4546">    synpat_T        *pp_synp;                   /* pointer to syn_pattern */</a>
<a name="ln4547">    int pp_matchgroup_id;                       /* matchgroup ID */</a>
<a name="ln4548">    struct pat_ptr  *pp_next;                   /* pointer to next pat_ptr */</a>
<a name="ln4549">  }                   *(pat_ptrs[3]);</a>
<a name="ln4550">  /* patterns found in the line */</a>
<a name="ln4551">  struct pat_ptr      *ppp;</a>
<a name="ln4552">  struct pat_ptr      *ppp_next;</a>
<a name="ln4553">  int pat_count = 0;                            /* nr of syn_patterns found */</a>
<a name="ln4554">  int syn_id;</a>
<a name="ln4555">  int matchgroup_id = 0;</a>
<a name="ln4556">  int not_enough = FALSE;                       /* not enough arguments */</a>
<a name="ln4557">  int illegal = FALSE;                          /* illegal arguments */</a>
<a name="ln4558">  int success = FALSE;</a>
<a name="ln4559">  syn_opt_arg_T syn_opt_arg;</a>
<a name="ln4560">  int conceal_char = NUL;</a>
<a name="ln4561"> </a>
<a name="ln4562">  /* Isolate the group name, check for validity */</a>
<a name="ln4563">  rest = get_group_name(arg, &amp;group_name_end);</a>
<a name="ln4564"> </a>
<a name="ln4565">  pat_ptrs[0] = NULL;</a>
<a name="ln4566">  pat_ptrs[1] = NULL;</a>
<a name="ln4567">  pat_ptrs[2] = NULL;</a>
<a name="ln4568"> </a>
<a name="ln4569">  init_syn_patterns();</a>
<a name="ln4570"> </a>
<a name="ln4571">  syn_opt_arg.flags = 0;</a>
<a name="ln4572">  syn_opt_arg.keyword = false;</a>
<a name="ln4573">  syn_opt_arg.sync_idx = NULL;</a>
<a name="ln4574">  syn_opt_arg.has_cont_list = true;</a>
<a name="ln4575">  syn_opt_arg.cont_list = NULL;</a>
<a name="ln4576">  syn_opt_arg.cont_in_list = NULL;</a>
<a name="ln4577">  syn_opt_arg.next_list = NULL;</a>
<a name="ln4578"> </a>
<a name="ln4579">  // get the options, patterns and matchgroup.</a>
<a name="ln4580">  while (rest != NULL &amp;&amp; !ends_excmd(*rest)) {</a>
<a name="ln4581">    // Check for option arguments</a>
<a name="ln4582">    rest = get_syn_options(rest, &amp;syn_opt_arg, &amp;conceal_char, eap-&gt;skip);</a>
<a name="ln4583">    if (rest == NULL || ends_excmd(*rest)) {</a>
<a name="ln4584">      break;</a>
<a name="ln4585">    }</a>
<a name="ln4586"> </a>
<a name="ln4587">    /* must be a pattern or matchgroup then */</a>
<a name="ln4588">    key_end = rest;</a>
<a name="ln4589">    while (*key_end &amp;&amp; !ascii_iswhite(*key_end) &amp;&amp; *key_end != '=')</a>
<a name="ln4590">      ++key_end;</a>
<a name="ln4591">    xfree(key);</a>
<a name="ln4592">    key = vim_strnsave_up(rest, key_end - rest);</a>
<a name="ln4593">    if (STRCMP(key, &quot;MATCHGROUP&quot;) == 0) {</a>
<a name="ln4594">      item = ITEM_MATCHGROUP;</a>
<a name="ln4595">    } else if (STRCMP(key, &quot;START&quot;) == 0) {</a>
<a name="ln4596">      item = ITEM_START;</a>
<a name="ln4597">    } else if (STRCMP(key, &quot;END&quot;) == 0) {</a>
<a name="ln4598">      item = ITEM_END;</a>
<a name="ln4599">    } else if (STRCMP(key, &quot;SKIP&quot;) == 0) {</a>
<a name="ln4600">      if (pat_ptrs[ITEM_SKIP] != NULL) {  // One skip pattern allowed.</a>
<a name="ln4601">        illegal = true;</a>
<a name="ln4602">        break;</a>
<a name="ln4603">      }</a>
<a name="ln4604">      item = ITEM_SKIP;</a>
<a name="ln4605">    } else {</a>
<a name="ln4606">      break;</a>
<a name="ln4607">    }</a>
<a name="ln4608">    rest = skipwhite(key_end);</a>
<a name="ln4609">    if (*rest != '=') {</a>
<a name="ln4610">      rest = NULL;</a>
<a name="ln4611">      EMSG2(_(&quot;E398: Missing '=': %s&quot;), arg);</a>
<a name="ln4612">      break;</a>
<a name="ln4613">    }</a>
<a name="ln4614">    rest = skipwhite(rest + 1);</a>
<a name="ln4615">    if (*rest == NUL) {</a>
<a name="ln4616">      not_enough = TRUE;</a>
<a name="ln4617">      break;</a>
<a name="ln4618">    }</a>
<a name="ln4619"> </a>
<a name="ln4620">    if (item == ITEM_MATCHGROUP) {</a>
<a name="ln4621">      p = skiptowhite(rest);</a>
<a name="ln4622">      if ((p - rest == 4 &amp;&amp; STRNCMP(rest, &quot;NONE&quot;, 4) == 0) || eap-&gt;skip)</a>
<a name="ln4623">        matchgroup_id = 0;</a>
<a name="ln4624">      else {</a>
<a name="ln4625">        matchgroup_id = syn_check_group(rest, (int)(p - rest));</a>
<a name="ln4626">        if (matchgroup_id == 0) {</a>
<a name="ln4627">          illegal = TRUE;</a>
<a name="ln4628">          break;</a>
<a name="ln4629">        }</a>
<a name="ln4630">      }</a>
<a name="ln4631">      rest = skipwhite(p);</a>
<a name="ln4632">    } else {</a>
<a name="ln4633">      /*</a>
<a name="ln4634">       * Allocate room for a syn_pattern, and link it in the list of</a>
<a name="ln4635">       * syn_patterns for this item, at the start (because the list is</a>
<a name="ln4636">       * used from end to start).</a>
<a name="ln4637">       */</a>
<a name="ln4638">      ppp = xmalloc(sizeof(struct pat_ptr));</a>
<a name="ln4639">      ppp-&gt;pp_next = pat_ptrs[item];</a>
<a name="ln4640">      pat_ptrs[item] = ppp;</a>
<a name="ln4641">      ppp-&gt;pp_synp = xcalloc(1, sizeof(synpat_T));</a>
<a name="ln4642"> </a>
<a name="ln4643">      // Get the syntax pattern and the following offset(s).</a>
<a name="ln4644"> </a>
<a name="ln4645">      // Enable the appropriate \z specials.</a>
<a name="ln4646">      if (item == ITEM_START) {</a>
<a name="ln4647">        reg_do_extmatch = REX_SET;</a>
<a name="ln4648">      } else {</a>
<a name="ln4649">        assert(item == ITEM_SKIP || item == ITEM_END);</a>
<a name="ln4650">        reg_do_extmatch = REX_USE;</a>
<a name="ln4651">      }</a>
<a name="ln4652">      rest = get_syn_pattern(rest, ppp-&gt;pp_synp);</a>
<a name="ln4653">      reg_do_extmatch = 0;</a>
<a name="ln4654">      if (item == ITEM_END &amp;&amp; vim_regcomp_had_eol()</a>
<a name="ln4655">          &amp;&amp; !(syn_opt_arg.flags &amp; HL_EXCLUDENL)) {</a>
<a name="ln4656">        ppp-&gt;pp_synp-&gt;sp_flags |= HL_HAS_EOL;</a>
<a name="ln4657">      }</a>
<a name="ln4658">      ppp-&gt;pp_matchgroup_id = matchgroup_id;</a>
<a name="ln4659">      pat_count++;</a>
<a name="ln4660">    }</a>
<a name="ln4661">  }</a>
<a name="ln4662">  xfree(key);</a>
<a name="ln4663">  if (illegal || not_enough)</a>
<a name="ln4664">    rest = NULL;</a>
<a name="ln4665"> </a>
<a name="ln4666">  // Must have a &quot;start&quot; and &quot;end&quot; pattern.</a>
<a name="ln4667">  if (rest != NULL &amp;&amp; (pat_ptrs[ITEM_START] == NULL</a>
<a name="ln4668">                       || pat_ptrs[ITEM_END] == NULL)) {</a>
<a name="ln4669">    not_enough = true;</a>
<a name="ln4670">    rest = NULL;</a>
<a name="ln4671">  }</a>
<a name="ln4672"> </a>
<a name="ln4673">  if (rest != NULL) {</a>
<a name="ln4674">    /*</a>
<a name="ln4675">     * Check for trailing garbage or command.</a>
<a name="ln4676">     * If OK, add the item.</a>
<a name="ln4677">     */</a>
<a name="ln4678">    eap-&gt;nextcmd = check_nextcmd(rest);</a>
<a name="ln4679">    if (!ends_excmd(*rest) || eap-&gt;skip)</a>
<a name="ln4680">      rest = NULL;</a>
<a name="ln4681">    else {</a>
<a name="ln4682">      ga_grow(&amp;(curwin-&gt;w_s-&gt;b_syn_patterns), pat_count);</a>
<a name="ln4683">      if ((syn_id = syn_check_group(arg, (int)(group_name_end - arg))) != 0) {</a>
<a name="ln4684">        syn_incl_toplevel(syn_id, &amp;syn_opt_arg.flags);</a>
<a name="ln4685">        /*</a>
<a name="ln4686">         * Store the start/skip/end in the syn_items list</a>
<a name="ln4687">         */</a>
<a name="ln4688">        int idx = curwin-&gt;w_s-&gt;b_syn_patterns.ga_len;</a>
<a name="ln4689">        for (item = ITEM_START; item &lt;= ITEM_END; ++item) {</a>
<a name="ln4690">          for (ppp = pat_ptrs[item]; ppp != NULL; ppp = ppp-&gt;pp_next) {</a>
<a name="ln4691">            SYN_ITEMS(curwin-&gt;w_s)[idx] = *(ppp-&gt;pp_synp);</a>
<a name="ln4692">            SYN_ITEMS(curwin-&gt;w_s)[idx].sp_syncing = syncing;</a>
<a name="ln4693">            SYN_ITEMS(curwin-&gt;w_s)[idx].sp_type =</a>
<a name="ln4694">              (item == ITEM_START) ? SPTYPE_START :</a>
<a name="ln4695">              (item == ITEM_SKIP) ? SPTYPE_SKIP : SPTYPE_END;</a>
<a name="ln4696">            SYN_ITEMS(curwin-&gt;w_s)[idx].sp_flags |= syn_opt_arg.flags;</a>
<a name="ln4697">            SYN_ITEMS(curwin-&gt;w_s)[idx].sp_syn.id = syn_id;</a>
<a name="ln4698">            SYN_ITEMS(curwin-&gt;w_s)[idx].sp_syn.inc_tag =</a>
<a name="ln4699">              current_syn_inc_tag;</a>
<a name="ln4700">            SYN_ITEMS(curwin-&gt;w_s)[idx].sp_syn_match_id =</a>
<a name="ln4701">              ppp-&gt;pp_matchgroup_id;</a>
<a name="ln4702">            SYN_ITEMS(curwin-&gt;w_s)[idx].sp_cchar = conceal_char;</a>
<a name="ln4703">            if (item == ITEM_START) {</a>
<a name="ln4704">              SYN_ITEMS(curwin-&gt;w_s)[idx].sp_cont_list =</a>
<a name="ln4705">                syn_opt_arg.cont_list;</a>
<a name="ln4706">              SYN_ITEMS(curwin-&gt;w_s)[idx].sp_syn.cont_in_list =</a>
<a name="ln4707">                syn_opt_arg.cont_in_list;</a>
<a name="ln4708">              if (syn_opt_arg.cont_in_list != NULL)</a>
<a name="ln4709">                curwin-&gt;w_s-&gt;b_syn_containedin = TRUE;</a>
<a name="ln4710">              SYN_ITEMS(curwin-&gt;w_s)[idx].sp_next_list =</a>
<a name="ln4711">                syn_opt_arg.next_list;</a>
<a name="ln4712">            }</a>
<a name="ln4713">            ++curwin-&gt;w_s-&gt;b_syn_patterns.ga_len;</a>
<a name="ln4714">            ++idx;</a>
<a name="ln4715">            if (syn_opt_arg.flags &amp; HL_FOLD)</a>
<a name="ln4716">              ++curwin-&gt;w_s-&gt;b_syn_folditems;</a>
<a name="ln4717">          }</a>
<a name="ln4718">        }</a>
<a name="ln4719"> </a>
<a name="ln4720">        redraw_curbuf_later(SOME_VALID);</a>
<a name="ln4721">        syn_stack_free_all(curwin-&gt;w_s);          /* Need to recompute all syntax. */</a>
<a name="ln4722">        success = TRUE;               /* don't free the progs and patterns now */</a>
<a name="ln4723">      }</a>
<a name="ln4724">    }</a>
<a name="ln4725">  }</a>
<a name="ln4726"> </a>
<a name="ln4727">  /*</a>
<a name="ln4728">   * Free the allocated memory.</a>
<a name="ln4729">   */</a>
<a name="ln4730">  for (item = ITEM_START; item &lt;= ITEM_END; ++item)</a>
<a name="ln4731">    for (ppp = pat_ptrs[item]; ppp != NULL; ppp = ppp_next) {</a>
<a name="ln4732">      if (!success &amp;&amp; ppp-&gt;pp_synp != NULL) {</a>
<a name="ln4733">        vim_regfree(ppp-&gt;pp_synp-&gt;sp_prog);</a>
<a name="ln4734">        xfree(ppp-&gt;pp_synp-&gt;sp_pattern);</a>
<a name="ln4735">      }</a>
<a name="ln4736">      xfree(ppp-&gt;pp_synp);</a>
<a name="ln4737">      ppp_next = ppp-&gt;pp_next;</a>
<a name="ln4738">      xfree(ppp);</a>
<a name="ln4739">    }</a>
<a name="ln4740"> </a>
<a name="ln4741">  if (!success) {</a>
<a name="ln4742">    xfree(syn_opt_arg.cont_list);</a>
<a name="ln4743">    xfree(syn_opt_arg.cont_in_list);</a>
<a name="ln4744">    xfree(syn_opt_arg.next_list);</a>
<a name="ln4745">    if (not_enough)</a>
<a name="ln4746">      EMSG2(_(&quot;E399: Not enough arguments: syntax region %s&quot;), arg);</a>
<a name="ln4747">    else if (illegal || rest == NULL)</a>
<a name="ln4748">      EMSG2(_(e_invarg2), arg);</a>
<a name="ln4749">  }</a>
<a name="ln4750">}</a>
<a name="ln4751"> </a>
<a name="ln4752">// A simple syntax group ID comparison function suitable for use in qsort()</a>
<a name="ln4753">static int syn_compare_stub(const void *const v1, const void *const v2)</a>
<a name="ln4754">{</a>
<a name="ln4755">  const int16_t *const s1 = v1;</a>
<a name="ln4756">  const int16_t *const s2 = v2;</a>
<a name="ln4757"> </a>
<a name="ln4758">  return *s1 &gt; *s2 ? 1 : *s1 &lt; *s2 ? -1 : 0;</a>
<a name="ln4759">}</a>
<a name="ln4760"> </a>
<a name="ln4761">// Combines lists of syntax clusters.</a>
<a name="ln4762">// *clstr1 and *clstr2 must both be allocated memory; they will be consumed.</a>
<a name="ln4763">static void syn_combine_list(int16_t **const clstr1, int16_t **const clstr2,</a>
<a name="ln4764">                             const int list_op)</a>
<a name="ln4765">{</a>
<a name="ln4766">  size_t count1 = 0;</a>
<a name="ln4767">  size_t count2 = 0;</a>
<a name="ln4768">  const int16_t *g1;</a>
<a name="ln4769">  const int16_t *g2;</a>
<a name="ln4770">  int16_t *clstr = NULL;</a>
<a name="ln4771"> </a>
<a name="ln4772">  /*</a>
<a name="ln4773">   * Handle degenerate cases.</a>
<a name="ln4774">   */</a>
<a name="ln4775">  if (*clstr2 == NULL)</a>
<a name="ln4776">    return;</a>
<a name="ln4777">  if (*clstr1 == NULL || list_op == CLUSTER_REPLACE) {</a>
<a name="ln4778">    if (list_op == CLUSTER_REPLACE)</a>
<a name="ln4779">      xfree(*clstr1);</a>
<a name="ln4780">    if (list_op == CLUSTER_REPLACE || list_op == CLUSTER_ADD)</a>
<a name="ln4781">      *clstr1 = *clstr2;</a>
<a name="ln4782">    else</a>
<a name="ln4783">      xfree(*clstr2);</a>
<a name="ln4784">    return;</a>
<a name="ln4785">  }</a>
<a name="ln4786"> </a>
<a name="ln4787">  for (g1 = *clstr1; *g1; g1++) {</a>
<a name="ln4788">    count1++;</a>
<a name="ln4789">  }</a>
<a name="ln4790">  for (g2 = *clstr2; *g2; g2++) {</a>
<a name="ln4791">    count2++;</a>
<a name="ln4792">  }</a>
<a name="ln4793"> </a>
<a name="ln4794">  // For speed purposes, sort both lists.</a>
<a name="ln4795">  qsort(*clstr1, count1, sizeof(**clstr1), syn_compare_stub);</a>
<a name="ln4796">  qsort(*clstr2, count2, sizeof(**clstr2), syn_compare_stub);</a>
<a name="ln4797"> </a>
<a name="ln4798">  // We proceed in two passes; in round 1, we count the elements to place</a>
<a name="ln4799">  // in the new list, and in round 2, we allocate and populate the new</a>
<a name="ln4800">  // list.  For speed, we use a mergesort-like method, adding the smaller</a>
<a name="ln4801">  // of the current elements in each list to the new list.</a>
<a name="ln4802">  for (int round = 1; round &lt;= 2; round++) {</a>
<a name="ln4803">    g1 = *clstr1;</a>
<a name="ln4804">    g2 = *clstr2;</a>
<a name="ln4805">    int count = 0;</a>
<a name="ln4806"> </a>
<a name="ln4807">    /*</a>
<a name="ln4808">     * First, loop through the lists until one of them is empty.</a>
<a name="ln4809">     */</a>
<a name="ln4810">    while (*g1 &amp;&amp; *g2) {</a>
<a name="ln4811">      /*</a>
<a name="ln4812">       * We always want to add from the first list.</a>
<a name="ln4813">       */</a>
<a name="ln4814">      if (*g1 &lt; *g2) {</a>
<a name="ln4815">        if (round == 2)</a>
<a name="ln4816">          clstr[count] = *g1;</a>
<a name="ln4817">        count++;</a>
<a name="ln4818">        g1++;</a>
<a name="ln4819">        continue;</a>
<a name="ln4820">      }</a>
<a name="ln4821">      /*</a>
<a name="ln4822">       * We only want to add from the second list if we're adding the</a>
<a name="ln4823">       * lists.</a>
<a name="ln4824">       */</a>
<a name="ln4825">      if (list_op == CLUSTER_ADD) {</a>
<a name="ln4826">        if (round == 2)</a>
<a name="ln4827">          clstr[count] = *g2;</a>
<a name="ln4828">        count++;</a>
<a name="ln4829">      }</a>
<a name="ln4830">      if (*g1 == *g2)</a>
<a name="ln4831">        g1++;</a>
<a name="ln4832">      g2++;</a>
<a name="ln4833">    }</a>
<a name="ln4834"> </a>
<a name="ln4835">    /*</a>
<a name="ln4836">     * Now add the leftovers from whichever list didn't get finished</a>
<a name="ln4837">     * first.  As before, we only want to add from the second list if</a>
<a name="ln4838">     * we're adding the lists.</a>
<a name="ln4839">     */</a>
<a name="ln4840">    for (; *g1; g1++, count++)</a>
<a name="ln4841">      if (round == 2)</a>
<a name="ln4842">        clstr[count] = *g1;</a>
<a name="ln4843">    if (list_op == CLUSTER_ADD)</a>
<a name="ln4844">      for (; *g2; g2++, count++)</a>
<a name="ln4845">        if (round == 2)</a>
<a name="ln4846">          clstr[count] = *g2;</a>
<a name="ln4847"> </a>
<a name="ln4848">    if (round == 1) {</a>
<a name="ln4849">      /*</a>
<a name="ln4850">       * If the group ended up empty, we don't need to allocate any</a>
<a name="ln4851">       * space for it.</a>
<a name="ln4852">       */</a>
<a name="ln4853">      if (count == 0) {</a>
<a name="ln4854">        clstr = NULL;</a>
<a name="ln4855">        break;</a>
<a name="ln4856">      }</a>
<a name="ln4857">      clstr = xmalloc((count + 1) * sizeof(*clstr));</a>
<a name="ln4858">      clstr[count] = 0;</a>
<a name="ln4859">    }</a>
<a name="ln4860">  }</a>
<a name="ln4861"> </a>
<a name="ln4862">  /*</a>
<a name="ln4863">   * Finally, put the new list in place.</a>
<a name="ln4864">   */</a>
<a name="ln4865">  xfree(*clstr1);</a>
<a name="ln4866">  xfree(*clstr2);</a>
<a name="ln4867">  *clstr1 = clstr;</a>
<a name="ln4868">}</a>
<a name="ln4869"> </a>
<a name="ln4870">// Lookup a syntax cluster name and return its ID.</a>
<a name="ln4871">// If it is not found, 0 is returned.</a>
<a name="ln4872">static int syn_scl_name2id(char_u *name)</a>
<a name="ln4873">{</a>
<a name="ln4874">  // Avoid using stricmp() too much, it's slow on some systems</a>
<a name="ln4875">  char_u *name_u = vim_strsave_up(name);</a>
<a name="ln4876">  int i;</a>
<a name="ln4877">  for (i = curwin-&gt;w_s-&gt;b_syn_clusters.ga_len; --i &gt;= 0; ) {</a>
<a name="ln4878">    if (SYN_CLSTR(curwin-&gt;w_s)[i].scl_name_u != NULL</a>
<a name="ln4879">        &amp;&amp; STRCMP(name_u, SYN_CLSTR(curwin-&gt;w_s)[i].scl_name_u) == 0) {</a>
<a name="ln4880">      break;</a>
<a name="ln4881">    }</a>
<a name="ln4882">  }</a>
<a name="ln4883">  xfree(name_u);</a>
<a name="ln4884">  return i &lt; 0 ? 0 : i + SYNID_CLUSTER;</a>
<a name="ln4885">}</a>
<a name="ln4886"> </a>
<a name="ln4887">/*</a>
<a name="ln4888"> * Like syn_scl_name2id(), but take a pointer + length argument.</a>
<a name="ln4889"> */</a>
<a name="ln4890">static int syn_scl_namen2id(char_u *linep, int len)</a>
<a name="ln4891">{</a>
<a name="ln4892">  char_u *name = vim_strnsave(linep, len);</a>
<a name="ln4893">  int id = syn_scl_name2id(name);</a>
<a name="ln4894">  xfree(name);</a>
<a name="ln4895"> </a>
<a name="ln4896">  return id;</a>
<a name="ln4897">}</a>
<a name="ln4898"> </a>
<a name="ln4899">// Find syntax cluster name in the table and return its ID.</a>
<a name="ln4900">// The argument is a pointer to the name and the length of the name.</a>
<a name="ln4901">// If it doesn't exist yet, a new entry is created.</a>
<a name="ln4902">// Return 0 for failure.</a>
<a name="ln4903">static int syn_check_cluster(char_u *pp, int len)</a>
<a name="ln4904">{</a>
<a name="ln4905">  int id;</a>
<a name="ln4906">  char_u      *name;</a>
<a name="ln4907"> </a>
<a name="ln4908">  name = vim_strnsave(pp, len);</a>
<a name="ln4909"> </a>
<a name="ln4910">  id = syn_scl_name2id(name);</a>
<a name="ln4911">  if (id == 0)                          /* doesn't exist yet */</a>
<a name="ln4912">    id = syn_add_cluster(name);</a>
<a name="ln4913">  else</a>
<a name="ln4914">    xfree(name);</a>
<a name="ln4915">  return id;</a>
<a name="ln4916">}</a>
<a name="ln4917"> </a>
<a name="ln4918">// Add new syntax cluster and return its ID.</a>
<a name="ln4919">// &quot;name&quot; must be an allocated string, it will be consumed.</a>
<a name="ln4920">// Return 0 for failure.</a>
<a name="ln4921">static int syn_add_cluster(char_u *name)</a>
<a name="ln4922">{</a>
<a name="ln4923">  /*</a>
<a name="ln4924">   * First call for this growarray: init growing array.</a>
<a name="ln4925">   */</a>
<a name="ln4926">  if (curwin-&gt;w_s-&gt;b_syn_clusters.ga_data == NULL) {</a>
<a name="ln4927">    curwin-&gt;w_s-&gt;b_syn_clusters.ga_itemsize = sizeof(syn_cluster_T);</a>
<a name="ln4928">    ga_set_growsize(&amp;curwin-&gt;w_s-&gt;b_syn_clusters, 10);</a>
<a name="ln4929">  }</a>
<a name="ln4930"> </a>
<a name="ln4931">  int len = curwin-&gt;w_s-&gt;b_syn_clusters.ga_len;</a>
<a name="ln4932">  if (len &gt;= MAX_CLUSTER_ID) {</a>
<a name="ln4933">    EMSG((char_u *)_(&quot;E848: Too many syntax clusters&quot;));</a>
<a name="ln4934">    xfree(name);</a>
<a name="ln4935">    return 0;</a>
<a name="ln4936">  }</a>
<a name="ln4937"> </a>
<a name="ln4938">  syn_cluster_T *scp = GA_APPEND_VIA_PTR(syn_cluster_T,</a>
<a name="ln4939">                                         &amp;curwin-&gt;w_s-&gt;b_syn_clusters);</a>
<a name="ln4940">  memset(scp, 0, sizeof(*scp));</a>
<a name="ln4941">  scp-&gt;scl_name = name;</a>
<a name="ln4942">  scp-&gt;scl_name_u = vim_strsave_up(name);</a>
<a name="ln4943">  scp-&gt;scl_list = NULL;</a>
<a name="ln4944"> </a>
<a name="ln4945">  if (STRICMP(name, &quot;Spell&quot;) == 0)</a>
<a name="ln4946">    curwin-&gt;w_s-&gt;b_spell_cluster_id = len + SYNID_CLUSTER;</a>
<a name="ln4947">  if (STRICMP(name, &quot;NoSpell&quot;) == 0)</a>
<a name="ln4948">    curwin-&gt;w_s-&gt;b_nospell_cluster_id = len + SYNID_CLUSTER;</a>
<a name="ln4949"> </a>
<a name="ln4950">  return len + SYNID_CLUSTER;</a>
<a name="ln4951">}</a>
<a name="ln4952"> </a>
<a name="ln4953">/*</a>
<a name="ln4954"> * Handle &quot;:syntax cluster {cluster-name} [contains={groupname},..]</a>
<a name="ln4955"> *		[add={groupname},..] [remove={groupname},..]&quot;.</a>
<a name="ln4956"> */</a>
<a name="ln4957">static void syn_cmd_cluster(exarg_T *eap, int syncing)</a>
<a name="ln4958">{</a>
<a name="ln4959">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln4960">  char_u      *group_name_end;</a>
<a name="ln4961">  char_u      *rest;</a>
<a name="ln4962">  bool got_clstr = false;</a>
<a name="ln4963">  int opt_len;</a>
<a name="ln4964">  int list_op;</a>
<a name="ln4965"> </a>
<a name="ln4966">  eap-&gt;nextcmd = find_nextcmd(arg);</a>
<a name="ln4967">  if (eap-&gt;skip)</a>
<a name="ln4968">    return;</a>
<a name="ln4969"> </a>
<a name="ln4970">  rest = get_group_name(arg, &amp;group_name_end);</a>
<a name="ln4971"> </a>
<a name="ln4972">  if (rest != NULL) {</a>
<a name="ln4973">    int scl_id = syn_check_cluster(arg, (int)(group_name_end - arg));</a>
<a name="ln4974">    if (scl_id == 0) {</a>
<a name="ln4975">      return;</a>
<a name="ln4976">    }</a>
<a name="ln4977">    scl_id -= SYNID_CLUSTER;</a>
<a name="ln4978"> </a>
<a name="ln4979">    for (;; ) {</a>
<a name="ln4980">      if (STRNICMP(rest, &quot;add&quot;, 3) == 0</a>
<a name="ln4981">          &amp;&amp; (ascii_iswhite(rest[3]) || rest[3] == '=')) {</a>
<a name="ln4982">        opt_len = 3;</a>
<a name="ln4983">        list_op = CLUSTER_ADD;</a>
<a name="ln4984">      } else if (STRNICMP(rest, &quot;remove&quot;, 6) == 0</a>
<a name="ln4985">                 &amp;&amp; (ascii_iswhite(rest[6]) || rest[6] == '=')) {</a>
<a name="ln4986">        opt_len = 6;</a>
<a name="ln4987">        list_op = CLUSTER_SUBTRACT;</a>
<a name="ln4988">      } else if (STRNICMP(rest, &quot;contains&quot;, 8) == 0</a>
<a name="ln4989">                 &amp;&amp; (ascii_iswhite(rest[8]) || rest[8] == '=')) {</a>
<a name="ln4990">        opt_len = 8;</a>
<a name="ln4991">        list_op = CLUSTER_REPLACE;</a>
<a name="ln4992">      } else</a>
<a name="ln4993">        break;</a>
<a name="ln4994"> </a>
<a name="ln4995">      int16_t *clstr_list = NULL;</a>
<a name="ln4996">      if (get_id_list(&amp;rest, opt_len, &amp;clstr_list, eap-&gt;skip) == FAIL) {</a>
<a name="ln4997">        EMSG2(_(e_invarg2), rest);</a>
<a name="ln4998">        break;</a>
<a name="ln4999">      }</a>
<a name="ln5000">      if (scl_id &gt;= 0) {</a>
<a name="ln5001">        syn_combine_list(&amp;SYN_CLSTR(curwin-&gt;w_s)[scl_id].scl_list,</a>
<a name="ln5002">                         &amp;clstr_list, list_op);</a>
<a name="ln5003">      } else {</a>
<a name="ln5004">        xfree(clstr_list);</a>
<a name="ln5005">      }</a>
<a name="ln5006">      got_clstr = true;</a>
<a name="ln5007">    }</a>
<a name="ln5008"> </a>
<a name="ln5009">    if (got_clstr) {</a>
<a name="ln5010">      redraw_curbuf_later(SOME_VALID);</a>
<a name="ln5011">      syn_stack_free_all(curwin-&gt;w_s);          /* Need to recompute all. */</a>
<a name="ln5012">    }</a>
<a name="ln5013">  }</a>
<a name="ln5014"> </a>
<a name="ln5015">  if (!got_clstr)</a>
<a name="ln5016">    EMSG(_(&quot;E400: No cluster specified&quot;));</a>
<a name="ln5017">  if (rest == NULL || !ends_excmd(*rest))</a>
<a name="ln5018">    EMSG2(_(e_invarg2), arg);</a>
<a name="ln5019">}</a>
<a name="ln5020"> </a>
<a name="ln5021">/*</a>
<a name="ln5022"> * On first call for current buffer: Init growing array.</a>
<a name="ln5023"> */</a>
<a name="ln5024">static void init_syn_patterns(void)</a>
<a name="ln5025">{</a>
<a name="ln5026">  curwin-&gt;w_s-&gt;b_syn_patterns.ga_itemsize = sizeof(synpat_T);</a>
<a name="ln5027">  ga_set_growsize(&amp;curwin-&gt;w_s-&gt;b_syn_patterns, 10);</a>
<a name="ln5028">}</a>
<a name="ln5029"> </a>
<a name="ln5030">/*</a>
<a name="ln5031"> * Get one pattern for a &quot;:syntax match&quot; or &quot;:syntax region&quot; command.</a>
<a name="ln5032"> * Stores the pattern and program in a synpat_T.</a>
<a name="ln5033"> * Returns a pointer to the next argument, or NULL in case of an error.</a>
<a name="ln5034"> */</a>
<a name="ln5035">static char_u *get_syn_pattern(char_u *arg, synpat_T *ci)</a>
<a name="ln5036">{</a>
<a name="ln5037">  char_u      *end;</a>
<a name="ln5038">  int         *p;</a>
<a name="ln5039">  int idx;</a>
<a name="ln5040">  char_u      *cpo_save;</a>
<a name="ln5041"> </a>
<a name="ln5042">  // need at least three chars</a>
<a name="ln5043">  if (arg == NULL || arg[0] == NUL || arg[1] == NUL || arg[2] == NUL) {</a>
<a name="ln5044">    return NULL;</a>
<a name="ln5045">  }</a>
<a name="ln5046"> </a>
<a name="ln5047">  end = skip_regexp(arg + 1, *arg, TRUE, NULL);</a>
<a name="ln5048">  if (*end != *arg) {                       /* end delimiter not found */</a>
<a name="ln5049">    EMSG2(_(&quot;E401: Pattern delimiter not found: %s&quot;), arg);</a>
<a name="ln5050">    return NULL;</a>
<a name="ln5051">  }</a>
<a name="ln5052">  // store the pattern and compiled regexp program</a>
<a name="ln5053">  ci-&gt;sp_pattern = vim_strnsave(arg + 1, end - arg - 1);</a>
<a name="ln5054"> </a>
<a name="ln5055">  /* Make 'cpoptions' empty, to avoid the 'l' flag */</a>
<a name="ln5056">  cpo_save = p_cpo;</a>
<a name="ln5057">  p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln5058">  ci-&gt;sp_prog = vim_regcomp(ci-&gt;sp_pattern, RE_MAGIC);</a>
<a name="ln5059">  p_cpo = cpo_save;</a>
<a name="ln5060"> </a>
<a name="ln5061">  if (ci-&gt;sp_prog == NULL)</a>
<a name="ln5062">    return NULL;</a>
<a name="ln5063">  ci-&gt;sp_ic = curwin-&gt;w_s-&gt;b_syn_ic;</a>
<a name="ln5064">  syn_clear_time(&amp;ci-&gt;sp_time);</a>
<a name="ln5065"> </a>
<a name="ln5066">  /*</a>
<a name="ln5067">   * Check for a match, highlight or region offset.</a>
<a name="ln5068">   */</a>
<a name="ln5069">  ++end;</a>
<a name="ln5070">  do {</a>
<a name="ln5071">    for (idx = SPO_COUNT; --idx &gt;= 0; )</a>
<a name="ln5072">      if (STRNCMP(end, spo_name_tab[idx], 3) == 0)</a>
<a name="ln5073">        break;</a>
<a name="ln5074">    if (idx &gt;= 0) {</a>
<a name="ln5075">      p = &amp;(ci-&gt;sp_offsets[idx]);</a>
<a name="ln5076">      if (idx != SPO_LC_OFF)</a>
<a name="ln5077">        switch (end[3]) {</a>
<a name="ln5078">        case 's':   break;</a>
<a name="ln5079">        case 'b':   break;</a>
<a name="ln5080">        case 'e':   idx += SPO_COUNT; break;</a>
<a name="ln5081">        default:    idx = -1; break;</a>
<a name="ln5082">        }</a>
<a name="ln5083">      if (idx &gt;= 0) {</a>
<a name="ln5084">        ci-&gt;sp_off_flags |= (1 &lt;&lt; idx);</a>
<a name="ln5085">        if (idx == SPO_LC_OFF) {            /* lc=99 */</a>
<a name="ln5086">          end += 3;</a>
<a name="ln5087">          *p = getdigits_int(&amp;end, true, 0);</a>
<a name="ln5088"> </a>
<a name="ln5089">          /* &quot;lc=&quot; offset automatically sets &quot;ms=&quot; offset */</a>
<a name="ln5090">          if (!(ci-&gt;sp_off_flags &amp; (1 &lt;&lt; SPO_MS_OFF))) {</a>
<a name="ln5091">            ci-&gt;sp_off_flags |= (1 &lt;&lt; SPO_MS_OFF);</a>
<a name="ln5092">            ci-&gt;sp_offsets[SPO_MS_OFF] = *p;</a>
<a name="ln5093">          }</a>
<a name="ln5094">        } else {                          /* yy=x+99 */</a>
<a name="ln5095">          end += 4;</a>
<a name="ln5096">          if (*end == '+') {</a>
<a name="ln5097">            end++;</a>
<a name="ln5098">            *p = getdigits_int(&amp;end, true, 0);    // positive offset</a>
<a name="ln5099">          } else if (*end == '-')   {</a>
<a name="ln5100">            end++;</a>
<a name="ln5101">            *p = -getdigits_int(&amp;end, true, 0);   // negative offset</a>
<a name="ln5102">          }</a>
<a name="ln5103">        }</a>
<a name="ln5104">        if (*end != ',')</a>
<a name="ln5105">          break;</a>
<a name="ln5106">        ++end;</a>
<a name="ln5107">      }</a>
<a name="ln5108">    }</a>
<a name="ln5109">  } while (idx &gt;= 0);</a>
<a name="ln5110"> </a>
<a name="ln5111">  if (!ends_excmd(*end) &amp;&amp; !ascii_iswhite(*end)) {</a>
<a name="ln5112">    EMSG2(_(&quot;E402: Garbage after pattern: %s&quot;), arg);</a>
<a name="ln5113">    return NULL;</a>
<a name="ln5114">  }</a>
<a name="ln5115">  return skipwhite(end);</a>
<a name="ln5116">}</a>
<a name="ln5117"> </a>
<a name="ln5118">/*</a>
<a name="ln5119"> * Handle &quot;:syntax sync ..&quot; command.</a>
<a name="ln5120"> */</a>
<a name="ln5121">static void syn_cmd_sync(exarg_T *eap, int syncing)</a>
<a name="ln5122">{</a>
<a name="ln5123">  char_u      *arg_start = eap-&gt;arg;</a>
<a name="ln5124">  char_u      *arg_end;</a>
<a name="ln5125">  char_u      *key = NULL;</a>
<a name="ln5126">  char_u      *next_arg;</a>
<a name="ln5127">  int illegal = FALSE;</a>
<a name="ln5128">  int finished = FALSE;</a>
<a name="ln5129">  long n;</a>
<a name="ln5130">  char_u      *cpo_save;</a>
<a name="ln5131"> </a>
<a name="ln5132">  if (ends_excmd(*arg_start)) {</a>
<a name="ln5133">    syn_cmd_list(eap, TRUE);</a>
<a name="ln5134">    return;</a>
<a name="ln5135">  }</a>
<a name="ln5136"> </a>
<a name="ln5137">  while (!ends_excmd(*arg_start)) {</a>
<a name="ln5138">    arg_end = skiptowhite(arg_start);</a>
<a name="ln5139">    next_arg = skipwhite(arg_end);</a>
<a name="ln5140">    xfree(key);</a>
<a name="ln5141">    key = vim_strnsave_up(arg_start, arg_end - arg_start);</a>
<a name="ln5142">    if (STRCMP(key, &quot;CCOMMENT&quot;) == 0) {</a>
<a name="ln5143">      if (!eap-&gt;skip)</a>
<a name="ln5144">        curwin-&gt;w_s-&gt;b_syn_sync_flags |= SF_CCOMMENT;</a>
<a name="ln5145">      if (!ends_excmd(*next_arg)) {</a>
<a name="ln5146">        arg_end = skiptowhite(next_arg);</a>
<a name="ln5147">        if (!eap-&gt;skip)</a>
<a name="ln5148">          curwin-&gt;w_s-&gt;b_syn_sync_id = syn_check_group(next_arg,</a>
<a name="ln5149">              (int)(arg_end - next_arg));</a>
<a name="ln5150">        next_arg = skipwhite(arg_end);</a>
<a name="ln5151">      } else if (!eap-&gt;skip)</a>
<a name="ln5152">        curwin-&gt;w_s-&gt;b_syn_sync_id = syn_name2id((char_u *)&quot;Comment&quot;);</a>
<a name="ln5153">    } else if (  STRNCMP(key, &quot;LINES&quot;, 5) == 0</a>
<a name="ln5154">                 || STRNCMP(key, &quot;MINLINES&quot;, 8) == 0</a>
<a name="ln5155">                 || STRNCMP(key, &quot;MAXLINES&quot;, 8) == 0</a>
<a name="ln5156">                 || STRNCMP(key, &quot;LINEBREAKS&quot;, 10) == 0) {</a>
<a name="ln5157">      if (key[4] == 'S')</a>
<a name="ln5158">        arg_end = key + 6;</a>
<a name="ln5159">      else if (key[0] == 'L')</a>
<a name="ln5160">        arg_end = key + 11;</a>
<a name="ln5161">      else</a>
<a name="ln5162">        arg_end = key + 9;</a>
<a name="ln5163">      if (arg_end[-1] != '=' || !ascii_isdigit(*arg_end)) {</a>
<a name="ln5164">        illegal = TRUE;</a>
<a name="ln5165">        break;</a>
<a name="ln5166">      }</a>
<a name="ln5167">      n = getdigits_long(&amp;arg_end, false, 0);</a>
<a name="ln5168">      if (!eap-&gt;skip) {</a>
<a name="ln5169">        if (key[4] == 'B')</a>
<a name="ln5170">          curwin-&gt;w_s-&gt;b_syn_sync_linebreaks = n;</a>
<a name="ln5171">        else if (key[1] == 'A')</a>
<a name="ln5172">          curwin-&gt;w_s-&gt;b_syn_sync_maxlines = n;</a>
<a name="ln5173">        else</a>
<a name="ln5174">          curwin-&gt;w_s-&gt;b_syn_sync_minlines = n;</a>
<a name="ln5175">      }</a>
<a name="ln5176">    } else if (STRCMP(key, &quot;FROMSTART&quot;) == 0)   {</a>
<a name="ln5177">      if (!eap-&gt;skip) {</a>
<a name="ln5178">        curwin-&gt;w_s-&gt;b_syn_sync_minlines = MAXLNUM;</a>
<a name="ln5179">        curwin-&gt;w_s-&gt;b_syn_sync_maxlines = 0;</a>
<a name="ln5180">      }</a>
<a name="ln5181">    } else if (STRCMP(key, &quot;LINECONT&quot;) == 0)   {</a>
<a name="ln5182">      if (*next_arg == NUL) {  // missing pattern</a>
<a name="ln5183">        illegal = true;</a>
<a name="ln5184">        break;</a>
<a name="ln5185">      }</a>
<a name="ln5186">      if (curwin-&gt;w_s-&gt;b_syn_linecont_pat != NULL) {</a>
<a name="ln5187">        EMSG(_(&quot;E403: syntax sync: line continuations pattern specified twice&quot;));</a>
<a name="ln5188">        finished = TRUE;</a>
<a name="ln5189">        break;</a>
<a name="ln5190">      }</a>
<a name="ln5191">      arg_end = skip_regexp(next_arg + 1, *next_arg, TRUE, NULL);</a>
<a name="ln5192">      if (*arg_end != *next_arg) {          /* end delimiter not found */</a>
<a name="ln5193">        illegal = TRUE;</a>
<a name="ln5194">        break;</a>
<a name="ln5195">      }</a>
<a name="ln5196"> </a>
<a name="ln5197">      if (!eap-&gt;skip) {</a>
<a name="ln5198">        /* store the pattern and compiled regexp program */</a>
<a name="ln5199">        curwin-&gt;w_s-&gt;b_syn_linecont_pat =</a>
<a name="ln5200">          vim_strnsave(next_arg + 1, arg_end - next_arg - 1);</a>
<a name="ln5201">        curwin-&gt;w_s-&gt;b_syn_linecont_ic = curwin-&gt;w_s-&gt;b_syn_ic;</a>
<a name="ln5202"> </a>
<a name="ln5203">        /* Make 'cpoptions' empty, to avoid the 'l' flag */</a>
<a name="ln5204">        cpo_save = p_cpo;</a>
<a name="ln5205">        p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln5206">        curwin-&gt;w_s-&gt;b_syn_linecont_prog =</a>
<a name="ln5207">          vim_regcomp(curwin-&gt;w_s-&gt;b_syn_linecont_pat, RE_MAGIC);</a>
<a name="ln5208">        p_cpo = cpo_save;</a>
<a name="ln5209">        syn_clear_time(&amp;curwin-&gt;w_s-&gt;b_syn_linecont_time);</a>
<a name="ln5210"> </a>
<a name="ln5211">        if (curwin-&gt;w_s-&gt;b_syn_linecont_prog == NULL) {</a>
<a name="ln5212">          XFREE_CLEAR(curwin-&gt;w_s-&gt;b_syn_linecont_pat);</a>
<a name="ln5213">          finished = true;</a>
<a name="ln5214">          break;</a>
<a name="ln5215">        }</a>
<a name="ln5216">      }</a>
<a name="ln5217">      next_arg = skipwhite(arg_end + 1);</a>
<a name="ln5218">    } else {</a>
<a name="ln5219">      eap-&gt;arg = next_arg;</a>
<a name="ln5220">      if (STRCMP(key, &quot;MATCH&quot;) == 0)</a>
<a name="ln5221">        syn_cmd_match(eap, TRUE);</a>
<a name="ln5222">      else if (STRCMP(key, &quot;REGION&quot;) == 0)</a>
<a name="ln5223">        syn_cmd_region(eap, TRUE);</a>
<a name="ln5224">      else if (STRCMP(key, &quot;CLEAR&quot;) == 0)</a>
<a name="ln5225">        syn_cmd_clear(eap, TRUE);</a>
<a name="ln5226">      else</a>
<a name="ln5227">        illegal = TRUE;</a>
<a name="ln5228">      finished = TRUE;</a>
<a name="ln5229">      break;</a>
<a name="ln5230">    }</a>
<a name="ln5231">    arg_start = next_arg;</a>
<a name="ln5232">  }</a>
<a name="ln5233">  xfree(key);</a>
<a name="ln5234">  if (illegal)</a>
<a name="ln5235">    EMSG2(_(&quot;E404: Illegal arguments: %s&quot;), arg_start);</a>
<a name="ln5236">  else if (!finished) {</a>
<a name="ln5237">    eap-&gt;nextcmd = check_nextcmd(arg_start);</a>
<a name="ln5238">    redraw_curbuf_later(SOME_VALID);</a>
<a name="ln5239">    syn_stack_free_all(curwin-&gt;w_s);            /* Need to recompute all syntax. */</a>
<a name="ln5240">  }</a>
<a name="ln5241">}</a>
<a name="ln5242"> </a>
<a name="ln5243">/*</a>
<a name="ln5244"> * Convert a line of highlight group names into a list of group ID numbers.</a>
<a name="ln5245"> * &quot;arg&quot; should point to the &quot;contains&quot; or &quot;nextgroup&quot; keyword.</a>
<a name="ln5246"> * &quot;arg&quot; is advanced to after the last group name.</a>
<a name="ln5247"> * Careful: the argument is modified (NULs added).</a>
<a name="ln5248"> * returns FAIL for some error, OK for success.</a>
<a name="ln5249"> */</a>
<a name="ln5250">static int</a>
<a name="ln5251">get_id_list(</a>
<a name="ln5252">    char_u **const arg,</a>
<a name="ln5253">    const int keylen,       // length of keyword</a>
<a name="ln5254">    int16_t **const list,   // where to store the resulting list, if not</a>
<a name="ln5255">                            // NULL, the list is silently skipped!</a>
<a name="ln5256">    const bool skip</a>
<a name="ln5257">)</a>
<a name="ln5258">{</a>
<a name="ln5259">  char_u      *p = NULL;</a>
<a name="ln5260">  char_u      *end;</a>
<a name="ln5261">  int total_count = 0;</a>
<a name="ln5262">  int16_t *retval = NULL;</a>
<a name="ln5263">  regmatch_T regmatch;</a>
<a name="ln5264">  int id;</a>
<a name="ln5265">  bool failed = false;</a>
<a name="ln5266"> </a>
<a name="ln5267">  // We parse the list twice:</a>
<a name="ln5268">  // round == 1: count the number of items, allocate the array.</a>
<a name="ln5269">  // round == 2: fill the array with the items.</a>
<a name="ln5270">  // In round 1 new groups may be added, causing the number of items to</a>
<a name="ln5271">  // grow when a regexp is used.  In that case round 1 is done once again.</a>
<a name="ln5272">  for (int round = 1; round &lt;= 2; round++) {</a>
<a name="ln5273">    // skip &quot;contains&quot;</a>
<a name="ln5274">    p = skipwhite(*arg + keylen);</a>
<a name="ln5275">    if (*p != '=') {</a>
<a name="ln5276">      EMSG2(_(&quot;E405: Missing equal sign: %s&quot;), *arg);</a>
<a name="ln5277">      break;</a>
<a name="ln5278">    }</a>
<a name="ln5279">    p = skipwhite(p + 1);</a>
<a name="ln5280">    if (ends_excmd(*p)) {</a>
<a name="ln5281">      EMSG2(_(&quot;E406: Empty argument: %s&quot;), *arg);</a>
<a name="ln5282">      break;</a>
<a name="ln5283">    }</a>
<a name="ln5284"> </a>
<a name="ln5285">    // parse the arguments after &quot;contains&quot;</a>
<a name="ln5286">    int count = 0;</a>
<a name="ln5287">    do {</a>
<a name="ln5288">      for (end = p; *end &amp;&amp; !ascii_iswhite(*end) &amp;&amp; *end != ','; end++) {</a>
<a name="ln5289">      }</a>
<a name="ln5290">      char_u *const name = xmalloc((int)(end - p + 3));   // leave room for &quot;^$&quot;</a>
<a name="ln5291">      STRLCPY(name + 1, p, end - p + 1);</a>
<a name="ln5292">      if (       STRCMP(name + 1, &quot;ALLBUT&quot;) == 0</a>
<a name="ln5293">                 || STRCMP(name + 1, &quot;ALL&quot;) == 0</a>
<a name="ln5294">                 || STRCMP(name + 1, &quot;TOP&quot;) == 0</a>
<a name="ln5295">                 || STRCMP(name + 1, &quot;CONTAINED&quot;) == 0) {</a>
<a name="ln5296">        if (TOUPPER_ASC(**arg) != 'C') {</a>
<a name="ln5297">          EMSG2(_(&quot;E407: %s not allowed here&quot;), name + 1);</a>
<a name="ln5298">          failed = true;</a>
<a name="ln5299">          xfree(name);</a>
<a name="ln5300">          break;</a>
<a name="ln5301">        }</a>
<a name="ln5302">        if (count != 0) {</a>
<a name="ln5303">          EMSG2(_(&quot;E408: %s must be first in contains list&quot;),</a>
<a name="ln5304">                name + 1);</a>
<a name="ln5305">          failed = true;</a>
<a name="ln5306">          xfree(name);</a>
<a name="ln5307">          break;</a>
<a name="ln5308">        }</a>
<a name="ln5309">        if (name[1] == 'A') {</a>
<a name="ln5310">          id = SYNID_ALLBUT + current_syn_inc_tag;</a>
<a name="ln5311">        } else if (name[1] == 'T') {</a>
<a name="ln5312">          if (curwin-&gt;w_s-&gt;b_syn_topgrp &gt;= SYNID_CLUSTER) {</a>
<a name="ln5313">            id = curwin-&gt;w_s-&gt;b_syn_topgrp;</a>
<a name="ln5314">          } else {</a>
<a name="ln5315">            id = SYNID_TOP + current_syn_inc_tag;</a>
<a name="ln5316">          }</a>
<a name="ln5317">        } else {</a>
<a name="ln5318">          id = SYNID_CONTAINED + current_syn_inc_tag;</a>
<a name="ln5319">        }</a>
<a name="ln5320">      } else if (name[1] == '@')   {</a>
<a name="ln5321">        if (skip) {</a>
<a name="ln5322">          id = -1;</a>
<a name="ln5323">        } else {</a>
<a name="ln5324">          id = syn_check_cluster(name + 2, (int)(end - p - 1));</a>
<a name="ln5325">        }</a>
<a name="ln5326">      } else {</a>
<a name="ln5327">        /*</a>
<a name="ln5328">         * Handle full group name.</a>
<a name="ln5329">         */</a>
<a name="ln5330">        if (vim_strpbrk(name + 1, (char_u *)&quot;\\.*^$~[&quot;) == NULL) {</a>
<a name="ln5331">          id = syn_check_group(name + 1, (int)(end - p));</a>
<a name="ln5332">        } else {</a>
<a name="ln5333">          // Handle match of regexp with group names.</a>
<a name="ln5334">          *name = '^';</a>
<a name="ln5335">          STRCAT(name, &quot;$&quot;);</a>
<a name="ln5336">          regmatch.regprog = vim_regcomp(name, RE_MAGIC);</a>
<a name="ln5337">          if (regmatch.regprog == NULL) {</a>
<a name="ln5338">            failed = true;</a>
<a name="ln5339">            xfree(name);</a>
<a name="ln5340">            break;</a>
<a name="ln5341">          }</a>
<a name="ln5342"> </a>
<a name="ln5343">          regmatch.rm_ic = TRUE;</a>
<a name="ln5344">          id = 0;</a>
<a name="ln5345">          for (int i = highlight_ga.ga_len; --i &gt;= 0; ) {</a>
<a name="ln5346">            if (vim_regexec(&amp;regmatch, HL_TABLE()[i].sg_name, (colnr_T)0)) {</a>
<a name="ln5347">              if (round == 2) {</a>
<a name="ln5348">                // Got more items than expected; can happen</a>
<a name="ln5349">                // when adding items that match:</a>
<a name="ln5350">                // &quot;contains=a.*b,axb&quot;.</a>
<a name="ln5351">                // Go back to first round.</a>
<a name="ln5352">                if (count &gt;= total_count) {</a>
<a name="ln5353">                  xfree(retval);</a>
<a name="ln5354">                  round = 1;</a>
<a name="ln5355">                } else {</a>
<a name="ln5356">                  retval[count] = i + 1;  // -V522</a>
<a name="ln5357">                }</a>
<a name="ln5358">              }</a>
<a name="ln5359">              count++;</a>
<a name="ln5360">              id = -1;  // Remember that we found one.</a>
<a name="ln5361">            }</a>
<a name="ln5362">          }</a>
<a name="ln5363">          vim_regfree(regmatch.regprog);</a>
<a name="ln5364">        }</a>
<a name="ln5365">      }</a>
<a name="ln5366">      xfree(name);</a>
<a name="ln5367">      if (id == 0) {</a>
<a name="ln5368">        EMSG2(_(&quot;E409: Unknown group name: %s&quot;), p);</a>
<a name="ln5369">        failed = true;</a>
<a name="ln5370">        break;</a>
<a name="ln5371">      }</a>
<a name="ln5372">      if (id &gt; 0) {</a>
<a name="ln5373">        if (round == 2) {</a>
<a name="ln5374">          // Got more items than expected, go back to first round.</a>
<a name="ln5375">          if (count &gt;= total_count) {</a>
<a name="ln5376">            xfree(retval);</a>
<a name="ln5377">            round = 1;</a>
<a name="ln5378">          } else {</a>
<a name="ln5379">            retval[count] = id;</a>
<a name="ln5380">          }</a>
<a name="ln5381">        }</a>
<a name="ln5382">        ++count;</a>
<a name="ln5383">      }</a>
<a name="ln5384">      p = skipwhite(end);</a>
<a name="ln5385">      if (*p != ',')</a>
<a name="ln5386">        break;</a>
<a name="ln5387">      p = skipwhite(p + 1);             /* skip comma in between arguments */</a>
<a name="ln5388">    } while (!ends_excmd(*p));</a>
<a name="ln5389">    if (failed)</a>
<a name="ln5390">      break;</a>
<a name="ln5391">    if (round == 1) {</a>
<a name="ln5392">      retval = xmalloc((count + 1) * sizeof(*retval));</a>
<a name="ln5393">      retval[count] = 0;            // zero means end of the list</a>
<a name="ln5394">      total_count = count;</a>
<a name="ln5395">    }</a>
<a name="ln5396">  }</a>
<a name="ln5397"> </a>
<a name="ln5398">  *arg = p;</a>
<a name="ln5399">  if (failed || retval == NULL) {</a>
<a name="ln5400">    xfree(retval);</a>
<a name="ln5401">    return FAIL;</a>
<a name="ln5402">  }</a>
<a name="ln5403"> </a>
<a name="ln5404">  if (*list == NULL)</a>
<a name="ln5405">    *list = retval;</a>
<a name="ln5406">  else</a>
<a name="ln5407">    xfree(retval);           /* list already found, don't overwrite it */</a>
<a name="ln5408"> </a>
<a name="ln5409">  return OK;</a>
<a name="ln5410">}</a>
<a name="ln5411"> </a>
<a name="ln5412">/*</a>
<a name="ln5413"> * Make a copy of an ID list.</a>
<a name="ln5414"> */</a>
<a name="ln5415">static int16_t *copy_id_list(const int16_t *const list)</a>
<a name="ln5416">{</a>
<a name="ln5417">  if (list == NULL) {</a>
<a name="ln5418">    return NULL;</a>
<a name="ln5419">  }</a>
<a name="ln5420"> </a>
<a name="ln5421">  int count;</a>
<a name="ln5422">  for (count = 0; list[count]; count++) {</a>
<a name="ln5423">  }</a>
<a name="ln5424">  const size_t len = (count + 1) * sizeof(int16_t);</a>
<a name="ln5425">  int16_t *const retval = xmalloc(len);</a>
<a name="ln5426">  memmove(retval, list, len);</a>
<a name="ln5427"> </a>
<a name="ln5428">  return retval;</a>
<a name="ln5429">}</a>
<a name="ln5430"> </a>
<a name="ln5431">/*</a>
<a name="ln5432"> * Check if syntax group &quot;ssp&quot; is in the ID list &quot;list&quot; of &quot;cur_si&quot;.</a>
<a name="ln5433"> * &quot;cur_si&quot; can be NULL if not checking the &quot;containedin&quot; list.</a>
<a name="ln5434"> * Used to check if a syntax item is in the &quot;contains&quot; or &quot;nextgroup&quot; list of</a>
<a name="ln5435"> * the current item.</a>
<a name="ln5436"> * This function is called very often, keep it fast!!</a>
<a name="ln5437"> */</a>
<a name="ln5438">static int</a>
<a name="ln5439">in_id_list(</a>
<a name="ln5440">    stateitem_T *cur_si,    // current item or NULL</a>
<a name="ln5441">    int16_t *list,          // id list</a>
<a name="ln5442">    struct sp_syn *ssp,     // group id and &quot;:syn include&quot; tag of group</a>
<a name="ln5443">    int contained           // group id is contained</a>
<a name="ln5444">)</a>
<a name="ln5445">{</a>
<a name="ln5446">  int retval;</a>
<a name="ln5447">  int16_t *scl_list;</a>
<a name="ln5448">  int16_t item;</a>
<a name="ln5449">  int16_t id = ssp-&gt;id;</a>
<a name="ln5450">  static int depth = 0;</a>
<a name="ln5451">  int r;</a>
<a name="ln5452"> </a>
<a name="ln5453">  /* If ssp has a &quot;containedin&quot; list and &quot;cur_si&quot; is in it, return TRUE. */</a>
<a name="ln5454">  if (cur_si != NULL &amp;&amp; ssp-&gt;cont_in_list != NULL</a>
<a name="ln5455">      &amp;&amp; !(cur_si-&gt;si_flags &amp; HL_MATCH)) {</a>
<a name="ln5456">    /* Ignore transparent items without a contains argument.  Double check</a>
<a name="ln5457">     * that we don't go back past the first one. */</a>
<a name="ln5458">    while ((cur_si-&gt;si_flags &amp; HL_TRANS_CONT)</a>
<a name="ln5459">           &amp;&amp; cur_si &gt; (stateitem_T *)(current_state.ga_data))</a>
<a name="ln5460">      --cur_si;</a>
<a name="ln5461">    /* cur_si-&gt;si_idx is -1 for keywords, these never contain anything. */</a>
<a name="ln5462">    if (cur_si-&gt;si_idx &gt;= 0 &amp;&amp; in_id_list(NULL, ssp-&gt;cont_in_list,</a>
<a name="ln5463">            &amp;(SYN_ITEMS(syn_block)[cur_si-&gt;si_idx].sp_syn),</a>
<a name="ln5464">            SYN_ITEMS(syn_block)[cur_si-&gt;si_idx].sp_flags &amp; HL_CONTAINED))</a>
<a name="ln5465">      return TRUE;</a>
<a name="ln5466">  }</a>
<a name="ln5467"> </a>
<a name="ln5468">  if (list == NULL)</a>
<a name="ln5469">    return FALSE;</a>
<a name="ln5470"> </a>
<a name="ln5471">  /*</a>
<a name="ln5472">   * If list is ID_LIST_ALL, we are in a transparent item that isn't</a>
<a name="ln5473">   * inside anything.  Only allow not-contained groups.</a>
<a name="ln5474">   */</a>
<a name="ln5475">  if (list == ID_LIST_ALL)</a>
<a name="ln5476">    return !contained;</a>
<a name="ln5477"> </a>
<a name="ln5478">  /*</a>
<a name="ln5479">   * If the first item is &quot;ALLBUT&quot;, return TRUE if &quot;id&quot; is NOT in the</a>
<a name="ln5480">   * contains list.  We also require that &quot;id&quot; is at the same &quot;:syn include&quot;</a>
<a name="ln5481">   * level as the list.</a>
<a name="ln5482">   */</a>
<a name="ln5483">  item = *list;</a>
<a name="ln5484">  if (item &gt;= SYNID_ALLBUT &amp;&amp; item &lt; SYNID_CLUSTER) {</a>
<a name="ln5485">    if (item &lt; SYNID_TOP) {</a>
<a name="ln5486">      /* ALL or ALLBUT: accept all groups in the same file */</a>
<a name="ln5487">      if (item - SYNID_ALLBUT != ssp-&gt;inc_tag)</a>
<a name="ln5488">        return FALSE;</a>
<a name="ln5489">    } else if (item &lt; SYNID_CONTAINED)   {</a>
<a name="ln5490">      /* TOP: accept all not-contained groups in the same file */</a>
<a name="ln5491">      if (item - SYNID_TOP != ssp-&gt;inc_tag || contained)</a>
<a name="ln5492">        return FALSE;</a>
<a name="ln5493">    } else {</a>
<a name="ln5494">      /* CONTAINED: accept all contained groups in the same file */</a>
<a name="ln5495">      if (item - SYNID_CONTAINED != ssp-&gt;inc_tag || !contained)</a>
<a name="ln5496">        return FALSE;</a>
<a name="ln5497">    }</a>
<a name="ln5498">    item = *++list;</a>
<a name="ln5499">    retval = FALSE;</a>
<a name="ln5500">  } else</a>
<a name="ln5501">    retval = TRUE;</a>
<a name="ln5502"> </a>
<a name="ln5503">  /*</a>
<a name="ln5504">   * Return &quot;retval&quot; if id is in the contains list.</a>
<a name="ln5505">   */</a>
<a name="ln5506">  while (item != 0) {</a>
<a name="ln5507">    if (item == id)</a>
<a name="ln5508">      return retval;</a>
<a name="ln5509">    if (item &gt;= SYNID_CLUSTER) {</a>
<a name="ln5510">      scl_list = SYN_CLSTR(syn_block)[item - SYNID_CLUSTER].scl_list;</a>
<a name="ln5511">      /* restrict recursiveness to 30 to avoid an endless loop for a</a>
<a name="ln5512">       * cluster that includes itself (indirectly) */</a>
<a name="ln5513">      if (scl_list != NULL &amp;&amp; depth &lt; 30) {</a>
<a name="ln5514">        ++depth;</a>
<a name="ln5515">        r = in_id_list(NULL, scl_list, ssp, contained);</a>
<a name="ln5516">        --depth;</a>
<a name="ln5517">        if (r)</a>
<a name="ln5518">          return retval;</a>
<a name="ln5519">      }</a>
<a name="ln5520">    }</a>
<a name="ln5521">    item = *++list;</a>
<a name="ln5522">  }</a>
<a name="ln5523">  return !retval;</a>
<a name="ln5524">}</a>
<a name="ln5525"> </a>
<a name="ln5526">struct subcommand {</a>
<a name="ln5527">  char    *name;                                /* subcommand name */</a>
<a name="ln5528">  void    (*func)(exarg_T *, int);              /* function to call */</a>
<a name="ln5529">};</a>
<a name="ln5530"> </a>
<a name="ln5531">static struct subcommand subcommands[] =</a>
<a name="ln5532">{</a>
<a name="ln5533">  { &quot;case&quot;,      syn_cmd_case },</a>
<a name="ln5534">  { &quot;clear&quot;,     syn_cmd_clear },</a>
<a name="ln5535">  { &quot;cluster&quot;,   syn_cmd_cluster },</a>
<a name="ln5536">  { &quot;conceal&quot;,   syn_cmd_conceal },</a>
<a name="ln5537">  { &quot;enable&quot;,    syn_cmd_enable },</a>
<a name="ln5538">  { &quot;foldlevel&quot;, syn_cmd_foldlevel },</a>
<a name="ln5539">  { &quot;include&quot;,   syn_cmd_include },</a>
<a name="ln5540">  { &quot;iskeyword&quot;, syn_cmd_iskeyword },</a>
<a name="ln5541">  { &quot;keyword&quot;,   syn_cmd_keyword },</a>
<a name="ln5542">  { &quot;list&quot;,      syn_cmd_list },</a>
<a name="ln5543">  { &quot;manual&quot;,    syn_cmd_manual },</a>
<a name="ln5544">  { &quot;match&quot;,     syn_cmd_match },</a>
<a name="ln5545">  { &quot;on&quot;,        syn_cmd_on },</a>
<a name="ln5546">  { &quot;off&quot;,       syn_cmd_off },</a>
<a name="ln5547">  { &quot;region&quot;,    syn_cmd_region },</a>
<a name="ln5548">  { &quot;reset&quot;,     syn_cmd_reset },</a>
<a name="ln5549">  { &quot;spell&quot;,     syn_cmd_spell },</a>
<a name="ln5550">  { &quot;sync&quot;,      syn_cmd_sync },</a>
<a name="ln5551">  { &quot;&quot;,          syn_cmd_list },</a>
<a name="ln5552">  { NULL, NULL }</a>
<a name="ln5553">};</a>
<a name="ln5554"> </a>
<a name="ln5555">/*</a>
<a name="ln5556"> * &quot;:syntax&quot;.</a>
<a name="ln5557"> * This searches the subcommands[] table for the subcommand name, and calls a</a>
<a name="ln5558"> * syntax_subcommand() function to do the rest.</a>
<a name="ln5559"> */</a>
<a name="ln5560">void ex_syntax(exarg_T *eap)</a>
<a name="ln5561">{</a>
<a name="ln5562">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln5563">  char_u      *subcmd_end;</a>
<a name="ln5564"> </a>
<a name="ln5565">  syn_cmdlinep = eap-&gt;cmdlinep;</a>
<a name="ln5566"> </a>
<a name="ln5567">  // isolate subcommand name</a>
<a name="ln5568">  for (subcmd_end = arg; ASCII_ISALPHA(*subcmd_end); subcmd_end++) {</a>
<a name="ln5569">  }</a>
<a name="ln5570">  char_u *const subcmd_name = vim_strnsave(arg, subcmd_end - arg);</a>
<a name="ln5571">  if (eap-&gt;skip) {  // skip error messages for all subcommands</a>
<a name="ln5572">    emsg_skip++;</a>
<a name="ln5573">  }</a>
<a name="ln5574">  for (int i = 0;; i++) {</a>
<a name="ln5575">    if (subcommands[i].name == NULL) {</a>
<a name="ln5576">      EMSG2(_(&quot;E410: Invalid :syntax subcommand: %s&quot;), subcmd_name);</a>
<a name="ln5577">      break;</a>
<a name="ln5578">    }</a>
<a name="ln5579">    if (STRCMP(subcmd_name, (char_u *)subcommands[i].name) == 0) {</a>
<a name="ln5580">      eap-&gt;arg = skipwhite(subcmd_end);</a>
<a name="ln5581">      (subcommands[i].func)(eap, FALSE);</a>
<a name="ln5582">      break;</a>
<a name="ln5583">    }</a>
<a name="ln5584">  }</a>
<a name="ln5585">  xfree(subcmd_name);</a>
<a name="ln5586">  if (eap-&gt;skip)</a>
<a name="ln5587">    --emsg_skip;</a>
<a name="ln5588">}</a>
<a name="ln5589"> </a>
<a name="ln5590">void ex_ownsyntax(exarg_T *eap)</a>
<a name="ln5591">{</a>
<a name="ln5592">  char_u      *old_value;</a>
<a name="ln5593">  char_u      *new_value;</a>
<a name="ln5594"> </a>
<a name="ln5595">  if (curwin-&gt;w_s == &amp;curwin-&gt;w_buffer-&gt;b_s) {</a>
<a name="ln5596">    curwin-&gt;w_s = xmalloc(sizeof(synblock_T));</a>
<a name="ln5597">    memset(curwin-&gt;w_s, 0, sizeof(synblock_T));</a>
<a name="ln5598">    hash_init(&amp;curwin-&gt;w_s-&gt;b_keywtab);</a>
<a name="ln5599">    hash_init(&amp;curwin-&gt;w_s-&gt;b_keywtab_ic);</a>
<a name="ln5600">    // TODO: Keep the spell checking as it was. NOLINT(readability/todo)</a>
<a name="ln5601">    curwin-&gt;w_p_spell = false;  // No spell checking</a>
<a name="ln5602">    // make sure option values are &quot;empty_option&quot; instead of NULL</a>
<a name="ln5603">    clear_string_option(&amp;curwin-&gt;w_s-&gt;b_p_spc);</a>
<a name="ln5604">    clear_string_option(&amp;curwin-&gt;w_s-&gt;b_p_spf);</a>
<a name="ln5605">    clear_string_option(&amp;curwin-&gt;w_s-&gt;b_p_spl);</a>
<a name="ln5606">    clear_string_option(&amp;curwin-&gt;w_s-&gt;b_p_spo);</a>
<a name="ln5607">    clear_string_option(&amp;curwin-&gt;w_s-&gt;b_syn_isk);</a>
<a name="ln5608">  }</a>
<a name="ln5609"> </a>
<a name="ln5610">  // Save value of b:current_syntax.</a>
<a name="ln5611">  old_value = get_var_value(&quot;b:current_syntax&quot;);</a>
<a name="ln5612">  if (old_value != NULL) {</a>
<a name="ln5613">    old_value = vim_strsave(old_value);</a>
<a name="ln5614">  }</a>
<a name="ln5615"> </a>
<a name="ln5616">  /* Apply the &quot;syntax&quot; autocommand event, this finds and loads the syntax</a>
<a name="ln5617">   * file. */</a>
<a name="ln5618">  apply_autocmds(EVENT_SYNTAX, eap-&gt;arg, curbuf-&gt;b_fname, TRUE, curbuf);</a>
<a name="ln5619"> </a>
<a name="ln5620">  // Move value of b:current_syntax to w:current_syntax.</a>
<a name="ln5621">  new_value = get_var_value(&quot;b:current_syntax&quot;);</a>
<a name="ln5622">  if (new_value != NULL) {</a>
<a name="ln5623">    set_internal_string_var(&quot;w:current_syntax&quot;, new_value);</a>
<a name="ln5624">  }</a>
<a name="ln5625"> </a>
<a name="ln5626">  // Restore value of b:current_syntax.</a>
<a name="ln5627">  if (old_value == NULL) {</a>
<a name="ln5628">    do_unlet(S_LEN(&quot;b:current_syntax&quot;), true);</a>
<a name="ln5629">  } else {</a>
<a name="ln5630">    set_internal_string_var(&quot;b:current_syntax&quot;, old_value);</a>
<a name="ln5631">    xfree(old_value);</a>
<a name="ln5632">  }</a>
<a name="ln5633">}</a>
<a name="ln5634"> </a>
<a name="ln5635">bool syntax_present(win_T *win)</a>
<a name="ln5636">{</a>
<a name="ln5637">  return win-&gt;w_s-&gt;b_syn_patterns.ga_len != 0</a>
<a name="ln5638">         || win-&gt;w_s-&gt;b_syn_clusters.ga_len != 0</a>
<a name="ln5639">         || win-&gt;w_s-&gt;b_keywtab.ht_used &gt; 0</a>
<a name="ln5640">         || win-&gt;w_s-&gt;b_keywtab_ic.ht_used &gt; 0;</a>
<a name="ln5641">}</a>
<a name="ln5642"> </a>
<a name="ln5643"> </a>
<a name="ln5644">static enum {</a>
<a name="ln5645">  EXP_SUBCMD,       // expand &quot;:syn&quot; sub-commands</a>
<a name="ln5646">  EXP_CASE,         // expand &quot;:syn case&quot; arguments</a>
<a name="ln5647">  EXP_SPELL,        // expand &quot;:syn spell&quot; arguments</a>
<a name="ln5648">  EXP_SYNC          // expand &quot;:syn sync&quot; arguments</a>
<a name="ln5649">} expand_what;</a>
<a name="ln5650"> </a>
<a name="ln5651">/*</a>
<a name="ln5652"> * Reset include_link, include_default, include_none to 0.</a>
<a name="ln5653"> * Called when we are done expanding.</a>
<a name="ln5654"> */</a>
<a name="ln5655">void reset_expand_highlight(void)</a>
<a name="ln5656">{</a>
<a name="ln5657">  include_link = include_default = include_none = 0;</a>
<a name="ln5658">}</a>
<a name="ln5659"> </a>
<a name="ln5660">/*</a>
<a name="ln5661"> * Handle command line completion for :match and :echohl command: Add &quot;None&quot;</a>
<a name="ln5662"> * as highlight group.</a>
<a name="ln5663"> */</a>
<a name="ln5664">void set_context_in_echohl_cmd(expand_T *xp, const char *arg)</a>
<a name="ln5665">{</a>
<a name="ln5666">  xp-&gt;xp_context = EXPAND_HIGHLIGHT;</a>
<a name="ln5667">  xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln5668">  include_none = 1;</a>
<a name="ln5669">}</a>
<a name="ln5670"> </a>
<a name="ln5671">/*</a>
<a name="ln5672"> * Handle command line completion for :syntax command.</a>
<a name="ln5673"> */</a>
<a name="ln5674">void set_context_in_syntax_cmd(expand_T *xp, const char *arg)</a>
<a name="ln5675">{</a>
<a name="ln5676">  // Default: expand subcommands.</a>
<a name="ln5677">  xp-&gt;xp_context = EXPAND_SYNTAX;</a>
<a name="ln5678">  expand_what = EXP_SUBCMD;</a>
<a name="ln5679">  xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln5680">  include_link = 0;</a>
<a name="ln5681">  include_default = 0;</a>
<a name="ln5682"> </a>
<a name="ln5683">  /* (part of) subcommand already typed */</a>
<a name="ln5684">  if (*arg != NUL) {</a>
<a name="ln5685">    const char *p = (const char *)skiptowhite((const char_u *)arg);</a>
<a name="ln5686">    if (*p != NUL) {  // Past first word.</a>
<a name="ln5687">      xp-&gt;xp_pattern = skipwhite((const char_u *)p);</a>
<a name="ln5688">      if (*skiptowhite(xp-&gt;xp_pattern) != NUL) {</a>
<a name="ln5689">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln5690">      } else if (STRNICMP(arg, &quot;case&quot;, p - arg) == 0) {</a>
<a name="ln5691">        expand_what = EXP_CASE;</a>
<a name="ln5692">      } else if (STRNICMP(arg, &quot;spell&quot;, p - arg) == 0) {</a>
<a name="ln5693">        expand_what = EXP_SPELL;</a>
<a name="ln5694">      } else if (STRNICMP(arg, &quot;sync&quot;, p - arg) == 0) {</a>
<a name="ln5695">        expand_what = EXP_SYNC;</a>
<a name="ln5696">      } else if (STRNICMP(arg, &quot;keyword&quot;, p - arg) == 0</a>
<a name="ln5697">                 || STRNICMP(arg, &quot;region&quot;, p - arg) == 0</a>
<a name="ln5698">                 || STRNICMP(arg, &quot;match&quot;, p - arg) == 0</a>
<a name="ln5699">                 || STRNICMP(arg, &quot;list&quot;, p - arg) == 0) {</a>
<a name="ln5700">        xp-&gt;xp_context = EXPAND_HIGHLIGHT;</a>
<a name="ln5701">      } else {</a>
<a name="ln5702">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln5703">      }</a>
<a name="ln5704">    }</a>
<a name="ln5705">  }</a>
<a name="ln5706">}</a>
<a name="ln5707"> </a>
<a name="ln5708">/*</a>
<a name="ln5709"> * Function given to ExpandGeneric() to obtain the list syntax names for</a>
<a name="ln5710"> * expansion.</a>
<a name="ln5711"> */</a>
<a name="ln5712">char_u *get_syntax_name(expand_T *xp, int idx)</a>
<a name="ln5713">{</a>
<a name="ln5714">  switch (expand_what) {</a>
<a name="ln5715">    case EXP_SUBCMD:</a>
<a name="ln5716">        return (char_u *)subcommands[idx].name;</a>
<a name="ln5717">    case EXP_CASE: {</a>
<a name="ln5718">        static char *case_args[] = { &quot;match&quot;, &quot;ignore&quot;, NULL };</a>
<a name="ln5719">        return (char_u *)case_args[idx];</a>
<a name="ln5720">    }</a>
<a name="ln5721">    case EXP_SPELL: {</a>
<a name="ln5722">        static char *spell_args[] =</a>
<a name="ln5723">        { &quot;toplevel&quot;, &quot;notoplevel&quot;, &quot;default&quot;, NULL };</a>
<a name="ln5724">        return (char_u *)spell_args[idx];</a>
<a name="ln5725">    }</a>
<a name="ln5726">    case EXP_SYNC: {</a>
<a name="ln5727">        static char *sync_args[] =</a>
<a name="ln5728">        { &quot;ccomment&quot;, &quot;clear&quot;, &quot;fromstart&quot;,</a>
<a name="ln5729">         &quot;linebreaks=&quot;, &quot;linecont&quot;, &quot;lines=&quot;, &quot;match&quot;,</a>
<a name="ln5730">         &quot;maxlines=&quot;, &quot;minlines=&quot;, &quot;region&quot;, NULL };</a>
<a name="ln5731">        return (char_u *)sync_args[idx];</a>
<a name="ln5732">    }</a>
<a name="ln5733">  }</a>
<a name="ln5734">  return NULL;</a>
<a name="ln5735">}</a>
<a name="ln5736"> </a>
<a name="ln5737"> </a>
<a name="ln5738">// Function called for expression evaluation: get syntax ID at file position.</a>
<a name="ln5739">int syn_get_id(</a>
<a name="ln5740">    win_T *wp,</a>
<a name="ln5741">    long lnum,</a>
<a name="ln5742">    colnr_T col,</a>
<a name="ln5743">    int trans,      // remove transparency</a>
<a name="ln5744">    bool *spellp,   // return: can do spell checking</a>
<a name="ln5745">    int keep_state  // keep state of char at &quot;col&quot;</a>
<a name="ln5746">)</a>
<a name="ln5747">{</a>
<a name="ln5748">  // When the position is not after the current position and in the same</a>
<a name="ln5749">  // line of the same buffer, need to restart parsing.</a>
<a name="ln5750">  if (wp-&gt;w_buffer != syn_buf || lnum != current_lnum || col &lt; current_col) {</a>
<a name="ln5751">    syntax_start(wp, lnum);</a>
<a name="ln5752">  } else if (col &gt; current_col) {</a>
<a name="ln5753">      // next_match may not be correct when moving around, e.g. with the</a>
<a name="ln5754">      // &quot;skip&quot; expression in searchpair()</a>
<a name="ln5755">      next_match_idx = -1;</a>
<a name="ln5756">  }</a>
<a name="ln5757"> </a>
<a name="ln5758">  (void)get_syntax_attr(col, spellp, keep_state);</a>
<a name="ln5759"> </a>
<a name="ln5760">  return trans ? current_trans_id : current_id;</a>
<a name="ln5761">}</a>
<a name="ln5762"> </a>
<a name="ln5763">/*</a>
<a name="ln5764"> * Get extra information about the syntax item.  Must be called right after</a>
<a name="ln5765"> * get_syntax_attr().</a>
<a name="ln5766"> * Stores the current item sequence nr in &quot;*seqnrp&quot;.</a>
<a name="ln5767"> * Returns the current flags.</a>
<a name="ln5768"> */</a>
<a name="ln5769">int get_syntax_info(int *seqnrp)</a>
<a name="ln5770">{</a>
<a name="ln5771">  *seqnrp = current_seqnr;</a>
<a name="ln5772">  return current_flags;</a>
<a name="ln5773">}</a>
<a name="ln5774"> </a>
<a name="ln5775"> </a>
<a name="ln5776">/// Get the sequence number of the concealed file position.</a>
<a name="ln5777">///</a>
<a name="ln5778">/// @return seqnr if the file position is concealed, 0 otherwise.</a>
<a name="ln5779">int syn_get_concealed_id(win_T *wp, linenr_T lnum, colnr_T col)</a>
<a name="ln5780">{</a>
<a name="ln5781">  int seqnr;</a>
<a name="ln5782">  int syntax_flags;</a>
<a name="ln5783"> </a>
<a name="ln5784">  (void)syn_get_id(wp, lnum, col, false, NULL, false);</a>
<a name="ln5785">  syntax_flags = get_syntax_info(&amp;seqnr);</a>
<a name="ln5786"> </a>
<a name="ln5787">  if (syntax_flags &amp; HL_CONCEAL) {</a>
<a name="ln5788">    return seqnr;</a>
<a name="ln5789">  }</a>
<a name="ln5790">  return 0;</a>
<a name="ln5791">}</a>
<a name="ln5792"> </a>
<a name="ln5793">/*</a>
<a name="ln5794"> * Return conceal substitution character</a>
<a name="ln5795"> */</a>
<a name="ln5796">int syn_get_sub_char(void)</a>
<a name="ln5797">{</a>
<a name="ln5798">  return current_sub_char;</a>
<a name="ln5799">}</a>
<a name="ln5800"> </a>
<a name="ln5801">/*</a>
<a name="ln5802"> * Return the syntax ID at position &quot;i&quot; in the current stack.</a>
<a name="ln5803"> * The caller must have called syn_get_id() before to fill the stack.</a>
<a name="ln5804"> * Returns -1 when &quot;i&quot; is out of range.</a>
<a name="ln5805"> */</a>
<a name="ln5806">int syn_get_stack_item(int i)</a>
<a name="ln5807">{</a>
<a name="ln5808">  if (i &gt;= current_state.ga_len) {</a>
<a name="ln5809">    /* Need to invalidate the state, because we didn't properly finish it</a>
<a name="ln5810">     * for the last character, &quot;keep_state&quot; was TRUE. */</a>
<a name="ln5811">    invalidate_current_state();</a>
<a name="ln5812">    current_col = MAXCOL;</a>
<a name="ln5813">    return -1;</a>
<a name="ln5814">  }</a>
<a name="ln5815">  return CUR_STATE(i).si_id;</a>
<a name="ln5816">}</a>
<a name="ln5817"> </a>
<a name="ln5818">static int syn_cur_foldlevel(void)</a>
<a name="ln5819">{</a>
<a name="ln5820">  int level = 0;</a>
<a name="ln5821">  for (int i = 0; i &lt; current_state.ga_len; i++) {</a>
<a name="ln5822">    if (CUR_STATE(i).si_flags &amp; HL_FOLD) {</a>
<a name="ln5823">      level++;</a>
<a name="ln5824">    }</a>
<a name="ln5825">  }</a>
<a name="ln5826">  return level;</a>
<a name="ln5827">}</a>
<a name="ln5828"> </a>
<a name="ln5829">/*</a>
<a name="ln5830"> * Function called to get folding level for line &quot;lnum&quot; in window &quot;wp&quot;.</a>
<a name="ln5831"> */</a>
<a name="ln5832">int syn_get_foldlevel(win_T *wp, long lnum)</a>
<a name="ln5833">{</a>
<a name="ln5834">  int level = 0;</a>
<a name="ln5835"> </a>
<a name="ln5836">  // Return quickly when there are no fold items at all.</a>
<a name="ln5837">  if (wp-&gt;w_s-&gt;b_syn_folditems != 0</a>
<a name="ln5838">      &amp;&amp; !wp-&gt;w_s-&gt;b_syn_error</a>
<a name="ln5839">      &amp;&amp; !wp-&gt;w_s-&gt;b_syn_slow) {</a>
<a name="ln5840">    syntax_start(wp, lnum);</a>
<a name="ln5841"> </a>
<a name="ln5842">    // Start with the fold level at the start of the line.</a>
<a name="ln5843">    level = syn_cur_foldlevel();</a>
<a name="ln5844"> </a>
<a name="ln5845">    if (wp-&gt;w_s-&gt;b_syn_foldlevel == SYNFLD_MINIMUM) {</a>
<a name="ln5846">      // Find the lowest fold level that is followed by a higher one.</a>
<a name="ln5847">      int cur_level = level;</a>
<a name="ln5848">      int low_level = cur_level;</a>
<a name="ln5849">      while (!current_finished) {</a>
<a name="ln5850">        (void)syn_current_attr(false, false, NULL, false);</a>
<a name="ln5851">        cur_level = syn_cur_foldlevel();</a>
<a name="ln5852">        if (cur_level &lt; low_level) {</a>
<a name="ln5853">          low_level = cur_level;</a>
<a name="ln5854">        } else if (cur_level &gt; low_level) {</a>
<a name="ln5855">          level = low_level;</a>
<a name="ln5856">        }</a>
<a name="ln5857">        current_col++;</a>
<a name="ln5858">      }</a>
<a name="ln5859">    }</a>
<a name="ln5860">  }</a>
<a name="ln5861">  if (level &gt; wp-&gt;w_p_fdn) {</a>
<a name="ln5862">    level = wp-&gt;w_p_fdn;</a>
<a name="ln5863">    if (level &lt; 0)</a>
<a name="ln5864">      level = 0;</a>
<a name="ln5865">  }</a>
<a name="ln5866">  return level;</a>
<a name="ln5867">}</a>
<a name="ln5868"> </a>
<a name="ln5869">/*</a>
<a name="ln5870"> * &quot;:syntime&quot;.</a>
<a name="ln5871"> */</a>
<a name="ln5872">void ex_syntime(exarg_T *eap)</a>
<a name="ln5873">{</a>
<a name="ln5874">  if (STRCMP(eap-&gt;arg, &quot;on&quot;) == 0)</a>
<a name="ln5875">    syn_time_on = TRUE;</a>
<a name="ln5876">  else if (STRCMP(eap-&gt;arg, &quot;off&quot;) == 0)</a>
<a name="ln5877">    syn_time_on = FALSE;</a>
<a name="ln5878">  else if (STRCMP(eap-&gt;arg, &quot;clear&quot;) == 0)</a>
<a name="ln5879">    syntime_clear();</a>
<a name="ln5880">  else if (STRCMP(eap-&gt;arg, &quot;report&quot;) == 0)</a>
<a name="ln5881">    syntime_report();</a>
<a name="ln5882">  else</a>
<a name="ln5883">    EMSG2(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln5884">}</a>
<a name="ln5885"> </a>
<a name="ln5886">static void syn_clear_time(syn_time_T *st)</a>
<a name="ln5887">{</a>
<a name="ln5888">  st-&gt;total = profile_zero();</a>
<a name="ln5889">  st-&gt;slowest = profile_zero();</a>
<a name="ln5890">  st-&gt;count = 0;</a>
<a name="ln5891">  st-&gt;match = 0;</a>
<a name="ln5892">}</a>
<a name="ln5893"> </a>
<a name="ln5894">/*</a>
<a name="ln5895"> * Clear the syntax timing for the current buffer.</a>
<a name="ln5896"> */</a>
<a name="ln5897">static void syntime_clear(void)</a>
<a name="ln5898">{</a>
<a name="ln5899">  synpat_T    *spp;</a>
<a name="ln5900"> </a>
<a name="ln5901">  if (!syntax_present(curwin)) {</a>
<a name="ln5902">    MSG(_(msg_no_items));</a>
<a name="ln5903">    return;</a>
<a name="ln5904">  }</a>
<a name="ln5905">  for (int idx = 0; idx &lt; curwin-&gt;w_s-&gt;b_syn_patterns.ga_len; ++idx) {</a>
<a name="ln5906">    spp = &amp;(SYN_ITEMS(curwin-&gt;w_s)[idx]);</a>
<a name="ln5907">    syn_clear_time(&amp;spp-&gt;sp_time);</a>
<a name="ln5908">  }</a>
<a name="ln5909">}</a>
<a name="ln5910"> </a>
<a name="ln5911">/*</a>
<a name="ln5912"> * Function given to ExpandGeneric() to obtain the possible arguments of the</a>
<a name="ln5913"> * &quot;:syntime {on,off,clear,report}&quot; command.</a>
<a name="ln5914"> */</a>
<a name="ln5915">char_u *get_syntime_arg(expand_T *xp, int idx)</a>
<a name="ln5916">{</a>
<a name="ln5917">  switch (idx) {</a>
<a name="ln5918">  case 0: return (char_u *)&quot;on&quot;;</a>
<a name="ln5919">  case 1: return (char_u *)&quot;off&quot;;</a>
<a name="ln5920">  case 2: return (char_u *)&quot;clear&quot;;</a>
<a name="ln5921">  case 3: return (char_u *)&quot;report&quot;;</a>
<a name="ln5922">  }</a>
<a name="ln5923">  return NULL;</a>
<a name="ln5924">}</a>
<a name="ln5925"> </a>
<a name="ln5926">static int syn_compare_syntime(const void *v1, const void *v2)</a>
<a name="ln5927">{</a>
<a name="ln5928">  const time_entry_T  *s1 = v1;</a>
<a name="ln5929">  const time_entry_T  *s2 = v2;</a>
<a name="ln5930"> </a>
<a name="ln5931">  return profile_cmp(s1-&gt;total, s2-&gt;total);</a>
<a name="ln5932">}</a>
<a name="ln5933"> </a>
<a name="ln5934">/*</a>
<a name="ln5935"> * Clear the syntax timing for the current buffer.</a>
<a name="ln5936"> */</a>
<a name="ln5937">static void syntime_report(void)</a>
<a name="ln5938">{</a>
<a name="ln5939">  if (!syntax_present(curwin)) {</a>
<a name="ln5940">    MSG(_(msg_no_items));</a>
<a name="ln5941">    return;</a>
<a name="ln5942">  }</a>
<a name="ln5943"> </a>
<a name="ln5944">  garray_T ga;</a>
<a name="ln5945">  ga_init(&amp;ga, sizeof(time_entry_T), 50);</a>
<a name="ln5946"> </a>
<a name="ln5947">  proftime_T total_total = profile_zero();</a>
<a name="ln5948">  int total_count = 0;</a>
<a name="ln5949">  time_entry_T *p;</a>
<a name="ln5950">  for (int idx = 0; idx &lt; curwin-&gt;w_s-&gt;b_syn_patterns.ga_len; ++idx) {</a>
<a name="ln5951">    synpat_T *spp = &amp;(SYN_ITEMS(curwin-&gt;w_s)[idx]);</a>
<a name="ln5952">    if (spp-&gt;sp_time.count &gt; 0) {</a>
<a name="ln5953">      p = GA_APPEND_VIA_PTR(time_entry_T, &amp;ga);</a>
<a name="ln5954">      p-&gt;total = spp-&gt;sp_time.total;</a>
<a name="ln5955">      total_total = profile_add(total_total, spp-&gt;sp_time.total);</a>
<a name="ln5956">      p-&gt;count = spp-&gt;sp_time.count;</a>
<a name="ln5957">      p-&gt;match = spp-&gt;sp_time.match;</a>
<a name="ln5958">      total_count += spp-&gt;sp_time.count;</a>
<a name="ln5959">      p-&gt;slowest = spp-&gt;sp_time.slowest;</a>
<a name="ln5960">      proftime_T tm = profile_divide(spp-&gt;sp_time.total, spp-&gt;sp_time.count);</a>
<a name="ln5961">      p-&gt;average = tm;</a>
<a name="ln5962">      p-&gt;id = spp-&gt;sp_syn.id;</a>
<a name="ln5963">      p-&gt;pattern = spp-&gt;sp_pattern;</a>
<a name="ln5964">    }</a>
<a name="ln5965">  }</a>
<a name="ln5966"> </a>
<a name="ln5967">  // Sort on total time. Skip if there are no items to avoid passing NULL</a>
<a name="ln5968">  // pointer to qsort().</a>
<a name="ln5969">  if (ga.ga_len &gt; 1) {</a>
<a name="ln5970">    qsort(ga.ga_data, (size_t)ga.ga_len, sizeof(time_entry_T),</a>
<a name="ln5971">          syn_compare_syntime);</a>
<a name="ln5972">  }</a>
<a name="ln5973"> </a>
<a name="ln5974">  MSG_PUTS_TITLE(_(</a>
<a name="ln5975">          &quot;  TOTAL      COUNT  MATCH   SLOWEST     AVERAGE   NAME               PATTERN&quot;));</a>
<a name="ln5976">  MSG_PUTS(&quot;\n&quot;);</a>
<a name="ln5977">  for (int idx = 0; idx &lt; ga.ga_len &amp;&amp; !got_int; ++idx) {</a>
<a name="ln5978">    p = ((time_entry_T *)ga.ga_data) + idx;</a>
<a name="ln5979"> </a>
<a name="ln5980">    MSG_PUTS(profile_msg(p-&gt;total));</a>
<a name="ln5981">    MSG_PUTS(&quot; &quot;);     /* make sure there is always a separating space */</a>
<a name="ln5982">    msg_advance(13);</a>
<a name="ln5983">    msg_outnum(p-&gt;count);</a>
<a name="ln5984">    MSG_PUTS(&quot; &quot;);</a>
<a name="ln5985">    msg_advance(20);</a>
<a name="ln5986">    msg_outnum(p-&gt;match);</a>
<a name="ln5987">    MSG_PUTS(&quot; &quot;);</a>
<a name="ln5988">    msg_advance(26);</a>
<a name="ln5989">    MSG_PUTS(profile_msg(p-&gt;slowest));</a>
<a name="ln5990">    MSG_PUTS(&quot; &quot;);</a>
<a name="ln5991">    msg_advance(38);</a>
<a name="ln5992">    MSG_PUTS(profile_msg(p-&gt;average));</a>
<a name="ln5993">    MSG_PUTS(&quot; &quot;);</a>
<a name="ln5994">    msg_advance(50);</a>
<a name="ln5995">    msg_outtrans(HL_TABLE()[p-&gt;id - 1].sg_name);</a>
<a name="ln5996">    MSG_PUTS(&quot; &quot;);</a>
<a name="ln5997"> </a>
<a name="ln5998">    msg_advance(69);</a>
<a name="ln5999">    int len;</a>
<a name="ln6000">    if (Columns &lt; 80)</a>
<a name="ln6001">      len = 20;       /* will wrap anyway */</a>
<a name="ln6002">    else</a>
<a name="ln6003">      len = Columns - 70;</a>
<a name="ln6004">    if (len &gt; (int)STRLEN(p-&gt;pattern))</a>
<a name="ln6005">      len = (int)STRLEN(p-&gt;pattern);</a>
<a name="ln6006">    msg_outtrans_len(p-&gt;pattern, len);</a>
<a name="ln6007">    MSG_PUTS(&quot;\n&quot;);</a>
<a name="ln6008">  }</a>
<a name="ln6009">  ga_clear(&amp;ga);</a>
<a name="ln6010">  if (!got_int) {</a>
<a name="ln6011">    MSG_PUTS(&quot;\n&quot;);</a>
<a name="ln6012">    MSG_PUTS(profile_msg(total_total));</a>
<a name="ln6013">    msg_advance(13);</a>
<a name="ln6014">    msg_outnum(total_count);</a>
<a name="ln6015">    MSG_PUTS(&quot;\n&quot;);</a>
<a name="ln6016">  }</a>
<a name="ln6017">}</a>
<a name="ln6018"> </a>
<a name="ln6019">/**************************************</a>
<a name="ln6020">*  Highlighting stuff		      *</a>
<a name="ln6021">**************************************/</a>
<a name="ln6022"> </a>
<a name="ln6023">// The default highlight groups.  These are compiled-in for fast startup and</a>
<a name="ln6024">// they still work when the runtime files can't be found.</a>
<a name="ln6025">//</a>
<a name="ln6026">// When making changes here, also change runtime/colors/default.vim!</a>
<a name="ln6027"> </a>
<a name="ln6028">static const char *highlight_init_both[] = {</a>
<a name="ln6029">  &quot;Conceal &quot;</a>
<a name="ln6030">      &quot;ctermbg=DarkGrey ctermfg=LightGrey guibg=DarkGrey guifg=LightGrey&quot;,</a>
<a name="ln6031">  &quot;Cursor       guibg=fg guifg=bg&quot;,</a>
<a name="ln6032">  &quot;lCursor      guibg=fg guifg=bg&quot;,</a>
<a name="ln6033">  &quot;DiffText     cterm=bold ctermbg=Red gui=bold guibg=Red&quot;,</a>
<a name="ln6034">  &quot;ErrorMsg     ctermbg=DarkRed ctermfg=White guibg=Red guifg=White&quot;,</a>
<a name="ln6035">  &quot;IncSearch    cterm=reverse gui=reverse&quot;,</a>
<a name="ln6036">  &quot;ModeMsg      cterm=bold gui=bold&quot;,</a>
<a name="ln6037">  &quot;NonText      ctermfg=Blue gui=bold guifg=Blue&quot;,</a>
<a name="ln6038">  &quot;Normal       cterm=NONE gui=NONE&quot;,</a>
<a name="ln6039">  &quot;PmenuSbar    ctermbg=Grey guibg=Grey&quot;,</a>
<a name="ln6040">  &quot;StatusLine   cterm=reverse,bold gui=reverse,bold&quot;,</a>
<a name="ln6041">  &quot;StatusLineNC cterm=reverse gui=reverse&quot;,</a>
<a name="ln6042">  &quot;TabLineFill  cterm=reverse gui=reverse&quot;,</a>
<a name="ln6043">  &quot;TabLineSel   cterm=bold gui=bold&quot;,</a>
<a name="ln6044">  &quot;TermCursor   cterm=reverse gui=reverse&quot;,</a>
<a name="ln6045">  &quot;VertSplit    cterm=reverse gui=reverse&quot;,</a>
<a name="ln6046">  &quot;WildMenu     ctermbg=Yellow ctermfg=Black guibg=Yellow guifg=Black&quot;,</a>
<a name="ln6047">  &quot;default link EndOfBuffer NonText&quot;,</a>
<a name="ln6048">  &quot;default link QuickFixLine Search&quot;,</a>
<a name="ln6049">  &quot;default link Substitute Search&quot;,</a>
<a name="ln6050">  &quot;default link Whitespace NonText&quot;,</a>
<a name="ln6051">  &quot;default link MsgSeparator StatusLine&quot;,</a>
<a name="ln6052">  &quot;default link NormalFloat Pmenu&quot;,</a>
<a name="ln6053">  &quot;default link FloatBorder VertSplit&quot;,</a>
<a name="ln6054">  &quot;default FloatShadow blend=80 guibg=Black&quot;,</a>
<a name="ln6055">  &quot;default FloatShadowThrough blend=100 guibg=Black&quot;,</a>
<a name="ln6056">  &quot;RedrawDebugNormal cterm=reverse gui=reverse&quot;,</a>
<a name="ln6057">  &quot;RedrawDebugClear ctermbg=Yellow guibg=Yellow&quot;,</a>
<a name="ln6058">  &quot;RedrawDebugComposed ctermbg=Green guibg=Green&quot;,</a>
<a name="ln6059">  &quot;RedrawDebugRecompose ctermbg=Red guibg=Red&quot;,</a>
<a name="ln6060">  NULL</a>
<a name="ln6061">};</a>
<a name="ln6062"> </a>
<a name="ln6063">// Default colors only used with a light background.</a>
<a name="ln6064">static const char *highlight_init_light[] = {</a>
<a name="ln6065">  &quot;ColorColumn  ctermbg=LightRed guibg=LightRed&quot;,</a>
<a name="ln6066">  &quot;CursorColumn ctermbg=LightGrey guibg=Grey90&quot;,</a>
<a name="ln6067">  &quot;CursorLine   cterm=underline guibg=Grey90&quot;,</a>
<a name="ln6068">  &quot;CursorLineNr ctermfg=Brown gui=bold guifg=Brown&quot;,</a>
<a name="ln6069">  &quot;DiffAdd      ctermbg=LightBlue guibg=LightBlue&quot;,</a>
<a name="ln6070">  &quot;DiffChange   ctermbg=LightMagenta guibg=LightMagenta&quot;,</a>
<a name="ln6071">  &quot;DiffDelete   ctermfg=Blue ctermbg=LightCyan gui=bold guifg=Blue guibg=LightCyan&quot;,</a>
<a name="ln6072">  &quot;Directory    ctermfg=DarkBlue guifg=Blue&quot;,</a>
<a name="ln6073">  &quot;FoldColumn   ctermbg=Grey ctermfg=DarkBlue guibg=Grey guifg=DarkBlue&quot;,</a>
<a name="ln6074">  &quot;Folded       ctermbg=Grey ctermfg=DarkBlue guibg=LightGrey guifg=DarkBlue&quot;,</a>
<a name="ln6075">  &quot;LineNr       ctermfg=Brown guifg=Brown&quot;,</a>
<a name="ln6076">  &quot;MatchParen   ctermbg=Cyan guibg=Cyan&quot;,</a>
<a name="ln6077">  &quot;MoreMsg      ctermfg=DarkGreen gui=bold guifg=SeaGreen&quot;,</a>
<a name="ln6078">  &quot;Pmenu        ctermbg=LightMagenta ctermfg=Black guibg=LightMagenta&quot;,</a>
<a name="ln6079">  &quot;PmenuSel     ctermbg=LightGrey ctermfg=Black guibg=Grey&quot;,</a>
<a name="ln6080">  &quot;PmenuThumb   ctermbg=Black guibg=Black&quot;,</a>
<a name="ln6081">  &quot;Question     ctermfg=DarkGreen gui=bold guifg=SeaGreen&quot;,</a>
<a name="ln6082">  &quot;Search       ctermbg=Yellow ctermfg=NONE guibg=Yellow guifg=NONE&quot;,</a>
<a name="ln6083">  &quot;SignColumn   ctermbg=Grey ctermfg=DarkBlue guibg=Grey guifg=DarkBlue&quot;,</a>
<a name="ln6084">  &quot;SpecialKey   ctermfg=DarkBlue guifg=Blue&quot;,</a>
<a name="ln6085">  &quot;SpellBad     ctermbg=LightRed guisp=Red gui=undercurl&quot;,</a>
<a name="ln6086">  &quot;SpellCap     ctermbg=LightBlue guisp=Blue gui=undercurl&quot;,</a>
<a name="ln6087">  &quot;SpellLocal   ctermbg=Cyan guisp=DarkCyan gui=undercurl&quot;,</a>
<a name="ln6088">  &quot;SpellRare    ctermbg=LightMagenta guisp=Magenta gui=undercurl&quot;,</a>
<a name="ln6089">  &quot;TabLine      cterm=underline ctermfg=black ctermbg=LightGrey gui=underline guibg=LightGrey&quot;,</a>
<a name="ln6090">  &quot;Title        ctermfg=DarkMagenta gui=bold guifg=Magenta&quot;,</a>
<a name="ln6091">  &quot;Visual       guibg=LightGrey&quot;,</a>
<a name="ln6092">  &quot;WarningMsg   ctermfg=DarkRed guifg=Red&quot;,</a>
<a name="ln6093">  NULL</a>
<a name="ln6094">};</a>
<a name="ln6095"> </a>
<a name="ln6096">// Default colors only used with a dark background.</a>
<a name="ln6097">static const char *highlight_init_dark[] = {</a>
<a name="ln6098">  &quot;ColorColumn  ctermbg=DarkRed guibg=DarkRed&quot;,</a>
<a name="ln6099">  &quot;CursorColumn ctermbg=DarkGrey guibg=Grey40&quot;,</a>
<a name="ln6100">  &quot;CursorLine   cterm=underline guibg=Grey40&quot;,</a>
<a name="ln6101">  &quot;CursorLineNr ctermfg=Yellow gui=bold guifg=Yellow&quot;,</a>
<a name="ln6102">  &quot;DiffAdd      ctermbg=DarkBlue guibg=DarkBlue&quot;,</a>
<a name="ln6103">  &quot;DiffChange   ctermbg=DarkMagenta guibg=DarkMagenta&quot;,</a>
<a name="ln6104">  &quot;DiffDelete   ctermfg=Blue ctermbg=DarkCyan gui=bold guifg=Blue guibg=DarkCyan&quot;,</a>
<a name="ln6105">  &quot;Directory    ctermfg=LightCyan guifg=Cyan&quot;,</a>
<a name="ln6106">  &quot;FoldColumn   ctermbg=DarkGrey ctermfg=Cyan guibg=Grey guifg=Cyan&quot;,</a>
<a name="ln6107">  &quot;Folded       ctermbg=DarkGrey ctermfg=Cyan guibg=DarkGrey guifg=Cyan&quot;,</a>
<a name="ln6108">  &quot;LineNr       ctermfg=Yellow guifg=Yellow&quot;,</a>
<a name="ln6109">  &quot;MatchParen   ctermbg=DarkCyan guibg=DarkCyan&quot;,</a>
<a name="ln6110">  &quot;MoreMsg      ctermfg=LightGreen gui=bold guifg=SeaGreen&quot;,</a>
<a name="ln6111">  &quot;Pmenu        ctermbg=Magenta ctermfg=Black guibg=Magenta&quot;,</a>
<a name="ln6112">  &quot;PmenuSel     ctermbg=Black ctermfg=DarkGrey guibg=DarkGrey&quot;,</a>
<a name="ln6113">  &quot;PmenuThumb   ctermbg=White guibg=White&quot;,</a>
<a name="ln6114">  &quot;Question     ctermfg=LightGreen gui=bold guifg=Green&quot;,</a>
<a name="ln6115">  &quot;Search       ctermbg=Yellow ctermfg=Black guibg=Yellow guifg=Black&quot;,</a>
<a name="ln6116">  &quot;SignColumn   ctermbg=DarkGrey ctermfg=Cyan guibg=Grey guifg=Cyan&quot;,</a>
<a name="ln6117">  &quot;SpecialKey   ctermfg=LightBlue guifg=Cyan&quot;,</a>
<a name="ln6118">  &quot;SpellBad     ctermbg=Red guisp=Red gui=undercurl&quot;,</a>
<a name="ln6119">  &quot;SpellCap     ctermbg=Blue guisp=Blue gui=undercurl&quot;,</a>
<a name="ln6120">  &quot;SpellLocal   ctermbg=Cyan guisp=Cyan gui=undercurl&quot;,</a>
<a name="ln6121">  &quot;SpellRare    ctermbg=Magenta guisp=Magenta gui=undercurl&quot;,</a>
<a name="ln6122">  &quot;TabLine      cterm=underline ctermfg=white ctermbg=DarkGrey gui=underline guibg=DarkGrey&quot;,</a>
<a name="ln6123">  &quot;Title        ctermfg=LightMagenta gui=bold guifg=Magenta&quot;,</a>
<a name="ln6124">  &quot;Visual       guibg=DarkGrey&quot;,</a>
<a name="ln6125">  &quot;WarningMsg   ctermfg=LightRed guifg=Red&quot;,</a>
<a name="ln6126">  NULL</a>
<a name="ln6127">};</a>
<a name="ln6128"> </a>
<a name="ln6129">const char *const highlight_init_cmdline[] = {</a>
<a name="ln6130">  // XXX When modifying a list modify it in both valid and invalid halfs.</a>
<a name="ln6131">  // TODO(ZyX-I): merge valid and invalid groups via a macros.</a>
<a name="ln6132"> </a>
<a name="ln6133">  // NvimInternalError should appear only when highlighter has a bug.</a>
<a name="ln6134">  &quot;NvimInternalError ctermfg=Red ctermbg=Red guifg=Red guibg=Red&quot;,</a>
<a name="ln6135"> </a>
<a name="ln6136">  // Highlight groups (links) used by parser:</a>
<a name="ln6137"> </a>
<a name="ln6138">  &quot;default link NvimAssignment Operator&quot;,</a>
<a name="ln6139">  &quot;default link NvimPlainAssignment NvimAssignment&quot;,</a>
<a name="ln6140">  &quot;default link NvimAugmentedAssignment NvimAssignment&quot;,</a>
<a name="ln6141">  &quot;default link NvimAssignmentWithAddition NvimAugmentedAssignment&quot;,</a>
<a name="ln6142">  &quot;default link NvimAssignmentWithSubtraction NvimAugmentedAssignment&quot;,</a>
<a name="ln6143">  &quot;default link NvimAssignmentWithConcatenation NvimAugmentedAssignment&quot;,</a>
<a name="ln6144"> </a>
<a name="ln6145">  &quot;default link NvimOperator Operator&quot;,</a>
<a name="ln6146"> </a>
<a name="ln6147">  &quot;default link NvimUnaryOperator NvimOperator&quot;,</a>
<a name="ln6148">  &quot;default link NvimUnaryPlus NvimUnaryOperator&quot;,</a>
<a name="ln6149">  &quot;default link NvimUnaryMinus NvimUnaryOperator&quot;,</a>
<a name="ln6150">  &quot;default link NvimNot NvimUnaryOperator&quot;,</a>
<a name="ln6151"> </a>
<a name="ln6152">  &quot;default link NvimBinaryOperator NvimOperator&quot;,</a>
<a name="ln6153">  &quot;default link NvimComparison NvimBinaryOperator&quot;,</a>
<a name="ln6154">  &quot;default link NvimComparisonModifier NvimComparison&quot;,</a>
<a name="ln6155">  &quot;default link NvimBinaryPlus NvimBinaryOperator&quot;,</a>
<a name="ln6156">  &quot;default link NvimBinaryMinus NvimBinaryOperator&quot;,</a>
<a name="ln6157">  &quot;default link NvimConcat NvimBinaryOperator&quot;,</a>
<a name="ln6158">  &quot;default link NvimConcatOrSubscript NvimConcat&quot;,</a>
<a name="ln6159">  &quot;default link NvimOr NvimBinaryOperator&quot;,</a>
<a name="ln6160">  &quot;default link NvimAnd NvimBinaryOperator&quot;,</a>
<a name="ln6161">  &quot;default link NvimMultiplication NvimBinaryOperator&quot;,</a>
<a name="ln6162">  &quot;default link NvimDivision NvimBinaryOperator&quot;,</a>
<a name="ln6163">  &quot;default link NvimMod NvimBinaryOperator&quot;,</a>
<a name="ln6164"> </a>
<a name="ln6165">  &quot;default link NvimTernary NvimOperator&quot;,</a>
<a name="ln6166">  &quot;default link NvimTernaryColon NvimTernary&quot;,</a>
<a name="ln6167"> </a>
<a name="ln6168">  &quot;default link NvimParenthesis Delimiter&quot;,</a>
<a name="ln6169">  &quot;default link NvimLambda NvimParenthesis&quot;,</a>
<a name="ln6170">  &quot;default link NvimNestingParenthesis NvimParenthesis&quot;,</a>
<a name="ln6171">  &quot;default link NvimCallingParenthesis NvimParenthesis&quot;,</a>
<a name="ln6172"> </a>
<a name="ln6173">  &quot;default link NvimSubscript NvimParenthesis&quot;,</a>
<a name="ln6174">  &quot;default link NvimSubscriptBracket NvimSubscript&quot;,</a>
<a name="ln6175">  &quot;default link NvimSubscriptColon NvimSubscript&quot;,</a>
<a name="ln6176">  &quot;default link NvimCurly NvimSubscript&quot;,</a>
<a name="ln6177"> </a>
<a name="ln6178">  &quot;default link NvimContainer NvimParenthesis&quot;,</a>
<a name="ln6179">  &quot;default link NvimDict NvimContainer&quot;,</a>
<a name="ln6180">  &quot;default link NvimList NvimContainer&quot;,</a>
<a name="ln6181"> </a>
<a name="ln6182">  &quot;default link NvimIdentifier Identifier&quot;,</a>
<a name="ln6183">  &quot;default link NvimIdentifierScope NvimIdentifier&quot;,</a>
<a name="ln6184">  &quot;default link NvimIdentifierScopeDelimiter NvimIdentifier&quot;,</a>
<a name="ln6185">  &quot;default link NvimIdentifierName NvimIdentifier&quot;,</a>
<a name="ln6186">  &quot;default link NvimIdentifierKey NvimIdentifier&quot;,</a>
<a name="ln6187"> </a>
<a name="ln6188">  &quot;default link NvimColon Delimiter&quot;,</a>
<a name="ln6189">  &quot;default link NvimComma Delimiter&quot;,</a>
<a name="ln6190">  &quot;default link NvimArrow Delimiter&quot;,</a>
<a name="ln6191"> </a>
<a name="ln6192">  &quot;default link NvimRegister SpecialChar&quot;,</a>
<a name="ln6193">  &quot;default link NvimNumber Number&quot;,</a>
<a name="ln6194">  &quot;default link NvimFloat NvimNumber&quot;,</a>
<a name="ln6195">  &quot;default link NvimNumberPrefix Type&quot;,</a>
<a name="ln6196"> </a>
<a name="ln6197">  &quot;default link NvimOptionSigil Type&quot;,</a>
<a name="ln6198">  &quot;default link NvimOptionName NvimIdentifier&quot;,</a>
<a name="ln6199">  &quot;default link NvimOptionScope NvimIdentifierScope&quot;,</a>
<a name="ln6200">  &quot;default link NvimOptionScopeDelimiter NvimIdentifierScopeDelimiter&quot;,</a>
<a name="ln6201"> </a>
<a name="ln6202">  &quot;default link NvimEnvironmentSigil NvimOptionSigil&quot;,</a>
<a name="ln6203">  &quot;default link NvimEnvironmentName NvimIdentifier&quot;,</a>
<a name="ln6204"> </a>
<a name="ln6205">  &quot;default link NvimString String&quot;,</a>
<a name="ln6206">  &quot;default link NvimStringBody NvimString&quot;,</a>
<a name="ln6207">  &quot;default link NvimStringQuote NvimString&quot;,</a>
<a name="ln6208">  &quot;default link NvimStringSpecial SpecialChar&quot;,</a>
<a name="ln6209"> </a>
<a name="ln6210">  &quot;default link NvimSingleQuote NvimStringQuote&quot;,</a>
<a name="ln6211">  &quot;default link NvimSingleQuotedBody NvimStringBody&quot;,</a>
<a name="ln6212">  &quot;default link NvimSingleQuotedQuote NvimStringSpecial&quot;,</a>
<a name="ln6213"> </a>
<a name="ln6214">  &quot;default link NvimDoubleQuote NvimStringQuote&quot;,</a>
<a name="ln6215">  &quot;default link NvimDoubleQuotedBody NvimStringBody&quot;,</a>
<a name="ln6216">  &quot;default link NvimDoubleQuotedEscape NvimStringSpecial&quot;,</a>
<a name="ln6217"> </a>
<a name="ln6218">  &quot;default link NvimFigureBrace NvimInternalError&quot;,</a>
<a name="ln6219">  &quot;default link NvimSingleQuotedUnknownEscape NvimInternalError&quot;,</a>
<a name="ln6220"> </a>
<a name="ln6221">  &quot;default link NvimSpacing Normal&quot;,</a>
<a name="ln6222"> </a>
<a name="ln6223">  // NvimInvalid groups:</a>
<a name="ln6224"> </a>
<a name="ln6225">  &quot;default link NvimInvalidSingleQuotedUnknownEscape NvimInternalError&quot;,</a>
<a name="ln6226"> </a>
<a name="ln6227">  &quot;default link NvimInvalid Error&quot;,</a>
<a name="ln6228"> </a>
<a name="ln6229">  &quot;default link NvimInvalidAssignment NvimInvalid&quot;,</a>
<a name="ln6230">  &quot;default link NvimInvalidPlainAssignment NvimInvalidAssignment&quot;,</a>
<a name="ln6231">  &quot;default link NvimInvalidAugmentedAssignment NvimInvalidAssignment&quot;,</a>
<a name="ln6232">  &quot;default link NvimInvalidAssignmentWithAddition &quot;</a>
<a name="ln6233">      &quot;NvimInvalidAugmentedAssignment&quot;,</a>
<a name="ln6234">  &quot;default link NvimInvalidAssignmentWithSubtraction &quot;</a>
<a name="ln6235">      &quot;NvimInvalidAugmentedAssignment&quot;,</a>
<a name="ln6236">  &quot;default link NvimInvalidAssignmentWithConcatenation &quot;</a>
<a name="ln6237">      &quot;NvimInvalidAugmentedAssignment&quot;,</a>
<a name="ln6238"> </a>
<a name="ln6239">  &quot;default link NvimInvalidOperator NvimInvalid&quot;,</a>
<a name="ln6240"> </a>
<a name="ln6241">  &quot;default link NvimInvalidUnaryOperator NvimInvalidOperator&quot;,</a>
<a name="ln6242">  &quot;default link NvimInvalidUnaryPlus NvimInvalidUnaryOperator&quot;,</a>
<a name="ln6243">  &quot;default link NvimInvalidUnaryMinus NvimInvalidUnaryOperator&quot;,</a>
<a name="ln6244">  &quot;default link NvimInvalidNot NvimInvalidUnaryOperator&quot;,</a>
<a name="ln6245"> </a>
<a name="ln6246">  &quot;default link NvimInvalidBinaryOperator NvimInvalidOperator&quot;,</a>
<a name="ln6247">  &quot;default link NvimInvalidComparison NvimInvalidBinaryOperator&quot;,</a>
<a name="ln6248">  &quot;default link NvimInvalidComparisonModifier NvimInvalidComparison&quot;,</a>
<a name="ln6249">  &quot;default link NvimInvalidBinaryPlus NvimInvalidBinaryOperator&quot;,</a>
<a name="ln6250">  &quot;default link NvimInvalidBinaryMinus NvimInvalidBinaryOperator&quot;,</a>
<a name="ln6251">  &quot;default link NvimInvalidConcat NvimInvalidBinaryOperator&quot;,</a>
<a name="ln6252">  &quot;default link NvimInvalidConcatOrSubscript NvimInvalidConcat&quot;,</a>
<a name="ln6253">  &quot;default link NvimInvalidOr NvimInvalidBinaryOperator&quot;,</a>
<a name="ln6254">  &quot;default link NvimInvalidAnd NvimInvalidBinaryOperator&quot;,</a>
<a name="ln6255">  &quot;default link NvimInvalidMultiplication NvimInvalidBinaryOperator&quot;,</a>
<a name="ln6256">  &quot;default link NvimInvalidDivision NvimInvalidBinaryOperator&quot;,</a>
<a name="ln6257">  &quot;default link NvimInvalidMod NvimInvalidBinaryOperator&quot;,</a>
<a name="ln6258"> </a>
<a name="ln6259">  &quot;default link NvimInvalidTernary NvimInvalidOperator&quot;,</a>
<a name="ln6260">  &quot;default link NvimInvalidTernaryColon NvimInvalidTernary&quot;,</a>
<a name="ln6261"> </a>
<a name="ln6262">  &quot;default link NvimInvalidDelimiter NvimInvalid&quot;,</a>
<a name="ln6263"> </a>
<a name="ln6264">  &quot;default link NvimInvalidParenthesis NvimInvalidDelimiter&quot;,</a>
<a name="ln6265">  &quot;default link NvimInvalidLambda NvimInvalidParenthesis&quot;,</a>
<a name="ln6266">  &quot;default link NvimInvalidNestingParenthesis NvimInvalidParenthesis&quot;,</a>
<a name="ln6267">  &quot;default link NvimInvalidCallingParenthesis NvimInvalidParenthesis&quot;,</a>
<a name="ln6268"> </a>
<a name="ln6269">  &quot;default link NvimInvalidSubscript NvimInvalidParenthesis&quot;,</a>
<a name="ln6270">  &quot;default link NvimInvalidSubscriptBracket NvimInvalidSubscript&quot;,</a>
<a name="ln6271">  &quot;default link NvimInvalidSubscriptColon NvimInvalidSubscript&quot;,</a>
<a name="ln6272">  &quot;default link NvimInvalidCurly NvimInvalidSubscript&quot;,</a>
<a name="ln6273"> </a>
<a name="ln6274">  &quot;default link NvimInvalidContainer NvimInvalidParenthesis&quot;,</a>
<a name="ln6275">  &quot;default link NvimInvalidDict NvimInvalidContainer&quot;,</a>
<a name="ln6276">  &quot;default link NvimInvalidList NvimInvalidContainer&quot;,</a>
<a name="ln6277"> </a>
<a name="ln6278">  &quot;default link NvimInvalidValue NvimInvalid&quot;,</a>
<a name="ln6279"> </a>
<a name="ln6280">  &quot;default link NvimInvalidIdentifier NvimInvalidValue&quot;,</a>
<a name="ln6281">  &quot;default link NvimInvalidIdentifierScope NvimInvalidIdentifier&quot;,</a>
<a name="ln6282">  &quot;default link NvimInvalidIdentifierScopeDelimiter NvimInvalidIdentifier&quot;,</a>
<a name="ln6283">  &quot;default link NvimInvalidIdentifierName NvimInvalidIdentifier&quot;,</a>
<a name="ln6284">  &quot;default link NvimInvalidIdentifierKey NvimInvalidIdentifier&quot;,</a>
<a name="ln6285"> </a>
<a name="ln6286">  &quot;default link NvimInvalidColon NvimInvalidDelimiter&quot;,</a>
<a name="ln6287">  &quot;default link NvimInvalidComma NvimInvalidDelimiter&quot;,</a>
<a name="ln6288">  &quot;default link NvimInvalidArrow NvimInvalidDelimiter&quot;,</a>
<a name="ln6289"> </a>
<a name="ln6290">  &quot;default link NvimInvalidRegister NvimInvalidValue&quot;,</a>
<a name="ln6291">  &quot;default link NvimInvalidNumber NvimInvalidValue&quot;,</a>
<a name="ln6292">  &quot;default link NvimInvalidFloat NvimInvalidNumber&quot;,</a>
<a name="ln6293">  &quot;default link NvimInvalidNumberPrefix NvimInvalidNumber&quot;,</a>
<a name="ln6294"> </a>
<a name="ln6295">  &quot;default link NvimInvalidOptionSigil NvimInvalidIdentifier&quot;,</a>
<a name="ln6296">  &quot;default link NvimInvalidOptionName NvimInvalidIdentifier&quot;,</a>
<a name="ln6297">  &quot;default link NvimInvalidOptionScope NvimInvalidIdentifierScope&quot;,</a>
<a name="ln6298">  &quot;default link NvimInvalidOptionScopeDelimiter &quot;</a>
<a name="ln6299">      &quot;NvimInvalidIdentifierScopeDelimiter&quot;,</a>
<a name="ln6300"> </a>
<a name="ln6301">  &quot;default link NvimInvalidEnvironmentSigil NvimInvalidOptionSigil&quot;,</a>
<a name="ln6302">  &quot;default link NvimInvalidEnvironmentName NvimInvalidIdentifier&quot;,</a>
<a name="ln6303"> </a>
<a name="ln6304">  // Invalid string bodies and specials are still highlighted as valid ones to</a>
<a name="ln6305">  // minimize the red area.</a>
<a name="ln6306">  &quot;default link NvimInvalidString NvimInvalidValue&quot;,</a>
<a name="ln6307">  &quot;default link NvimInvalidStringBody NvimStringBody&quot;,</a>
<a name="ln6308">  &quot;default link NvimInvalidStringQuote NvimInvalidString&quot;,</a>
<a name="ln6309">  &quot;default link NvimInvalidStringSpecial NvimStringSpecial&quot;,</a>
<a name="ln6310"> </a>
<a name="ln6311">  &quot;default link NvimInvalidSingleQuote NvimInvalidStringQuote&quot;,</a>
<a name="ln6312">  &quot;default link NvimInvalidSingleQuotedBody NvimInvalidStringBody&quot;,</a>
<a name="ln6313">  &quot;default link NvimInvalidSingleQuotedQuote NvimInvalidStringSpecial&quot;,</a>
<a name="ln6314"> </a>
<a name="ln6315">  &quot;default link NvimInvalidDoubleQuote NvimInvalidStringQuote&quot;,</a>
<a name="ln6316">  &quot;default link NvimInvalidDoubleQuotedBody NvimInvalidStringBody&quot;,</a>
<a name="ln6317">  &quot;default link NvimInvalidDoubleQuotedEscape NvimInvalidStringSpecial&quot;,</a>
<a name="ln6318">  &quot;default link NvimInvalidDoubleQuotedUnknownEscape NvimInvalidValue&quot;,</a>
<a name="ln6319"> </a>
<a name="ln6320">  &quot;default link NvimInvalidFigureBrace NvimInvalidDelimiter&quot;,</a>
<a name="ln6321"> </a>
<a name="ln6322">  &quot;default link NvimInvalidSpacing ErrorMsg&quot;,</a>
<a name="ln6323"> </a>
<a name="ln6324">  // Not actually invalid, but we highlight user that he is doing something</a>
<a name="ln6325">  // wrong.</a>
<a name="ln6326">  &quot;default link NvimDoubleQuotedUnknownEscape NvimInvalidValue&quot;,</a>
<a name="ln6327">  NULL,</a>
<a name="ln6328">};</a>
<a name="ln6329"> </a>
<a name="ln6330">/// Create default links for Nvim* highlight groups used for cmdline coloring</a>
<a name="ln6331">void syn_init_cmdline_highlight(bool reset, bool init)</a>
<a name="ln6332">{</a>
<a name="ln6333">  for (size_t i = 0 ; highlight_init_cmdline[i] != NULL ; i++) {</a>
<a name="ln6334">    do_highlight(highlight_init_cmdline[i], reset, init);</a>
<a name="ln6335">  }</a>
<a name="ln6336">}</a>
<a name="ln6337"> </a>
<a name="ln6338">/// Load colors from a file if &quot;g:colors_name&quot; is set, otherwise load builtin</a>
<a name="ln6339">/// colors</a>
<a name="ln6340">///</a>
<a name="ln6341">/// @param both include groups where 'bg' doesn't matter</a>
<a name="ln6342">/// @param reset clear groups first</a>
<a name="ln6343">void init_highlight(bool both, bool reset)</a>
<a name="ln6344">{</a>
<a name="ln6345">  static int had_both = false;</a>
<a name="ln6346"> </a>
<a name="ln6347">  // Try finding the color scheme file.  Used when a color file was loaded</a>
<a name="ln6348">  // and 'background' or 't_Co' is changed.</a>
<a name="ln6349">  char_u *p = get_var_value(&quot;g:colors_name&quot;);</a>
<a name="ln6350">  if (p != NULL) {</a>
<a name="ln6351">    // Value of g:colors_name could be freed in load_colors() and make</a>
<a name="ln6352">    // p invalid, so copy it.</a>
<a name="ln6353">    char_u *copy_p = vim_strsave(p);</a>
<a name="ln6354">    bool okay = load_colors(copy_p);</a>
<a name="ln6355">    xfree(copy_p);</a>
<a name="ln6356">    if (okay) {</a>
<a name="ln6357">        return;</a>
<a name="ln6358">    }</a>
<a name="ln6359">  }</a>
<a name="ln6360"> </a>
<a name="ln6361">  /*</a>
<a name="ln6362">   * Didn't use a color file, use the compiled-in colors.</a>
<a name="ln6363">   */</a>
<a name="ln6364">  if (both) {</a>
<a name="ln6365">    had_both = true;</a>
<a name="ln6366">    const char *const *const pp = highlight_init_both;</a>
<a name="ln6367">    for (size_t i = 0; pp[i] != NULL; i++) {</a>
<a name="ln6368">      do_highlight(pp[i], reset, true);</a>
<a name="ln6369">    }</a>
<a name="ln6370">  } else if (!had_both) {</a>
<a name="ln6371">    // Don't do anything before the call with both == TRUE from main().</a>
<a name="ln6372">    // Not everything has been setup then, and that call will overrule</a>
<a name="ln6373">    // everything anyway.</a>
<a name="ln6374">    return;</a>
<a name="ln6375">  }</a>
<a name="ln6376"> </a>
<a name="ln6377">  const char *const *const pp = ((*p_bg == 'l')</a>
<a name="ln6378">                                 ? highlight_init_light</a>
<a name="ln6379">                                 : highlight_init_dark);</a>
<a name="ln6380">  for (size_t i = 0; pp[i] != NULL; i++) {</a>
<a name="ln6381">    do_highlight(pp[i], reset, true);</a>
<a name="ln6382">  }</a>
<a name="ln6383"> </a>
<a name="ln6384">  /* Reverse looks ugly, but grey may not work for 8 colors.  Thus let it</a>
<a name="ln6385">   * depend on the number of colors available.</a>
<a name="ln6386">   * With 8 colors brown is equal to yellow, need to use black for Search fg</a>
<a name="ln6387">   * to avoid Statement highlighted text disappears.</a>
<a name="ln6388">   * Clear the attributes, needed when changing the t_Co value. */</a>
<a name="ln6389">  if (t_colors &gt; 8) {</a>
<a name="ln6390">    do_highlight(</a>
<a name="ln6391">        (*p_bg == 'l'</a>
<a name="ln6392">         ? &quot;Visual cterm=NONE ctermbg=LightGrey&quot;</a>
<a name="ln6393">         : &quot;Visual cterm=NONE ctermbg=DarkGrey&quot;), false, true);</a>
<a name="ln6394">  } else {</a>
<a name="ln6395">    do_highlight(&quot;Visual cterm=reverse ctermbg=NONE&quot;, false, true);</a>
<a name="ln6396">    if (*p_bg == 'l') {</a>
<a name="ln6397">      do_highlight(&quot;Search ctermfg=black&quot;, false, true);</a>
<a name="ln6398">    }</a>
<a name="ln6399">  }</a>
<a name="ln6400"> </a>
<a name="ln6401">  /*</a>
<a name="ln6402">   * If syntax highlighting is enabled load the highlighting for it.</a>
<a name="ln6403">   */</a>
<a name="ln6404">  if (get_var_value(&quot;g:syntax_on&quot;) != NULL) {</a>
<a name="ln6405">    static int recursive = 0;</a>
<a name="ln6406"> </a>
<a name="ln6407">    if (recursive &gt;= 5) {</a>
<a name="ln6408">      EMSG(_(&quot;E679: recursive loop loading syncolor.vim&quot;));</a>
<a name="ln6409">    } else {</a>
<a name="ln6410">      recursive++;</a>
<a name="ln6411">      (void)source_runtime((char_u *)&quot;syntax/syncolor.vim&quot;, DIP_ALL);</a>
<a name="ln6412">      recursive--;</a>
<a name="ln6413">    }</a>
<a name="ln6414">  }</a>
<a name="ln6415">  syn_init_cmdline_highlight(false, false);</a>
<a name="ln6416">}</a>
<a name="ln6417"> </a>
<a name="ln6418">/*</a>
<a name="ln6419"> * Load color file &quot;name&quot;.</a>
<a name="ln6420"> * Return OK for success, FAIL for failure.</a>
<a name="ln6421"> */</a>
<a name="ln6422">int load_colors(char_u *name)</a>
<a name="ln6423">{</a>
<a name="ln6424">  char_u      *buf;</a>
<a name="ln6425">  int retval = FAIL;</a>
<a name="ln6426">  static int recursive = false;</a>
<a name="ln6427"> </a>
<a name="ln6428">  // When being called recursively, this is probably because setting</a>
<a name="ln6429">  // 'background' caused the highlighting to be reloaded.  This means it is</a>
<a name="ln6430">  // working, thus we should return OK.</a>
<a name="ln6431">  if (recursive) {</a>
<a name="ln6432">    return OK;</a>
<a name="ln6433">  }</a>
<a name="ln6434"> </a>
<a name="ln6435">  recursive = true;</a>
<a name="ln6436">  size_t buflen = STRLEN(name) + 12;</a>
<a name="ln6437">  buf = xmalloc(buflen);</a>
<a name="ln6438">  apply_autocmds(EVENT_COLORSCHEMEPRE, name, curbuf-&gt;b_fname, false, curbuf);</a>
<a name="ln6439">  snprintf((char *)buf, buflen, &quot;colors/%s.vim&quot;, name);</a>
<a name="ln6440">  retval = source_runtime(buf, DIP_START + DIP_OPT);</a>
<a name="ln6441">  xfree(buf);</a>
<a name="ln6442">  apply_autocmds(EVENT_COLORSCHEME, name, curbuf-&gt;b_fname, FALSE, curbuf);</a>
<a name="ln6443"> </a>
<a name="ln6444">  recursive = false;</a>
<a name="ln6445"> </a>
<a name="ln6446">  return retval;</a>
<a name="ln6447">}</a>
<a name="ln6448"> </a>
<a name="ln6449">static char *(color_names[28]) = {</a>
<a name="ln6450">  &quot;Black&quot;, &quot;DarkBlue&quot;, &quot;DarkGreen&quot;, &quot;DarkCyan&quot;,</a>
<a name="ln6451">  &quot;DarkRed&quot;, &quot;DarkMagenta&quot;, &quot;Brown&quot;, &quot;DarkYellow&quot;,</a>
<a name="ln6452">  &quot;Gray&quot;, &quot;Grey&quot;, &quot;LightGray&quot;, &quot;LightGrey&quot;,</a>
<a name="ln6453">  &quot;DarkGray&quot;, &quot;DarkGrey&quot;,</a>
<a name="ln6454">  &quot;Blue&quot;, &quot;LightBlue&quot;, &quot;Green&quot;, &quot;LightGreen&quot;,</a>
<a name="ln6455">  &quot;Cyan&quot;, &quot;LightCyan&quot;, &quot;Red&quot;, &quot;LightRed&quot;, &quot;Magenta&quot;,</a>
<a name="ln6456">  &quot;LightMagenta&quot;, &quot;Yellow&quot;, &quot;LightYellow&quot;, &quot;White&quot;, &quot;NONE&quot; };</a>
<a name="ln6457">  // indices:</a>
<a name="ln6458">  // 0, 1, 2, 3,</a>
<a name="ln6459">  // 4, 5, 6, 7,</a>
<a name="ln6460">  // 8, 9, 10, 11,</a>
<a name="ln6461">  // 12, 13,</a>
<a name="ln6462">  // 14, 15, 16, 17,</a>
<a name="ln6463">  // 18, 19, 20, 21, 22,</a>
<a name="ln6464">  // 23, 24, 25, 26, 27</a>
<a name="ln6465">static int color_numbers_16[28] = { 0, 1, 2, 3,</a>
<a name="ln6466">  4, 5, 6, 6,</a>
<a name="ln6467">  7, 7, 7, 7,</a>
<a name="ln6468">  8, 8,</a>
<a name="ln6469">  9, 9, 10, 10,</a>
<a name="ln6470">  11, 11, 12, 12, 13,</a>
<a name="ln6471">  13, 14, 14, 15, -1 };</a>
<a name="ln6472">// for xterm with 88 colors...</a>
<a name="ln6473">static int color_numbers_88[28] = { 0, 4, 2, 6,</a>
<a name="ln6474">  1, 5, 32, 72,</a>
<a name="ln6475">  84, 84, 7, 7,</a>
<a name="ln6476">  82, 82,</a>
<a name="ln6477">  12, 43, 10, 61,</a>
<a name="ln6478">  14, 63, 9, 74, 13,</a>
<a name="ln6479">  75, 11, 78, 15, -1 };</a>
<a name="ln6480">// for xterm with 256 colors...</a>
<a name="ln6481">static int color_numbers_256[28] = { 0, 4, 2, 6,</a>
<a name="ln6482">  1, 5, 130, 3,</a>
<a name="ln6483">  248, 248, 7, 7,</a>
<a name="ln6484">  242, 242,</a>
<a name="ln6485">  12, 81, 10, 121,</a>
<a name="ln6486">  14, 159, 9, 224, 13,</a>
<a name="ln6487">  225, 11, 229, 15, -1 };</a>
<a name="ln6488">// for terminals with less than 16 colors...</a>
<a name="ln6489">static int color_numbers_8[28] = { 0, 4, 2, 6,</a>
<a name="ln6490">  1, 5, 3, 3,</a>
<a name="ln6491">  7, 7, 7, 7,</a>
<a name="ln6492">  0+8, 0+8,</a>
<a name="ln6493">  4+8, 4+8, 2+8, 2+8,</a>
<a name="ln6494">  6+8, 6+8, 1+8, 1+8, 5+8,</a>
<a name="ln6495">  5+8, 3+8, 3+8, 7+8, -1 };</a>
<a name="ln6496"> </a>
<a name="ln6497">// Lookup the &quot;cterm&quot; value to be used for color with index &quot;idx&quot; in</a>
<a name="ln6498">// color_names[].</a>
<a name="ln6499">// &quot;boldp&quot; will be set to TRUE or FALSE for a foreground color when using 8</a>
<a name="ln6500">// colors, otherwise it will be unchanged.</a>
<a name="ln6501">int lookup_color(const int idx, const bool foreground, TriState *const boldp)</a>
<a name="ln6502">{</a>
<a name="ln6503">  int color = color_numbers_16[idx];</a>
<a name="ln6504"> </a>
<a name="ln6505">  // Use the _16 table to check if it's a valid color name.</a>
<a name="ln6506">  if (color &lt; 0) {</a>
<a name="ln6507">    return -1;</a>
<a name="ln6508">  }</a>
<a name="ln6509"> </a>
<a name="ln6510">  if (t_colors == 8) {</a>
<a name="ln6511">    // t_Co is 8: use the 8 colors table</a>
<a name="ln6512">    color = color_numbers_8[idx];</a>
<a name="ln6513">    if (foreground) {</a>
<a name="ln6514">      // set/reset bold attribute to get light foreground</a>
<a name="ln6515">      // colors (on some terminals, e.g. &quot;linux&quot;)</a>
<a name="ln6516">      if (color &amp; 8) {</a>
<a name="ln6517">        *boldp = kTrue;</a>
<a name="ln6518">      } else {</a>
<a name="ln6519">        *boldp = kFalse;</a>
<a name="ln6520">      }</a>
<a name="ln6521">    }</a>
<a name="ln6522">    color &amp;= 7;   // truncate to 8 colors</a>
<a name="ln6523">  } else if (t_colors == 16) {</a>
<a name="ln6524">    color = color_numbers_8[idx];</a>
<a name="ln6525">  } else if (t_colors == 88) {</a>
<a name="ln6526">    color = color_numbers_88[idx];</a>
<a name="ln6527">  } else if (t_colors &gt;= 256) {</a>
<a name="ln6528">    color = color_numbers_256[idx];</a>
<a name="ln6529">  }</a>
<a name="ln6530">  return color;</a>
<a name="ln6531">}</a>
<a name="ln6532"> </a>
<a name="ln6533"> </a>
<a name="ln6534">/// Handle &quot;:highlight&quot; command</a>
<a name="ln6535">///</a>
<a name="ln6536">/// When using &quot;:highlight clear&quot; this is called recursively for each group with</a>
<a name="ln6537">/// forceit and init being both true.</a>
<a name="ln6538">///</a>
<a name="ln6539">/// @param[in]  line  Command arguments.</a>
<a name="ln6540">/// @param[in]  forceit  True when bang is given, allows to link group even if</a>
<a name="ln6541">///                      it has its own settings.</a>
<a name="ln6542">/// @param[in]  init  True when initializing.</a>
<a name="ln6543">void do_highlight(const char *line, const bool forceit, const bool init)</a>
<a name="ln6544">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6545">{</a>
<a name="ln6546">  const char *name_end;</a>
<a name="ln6547">  const char *linep;</a>
<a name="ln6548">  const char *key_start;</a>
<a name="ln6549">  const char *arg_start;</a>
<a name="ln6550">  long i;</a>
<a name="ln6551">  int off;</a>
<a name="ln6552">  int len;</a>
<a name="ln6553">  int attr;</a>
<a name="ln6554">  int id;</a>
<a name="ln6555">  int idx;</a>
<a name="ln6556">  struct hl_group item_before;</a>
<a name="ln6557">  bool did_change = false;</a>
<a name="ln6558">  bool dodefault = false;</a>
<a name="ln6559">  bool doclear = false;</a>
<a name="ln6560">  bool dolink = false;</a>
<a name="ln6561">  bool error = false;</a>
<a name="ln6562">  int color;</a>
<a name="ln6563">  bool is_normal_group = false;   // &quot;Normal&quot; group</a>
<a name="ln6564">  bool did_highlight_changed = false;</a>
<a name="ln6565"> </a>
<a name="ln6566">  // If no argument, list current highlighting.</a>
<a name="ln6567">  if (ends_excmd((uint8_t)(*line))) {</a>
<a name="ln6568">    for (i = 1; i &lt;= highlight_ga.ga_len &amp;&amp; !got_int; i++) {</a>
<a name="ln6569">      // TODO(brammool): only call when the group has attributes set</a>
<a name="ln6570">      highlight_list_one(i);</a>
<a name="ln6571">    }</a>
<a name="ln6572">    return;</a>
<a name="ln6573">  }</a>
<a name="ln6574"> </a>
<a name="ln6575">  // Isolate the name.</a>
<a name="ln6576">  name_end = (const char *)skiptowhite((const char_u *)line);</a>
<a name="ln6577">  linep = (const char *)skipwhite((const char_u *)name_end);</a>
<a name="ln6578"> </a>
<a name="ln6579">  // Check for &quot;default&quot; argument.</a>
<a name="ln6580">  if (strncmp(line, &quot;default&quot;, name_end - line) == 0) {</a>
<a name="ln6581">    dodefault = true;</a>
<a name="ln6582">    line = linep;</a>
<a name="ln6583">    name_end = (const char *)skiptowhite((const char_u *)line);</a>
<a name="ln6584">    linep = (const char *)skipwhite((const char_u *)name_end);</a>
<a name="ln6585">  }</a>
<a name="ln6586"> </a>
<a name="ln6587">  // Check for &quot;clear&quot; or &quot;link&quot; argument.</a>
<a name="ln6588">  if (strncmp(line, &quot;clear&quot;, name_end - line) == 0) {</a>
<a name="ln6589">    doclear = true;</a>
<a name="ln6590">  } else if (strncmp(line, &quot;link&quot;, name_end - line) == 0) {</a>
<a name="ln6591">    dolink = true;</a>
<a name="ln6592">  }</a>
<a name="ln6593"> </a>
<a name="ln6594">  // &quot;:highlight {group-name}&quot;: list highlighting for one group.</a>
<a name="ln6595">  if (!doclear &amp;&amp; !dolink &amp;&amp; ends_excmd((uint8_t)(*linep))) {</a>
<a name="ln6596">    id = syn_namen2id((const char_u *)line, (int)(name_end - line));</a>
<a name="ln6597">    if (id == 0) {</a>
<a name="ln6598">      emsgf(_(&quot;E411: highlight group not found: %s&quot;), line);</a>
<a name="ln6599">    } else {</a>
<a name="ln6600">      highlight_list_one(id);</a>
<a name="ln6601">    }</a>
<a name="ln6602">    return;</a>
<a name="ln6603">  }</a>
<a name="ln6604"> </a>
<a name="ln6605">  // Handle &quot;:highlight link {from} {to}&quot; command.</a>
<a name="ln6606">  if (dolink) {</a>
<a name="ln6607">    const char *from_start = linep;</a>
<a name="ln6608">    const char *from_end;</a>
<a name="ln6609">    const char *to_start;</a>
<a name="ln6610">    const char *to_end;</a>
<a name="ln6611">    int from_id;</a>
<a name="ln6612">    int to_id;</a>
<a name="ln6613">    struct hl_group *hlgroup = NULL;</a>
<a name="ln6614"> </a>
<a name="ln6615">    from_end = (const char *)skiptowhite((const char_u *)from_start);</a>
<a name="ln6616">    to_start = (const char *)skipwhite((const char_u *)from_end);</a>
<a name="ln6617">    to_end   = (const char *)skiptowhite((const char_u *)to_start);</a>
<a name="ln6618"> </a>
<a name="ln6619">    if (ends_excmd((uint8_t)(*from_start))</a>
<a name="ln6620">        || ends_excmd((uint8_t)(*to_start))) {</a>
<a name="ln6621">      emsgf(_(&quot;E412: Not enough arguments: \&quot;:highlight link %s\&quot;&quot;),</a>
<a name="ln6622">            from_start);</a>
<a name="ln6623">      return;</a>
<a name="ln6624">    }</a>
<a name="ln6625"> </a>
<a name="ln6626">    if (!ends_excmd(*skipwhite((const char_u *)to_end))) {</a>
<a name="ln6627">      emsgf(_(&quot;E413: Too many arguments: \&quot;:highlight link %s\&quot;&quot;), from_start);</a>
<a name="ln6628">      return;</a>
<a name="ln6629">    }</a>
<a name="ln6630"> </a>
<a name="ln6631">    from_id = syn_check_group((const char_u *)from_start,</a>
<a name="ln6632">                              (int)(from_end - from_start));</a>
<a name="ln6633">    if (strncmp(to_start, &quot;NONE&quot;, 4) == 0) {</a>
<a name="ln6634">      to_id = 0;</a>
<a name="ln6635">    } else {</a>
<a name="ln6636">      to_id = syn_check_group((const char_u *)to_start,</a>
<a name="ln6637">                              (int)(to_end - to_start));</a>
<a name="ln6638">    }</a>
<a name="ln6639"> </a>
<a name="ln6640">    if (from_id &gt; 0) {</a>
<a name="ln6641">      hlgroup = &amp;HL_TABLE()[from_id - 1];</a>
<a name="ln6642">      if (dodefault &amp;&amp; (forceit || hlgroup-&gt;sg_deflink == 0)) {</a>
<a name="ln6643">        hlgroup-&gt;sg_deflink = to_id;</a>
<a name="ln6644">        hlgroup-&gt;sg_deflink_sctx = current_sctx;</a>
<a name="ln6645">        hlgroup-&gt;sg_deflink_sctx.sc_lnum += sourcing_lnum;</a>
<a name="ln6646">      }</a>
<a name="ln6647">    }</a>
<a name="ln6648"> </a>
<a name="ln6649">    if (from_id &gt; 0 &amp;&amp; (!init || hlgroup-&gt;sg_set == 0)) {</a>
<a name="ln6650">      // Don't allow a link when there already is some highlighting</a>
<a name="ln6651">      // for the group, unless '!' is used</a>
<a name="ln6652">      if (to_id &gt; 0 &amp;&amp; !forceit &amp;&amp; !init</a>
<a name="ln6653">          &amp;&amp; hl_has_settings(from_id - 1, dodefault)) {</a>
<a name="ln6654">        if (sourcing_name == NULL &amp;&amp; !dodefault) {</a>
<a name="ln6655">          EMSG(_(&quot;E414: group has settings, highlight link ignored&quot;));</a>
<a name="ln6656">        }</a>
<a name="ln6657">      } else if (hlgroup-&gt;sg_link != to_id</a>
<a name="ln6658">                 || hlgroup-&gt;sg_script_ctx.sc_sid != current_sctx.sc_sid</a>
<a name="ln6659">                 || hlgroup-&gt;sg_cleared) {</a>
<a name="ln6660">        if (!init) {</a>
<a name="ln6661">          hlgroup-&gt;sg_set |= SG_LINK;</a>
<a name="ln6662">        }</a>
<a name="ln6663">        hlgroup-&gt;sg_link = to_id;</a>
<a name="ln6664">        hlgroup-&gt;sg_script_ctx = current_sctx;</a>
<a name="ln6665">        hlgroup-&gt;sg_script_ctx.sc_lnum += sourcing_lnum;</a>
<a name="ln6666">        hlgroup-&gt;sg_cleared = false;</a>
<a name="ln6667">        redraw_all_later(SOME_VALID);</a>
<a name="ln6668"> </a>
<a name="ln6669">        // Only call highlight changed() once after multiple changes</a>
<a name="ln6670">        need_highlight_changed = true;</a>
<a name="ln6671">      }</a>
<a name="ln6672">    }</a>
<a name="ln6673"> </a>
<a name="ln6674">    return;</a>
<a name="ln6675">  }</a>
<a name="ln6676"> </a>
<a name="ln6677">  if (doclear) {</a>
<a name="ln6678">    // &quot;:highlight clear [group]&quot; command.</a>
<a name="ln6679">    line = linep;</a>
<a name="ln6680">    if (ends_excmd((uint8_t)(*line))) {</a>
<a name="ln6681">      do_unlet(S_LEN(&quot;colors_name&quot;), true);</a>
<a name="ln6682">      restore_cterm_colors();</a>
<a name="ln6683"> </a>
<a name="ln6684">      // Clear all default highlight groups and load the defaults.</a>
<a name="ln6685">      for (int j = 0; j &lt; highlight_ga.ga_len; j++) {</a>
<a name="ln6686">        highlight_clear(j);</a>
<a name="ln6687">      }</a>
<a name="ln6688">      init_highlight(true, true);</a>
<a name="ln6689">      highlight_changed();</a>
<a name="ln6690">      redraw_all_later(NOT_VALID);</a>
<a name="ln6691">      return;</a>
<a name="ln6692">    }</a>
<a name="ln6693">    name_end = (const char *)skiptowhite((const char_u *)line);</a>
<a name="ln6694">    linep = (const char *)skipwhite((const char_u *)name_end);</a>
<a name="ln6695">  }</a>
<a name="ln6696"> </a>
<a name="ln6697">  // Find the group name in the table.  If it does not exist yet, add it.</a>
<a name="ln6698">  id = syn_check_group((const char_u *)line, (int)(name_end - line));</a>
<a name="ln6699">  if (id == 0) {  // Failed (out of memory).</a>
<a name="ln6700">    return;</a>
<a name="ln6701">  }</a>
<a name="ln6702">  idx = id - 1;  // Index is ID minus one.</a>
<a name="ln6703"> </a>
<a name="ln6704">  // Return if &quot;default&quot; was used and the group already has settings</a>
<a name="ln6705">  if (dodefault &amp;&amp; hl_has_settings(idx, true)) {</a>
<a name="ln6706">    return;</a>
<a name="ln6707">  }</a>
<a name="ln6708"> </a>
<a name="ln6709">  // Make a copy so we can check if any attribute actually changed</a>
<a name="ln6710">  item_before = HL_TABLE()[idx];</a>
<a name="ln6711">  is_normal_group = (STRCMP(HL_TABLE()[idx].sg_name_u, &quot;NORMAL&quot;) == 0);</a>
<a name="ln6712"> </a>
<a name="ln6713">  // Clear the highlighting for &quot;:hi clear {group}&quot; and &quot;:hi clear&quot;.</a>
<a name="ln6714">  if (doclear || (forceit &amp;&amp; init)) {</a>
<a name="ln6715">    highlight_clear(idx);</a>
<a name="ln6716">    if (!doclear) {</a>
<a name="ln6717">      HL_TABLE()[idx].sg_set = 0;</a>
<a name="ln6718">    }</a>
<a name="ln6719">  }</a>
<a name="ln6720"> </a>
<a name="ln6721">  char *key = NULL;</a>
<a name="ln6722">  char *arg = NULL;</a>
<a name="ln6723">  if (!doclear) {</a>
<a name="ln6724">    while (!ends_excmd((uint8_t)(*linep))) {</a>
<a name="ln6725">      key_start = linep;</a>
<a name="ln6726">      if (*linep == '=') {</a>
<a name="ln6727">        emsgf(_(&quot;E415: unexpected equal sign: %s&quot;), key_start);</a>
<a name="ln6728">        error = true;</a>
<a name="ln6729">        break;</a>
<a name="ln6730">      }</a>
<a name="ln6731"> </a>
<a name="ln6732">      // Isolate the key (&quot;term&quot;, &quot;ctermfg&quot;, &quot;ctermbg&quot;, &quot;font&quot;, &quot;guifg&quot;,</a>
<a name="ln6733">      // &quot;guibg&quot; or &quot;guisp&quot;).</a>
<a name="ln6734">      while (*linep &amp;&amp; !ascii_iswhite(*linep) &amp;&amp; *linep != '=') {</a>
<a name="ln6735">        linep++;</a>
<a name="ln6736">      }</a>
<a name="ln6737">      xfree(key);</a>
<a name="ln6738">      key = (char *)vim_strnsave_up((const char_u *)key_start,</a>
<a name="ln6739">                                    linep - key_start);</a>
<a name="ln6740">      linep = (const char *)skipwhite((const char_u *)linep);</a>
<a name="ln6741"> </a>
<a name="ln6742">      if (strcmp(key, &quot;NONE&quot;) == 0) {</a>
<a name="ln6743">        if (!init || HL_TABLE()[idx].sg_set == 0) {</a>
<a name="ln6744">          if (!init) {</a>
<a name="ln6745">            HL_TABLE()[idx].sg_set |= SG_CTERM+SG_GUI;</a>
<a name="ln6746">          }</a>
<a name="ln6747">          highlight_clear(idx);</a>
<a name="ln6748">        }</a>
<a name="ln6749">        continue;</a>
<a name="ln6750">      }</a>
<a name="ln6751"> </a>
<a name="ln6752">      // Check for the equal sign.</a>
<a name="ln6753">      if (*linep != '=') {</a>
<a name="ln6754">        emsgf(_(&quot;E416: missing equal sign: %s&quot;), key_start);</a>
<a name="ln6755">        error = true;</a>
<a name="ln6756">        break;</a>
<a name="ln6757">      }</a>
<a name="ln6758">      linep++;</a>
<a name="ln6759"> </a>
<a name="ln6760">      // Isolate the argument.</a>
<a name="ln6761">      linep = (const char *)skipwhite((const char_u *)linep);</a>
<a name="ln6762">      if (*linep == '\'') {  // guifg='color name'</a>
<a name="ln6763">        arg_start = ++linep;</a>
<a name="ln6764">        linep = strchr(linep, '\'');</a>
<a name="ln6765">        if (linep == NULL) {</a>
<a name="ln6766">          emsgf(_(e_invarg2), key_start);</a>
<a name="ln6767">          error = true;</a>
<a name="ln6768">          break;</a>
<a name="ln6769">        }</a>
<a name="ln6770">      } else {</a>
<a name="ln6771">        arg_start = linep;</a>
<a name="ln6772">        linep = (const char *)skiptowhite((const char_u *)linep);</a>
<a name="ln6773">      }</a>
<a name="ln6774">      if (linep == arg_start) {</a>
<a name="ln6775">        emsgf(_(&quot;E417: missing argument: %s&quot;), key_start);</a>
<a name="ln6776">        error = true;</a>
<a name="ln6777">        break;</a>
<a name="ln6778">      }</a>
<a name="ln6779">      xfree(arg);</a>
<a name="ln6780">      arg = xstrndup(arg_start, (size_t)(linep - arg_start));</a>
<a name="ln6781"> </a>
<a name="ln6782">      if (*linep == '\'') {</a>
<a name="ln6783">        linep++;</a>
<a name="ln6784">      }</a>
<a name="ln6785"> </a>
<a name="ln6786">      // Store the argument.</a>
<a name="ln6787">      if (strcmp(key, &quot;TERM&quot;) == 0</a>
<a name="ln6788">          || strcmp(key, &quot;CTERM&quot;) == 0</a>
<a name="ln6789">          || strcmp(key, &quot;GUI&quot;) == 0) {</a>
<a name="ln6790">        attr = 0;</a>
<a name="ln6791">        off = 0;</a>
<a name="ln6792">        while (arg[off] != NUL) {</a>
<a name="ln6793">          for (i = ARRAY_SIZE(hl_attr_table); --i &gt;= 0; ) {</a>
<a name="ln6794">            len = (int)STRLEN(hl_name_table[i]);</a>
<a name="ln6795">            if (STRNICMP(arg + off, hl_name_table[i], len) == 0) {</a>
<a name="ln6796">              attr |= hl_attr_table[i];</a>
<a name="ln6797">              off += len;</a>
<a name="ln6798">              break;</a>
<a name="ln6799">            }</a>
<a name="ln6800">          }</a>
<a name="ln6801">          if (i &lt; 0) {</a>
<a name="ln6802">            emsgf(_(&quot;E418: Illegal value: %s&quot;), arg);</a>
<a name="ln6803">            error = true;</a>
<a name="ln6804">            break;</a>
<a name="ln6805">          }</a>
<a name="ln6806">          if (arg[off] == ',') {  // Another one follows.</a>
<a name="ln6807">            off++;</a>
<a name="ln6808">          }</a>
<a name="ln6809">        }</a>
<a name="ln6810">        if (error) {</a>
<a name="ln6811">          break;</a>
<a name="ln6812">        }</a>
<a name="ln6813">        if (*key == 'C')   {</a>
<a name="ln6814">          if (!init || !(HL_TABLE()[idx].sg_set &amp; SG_CTERM)) {</a>
<a name="ln6815">            if (!init) {</a>
<a name="ln6816">              HL_TABLE()[idx].sg_set |= SG_CTERM;</a>
<a name="ln6817">            }</a>
<a name="ln6818">            HL_TABLE()[idx].sg_cterm = attr;</a>
<a name="ln6819">            HL_TABLE()[idx].sg_cterm_bold = false;</a>
<a name="ln6820">          }</a>
<a name="ln6821">        } else if (*key == 'G') {</a>
<a name="ln6822">          if (!init || !(HL_TABLE()[idx].sg_set &amp; SG_GUI)) {</a>
<a name="ln6823">            if (!init) {</a>
<a name="ln6824">              HL_TABLE()[idx].sg_set |= SG_GUI;</a>
<a name="ln6825">            }</a>
<a name="ln6826">            HL_TABLE()[idx].sg_gui = attr;</a>
<a name="ln6827">          }</a>
<a name="ln6828">        }</a>
<a name="ln6829">      } else if (STRCMP(key, &quot;FONT&quot;) == 0)   {</a>
<a name="ln6830">        // in non-GUI fonts are simply ignored</a>
<a name="ln6831">      } else if (STRCMP(key, &quot;CTERMFG&quot;) == 0 || STRCMP(key, &quot;CTERMBG&quot;) == 0) {</a>
<a name="ln6832">        if (!init || !(HL_TABLE()[idx].sg_set &amp; SG_CTERM)) {</a>
<a name="ln6833">          if (!init) {</a>
<a name="ln6834">            HL_TABLE()[idx].sg_set |= SG_CTERM;</a>
<a name="ln6835">          }</a>
<a name="ln6836"> </a>
<a name="ln6837">          /* When setting the foreground color, and previously the &quot;bold&quot;</a>
<a name="ln6838">           * flag was set for a light color, reset it now */</a>
<a name="ln6839">          if (key[5] == 'F' &amp;&amp; HL_TABLE()[idx].sg_cterm_bold) {</a>
<a name="ln6840">            HL_TABLE()[idx].sg_cterm &amp;= ~HL_BOLD;</a>
<a name="ln6841">            HL_TABLE()[idx].sg_cterm_bold = false;</a>
<a name="ln6842">          }</a>
<a name="ln6843"> </a>
<a name="ln6844">          if (ascii_isdigit(*arg)) {</a>
<a name="ln6845">            color = atoi((char *)arg);</a>
<a name="ln6846">          } else if (STRICMP(arg, &quot;fg&quot;) == 0) {</a>
<a name="ln6847">            if (cterm_normal_fg_color) {</a>
<a name="ln6848">              color = cterm_normal_fg_color - 1;</a>
<a name="ln6849">            } else {</a>
<a name="ln6850">              EMSG(_(&quot;E419: FG color unknown&quot;));</a>
<a name="ln6851">              error = true;</a>
<a name="ln6852">              break;</a>
<a name="ln6853">            }</a>
<a name="ln6854">          } else if (STRICMP(arg, &quot;bg&quot;) == 0)   {</a>
<a name="ln6855">            if (cterm_normal_bg_color &gt; 0)</a>
<a name="ln6856">              color = cterm_normal_bg_color - 1;</a>
<a name="ln6857">            else {</a>
<a name="ln6858">              EMSG(_(&quot;E420: BG color unknown&quot;));</a>
<a name="ln6859">              error = true;</a>
<a name="ln6860">              break;</a>
<a name="ln6861">            }</a>
<a name="ln6862">          } else {</a>
<a name="ln6863">            // Reduce calls to STRICMP a bit, it can be slow.</a>
<a name="ln6864">            off = TOUPPER_ASC(*arg);</a>
<a name="ln6865">            for (i = ARRAY_SIZE(color_names); --i &gt;= 0; ) {</a>
<a name="ln6866">              if (off == color_names[i][0]</a>
<a name="ln6867">                  &amp;&amp; STRICMP(arg + 1, color_names[i] + 1) == 0) {</a>
<a name="ln6868">                break;</a>
<a name="ln6869">              }</a>
<a name="ln6870">            }</a>
<a name="ln6871">            if (i &lt; 0) {</a>
<a name="ln6872">              emsgf(_(&quot;E421: Color name or number not recognized: %s&quot;),</a>
<a name="ln6873">                    key_start);</a>
<a name="ln6874">              error = true;</a>
<a name="ln6875">              break;</a>
<a name="ln6876">            }</a>
<a name="ln6877"> </a>
<a name="ln6878">            TriState bold = kNone;</a>
<a name="ln6879">            color = lookup_color(i, key[5] == 'F', &amp;bold);</a>
<a name="ln6880"> </a>
<a name="ln6881">            // set/reset bold attribute to get light foreground</a>
<a name="ln6882">            // colors (on some terminals, e.g. &quot;linux&quot;)</a>
<a name="ln6883">            if (bold == kTrue) {</a>
<a name="ln6884">              HL_TABLE()[idx].sg_cterm |= HL_BOLD;</a>
<a name="ln6885">              HL_TABLE()[idx].sg_cterm_bold = true;</a>
<a name="ln6886">            } else if (bold == kFalse) {</a>
<a name="ln6887">              HL_TABLE()[idx].sg_cterm &amp;= ~HL_BOLD;</a>
<a name="ln6888">            }</a>
<a name="ln6889">          }</a>
<a name="ln6890">          // Add one to the argument, to avoid zero.  Zero is used for</a>
<a name="ln6891">          // &quot;NONE&quot;, then &quot;color&quot; is -1.</a>
<a name="ln6892">          if (key[5] == 'F') {</a>
<a name="ln6893">            HL_TABLE()[idx].sg_cterm_fg = color + 1;</a>
<a name="ln6894">            if (is_normal_group) {</a>
<a name="ln6895">              cterm_normal_fg_color = color + 1;</a>
<a name="ln6896">            }</a>
<a name="ln6897">          } else {</a>
<a name="ln6898">            HL_TABLE()[idx].sg_cterm_bg = color + 1;</a>
<a name="ln6899">            if (is_normal_group) {</a>
<a name="ln6900">              cterm_normal_bg_color = color + 1;</a>
<a name="ln6901">              if (!ui_rgb_attached()) {</a>
<a name="ln6902">                if (color &gt;= 0) {</a>
<a name="ln6903">                  int dark = -1;</a>
<a name="ln6904"> </a>
<a name="ln6905">                  if (t_colors &lt; 16) {</a>
<a name="ln6906">                    dark = (color == 0 || color == 4);</a>
<a name="ln6907">                  } else if (color &lt; 16) {</a>
<a name="ln6908">                    // Limit the heuristic to the standard 16 colors</a>
<a name="ln6909">                    dark = (color &lt; 7 || color == 8);</a>
<a name="ln6910">                  }</a>
<a name="ln6911">                  // Set the 'background' option if the value is</a>
<a name="ln6912">                  // wrong.</a>
<a name="ln6913">                  if (dark != -1</a>
<a name="ln6914">                      &amp;&amp; dark != (*p_bg == 'd')</a>
<a name="ln6915">                      &amp;&amp; !option_was_set(&quot;bg&quot;)) {</a>
<a name="ln6916">                    set_option_value(&quot;bg&quot;, 0L, (dark ? &quot;dark&quot; : &quot;light&quot;), 0);</a>
<a name="ln6917">                    reset_option_was_set(&quot;bg&quot;);</a>
<a name="ln6918">                  }</a>
<a name="ln6919">                }</a>
<a name="ln6920">              }</a>
<a name="ln6921">            }</a>
<a name="ln6922">          }</a>
<a name="ln6923">        }</a>
<a name="ln6924">      } else if (strcmp(key, &quot;GUIFG&quot;) == 0)   {</a>
<a name="ln6925">        char **namep = &amp;HL_TABLE()[idx].sg_rgb_fg_name;</a>
<a name="ln6926"> </a>
<a name="ln6927">        if (!init || !(HL_TABLE()[idx].sg_set &amp; SG_GUI)) {</a>
<a name="ln6928">          if (!init) {</a>
<a name="ln6929">            HL_TABLE()[idx].sg_set |= SG_GUI;</a>
<a name="ln6930">          }</a>
<a name="ln6931"> </a>
<a name="ln6932">          if (*namep == NULL || STRCMP(*namep, arg) != 0) {</a>
<a name="ln6933">            xfree(*namep);</a>
<a name="ln6934">            if (strcmp(arg, &quot;NONE&quot;) != 0) {</a>
<a name="ln6935">              *namep = xstrdup(arg);</a>
<a name="ln6936">              HL_TABLE()[idx].sg_rgb_fg = name_to_color(arg);</a>
<a name="ln6937">            } else {</a>
<a name="ln6938">              *namep = NULL;</a>
<a name="ln6939">              HL_TABLE()[idx].sg_rgb_fg = -1;</a>
<a name="ln6940">            }</a>
<a name="ln6941">            did_change = true;</a>
<a name="ln6942">          }</a>
<a name="ln6943">        }</a>
<a name="ln6944"> </a>
<a name="ln6945">        if (is_normal_group) {</a>
<a name="ln6946">          normal_fg = HL_TABLE()[idx].sg_rgb_fg;</a>
<a name="ln6947">        }</a>
<a name="ln6948">      } else if (STRCMP(key, &quot;GUIBG&quot;) == 0)   {</a>
<a name="ln6949">        char **const namep = &amp;HL_TABLE()[idx].sg_rgb_bg_name;</a>
<a name="ln6950"> </a>
<a name="ln6951">        if (!init || !(HL_TABLE()[idx].sg_set &amp; SG_GUI)) {</a>
<a name="ln6952">          if (!init) {</a>
<a name="ln6953">            HL_TABLE()[idx].sg_set |= SG_GUI;</a>
<a name="ln6954">          }</a>
<a name="ln6955"> </a>
<a name="ln6956">          if (*namep == NULL || STRCMP(*namep, arg) != 0) {</a>
<a name="ln6957">            xfree(*namep);</a>
<a name="ln6958">            if (STRCMP(arg, &quot;NONE&quot;) != 0) {</a>
<a name="ln6959">              *namep = xstrdup(arg);</a>
<a name="ln6960">              HL_TABLE()[idx].sg_rgb_bg = name_to_color(arg);</a>
<a name="ln6961">            } else {</a>
<a name="ln6962">              *namep = NULL;</a>
<a name="ln6963">              HL_TABLE()[idx].sg_rgb_bg = -1;</a>
<a name="ln6964">            }</a>
<a name="ln6965">            did_change = true;</a>
<a name="ln6966">          }</a>
<a name="ln6967">        }</a>
<a name="ln6968"> </a>
<a name="ln6969">        if (is_normal_group) {</a>
<a name="ln6970">          normal_bg = HL_TABLE()[idx].sg_rgb_bg;</a>
<a name="ln6971">        }</a>
<a name="ln6972">      } else if (strcmp(key, &quot;GUISP&quot;) == 0)   {</a>
<a name="ln6973">        char **const namep = &amp;HL_TABLE()[idx].sg_rgb_sp_name;</a>
<a name="ln6974"> </a>
<a name="ln6975">        if (!init || !(HL_TABLE()[idx].sg_set &amp; SG_GUI)) {</a>
<a name="ln6976">          if (!init) {</a>
<a name="ln6977">            HL_TABLE()[idx].sg_set |= SG_GUI;</a>
<a name="ln6978">          }</a>
<a name="ln6979"> </a>
<a name="ln6980">          if (*namep == NULL || STRCMP(*namep, arg) != 0) {</a>
<a name="ln6981">            xfree(*namep);</a>
<a name="ln6982">            if (strcmp(arg, &quot;NONE&quot;) != 0) {</a>
<a name="ln6983">              *namep = xstrdup(arg);</a>
<a name="ln6984">              HL_TABLE()[idx].sg_rgb_sp = name_to_color(arg);</a>
<a name="ln6985">            } else {</a>
<a name="ln6986">              *namep = NULL;</a>
<a name="ln6987">              HL_TABLE()[idx].sg_rgb_sp = -1;</a>
<a name="ln6988">            }</a>
<a name="ln6989">            did_change = true;</a>
<a name="ln6990">          }</a>
<a name="ln6991">        }</a>
<a name="ln6992"> </a>
<a name="ln6993">        if (is_normal_group) {</a>
<a name="ln6994">          normal_sp = HL_TABLE()[idx].sg_rgb_sp;</a>
<a name="ln6995">        }</a>
<a name="ln6996">      } else if (strcmp(key, &quot;START&quot;) == 0 || strcmp(key, &quot;STOP&quot;) == 0)   {</a>
<a name="ln6997">        // Ignored for now</a>
<a name="ln6998">      } else if (strcmp(key, &quot;BLEND&quot;) == 0)   {</a>
<a name="ln6999">        if (strcmp(arg, &quot;NONE&quot;) != 0) {</a>
<a name="ln7000">          HL_TABLE()[idx].sg_blend = strtol(arg, NULL, 10);</a>
<a name="ln7001">        } else {</a>
<a name="ln7002">          HL_TABLE()[idx].sg_blend = -1;</a>
<a name="ln7003">        }</a>
<a name="ln7004">      } else {</a>
<a name="ln7005">        emsgf(_(&quot;E423: Illegal argument: %s&quot;), key_start);</a>
<a name="ln7006">        error = true;</a>
<a name="ln7007">        break;</a>
<a name="ln7008">      }</a>
<a name="ln7009">      HL_TABLE()[idx].sg_cleared = false;</a>
<a name="ln7010"> </a>
<a name="ln7011">      // When highlighting has been given for a group, don't link it.</a>
<a name="ln7012">      if (!init || !(HL_TABLE()[idx].sg_set &amp; SG_LINK)) {</a>
<a name="ln7013">        HL_TABLE()[idx].sg_link = 0;</a>
<a name="ln7014">      }</a>
<a name="ln7015"> </a>
<a name="ln7016">      // Continue with next argument.</a>
<a name="ln7017">      linep = (const char *)skipwhite((const char_u *)linep);</a>
<a name="ln7018">    }</a>
<a name="ln7019">  }</a>
<a name="ln7020"> </a>
<a name="ln7021">  // If there is an error, and it's a new entry, remove it from the table.</a>
<a name="ln7022">  if (error &amp;&amp; idx == highlight_ga.ga_len) {</a>
<a name="ln7023">    syn_unadd_group();</a>
<a name="ln7024">  } else {</a>
<a name="ln7025">    if (!error &amp;&amp; is_normal_group) {</a>
<a name="ln7026">      // Need to update all groups, because they might be using &quot;bg&quot; and/or</a>
<a name="ln7027">      // &quot;fg&quot;, which have been changed now.</a>
<a name="ln7028">      highlight_attr_set_all();</a>
<a name="ln7029"> </a>
<a name="ln7030">      if (!ui_has(kUILinegrid) &amp;&amp; starting == 0) {</a>
<a name="ln7031">        // Older UIs assume that we clear the screen after normal group is</a>
<a name="ln7032">        // changed</a>
<a name="ln7033">        ui_refresh();</a>
<a name="ln7034">      } else {</a>
<a name="ln7035">        // TUI and newer UIs will repaint the screen themselves. NOT_VALID</a>
<a name="ln7036">        // redraw below will still handle usages of guibg=fg etc.</a>
<a name="ln7037">        ui_default_colors_set();</a>
<a name="ln7038">      }</a>
<a name="ln7039">      did_highlight_changed = true;</a>
<a name="ln7040">      redraw_all_later(NOT_VALID);</a>
<a name="ln7041">    } else {</a>
<a name="ln7042">      set_hl_attr(idx);</a>
<a name="ln7043">    }</a>
<a name="ln7044">    HL_TABLE()[idx].sg_script_ctx = current_sctx;</a>
<a name="ln7045">    HL_TABLE()[idx].sg_script_ctx.sc_lnum += sourcing_lnum;</a>
<a name="ln7046">  }</a>
<a name="ln7047">  xfree(key);</a>
<a name="ln7048">  xfree(arg);</a>
<a name="ln7049"> </a>
<a name="ln7050">  // Only call highlight_changed() once, after a sequence of highlight</a>
<a name="ln7051">  // commands, and only if an attribute actually changed</a>
<a name="ln7052">  if ((did_change</a>
<a name="ln7053">       || memcmp(&amp;HL_TABLE()[idx], &amp;item_before, sizeof(item_before)) != 0)</a>
<a name="ln7054">      &amp;&amp; !did_highlight_changed) {</a>
<a name="ln7055">    // Do not trigger a redraw when highlighting is changed while</a>
<a name="ln7056">    // redrawing.  This may happen when evaluating 'statusline' changes the</a>
<a name="ln7057">    // StatusLine group.</a>
<a name="ln7058">    if (!updating_screen) {</a>
<a name="ln7059">      redraw_all_later(NOT_VALID);</a>
<a name="ln7060">    }</a>
<a name="ln7061">    need_highlight_changed = true;</a>
<a name="ln7062">  }</a>
<a name="ln7063">}</a>
<a name="ln7064"> </a>
<a name="ln7065">#if defined(EXITFREE)</a>
<a name="ln7066">void free_highlight(void)</a>
<a name="ln7067">{</a>
<a name="ln7068">  for (int i = 0; i &lt; highlight_ga.ga_len; ++i) {</a>
<a name="ln7069">    highlight_clear(i);</a>
<a name="ln7070">    xfree(HL_TABLE()[i].sg_name);</a>
<a name="ln7071">    xfree(HL_TABLE()[i].sg_name_u);</a>
<a name="ln7072">  }</a>
<a name="ln7073">  ga_clear(&amp;highlight_ga);</a>
<a name="ln7074">}</a>
<a name="ln7075"> </a>
<a name="ln7076">#endif</a>
<a name="ln7077"> </a>
<a name="ln7078">/*</a>
<a name="ln7079"> * Reset the cterm colors to what they were before Vim was started, if</a>
<a name="ln7080"> * possible.  Otherwise reset them to zero.</a>
<a name="ln7081"> */</a>
<a name="ln7082">void restore_cterm_colors(void)</a>
<a name="ln7083">{</a>
<a name="ln7084">  normal_fg = -1;</a>
<a name="ln7085">  normal_bg = -1;</a>
<a name="ln7086">  normal_sp = -1;</a>
<a name="ln7087">  cterm_normal_fg_color = 0;</a>
<a name="ln7088">  cterm_normal_bg_color = 0;</a>
<a name="ln7089">}</a>
<a name="ln7090"> </a>
<a name="ln7091">/*</a>
<a name="ln7092"> * Return TRUE if highlight group &quot;idx&quot; has any settings.</a>
<a name="ln7093"> * When &quot;check_link&quot; is TRUE also check for an existing link.</a>
<a name="ln7094"> */</a>
<a name="ln7095">static int hl_has_settings(int idx, int check_link)</a>
<a name="ln7096">{</a>
<a name="ln7097">  return HL_TABLE()[idx].sg_cleared == 0</a>
<a name="ln7098">    &amp;&amp; (HL_TABLE()[idx].sg_attr != 0</a>
<a name="ln7099">        || HL_TABLE()[idx].sg_cterm_fg != 0</a>
<a name="ln7100">        || HL_TABLE()[idx].sg_cterm_bg != 0</a>
<a name="ln7101">        || HL_TABLE()[idx].sg_rgb_fg_name != NULL</a>
<a name="ln7102">        || HL_TABLE()[idx].sg_rgb_bg_name != NULL</a>
<a name="ln7103">        || HL_TABLE()[idx].sg_rgb_sp_name != NULL</a>
<a name="ln7104">        || (check_link &amp;&amp; (HL_TABLE()[idx].sg_set &amp; SG_LINK)));</a>
<a name="ln7105">}</a>
<a name="ln7106"> </a>
<a name="ln7107">/*</a>
<a name="ln7108"> * Clear highlighting for one group.</a>
<a name="ln7109"> */</a>
<a name="ln7110">static void highlight_clear(int idx)</a>
<a name="ln7111">{</a>
<a name="ln7112">  HL_TABLE()[idx].sg_cleared = true;</a>
<a name="ln7113"> </a>
<a name="ln7114">  HL_TABLE()[idx].sg_attr = 0;</a>
<a name="ln7115">  HL_TABLE()[idx].sg_cterm = 0;</a>
<a name="ln7116">  HL_TABLE()[idx].sg_cterm_bold = false;</a>
<a name="ln7117">  HL_TABLE()[idx].sg_cterm_fg = 0;</a>
<a name="ln7118">  HL_TABLE()[idx].sg_cterm_bg = 0;</a>
<a name="ln7119">  HL_TABLE()[idx].sg_gui = 0;</a>
<a name="ln7120">  HL_TABLE()[idx].sg_rgb_fg = -1;</a>
<a name="ln7121">  HL_TABLE()[idx].sg_rgb_bg = -1;</a>
<a name="ln7122">  HL_TABLE()[idx].sg_rgb_sp = -1;</a>
<a name="ln7123">  XFREE_CLEAR(HL_TABLE()[idx].sg_rgb_fg_name);</a>
<a name="ln7124">  XFREE_CLEAR(HL_TABLE()[idx].sg_rgb_bg_name);</a>
<a name="ln7125">  XFREE_CLEAR(HL_TABLE()[idx].sg_rgb_sp_name);</a>
<a name="ln7126">  HL_TABLE()[idx].sg_blend = -1;</a>
<a name="ln7127">  // Restore default link and context if they exist. Otherwise clears.</a>
<a name="ln7128">  HL_TABLE()[idx].sg_link = HL_TABLE()[idx].sg_deflink;</a>
<a name="ln7129">  // Since we set the default link, set the location to where the default</a>
<a name="ln7130">  // link was set.</a>
<a name="ln7131">  HL_TABLE()[idx].sg_script_ctx = HL_TABLE()[idx].sg_deflink_sctx;</a>
<a name="ln7132">}</a>
<a name="ln7133"> </a>
<a name="ln7134"> </a>
<a name="ln7135">/// \addtogroup LIST_XXX</a>
<a name="ln7136">/// @{</a>
<a name="ln7137">#define LIST_ATTR   1</a>
<a name="ln7138">#define LIST_STRING 2</a>
<a name="ln7139">#define LIST_INT    3</a>
<a name="ln7140">/// @}</a>
<a name="ln7141"> </a>
<a name="ln7142">static void highlight_list_one(const int id)</a>
<a name="ln7143">{</a>
<a name="ln7144">  struct hl_group *const sgp = &amp;HL_TABLE()[id - 1];  // index is ID minus one</a>
<a name="ln7145">  bool didh = false;</a>
<a name="ln7146"> </a>
<a name="ln7147">  if (message_filtered(sgp-&gt;sg_name)) {</a>
<a name="ln7148">    return;</a>
<a name="ln7149">  }</a>
<a name="ln7150"> </a>
<a name="ln7151">  didh = highlight_list_arg(id, didh, LIST_ATTR,</a>
<a name="ln7152">      sgp-&gt;sg_cterm, NULL, &quot;cterm&quot;);</a>
<a name="ln7153">  didh = highlight_list_arg(id, didh, LIST_INT,</a>
<a name="ln7154">      sgp-&gt;sg_cterm_fg, NULL, &quot;ctermfg&quot;);</a>
<a name="ln7155">  didh = highlight_list_arg(id, didh, LIST_INT,</a>
<a name="ln7156">      sgp-&gt;sg_cterm_bg, NULL, &quot;ctermbg&quot;);</a>
<a name="ln7157"> </a>
<a name="ln7158">  didh = highlight_list_arg(id, didh, LIST_ATTR,</a>
<a name="ln7159">      sgp-&gt;sg_gui, NULL, &quot;gui&quot;);</a>
<a name="ln7160">  didh = highlight_list_arg(id, didh, LIST_STRING,</a>
<a name="ln7161">      0, sgp-&gt;sg_rgb_fg_name, &quot;guifg&quot;);</a>
<a name="ln7162">  didh = highlight_list_arg(id, didh, LIST_STRING,</a>
<a name="ln7163">      0, sgp-&gt;sg_rgb_bg_name, &quot;guibg&quot;);</a>
<a name="ln7164">  didh = highlight_list_arg(id, didh, LIST_STRING,</a>
<a name="ln7165">                            0, sgp-&gt;sg_rgb_sp_name, &quot;guisp&quot;);</a>
<a name="ln7166"> </a>
<a name="ln7167">  didh = highlight_list_arg(id, didh, LIST_INT,</a>
<a name="ln7168">                            sgp-&gt;sg_blend+1, NULL, &quot;blend&quot;);</a>
<a name="ln7169"> </a>
<a name="ln7170">  if (sgp-&gt;sg_link &amp;&amp; !got_int) {</a>
<a name="ln7171">    (void)syn_list_header(didh, 0, id, true);</a>
<a name="ln7172">    didh = true;</a>
<a name="ln7173">    msg_puts_attr(&quot;links to&quot;, HL_ATTR(HLF_D));</a>
<a name="ln7174">    msg_putchar(' ');</a>
<a name="ln7175">    msg_outtrans(HL_TABLE()[HL_TABLE()[id - 1].sg_link - 1].sg_name);</a>
<a name="ln7176">  }</a>
<a name="ln7177"> </a>
<a name="ln7178">  if (!didh) {</a>
<a name="ln7179">    highlight_list_arg(id, didh, LIST_STRING, 0, &quot;cleared&quot;, &quot;&quot;);</a>
<a name="ln7180">  }</a>
<a name="ln7181">  if (p_verbose &gt; 0) {</a>
<a name="ln7182">    last_set_msg(sgp-&gt;sg_script_ctx);</a>
<a name="ln7183">  }</a>
<a name="ln7184">}</a>
<a name="ln7185"> </a>
<a name="ln7186">Dictionary get_global_hl_defs(void)</a>
<a name="ln7187">{</a>
<a name="ln7188">  Dictionary rv = ARRAY_DICT_INIT;</a>
<a name="ln7189">  for (int i = 1; i &lt;= highlight_ga.ga_len &amp;&amp; !got_int; i++) {</a>
<a name="ln7190">    Dictionary attrs = ARRAY_DICT_INIT;</a>
<a name="ln7191">    struct hl_group *h = &amp;HL_TABLE()[i - 1];</a>
<a name="ln7192">    if (h-&gt;sg_attr &gt; 0) {</a>
<a name="ln7193">      attrs = hlattrs2dict(syn_attr2entry(h-&gt;sg_attr), true);</a>
<a name="ln7194">    } else if (h-&gt;sg_link &gt; 0) {</a>
<a name="ln7195">      const char *link = (const char *)HL_TABLE()[h-&gt;sg_link - 1].sg_name;</a>
<a name="ln7196">      PUT(attrs, &quot;link&quot;, STRING_OBJ(cstr_to_string(link)));</a>
<a name="ln7197">    }</a>
<a name="ln7198">    PUT(rv, (const char *)h-&gt;sg_name, DICTIONARY_OBJ(attrs));</a>
<a name="ln7199">  }</a>
<a name="ln7200"> </a>
<a name="ln7201">  return rv;</a>
<a name="ln7202">}</a>
<a name="ln7203"> </a>
<a name="ln7204">/// Outputs a highlight when doing &quot;:hi MyHighlight&quot;</a>
<a name="ln7205">///</a>
<a name="ln7206">/// @param type one of \ref LIST_XXX</a>
<a name="ln7207">/// @param iarg integer argument used if \p type == LIST_INT</a>
<a name="ln7208">/// @param sarg string used if \p type == LIST_STRING</a>
<a name="ln7209">static bool highlight_list_arg(</a>
<a name="ln7210">    const int id, bool didh, const int type, int iarg,</a>
<a name="ln7211">    char *const sarg, const char *const name)</a>
<a name="ln7212">{</a>
<a name="ln7213">  char buf[100];</a>
<a name="ln7214"> </a>
<a name="ln7215">  if (got_int) {</a>
<a name="ln7216">    return false;</a>
<a name="ln7217">  }</a>
<a name="ln7218">  if (type == LIST_STRING ? (sarg != NULL) : (iarg != 0)) {</a>
<a name="ln7219">    char *ts = buf;</a>
<a name="ln7220">    if (type == LIST_INT) {</a>
<a name="ln7221">      snprintf((char *)buf, sizeof(buf), &quot;%d&quot;, iarg - 1);</a>
<a name="ln7222">    } else if (type == LIST_STRING) {</a>
<a name="ln7223">      ts = sarg;</a>
<a name="ln7224">    } else {    // type == LIST_ATTR</a>
<a name="ln7225">      buf[0] = NUL;</a>
<a name="ln7226">      for (int i = 0; hl_attr_table[i] != 0; i++) {</a>
<a name="ln7227">        if (iarg &amp; hl_attr_table[i]) {</a>
<a name="ln7228">          if (buf[0] != NUL)</a>
<a name="ln7229">            xstrlcat((char *)buf, &quot;,&quot;, 100);</a>
<a name="ln7230">          xstrlcat((char *)buf, hl_name_table[i], 100);</a>
<a name="ln7231">          iarg &amp;= ~hl_attr_table[i];                /* don't want &quot;inverse&quot; */</a>
<a name="ln7232">        }</a>
<a name="ln7233">      }</a>
<a name="ln7234">    }</a>
<a name="ln7235"> </a>
<a name="ln7236">    (void)syn_list_header(didh, (int)(vim_strsize((char_u *)ts) + STRLEN(name)</a>
<a name="ln7237">                                      + 1), id, false);</a>
<a name="ln7238">    didh = true;</a>
<a name="ln7239">    if (!got_int) {</a>
<a name="ln7240">      if (*name != NUL) {</a>
<a name="ln7241">        MSG_PUTS_ATTR(name, HL_ATTR(HLF_D));</a>
<a name="ln7242">        MSG_PUTS_ATTR(&quot;=&quot;, HL_ATTR(HLF_D));</a>
<a name="ln7243">      }</a>
<a name="ln7244">      msg_outtrans((char_u *)ts);</a>
<a name="ln7245">    }</a>
<a name="ln7246">  }</a>
<a name="ln7247">  return didh;</a>
<a name="ln7248">}</a>
<a name="ln7249"> </a>
<a name="ln7250">/// Check whether highlight group has attribute</a>
<a name="ln7251">///</a>
<a name="ln7252">/// @param[in]  id  Highlight group to check.</a>
<a name="ln7253">/// @param[in]  flag  Attribute to check.</a>
<a name="ln7254">/// @param[in]  modec  'g' for GUI, 'c' for term.</a>
<a name="ln7255">///</a>
<a name="ln7256">/// @return &quot;1&quot; if highlight group has attribute, NULL otherwise.</a>
<a name="ln7257">const char *highlight_has_attr(const int id, const int flag, const int modec)</a>
<a name="ln7258">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln7259">{</a>
<a name="ln7260">  int attr;</a>
<a name="ln7261"> </a>
<a name="ln7262">  if (id &lt;= 0 || id &gt; highlight_ga.ga_len) {</a>
<a name="ln7263">    return NULL;</a>
<a name="ln7264">  }</a>
<a name="ln7265"> </a>
<a name="ln7266">  if (modec == 'g') {</a>
<a name="ln7267">    attr = HL_TABLE()[id - 1].sg_gui;</a>
<a name="ln7268">  } else {</a>
<a name="ln7269">    attr = HL_TABLE()[id - 1].sg_cterm;</a>
<a name="ln7270">  }</a>
<a name="ln7271"> </a>
<a name="ln7272">  return (attr &amp; flag) ? &quot;1&quot; : NULL;</a>
<a name="ln7273">}</a>
<a name="ln7274"> </a>
<a name="ln7275">/// Return color name of the given highlight group</a>
<a name="ln7276">///</a>
<a name="ln7277">/// @param[in]  id  Highlight group to work with.</a>
<a name="ln7278">/// @param[in]  what  What to return: one of &quot;font&quot;, &quot;fg&quot;, &quot;bg&quot;, &quot;sp&quot;, &quot;fg#&quot;,</a>
<a name="ln7279">///                   &quot;bg#&quot; or &quot;sp#&quot;.</a>
<a name="ln7280">/// @param[in]  modec  'g' for GUI, 'c' for cterm and 't' for term.</a>
<a name="ln7281">///</a>
<a name="ln7282">/// @return color name, possibly in a static buffer. Buffer will be overwritten</a>
<a name="ln7283">///         on next highlight_color() call. May return NULL.</a>
<a name="ln7284">const char *highlight_color(const int id, const char *const what,</a>
<a name="ln7285">                            const int modec)</a>
<a name="ln7286">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7287">{</a>
<a name="ln7288">  static char name[20];</a>
<a name="ln7289">  int n;</a>
<a name="ln7290">  bool fg = false;</a>
<a name="ln7291">  bool sp = false;</a>
<a name="ln7292">  bool font = false;</a>
<a name="ln7293"> </a>
<a name="ln7294">  if (id &lt;= 0 || id &gt; highlight_ga.ga_len) {</a>
<a name="ln7295">    return NULL;</a>
<a name="ln7296">  }</a>
<a name="ln7297"> </a>
<a name="ln7298">  if (TOLOWER_ASC(what[0]) == 'f' &amp;&amp; TOLOWER_ASC(what[1]) == 'g') {</a>
<a name="ln7299">    fg = true;</a>
<a name="ln7300">  } else if (TOLOWER_ASC(what[0]) == 'f' &amp;&amp; TOLOWER_ASC(what[1]) == 'o'</a>
<a name="ln7301">             &amp;&amp; TOLOWER_ASC(what[2]) == 'n' &amp;&amp; TOLOWER_ASC(what[3]) == 't') {</a>
<a name="ln7302">    font = true;</a>
<a name="ln7303">  } else if (TOLOWER_ASC(what[0]) == 's' &amp;&amp; TOLOWER_ASC(what[1]) == 'p') {</a>
<a name="ln7304">    sp = true;</a>
<a name="ln7305">  } else if (!(TOLOWER_ASC(what[0]) == 'b' &amp;&amp; TOLOWER_ASC(what[1]) == 'g')) {</a>
<a name="ln7306">    return NULL;</a>
<a name="ln7307">  }</a>
<a name="ln7308">  if (modec == 'g') {</a>
<a name="ln7309">    if (what[2] == '#' &amp;&amp; ui_rgb_attached()) {</a>
<a name="ln7310">      if (fg) {</a>
<a name="ln7311">          n = HL_TABLE()[id - 1].sg_rgb_fg;</a>
<a name="ln7312">      } else if (sp) {</a>
<a name="ln7313">          n = HL_TABLE()[id - 1].sg_rgb_sp;</a>
<a name="ln7314">      } else {</a>
<a name="ln7315">          n = HL_TABLE()[id - 1].sg_rgb_bg;</a>
<a name="ln7316">      }</a>
<a name="ln7317">      if (n &lt; 0 || n &gt; 0xffffff) {</a>
<a name="ln7318">        return NULL;</a>
<a name="ln7319">      }</a>
<a name="ln7320">      snprintf(name, sizeof(name), &quot;#%06x&quot;, n);</a>
<a name="ln7321">      return name;</a>
<a name="ln7322">    }</a>
<a name="ln7323">    if (fg) {</a>
<a name="ln7324">      return (const char *)HL_TABLE()[id - 1].sg_rgb_fg_name;</a>
<a name="ln7325">    }</a>
<a name="ln7326">    if (sp) {</a>
<a name="ln7327">      return (const char *)HL_TABLE()[id - 1].sg_rgb_sp_name;</a>
<a name="ln7328">    }</a>
<a name="ln7329">    return (const char *)HL_TABLE()[id - 1].sg_rgb_bg_name;</a>
<a name="ln7330">  }</a>
<a name="ln7331">  if (font || sp) {</a>
<a name="ln7332">    return NULL;</a>
<a name="ln7333">  }</a>
<a name="ln7334">  if (modec == 'c') {</a>
<a name="ln7335">    if (fg) {</a>
<a name="ln7336">      n = HL_TABLE()[id - 1].sg_cterm_fg - 1;</a>
<a name="ln7337">    } else {</a>
<a name="ln7338">      n = HL_TABLE()[id - 1].sg_cterm_bg - 1;</a>
<a name="ln7339">    }</a>
<a name="ln7340">    if (n &lt; 0) {</a>
<a name="ln7341">      return NULL;</a>
<a name="ln7342">    }</a>
<a name="ln7343">    snprintf(name, sizeof(name), &quot;%d&quot;, n);</a>
<a name="ln7344">    return name;</a>
<a name="ln7345">  }</a>
<a name="ln7346">  // term doesn't have color.</a>
<a name="ln7347">  return NULL;</a>
<a name="ln7348">}</a>
<a name="ln7349"> </a>
<a name="ln7350">/// Output the syntax list header.</a>
<a name="ln7351">///</a>
<a name="ln7352">/// @param did_header did header already</a>
<a name="ln7353">/// @param outlen length of string that comes</a>
<a name="ln7354">/// @param id highlight group id</a>
<a name="ln7355">/// @param force_newline always start a new line</a>
<a name="ln7356">/// @return true when started a new line.</a>
<a name="ln7357">static bool syn_list_header(const bool did_header, const int outlen,</a>
<a name="ln7358">                            const int id, bool force_newline)</a>
<a name="ln7359">{</a>
<a name="ln7360">  int endcol = 19;</a>
<a name="ln7361">  bool newline = true;</a>
<a name="ln7362">  bool adjust = true;</a>
<a name="ln7363"> </a>
<a name="ln7364">  if (!did_header) {</a>
<a name="ln7365">    msg_putchar('\n');</a>
<a name="ln7366">    if (got_int) {</a>
<a name="ln7367">      return true;</a>
<a name="ln7368">    }</a>
<a name="ln7369">    msg_outtrans(HL_TABLE()[id - 1].sg_name);</a>
<a name="ln7370">    endcol = 15;</a>
<a name="ln7371">  } else if ((ui_has(kUIMessages) || msg_silent) &amp;&amp; !force_newline) {</a>
<a name="ln7372">    msg_putchar(' ');</a>
<a name="ln7373">    adjust = false;</a>
<a name="ln7374">  } else if (msg_col + outlen + 1 &gt;= Columns || force_newline)   {</a>
<a name="ln7375">    msg_putchar('\n');</a>
<a name="ln7376">    if (got_int) {</a>
<a name="ln7377">      return true;</a>
<a name="ln7378">    }</a>
<a name="ln7379">  } else {</a>
<a name="ln7380">    if (msg_col &gt;= endcol) {    // wrap around is like starting a new line</a>
<a name="ln7381">      newline = false;</a>
<a name="ln7382">    }</a>
<a name="ln7383">  }</a>
<a name="ln7384"> </a>
<a name="ln7385">  if (adjust) {</a>
<a name="ln7386">    if (msg_col &gt;= endcol) {</a>
<a name="ln7387">      // output at least one space</a>
<a name="ln7388">      endcol = msg_col + 1;</a>
<a name="ln7389">    }</a>
<a name="ln7390"> </a>
<a name="ln7391">    msg_advance(endcol);</a>
<a name="ln7392">  }</a>
<a name="ln7393"> </a>
<a name="ln7394">  /* Show &quot;xxx&quot; with the attributes. */</a>
<a name="ln7395">  if (!did_header) {</a>
<a name="ln7396">    msg_puts_attr(&quot;xxx&quot;, syn_id2attr(id));</a>
<a name="ln7397">    msg_putchar(' ');</a>
<a name="ln7398">  }</a>
<a name="ln7399"> </a>
<a name="ln7400">  return newline;</a>
<a name="ln7401">}</a>
<a name="ln7402"> </a>
<a name="ln7403">/// Set the attribute numbers for a highlight group.</a>
<a name="ln7404">/// Called after one of the attributes has changed.</a>
<a name="ln7405">/// @param idx corrected highlight index</a>
<a name="ln7406">static void set_hl_attr(int idx)</a>
<a name="ln7407">{</a>
<a name="ln7408">  HlAttrs at_en = HLATTRS_INIT;</a>
<a name="ln7409">  struct hl_group     *sgp = HL_TABLE() + idx;</a>
<a name="ln7410"> </a>
<a name="ln7411">  at_en.cterm_ae_attr = sgp-&gt;sg_cterm;</a>
<a name="ln7412">  at_en.cterm_fg_color = sgp-&gt;sg_cterm_fg;</a>
<a name="ln7413">  at_en.cterm_bg_color = sgp-&gt;sg_cterm_bg;</a>
<a name="ln7414">  at_en.rgb_ae_attr = sgp-&gt;sg_gui;</a>
<a name="ln7415">  // FIXME(tarruda): The &quot;unset value&quot; for rgb is -1, but since hlgroup is</a>
<a name="ln7416">  // initialized with 0(by garray functions), check for sg_rgb_{f,b}g_name</a>
<a name="ln7417">  // before setting attr_entry-&gt;{f,g}g_color to a other than -1</a>
<a name="ln7418">  at_en.rgb_fg_color = sgp-&gt;sg_rgb_fg_name ? sgp-&gt;sg_rgb_fg : -1;</a>
<a name="ln7419">  at_en.rgb_bg_color = sgp-&gt;sg_rgb_bg_name ? sgp-&gt;sg_rgb_bg : -1;</a>
<a name="ln7420">  at_en.rgb_sp_color = sgp-&gt;sg_rgb_sp_name ? sgp-&gt;sg_rgb_sp : -1;</a>
<a name="ln7421">  at_en.hl_blend = sgp-&gt;sg_blend;</a>
<a name="ln7422"> </a>
<a name="ln7423">  sgp-&gt;sg_attr = hl_get_syn_attr(0, idx+1, at_en);</a>
<a name="ln7424"> </a>
<a name="ln7425">  // a cursor style uses this syn_id, make sure its attribute is updated.</a>
<a name="ln7426">  if (cursor_mode_uses_syn_id(idx+1)) {</a>
<a name="ln7427">    ui_mode_info_set();</a>
<a name="ln7428">  }</a>
<a name="ln7429">}</a>
<a name="ln7430"> </a>
<a name="ln7431">/// Lookup a highlight group name and return its ID.</a>
<a name="ln7432">///</a>
<a name="ln7433">/// @param highlight name e.g. 'Cursor', 'Normal'</a>
<a name="ln7434">/// @return the highlight id, else 0 if \p name does not exist</a>
<a name="ln7435">int syn_name2id(const char_u *name)</a>
<a name="ln7436">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7437">{</a>
<a name="ln7438">  int i;</a>
<a name="ln7439">  char_u name_u[200];</a>
<a name="ln7440"> </a>
<a name="ln7441">  /* Avoid using stricmp() too much, it's slow on some systems */</a>
<a name="ln7442">  /* Avoid alloc()/free(), these are slow too.  ID names over 200 chars</a>
<a name="ln7443">   * don't deserve to be found! */</a>
<a name="ln7444">  STRLCPY(name_u, name, 200);</a>
<a name="ln7445">  vim_strup(name_u);</a>
<a name="ln7446">  for (i = highlight_ga.ga_len; --i &gt;= 0; )</a>
<a name="ln7447">    if (HL_TABLE()[i].sg_name_u != NULL</a>
<a name="ln7448">        &amp;&amp; STRCMP(name_u, HL_TABLE()[i].sg_name_u) == 0)</a>
<a name="ln7449">      break;</a>
<a name="ln7450">  return i + 1;</a>
<a name="ln7451">}</a>
<a name="ln7452"> </a>
<a name="ln7453">/// Lookup a highlight group name and return its attributes.</a>
<a name="ln7454">/// Return zero if not found.</a>
<a name="ln7455">int syn_name2attr(const char_u *name)</a>
<a name="ln7456">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7457">{</a>
<a name="ln7458">  int id = syn_name2id(name);</a>
<a name="ln7459"> </a>
<a name="ln7460">  if (id != 0) {</a>
<a name="ln7461">    return syn_id2attr(id);</a>
<a name="ln7462">  }</a>
<a name="ln7463">  return 0;</a>
<a name="ln7464">}</a>
<a name="ln7465"> </a>
<a name="ln7466">/*</a>
<a name="ln7467"> * Return TRUE if highlight group &quot;name&quot; exists.</a>
<a name="ln7468"> */</a>
<a name="ln7469">int highlight_exists(const char_u *name)</a>
<a name="ln7470">{</a>
<a name="ln7471">  return syn_name2id(name) &gt; 0;</a>
<a name="ln7472">}</a>
<a name="ln7473"> </a>
<a name="ln7474">/*</a>
<a name="ln7475"> * Return the name of highlight group &quot;id&quot;.</a>
<a name="ln7476"> * When not a valid ID return an empty string.</a>
<a name="ln7477"> */</a>
<a name="ln7478">char_u *syn_id2name(int id)</a>
<a name="ln7479">{</a>
<a name="ln7480">  if (id &lt;= 0 || id &gt; highlight_ga.ga_len)</a>
<a name="ln7481">    return (char_u *)&quot;&quot;;</a>
<a name="ln7482">  return HL_TABLE()[id - 1].sg_name;</a>
<a name="ln7483">}</a>
<a name="ln7484"> </a>
<a name="ln7485">/*</a>
<a name="ln7486"> * Like syn_name2id(), but take a pointer + length argument.</a>
<a name="ln7487"> */</a>
<a name="ln7488">int syn_namen2id(const char_u *linep, int len)</a>
<a name="ln7489">{</a>
<a name="ln7490">  char_u *name = vim_strnsave(linep, len);</a>
<a name="ln7491">  int id = syn_name2id(name);</a>
<a name="ln7492">  xfree(name);</a>
<a name="ln7493"> </a>
<a name="ln7494">  return id;</a>
<a name="ln7495">}</a>
<a name="ln7496"> </a>
<a name="ln7497">/// Find highlight group name in the table and return its ID.</a>
<a name="ln7498">/// If it doesn't exist yet, a new entry is created.</a>
<a name="ln7499">///</a>
<a name="ln7500">/// @param pp Highlight group name</a>
<a name="ln7501">/// @param len length of \p pp</a>
<a name="ln7502">///</a>
<a name="ln7503">/// @return 0 for failure else the id of the group</a>
<a name="ln7504">int syn_check_group(const char_u *pp, int len)</a>
<a name="ln7505">{</a>
<a name="ln7506">  char_u  *name = vim_strnsave(pp, len);</a>
<a name="ln7507">  int id = syn_name2id(name);</a>
<a name="ln7508">  if (id == 0) {  // doesn't exist yet</a>
<a name="ln7509">    id = syn_add_group(name);</a>
<a name="ln7510">  } else {</a>
<a name="ln7511">    xfree(name);</a>
<a name="ln7512">  }</a>
<a name="ln7513">  return id;</a>
<a name="ln7514">}</a>
<a name="ln7515"> </a>
<a name="ln7516">/// Add new highlight group and return its ID.</a>
<a name="ln7517">///</a>
<a name="ln7518">/// @param name must be an allocated string, it will be consumed.</a>
<a name="ln7519">/// @return 0 for failure, else the allocated group id</a>
<a name="ln7520">/// @see syn_check_group syn_unadd_group</a>
<a name="ln7521">static int syn_add_group(char_u *name)</a>
<a name="ln7522">{</a>
<a name="ln7523">  char_u      *p;</a>
<a name="ln7524"> </a>
<a name="ln7525">  /* Check that the name is ASCII letters, digits and underscore. */</a>
<a name="ln7526">  for (p = name; *p != NUL; ++p) {</a>
<a name="ln7527">    if (!vim_isprintc(*p)) {</a>
<a name="ln7528">      EMSG(_(&quot;E669: Unprintable character in group name&quot;));</a>
<a name="ln7529">      xfree(name);</a>
<a name="ln7530">      return 0;</a>
<a name="ln7531">    } else if (!ASCII_ISALNUM(*p) &amp;&amp; *p != '_')   {</a>
<a name="ln7532">      /* This is an error, but since there previously was no check only</a>
<a name="ln7533">       * give a warning. */</a>
<a name="ln7534">      msg_source(HL_ATTR(HLF_W));</a>
<a name="ln7535">      MSG(_(&quot;W18: Invalid character in group name&quot;));</a>
<a name="ln7536">      break;</a>
<a name="ln7537">    }</a>
<a name="ln7538">  }</a>
<a name="ln7539"> </a>
<a name="ln7540">  /*</a>
<a name="ln7541">   * First call for this growarray: init growing array.</a>
<a name="ln7542">   */</a>
<a name="ln7543">  if (highlight_ga.ga_data == NULL) {</a>
<a name="ln7544">    highlight_ga.ga_itemsize = sizeof(struct hl_group);</a>
<a name="ln7545">    ga_set_growsize(&amp;highlight_ga, 10);</a>
<a name="ln7546">  }</a>
<a name="ln7547"> </a>
<a name="ln7548">  if (highlight_ga.ga_len &gt;= MAX_HL_ID) {</a>
<a name="ln7549">    EMSG(_(&quot;E849: Too many highlight and syntax groups&quot;));</a>
<a name="ln7550">    xfree(name);</a>
<a name="ln7551">    return 0;</a>
<a name="ln7552">  }</a>
<a name="ln7553"> </a>
<a name="ln7554">  char_u *const name_up = vim_strsave_up(name);</a>
<a name="ln7555"> </a>
<a name="ln7556">  // Append another syntax_highlight entry.</a>
<a name="ln7557">  struct hl_group* hlgp = GA_APPEND_VIA_PTR(struct hl_group, &amp;highlight_ga);</a>
<a name="ln7558">  memset(hlgp, 0, sizeof(*hlgp));</a>
<a name="ln7559">  hlgp-&gt;sg_name = name;</a>
<a name="ln7560">  hlgp-&gt;sg_rgb_bg = -1;</a>
<a name="ln7561">  hlgp-&gt;sg_rgb_fg = -1;</a>
<a name="ln7562">  hlgp-&gt;sg_rgb_sp = -1;</a>
<a name="ln7563">  hlgp-&gt;sg_blend = -1;</a>
<a name="ln7564">  hlgp-&gt;sg_name_u = name_up;</a>
<a name="ln7565"> </a>
<a name="ln7566">  return highlight_ga.ga_len;               /* ID is index plus one */</a>
<a name="ln7567">}</a>
<a name="ln7568"> </a>
<a name="ln7569">/// When, just after calling syn_add_group(), an error is discovered, this</a>
<a name="ln7570">/// function deletes the new name.</a>
<a name="ln7571">static void syn_unadd_group(void)</a>
<a name="ln7572">{</a>
<a name="ln7573">  highlight_ga.ga_len--;</a>
<a name="ln7574">  xfree(HL_TABLE()[highlight_ga.ga_len].sg_name);</a>
<a name="ln7575">  xfree(HL_TABLE()[highlight_ga.ga_len].sg_name_u);</a>
<a name="ln7576">}</a>
<a name="ln7577"> </a>
<a name="ln7578"> </a>
<a name="ln7579">/// Translate a group ID to highlight attributes.</a>
<a name="ln7580">/// @see syn_attr2entry</a>
<a name="ln7581">int syn_id2attr(int hl_id)</a>
<a name="ln7582">{</a>
<a name="ln7583">  hl_id = syn_get_final_id(hl_id);</a>
<a name="ln7584">  struct hl_group *sgp = &amp;HL_TABLE()[hl_id - 1];  // index is ID minus one</a>
<a name="ln7585"> </a>
<a name="ln7586">  int attr = ns_get_hl(-1, hl_id, false, sgp-&gt;sg_set);</a>
<a name="ln7587">  if (attr &gt;= 0) {</a>
<a name="ln7588">    return attr;</a>
<a name="ln7589">  }</a>
<a name="ln7590">  return sgp-&gt;sg_attr;</a>
<a name="ln7591">}</a>
<a name="ln7592"> </a>
<a name="ln7593"> </a>
<a name="ln7594"> </a>
<a name="ln7595"> </a>
<a name="ln7596">/*</a>
<a name="ln7597"> * Translate a group ID to the final group ID (following links).</a>
<a name="ln7598"> */</a>
<a name="ln7599">int syn_get_final_id(int hl_id)</a>
<a name="ln7600">{</a>
<a name="ln7601">  int count;</a>
<a name="ln7602"> </a>
<a name="ln7603">  if (hl_id &gt; highlight_ga.ga_len || hl_id &lt; 1)</a>
<a name="ln7604">    return 0;                           /* Can be called from eval!! */</a>
<a name="ln7605"> </a>
<a name="ln7606">  /*</a>
<a name="ln7607">   * Follow links until there is no more.</a>
<a name="ln7608">   * Look out for loops!  Break after 100 links.</a>
<a name="ln7609">   */</a>
<a name="ln7610">  for (count = 100; --count &gt;= 0; ) {</a>
<a name="ln7611">    struct hl_group *sgp = &amp;HL_TABLE()[hl_id - 1];  // index is ID minus one</a>
<a name="ln7612"> </a>
<a name="ln7613">    // ACHTUNG: when using &quot;tmp&quot; attribute (no link) the function might be</a>
<a name="ln7614">    // called twice. it needs be smart enough to remember attr only to</a>
<a name="ln7615">    // syn_id2attr time</a>
<a name="ln7616">    int check = ns_get_hl(-1, hl_id, true, sgp-&gt;sg_set);</a>
<a name="ln7617">    if (check == 0) {</a>
<a name="ln7618">      return hl_id;  // how dare! it broke the link!</a>
<a name="ln7619">    } else if (check &gt; 0) {</a>
<a name="ln7620">      hl_id = check;</a>
<a name="ln7621">      continue;</a>
<a name="ln7622">    }</a>
<a name="ln7623"> </a>
<a name="ln7624"> </a>
<a name="ln7625">    if (sgp-&gt;sg_link == 0 || sgp-&gt;sg_link &gt; highlight_ga.ga_len) {</a>
<a name="ln7626">      break;</a>
<a name="ln7627">    }</a>
<a name="ln7628">    hl_id = sgp-&gt;sg_link;</a>
<a name="ln7629">  }</a>
<a name="ln7630"> </a>
<a name="ln7631">  return hl_id;</a>
<a name="ln7632">}</a>
<a name="ln7633"> </a>
<a name="ln7634">/// Refresh the color attributes of all highlight groups.</a>
<a name="ln7635">void highlight_attr_set_all(void)</a>
<a name="ln7636">{</a>
<a name="ln7637">  for (int idx = 0; idx &lt; highlight_ga.ga_len; idx++) {</a>
<a name="ln7638">    struct hl_group *sgp = &amp;HL_TABLE()[idx];</a>
<a name="ln7639">    if (sgp-&gt;sg_rgb_bg_name != NULL) {</a>
<a name="ln7640">      sgp-&gt;sg_rgb_bg = name_to_color(sgp-&gt;sg_rgb_bg_name);</a>
<a name="ln7641">    }</a>
<a name="ln7642">    if (sgp-&gt;sg_rgb_fg_name != NULL) {</a>
<a name="ln7643">      sgp-&gt;sg_rgb_fg = name_to_color(sgp-&gt;sg_rgb_fg_name);</a>
<a name="ln7644">    }</a>
<a name="ln7645">    if (sgp-&gt;sg_rgb_sp_name != NULL) {</a>
<a name="ln7646">      sgp-&gt;sg_rgb_sp = name_to_color(sgp-&gt;sg_rgb_sp_name);</a>
<a name="ln7647">    }</a>
<a name="ln7648">    set_hl_attr(idx);</a>
<a name="ln7649">  }</a>
<a name="ln7650">}</a>
<a name="ln7651"> </a>
<a name="ln7652">// Apply difference between User[1-9] and HLF_S to HLF_SNC.</a>
<a name="ln7653">static void combine_stl_hlt(int id, int id_S, int id_alt, int hlcnt, int i,</a>
<a name="ln7654">                            int hlf, int *table)</a>
<a name="ln7655">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7656">{</a>
<a name="ln7657">  struct hl_group *const hlt = HL_TABLE();</a>
<a name="ln7658"> </a>
<a name="ln7659">  if (id_alt == 0) {</a>
<a name="ln7660">    memset(&amp;hlt[hlcnt + i], 0, sizeof(struct hl_group));</a>
<a name="ln7661">    hlt[hlcnt + i].sg_cterm = highlight_attr[hlf];</a>
<a name="ln7662">    hlt[hlcnt + i].sg_gui = highlight_attr[hlf];</a>
<a name="ln7663">  } else {</a>
<a name="ln7664">    memmove(&amp;hlt[hlcnt + i], &amp;hlt[id_alt - 1], sizeof(struct hl_group));</a>
<a name="ln7665">  }</a>
<a name="ln7666">  hlt[hlcnt + i].sg_link = 0;</a>
<a name="ln7667"> </a>
<a name="ln7668">  hlt[hlcnt + i].sg_cterm ^= hlt[id - 1].sg_cterm ^ hlt[id_S - 1].sg_cterm;</a>
<a name="ln7669">  if (hlt[id - 1].sg_cterm_fg != hlt[id_S - 1].sg_cterm_fg) {</a>
<a name="ln7670">    hlt[hlcnt + i].sg_cterm_fg = hlt[id - 1].sg_cterm_fg;</a>
<a name="ln7671">  }</a>
<a name="ln7672">  if (hlt[id - 1].sg_cterm_bg != hlt[id_S - 1].sg_cterm_bg) {</a>
<a name="ln7673">    hlt[hlcnt + i].sg_cterm_bg = hlt[id - 1].sg_cterm_bg;</a>
<a name="ln7674">  }</a>
<a name="ln7675">  hlt[hlcnt + i].sg_gui ^= hlt[id - 1].sg_gui ^ hlt[id_S - 1].sg_gui;</a>
<a name="ln7676">  if (hlt[id - 1].sg_rgb_fg != hlt[id_S - 1].sg_rgb_fg) {</a>
<a name="ln7677">    hlt[hlcnt + i].sg_rgb_fg = hlt[id - 1].sg_rgb_fg;</a>
<a name="ln7678">  }</a>
<a name="ln7679">  if (hlt[id - 1].sg_rgb_bg != hlt[id_S - 1].sg_rgb_bg) {</a>
<a name="ln7680">    hlt[hlcnt + i].sg_rgb_bg = hlt[id - 1].sg_rgb_bg;</a>
<a name="ln7681">  }</a>
<a name="ln7682">  if (hlt[id - 1].sg_rgb_sp != hlt[id_S - 1].sg_rgb_sp) {</a>
<a name="ln7683">    hlt[hlcnt + i].sg_rgb_sp = hlt[id - 1].sg_rgb_sp;</a>
<a name="ln7684">  }</a>
<a name="ln7685">  highlight_ga.ga_len = hlcnt + i + 1;</a>
<a name="ln7686">  set_hl_attr(hlcnt + i);  // At long last we can apply</a>
<a name="ln7687">  table[i] = syn_id2attr(hlcnt + i + 1);</a>
<a name="ln7688">}</a>
<a name="ln7689"> </a>
<a name="ln7690">/// Translate highlight groups into attributes in highlight_attr[] and set up</a>
<a name="ln7691">/// the user highlights User1..9. A set of corresponding highlights to use on</a>
<a name="ln7692">/// top of HLF_SNC is computed.  Called only when nvim starts and upon first</a>
<a name="ln7693">/// screen redraw after any :highlight command.</a>
<a name="ln7694">void highlight_changed(void)</a>
<a name="ln7695">{</a>
<a name="ln7696">  int id;</a>
<a name="ln7697">  char_u userhl[30];  // use 30 to avoid compiler warning</a>
<a name="ln7698">  int id_S = -1;</a>
<a name="ln7699">  int id_SNC = 0;</a>
<a name="ln7700">  int hlcnt;</a>
<a name="ln7701"> </a>
<a name="ln7702">  need_highlight_changed = FALSE;</a>
<a name="ln7703"> </a>
<a name="ln7704">  /// Translate builtin highlight groups into attributes for quick lookup.</a>
<a name="ln7705">  for (int hlf = 0; hlf &lt; (int)HLF_COUNT; hlf++) {</a>
<a name="ln7706">    id = syn_check_group((char_u *)hlf_names[hlf], STRLEN(hlf_names[hlf]));</a>
<a name="ln7707">    if (id == 0) {</a>
<a name="ln7708">      abort();</a>
<a name="ln7709">    }</a>
<a name="ln7710">    int final_id = syn_get_final_id(id);</a>
<a name="ln7711">    if (hlf == (int)HLF_SNC) {</a>
<a name="ln7712">      id_SNC = final_id;</a>
<a name="ln7713">    } else if (hlf == (int)HLF_S) {</a>
<a name="ln7714">      id_S = final_id;</a>
<a name="ln7715">    }</a>
<a name="ln7716"> </a>
<a name="ln7717">    highlight_attr[hlf] = hl_get_ui_attr(hlf, final_id,</a>
<a name="ln7718">                                         hlf == (int)HLF_INACTIVE);</a>
<a name="ln7719"> </a>
<a name="ln7720">    if (highlight_attr[hlf] != highlight_attr_last[hlf]) {</a>
<a name="ln7721">      if (hlf == HLF_MSG) {</a>
<a name="ln7722">        clear_cmdline = true;</a>
<a name="ln7723">      }</a>
<a name="ln7724">      ui_call_hl_group_set(cstr_as_string((char *)hlf_names[hlf]),</a>
<a name="ln7725">                           highlight_attr[hlf]);</a>
<a name="ln7726">      highlight_attr_last[hlf] = highlight_attr[hlf];</a>
<a name="ln7727">    }</a>
<a name="ln7728">  }</a>
<a name="ln7729"> </a>
<a name="ln7730">  //</a>
<a name="ln7731">  // Setup the user highlights</a>
<a name="ln7732">  //</a>
<a name="ln7733">  // Temporarily utilize 10 more hl entries:</a>
<a name="ln7734">  // 9 for User1-User9 combined with StatusLineNC</a>
<a name="ln7735">  // 1 for StatusLine default</a>
<a name="ln7736">  // Must to be in there simultaneously in case of table overflows in</a>
<a name="ln7737">  // get_attr_entry()</a>
<a name="ln7738">  ga_grow(&amp;highlight_ga, 10);</a>
<a name="ln7739">  hlcnt = highlight_ga.ga_len;</a>
<a name="ln7740">  if (id_S == -1) {</a>
<a name="ln7741">    // Make sure id_S is always valid to simplify code below. Use the last entry</a>
<a name="ln7742">    memset(&amp;HL_TABLE()[hlcnt + 9], 0, sizeof(struct hl_group));</a>
<a name="ln7743">    id_S = hlcnt + 10;</a>
<a name="ln7744">  }</a>
<a name="ln7745">  for (int i = 0; i &lt; 9; i++) {</a>
<a name="ln7746">    sprintf((char *)userhl, &quot;User%d&quot;, i + 1);</a>
<a name="ln7747">    id = syn_name2id(userhl);</a>
<a name="ln7748">    if (id == 0) {</a>
<a name="ln7749">      highlight_user[i] = 0;</a>
<a name="ln7750">      highlight_stlnc[i] = 0;</a>
<a name="ln7751">    } else {</a>
<a name="ln7752">      highlight_user[i] = syn_id2attr(id);</a>
<a name="ln7753">      combine_stl_hlt(id, id_S, id_SNC, hlcnt, i, HLF_SNC, highlight_stlnc);</a>
<a name="ln7754">    }</a>
<a name="ln7755">  }</a>
<a name="ln7756">  highlight_ga.ga_len = hlcnt;</a>
<a name="ln7757">}</a>
<a name="ln7758"> </a>
<a name="ln7759"> </a>
<a name="ln7760">/*</a>
<a name="ln7761"> * Handle command line completion for :highlight command.</a>
<a name="ln7762"> */</a>
<a name="ln7763">void set_context_in_highlight_cmd(expand_T *xp, const char *arg)</a>
<a name="ln7764">{</a>
<a name="ln7765">  // Default: expand group names.</a>
<a name="ln7766">  xp-&gt;xp_context = EXPAND_HIGHLIGHT;</a>
<a name="ln7767">  xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln7768">  include_link = 2;</a>
<a name="ln7769">  include_default = 1;</a>
<a name="ln7770"> </a>
<a name="ln7771">  /* (part of) subcommand already typed */</a>
<a name="ln7772">  if (*arg != NUL) {</a>
<a name="ln7773">    const char *p = (const char *)skiptowhite((const char_u *)arg);</a>
<a name="ln7774">    if (*p != NUL) {  // Past &quot;default&quot; or group name.</a>
<a name="ln7775">      include_default = 0;</a>
<a name="ln7776">      if (strncmp(&quot;default&quot;, arg, p - arg) == 0) {</a>
<a name="ln7777">        arg = (const char *)skipwhite((const char_u *)p);</a>
<a name="ln7778">        xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln7779">        p = (const char *)skiptowhite((const char_u *)arg);</a>
<a name="ln7780">      }</a>
<a name="ln7781">      if (*p != NUL) {                          /* past group name */</a>
<a name="ln7782">        include_link = 0;</a>
<a name="ln7783">        if (arg[1] == 'i' &amp;&amp; arg[0] == 'N') {</a>
<a name="ln7784">          highlight_list();</a>
<a name="ln7785">        }</a>
<a name="ln7786">        if (strncmp(&quot;link&quot;, arg, p - arg) == 0</a>
<a name="ln7787">            || strncmp(&quot;clear&quot;, arg, p - arg) == 0) {</a>
<a name="ln7788">          xp-&gt;xp_pattern = skipwhite((const char_u *)p);</a>
<a name="ln7789">          p = (const char *)skiptowhite(xp-&gt;xp_pattern);</a>
<a name="ln7790">          if (*p != NUL) {  // Past first group name.</a>
<a name="ln7791">            xp-&gt;xp_pattern = skipwhite((const char_u *)p);</a>
<a name="ln7792">            p = (const char *)skiptowhite(xp-&gt;xp_pattern);</a>
<a name="ln7793">          }</a>
<a name="ln7794">        }</a>
<a name="ln7795">        if (*p != NUL) {  // Past group name(s).</a>
<a name="ln7796">          xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln7797">        }</a>
<a name="ln7798">      }</a>
<a name="ln7799">    }</a>
<a name="ln7800">  }</a>
<a name="ln7801">}</a>
<a name="ln7802"> </a>
<a name="ln7803">/*</a>
<a name="ln7804"> * List highlighting matches in a nice way.</a>
<a name="ln7805"> */</a>
<a name="ln7806">static void highlight_list(void)</a>
<a name="ln7807">{</a>
<a name="ln7808">  int i;</a>
<a name="ln7809"> </a>
<a name="ln7810">  for (i = 10; --i &gt;= 0; ) {</a>
<a name="ln7811">    highlight_list_two(i, HL_ATTR(HLF_D));</a>
<a name="ln7812">  }</a>
<a name="ln7813">  for (i = 40; --i &gt;= 0; ) {</a>
<a name="ln7814">    highlight_list_two(99, 0);</a>
<a name="ln7815">  }</a>
<a name="ln7816">}</a>
<a name="ln7817"> </a>
<a name="ln7818">static void highlight_list_two(int cnt, int attr)</a>
<a name="ln7819">{</a>
<a name="ln7820">  msg_puts_attr(&amp;(&quot;N \bI \b!  \b&quot;[cnt / 11]), attr);</a>
<a name="ln7821">  msg_clr_eos();</a>
<a name="ln7822">  ui_flush();</a>
<a name="ln7823">  os_delay(cnt == 99 ? 40L : (long)cnt * 50L, false);</a>
<a name="ln7824">}</a>
<a name="ln7825"> </a>
<a name="ln7826"> </a>
<a name="ln7827">/// Function given to ExpandGeneric() to obtain the list of group names.</a>
<a name="ln7828">const char *get_highlight_name(expand_T *const xp, int idx)</a>
<a name="ln7829">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7830">{</a>
<a name="ln7831">  return get_highlight_name_ext(xp, idx, true);</a>
<a name="ln7832">}</a>
<a name="ln7833"> </a>
<a name="ln7834"> </a>
<a name="ln7835">/// Obtain a highlight group name.</a>
<a name="ln7836">/// When &quot;skip_cleared&quot; is TRUE don't return a cleared entry.</a>
<a name="ln7837">const char *get_highlight_name_ext(expand_T *xp, int idx, int skip_cleared)</a>
<a name="ln7838">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7839">{</a>
<a name="ln7840">  if (idx &lt; 0) {</a>
<a name="ln7841">    return NULL;</a>
<a name="ln7842">  }</a>
<a name="ln7843"> </a>
<a name="ln7844">  // Items are never removed from the table, skip the ones that were cleared.</a>
<a name="ln7845">  if (skip_cleared &amp;&amp; idx &lt; highlight_ga.ga_len &amp;&amp; HL_TABLE()[idx].sg_cleared) {</a>
<a name="ln7846">    return &quot;&quot;;</a>
<a name="ln7847">  }</a>
<a name="ln7848"> </a>
<a name="ln7849">  if (idx == highlight_ga.ga_len &amp;&amp; include_none != 0) {</a>
<a name="ln7850">    return &quot;none&quot;;</a>
<a name="ln7851">  } else if (idx == highlight_ga.ga_len + include_none</a>
<a name="ln7852">             &amp;&amp; include_default != 0) {</a>
<a name="ln7853">    return &quot;default&quot;;</a>
<a name="ln7854">  } else if (idx == highlight_ga.ga_len + include_none + include_default</a>
<a name="ln7855">             &amp;&amp; include_link != 0) {</a>
<a name="ln7856">    return &quot;link&quot;;</a>
<a name="ln7857">  } else if (idx == highlight_ga.ga_len + include_none + include_default + 1</a>
<a name="ln7858">             &amp;&amp; include_link != 0) {</a>
<a name="ln7859">    return &quot;clear&quot;;</a>
<a name="ln7860">  } else if (idx &gt;= highlight_ga.ga_len) {</a>
<a name="ln7861">    return NULL;</a>
<a name="ln7862">  }</a>
<a name="ln7863">  return (const char *)HL_TABLE()[idx].sg_name;</a>
<a name="ln7864">}</a>
<a name="ln7865"> </a>
<a name="ln7866">color_name_table_T color_name_table[] = {</a>
<a name="ln7867">  // Colors from rgb.txt</a>
<a name="ln7868">  { &quot;AliceBlue&quot;, RGB_(0xf0, 0xf8, 0xff) },</a>
<a name="ln7869">  { &quot;AntiqueWhite&quot;, RGB_(0xfa, 0xeb, 0xd7) },</a>
<a name="ln7870">  { &quot;AntiqueWhite1&quot;, RGB_(0xff, 0xef, 0xdb) },</a>
<a name="ln7871">  { &quot;AntiqueWhite2&quot;, RGB_(0xee, 0xdf, 0xcc) },</a>
<a name="ln7872">  { &quot;AntiqueWhite3&quot;, RGB_(0xcd, 0xc0, 0xb0) },</a>
<a name="ln7873">  { &quot;AntiqueWhite4&quot;, RGB_(0x8b, 0x83, 0x78) },</a>
<a name="ln7874">  { &quot;Aqua&quot;, RGB_(0x00, 0xff, 0xff) },</a>
<a name="ln7875">  { &quot;Aquamarine&quot;, RGB_(0x7f, 0xff, 0xd4) },</a>
<a name="ln7876">  { &quot;Aquamarine1&quot;, RGB_(0x7f, 0xff, 0xd4) },</a>
<a name="ln7877">  { &quot;Aquamarine2&quot;, RGB_(0x76, 0xee, 0xc6) },</a>
<a name="ln7878">  { &quot;Aquamarine3&quot;, RGB_(0x66, 0xcd, 0xaa) },</a>
<a name="ln7879">  { &quot;Aquamarine4&quot;, RGB_(0x45, 0x8b, 0x74) },</a>
<a name="ln7880">  { &quot;Azure&quot;, RGB_(0xf0, 0xff, 0xff) },</a>
<a name="ln7881">  { &quot;Azure1&quot;, RGB_(0xf0, 0xff, 0xff) },</a>
<a name="ln7882">  { &quot;Azure2&quot;, RGB_(0xe0, 0xee, 0xee) },</a>
<a name="ln7883">  { &quot;Azure3&quot;, RGB_(0xc1, 0xcd, 0xcd) },</a>
<a name="ln7884">  { &quot;Azure4&quot;, RGB_(0x83, 0x8b, 0x8b) },</a>
<a name="ln7885">  { &quot;Beige&quot;, RGB_(0xf5, 0xf5, 0xdc) },</a>
<a name="ln7886">  { &quot;Bisque&quot;, RGB_(0xff, 0xe4, 0xc4) },</a>
<a name="ln7887">  { &quot;Bisque1&quot;, RGB_(0xff, 0xe4, 0xc4) },</a>
<a name="ln7888">  { &quot;Bisque2&quot;, RGB_(0xee, 0xd5, 0xb7) },</a>
<a name="ln7889">  { &quot;Bisque3&quot;, RGB_(0xcd, 0xb7, 0x9e) },</a>
<a name="ln7890">  { &quot;Bisque4&quot;, RGB_(0x8b, 0x7d, 0x6b) },</a>
<a name="ln7891">  { &quot;Black&quot;, RGB_(0x00, 0x00, 0x00) },</a>
<a name="ln7892">  { &quot;BlanchedAlmond&quot;, RGB_(0xff, 0xeb, 0xcd) },</a>
<a name="ln7893">  { &quot;Blue&quot;, RGB_(0x00, 0x00, 0xff) },</a>
<a name="ln7894">  { &quot;Blue1&quot;, RGB_(0x0, 0x0, 0xff) },</a>
<a name="ln7895">  { &quot;Blue2&quot;, RGB_(0x0, 0x0, 0xee) },</a>
<a name="ln7896">  { &quot;Blue3&quot;, RGB_(0x0, 0x0, 0xcd) },</a>
<a name="ln7897">  { &quot;Blue4&quot;, RGB_(0x0, 0x0, 0x8b) },</a>
<a name="ln7898">  { &quot;BlueViolet&quot;, RGB_(0x8a, 0x2b, 0xe2) },</a>
<a name="ln7899">  { &quot;Brown&quot;, RGB_(0xa5, 0x2a, 0x2a) },</a>
<a name="ln7900">  { &quot;Brown1&quot;, RGB_(0xff, 0x40, 0x40) },</a>
<a name="ln7901">  { &quot;Brown2&quot;, RGB_(0xee, 0x3b, 0x3b) },</a>
<a name="ln7902">  { &quot;Brown3&quot;, RGB_(0xcd, 0x33, 0x33) },</a>
<a name="ln7903">  { &quot;Brown4&quot;, RGB_(0x8b, 0x23, 0x23) },</a>
<a name="ln7904">  { &quot;BurlyWood&quot;, RGB_(0xde, 0xb8, 0x87) },</a>
<a name="ln7905">  { &quot;Burlywood1&quot;, RGB_(0xff, 0xd3, 0x9b) },</a>
<a name="ln7906">  { &quot;Burlywood2&quot;, RGB_(0xee, 0xc5, 0x91) },</a>
<a name="ln7907">  { &quot;Burlywood3&quot;, RGB_(0xcd, 0xaa, 0x7d) },</a>
<a name="ln7908">  { &quot;Burlywood4&quot;, RGB_(0x8b, 0x73, 0x55) },</a>
<a name="ln7909">  { &quot;CadetBlue&quot;, RGB_(0x5f, 0x9e, 0xa0) },</a>
<a name="ln7910">  { &quot;CadetBlue1&quot;, RGB_(0x98, 0xf5, 0xff) },</a>
<a name="ln7911">  { &quot;CadetBlue2&quot;, RGB_(0x8e, 0xe5, 0xee) },</a>
<a name="ln7912">  { &quot;CadetBlue3&quot;, RGB_(0x7a, 0xc5, 0xcd) },</a>
<a name="ln7913">  { &quot;CadetBlue4&quot;, RGB_(0x53, 0x86, 0x8b) },</a>
<a name="ln7914">  { &quot;ChartReuse&quot;, RGB_(0x7f, 0xff, 0x00) },</a>
<a name="ln7915">  { &quot;Chartreuse1&quot;, RGB_(0x7f, 0xff, 0x0) },</a>
<a name="ln7916">  { &quot;Chartreuse2&quot;, RGB_(0x76, 0xee, 0x0) },</a>
<a name="ln7917">  { &quot;Chartreuse3&quot;, RGB_(0x66, 0xcd, 0x0) },</a>
<a name="ln7918">  { &quot;Chartreuse4&quot;, RGB_(0x45, 0x8b, 0x0) },</a>
<a name="ln7919">  { &quot;Chocolate&quot;, RGB_(0xd2, 0x69, 0x1e) },</a>
<a name="ln7920">  { &quot;Chocolate1&quot;, RGB_(0xff, 0x7f, 0x24) },</a>
<a name="ln7921">  { &quot;Chocolate2&quot;, RGB_(0xee, 0x76, 0x21) },</a>
<a name="ln7922">  { &quot;Chocolate3&quot;, RGB_(0xcd, 0x66, 0x1d) },</a>
<a name="ln7923">  { &quot;Chocolate4&quot;, RGB_(0x8b, 0x45, 0x13) },</a>
<a name="ln7924">  { &quot;Coral&quot;, RGB_(0xff, 0x7f, 0x50) },</a>
<a name="ln7925">  { &quot;Coral1&quot;, RGB_(0xff, 0x72, 0x56) },</a>
<a name="ln7926">  { &quot;Coral2&quot;, RGB_(0xee, 0x6a, 0x50) },</a>
<a name="ln7927">  { &quot;Coral3&quot;, RGB_(0xcd, 0x5b, 0x45) },</a>
<a name="ln7928">  { &quot;Coral4&quot;, RGB_(0x8b, 0x3e, 0x2f) },</a>
<a name="ln7929">  { &quot;CornFlowerBlue&quot;, RGB_(0x64, 0x95, 0xed) },</a>
<a name="ln7930">  { &quot;Cornsilk&quot;, RGB_(0xff, 0xf8, 0xdc) },</a>
<a name="ln7931">  { &quot;Cornsilk1&quot;, RGB_(0xff, 0xf8, 0xdc) },</a>
<a name="ln7932">  { &quot;Cornsilk2&quot;, RGB_(0xee, 0xe8, 0xcd) },</a>
<a name="ln7933">  { &quot;Cornsilk3&quot;, RGB_(0xcd, 0xc8, 0xb1) },</a>
<a name="ln7934">  { &quot;Cornsilk4&quot;, RGB_(0x8b, 0x88, 0x78) },</a>
<a name="ln7935">  { &quot;Crimson&quot;, RGB_(0xdc, 0x14, 0x3c) },</a>
<a name="ln7936">  { &quot;Cyan&quot;, RGB_(0x00, 0xff, 0xff) },</a>
<a name="ln7937">  { &quot;Cyan1&quot;, RGB_(0x0, 0xff, 0xff) },</a>
<a name="ln7938">  { &quot;Cyan2&quot;, RGB_(0x0, 0xee, 0xee) },</a>
<a name="ln7939">  { &quot;Cyan3&quot;, RGB_(0x0, 0xcd, 0xcd) },</a>
<a name="ln7940">  { &quot;Cyan4&quot;, RGB_(0x0, 0x8b, 0x8b) },</a>
<a name="ln7941">  { &quot;DarkBlue&quot;, RGB_(0x00, 0x00, 0x8b) },</a>
<a name="ln7942">  { &quot;DarkCyan&quot;, RGB_(0x00, 0x8b, 0x8b) },</a>
<a name="ln7943">  { &quot;DarkGoldenRod&quot;, RGB_(0xb8, 0x86, 0x0b) },</a>
<a name="ln7944">  { &quot;DarkGoldenrod1&quot;, RGB_(0xff, 0xb9, 0xf) },</a>
<a name="ln7945">  { &quot;DarkGoldenrod2&quot;, RGB_(0xee, 0xad, 0xe) },</a>
<a name="ln7946">  { &quot;DarkGoldenrod3&quot;, RGB_(0xcd, 0x95, 0xc) },</a>
<a name="ln7947">  { &quot;DarkGoldenrod4&quot;, RGB_(0x8b, 0x65, 0x8) },</a>
<a name="ln7948">  { &quot;DarkGray&quot;, RGB_(0xa9, 0xa9, 0xa9) },</a>
<a name="ln7949">  { &quot;DarkGreen&quot;, RGB_(0x00, 0x64, 0x00) },</a>
<a name="ln7950">  { &quot;DarkGrey&quot;, RGB_(0xa9, 0xa9, 0xa9) },</a>
<a name="ln7951">  { &quot;DarkKhaki&quot;, RGB_(0xbd, 0xb7, 0x6b) },</a>
<a name="ln7952">  { &quot;DarkMagenta&quot;, RGB_(0x8b, 0x00, 0x8b) },</a>
<a name="ln7953">  { &quot;DarkOliveGreen&quot;, RGB_(0x55, 0x6b, 0x2f) },</a>
<a name="ln7954">  { &quot;DarkOliveGreen1&quot;, RGB_(0xca, 0xff, 0x70) },</a>
<a name="ln7955">  { &quot;DarkOliveGreen2&quot;, RGB_(0xbc, 0xee, 0x68) },</a>
<a name="ln7956">  { &quot;DarkOliveGreen3&quot;, RGB_(0xa2, 0xcd, 0x5a) },</a>
<a name="ln7957">  { &quot;DarkOliveGreen4&quot;, RGB_(0x6e, 0x8b, 0x3d) },</a>
<a name="ln7958">  { &quot;DarkOrange&quot;, RGB_(0xff, 0x8c, 0x00) },</a>
<a name="ln7959">  { &quot;DarkOrange1&quot;, RGB_(0xff, 0x7f, 0x0) },</a>
<a name="ln7960">  { &quot;DarkOrange2&quot;, RGB_(0xee, 0x76, 0x0) },</a>
<a name="ln7961">  { &quot;DarkOrange3&quot;, RGB_(0xcd, 0x66, 0x0) },</a>
<a name="ln7962">  { &quot;DarkOrange4&quot;, RGB_(0x8b, 0x45, 0x0) },</a>
<a name="ln7963">  { &quot;DarkOrchid&quot;, RGB_(0x99, 0x32, 0xcc) },</a>
<a name="ln7964">  { &quot;DarkOrchid1&quot;, RGB_(0xbf, 0x3e, 0xff) },</a>
<a name="ln7965">  { &quot;DarkOrchid2&quot;, RGB_(0xb2, 0x3a, 0xee) },</a>
<a name="ln7966">  { &quot;DarkOrchid3&quot;, RGB_(0x9a, 0x32, 0xcd) },</a>
<a name="ln7967">  { &quot;DarkOrchid4&quot;, RGB_(0x68, 0x22, 0x8b) },</a>
<a name="ln7968">  { &quot;DarkRed&quot;, RGB_(0x8b, 0x00, 0x00) },</a>
<a name="ln7969">  { &quot;DarkSalmon&quot;, RGB_(0xe9, 0x96, 0x7a) },</a>
<a name="ln7970">  { &quot;DarkSeaGreen&quot;, RGB_(0x8f, 0xbc, 0x8f) },</a>
<a name="ln7971">  { &quot;DarkSeaGreen1&quot;, RGB_(0xc1, 0xff, 0xc1) },</a>
<a name="ln7972">  { &quot;DarkSeaGreen2&quot;, RGB_(0xb4, 0xee, 0xb4) },</a>
<a name="ln7973">  { &quot;DarkSeaGreen3&quot;, RGB_(0x9b, 0xcd, 0x9b) },</a>
<a name="ln7974">  { &quot;DarkSeaGreen4&quot;, RGB_(0x69, 0x8b, 0x69) },</a>
<a name="ln7975">  { &quot;DarkSlateBlue&quot;, RGB_(0x48, 0x3d, 0x8b) },</a>
<a name="ln7976">  { &quot;DarkSlateGray&quot;, RGB_(0x2f, 0x4f, 0x4f) },</a>
<a name="ln7977">  { &quot;DarkSlateGray1&quot;, RGB_(0x97, 0xff, 0xff) },</a>
<a name="ln7978">  { &quot;DarkSlateGray2&quot;, RGB_(0x8d, 0xee, 0xee) },</a>
<a name="ln7979">  { &quot;DarkSlateGray3&quot;, RGB_(0x79, 0xcd, 0xcd) },</a>
<a name="ln7980">  { &quot;DarkSlateGray4&quot;, RGB_(0x52, 0x8b, 0x8b) },</a>
<a name="ln7981">  { &quot;DarkSlateGrey&quot;, RGB_(0x2f, 0x4f, 0x4f) },</a>
<a name="ln7982">  { &quot;DarkTurquoise&quot;, RGB_(0x00, 0xce, 0xd1) },</a>
<a name="ln7983">  { &quot;DarkViolet&quot;, RGB_(0x94, 0x00, 0xd3) },</a>
<a name="ln7984">  { &quot;DarkYellow&quot;, RGB_(0xbb, 0xbb, 0x00) },</a>
<a name="ln7985">  { &quot;DeepPink&quot;, RGB_(0xff, 0x14, 0x93) },</a>
<a name="ln7986">  { &quot;DeepPink1&quot;, RGB_(0xff, 0x14, 0x93) },</a>
<a name="ln7987">  { &quot;DeepPink2&quot;, RGB_(0xee, 0x12, 0x89) },</a>
<a name="ln7988">  { &quot;DeepPink3&quot;, RGB_(0xcd, 0x10, 0x76) },</a>
<a name="ln7989">  { &quot;DeepPink4&quot;, RGB_(0x8b, 0xa, 0x50) },</a>
<a name="ln7990">  { &quot;DeepSkyBlue&quot;, RGB_(0x00, 0xbf, 0xff) },</a>
<a name="ln7991">  { &quot;DeepSkyBlue1&quot;, RGB_(0x0, 0xbf, 0xff) },</a>
<a name="ln7992">  { &quot;DeepSkyBlue2&quot;, RGB_(0x0, 0xb2, 0xee) },</a>
<a name="ln7993">  { &quot;DeepSkyBlue3&quot;, RGB_(0x0, 0x9a, 0xcd) },</a>
<a name="ln7994">  { &quot;DeepSkyBlue4&quot;, RGB_(0x0, 0x68, 0x8b) },</a>
<a name="ln7995">  { &quot;DimGray&quot;, RGB_(0x69, 0x69, 0x69) },</a>
<a name="ln7996">  { &quot;DimGrey&quot;, RGB_(0x69, 0x69, 0x69) },</a>
<a name="ln7997">  { &quot;DodgerBlue&quot;, RGB_(0x1e, 0x90, 0xff) },</a>
<a name="ln7998">  { &quot;DodgerBlue1&quot;, RGB_(0x1e, 0x90, 0xff) },</a>
<a name="ln7999">  { &quot;DodgerBlue2&quot;, RGB_(0x1c, 0x86, 0xee) },</a>
<a name="ln8000">  { &quot;DodgerBlue3&quot;, RGB_(0x18, 0x74, 0xcd) },</a>
<a name="ln8001">  { &quot;DodgerBlue4&quot;, RGB_(0x10, 0x4e, 0x8b) },</a>
<a name="ln8002">  { &quot;Firebrick&quot;, RGB_(0xb2, 0x22, 0x22) },</a>
<a name="ln8003">  { &quot;Firebrick1&quot;, RGB_(0xff, 0x30, 0x30) },</a>
<a name="ln8004">  { &quot;Firebrick2&quot;, RGB_(0xee, 0x2c, 0x2c) },</a>
<a name="ln8005">  { &quot;Firebrick3&quot;, RGB_(0xcd, 0x26, 0x26) },</a>
<a name="ln8006">  { &quot;Firebrick4&quot;, RGB_(0x8b, 0x1a, 0x1a) },</a>
<a name="ln8007">  { &quot;FloralWhite&quot;, RGB_(0xff, 0xfa, 0xf0) },</a>
<a name="ln8008">  { &quot;ForestGreen&quot;, RGB_(0x22, 0x8b, 0x22) },</a>
<a name="ln8009">  { &quot;Fuchsia&quot;, RGB_(0xff, 0x00, 0xff) },</a>
<a name="ln8010">  { &quot;Gainsboro&quot;, RGB_(0xdc, 0xdc, 0xdc) },</a>
<a name="ln8011">  { &quot;GhostWhite&quot;, RGB_(0xf8, 0xf8, 0xff) },</a>
<a name="ln8012">  { &quot;Gold&quot;, RGB_(0xff, 0xd7, 0x00) },</a>
<a name="ln8013">  { &quot;Gold1&quot;, RGB_(0xff, 0xd7, 0x0) },</a>
<a name="ln8014">  { &quot;Gold2&quot;, RGB_(0xee, 0xc9, 0x0) },</a>
<a name="ln8015">  { &quot;Gold3&quot;, RGB_(0xcd, 0xad, 0x0) },</a>
<a name="ln8016">  { &quot;Gold4&quot;, RGB_(0x8b, 0x75, 0x0) },</a>
<a name="ln8017">  { &quot;GoldenRod&quot;, RGB_(0xda, 0xa5, 0x20) },</a>
<a name="ln8018">  { &quot;Goldenrod1&quot;, RGB_(0xff, 0xc1, 0x25) },</a>
<a name="ln8019">  { &quot;Goldenrod2&quot;, RGB_(0xee, 0xb4, 0x22) },</a>
<a name="ln8020">  { &quot;Goldenrod3&quot;, RGB_(0xcd, 0x9b, 0x1d) },</a>
<a name="ln8021">  { &quot;Goldenrod4&quot;, RGB_(0x8b, 0x69, 0x14) },</a>
<a name="ln8022">  { &quot;Gray&quot;, RGB_(0x80, 0x80, 0x80) },</a>
<a name="ln8023">  { &quot;Gray0&quot;, RGB_(0x0, 0x0, 0x0) },</a>
<a name="ln8024">  { &quot;Gray1&quot;, RGB_(0x3, 0x3, 0x3) },</a>
<a name="ln8025">  { &quot;Gray10&quot;, RGB_(0x1a, 0x1a, 0x1a) },</a>
<a name="ln8026">  { &quot;Gray100&quot;, RGB_(0xff, 0xff, 0xff) },</a>
<a name="ln8027">  { &quot;Gray11&quot;, RGB_(0x1c, 0x1c, 0x1c) },</a>
<a name="ln8028">  { &quot;Gray12&quot;, RGB_(0x1f, 0x1f, 0x1f) },</a>
<a name="ln8029">  { &quot;Gray13&quot;, RGB_(0x21, 0x21, 0x21) },</a>
<a name="ln8030">  { &quot;Gray14&quot;, RGB_(0x24, 0x24, 0x24) },</a>
<a name="ln8031">  { &quot;Gray15&quot;, RGB_(0x26, 0x26, 0x26) },</a>
<a name="ln8032">  { &quot;Gray16&quot;, RGB_(0x29, 0x29, 0x29) },</a>
<a name="ln8033">  { &quot;Gray17&quot;, RGB_(0x2b, 0x2b, 0x2b) },</a>
<a name="ln8034">  { &quot;Gray18&quot;, RGB_(0x2e, 0x2e, 0x2e) },</a>
<a name="ln8035">  { &quot;Gray19&quot;, RGB_(0x30, 0x30, 0x30) },</a>
<a name="ln8036">  { &quot;Gray2&quot;, RGB_(0x5, 0x5, 0x5) },</a>
<a name="ln8037">  { &quot;Gray20&quot;, RGB_(0x33, 0x33, 0x33) },</a>
<a name="ln8038">  { &quot;Gray21&quot;, RGB_(0x36, 0x36, 0x36) },</a>
<a name="ln8039">  { &quot;Gray22&quot;, RGB_(0x38, 0x38, 0x38) },</a>
<a name="ln8040">  { &quot;Gray23&quot;, RGB_(0x3b, 0x3b, 0x3b) },</a>
<a name="ln8041">  { &quot;Gray24&quot;, RGB_(0x3d, 0x3d, 0x3d) },</a>
<a name="ln8042">  { &quot;Gray25&quot;, RGB_(0x40, 0x40, 0x40) },</a>
<a name="ln8043">  { &quot;Gray26&quot;, RGB_(0x42, 0x42, 0x42) },</a>
<a name="ln8044">  { &quot;Gray27&quot;, RGB_(0x45, 0x45, 0x45) },</a>
<a name="ln8045">  { &quot;Gray28&quot;, RGB_(0x47, 0x47, 0x47) },</a>
<a name="ln8046">  { &quot;Gray29&quot;, RGB_(0x4a, 0x4a, 0x4a) },</a>
<a name="ln8047">  { &quot;Gray3&quot;, RGB_(0x8, 0x8, 0x8) },</a>
<a name="ln8048">  { &quot;Gray30&quot;, RGB_(0x4d, 0x4d, 0x4d) },</a>
<a name="ln8049">  { &quot;Gray31&quot;, RGB_(0x4f, 0x4f, 0x4f) },</a>
<a name="ln8050">  { &quot;Gray32&quot;, RGB_(0x52, 0x52, 0x52) },</a>
<a name="ln8051">  { &quot;Gray33&quot;, RGB_(0x54, 0x54, 0x54) },</a>
<a name="ln8052">  { &quot;Gray34&quot;, RGB_(0x57, 0x57, 0x57) },</a>
<a name="ln8053">  { &quot;Gray35&quot;, RGB_(0x59, 0x59, 0x59) },</a>
<a name="ln8054">  { &quot;Gray36&quot;, RGB_(0x5c, 0x5c, 0x5c) },</a>
<a name="ln8055">  { &quot;Gray37&quot;, RGB_(0x5e, 0x5e, 0x5e) },</a>
<a name="ln8056">  { &quot;Gray38&quot;, RGB_(0x61, 0x61, 0x61) },</a>
<a name="ln8057">  { &quot;Gray39&quot;, RGB_(0x63, 0x63, 0x63) },</a>
<a name="ln8058">  { &quot;Gray4&quot;, RGB_(0xa, 0xa, 0xa) },</a>
<a name="ln8059">  { &quot;Gray40&quot;, RGB_(0x66, 0x66, 0x66) },</a>
<a name="ln8060">  { &quot;Gray41&quot;, RGB_(0x69, 0x69, 0x69) },</a>
<a name="ln8061">  { &quot;Gray42&quot;, RGB_(0x6b, 0x6b, 0x6b) },</a>
<a name="ln8062">  { &quot;Gray43&quot;, RGB_(0x6e, 0x6e, 0x6e) },</a>
<a name="ln8063">  { &quot;Gray44&quot;, RGB_(0x70, 0x70, 0x70) },</a>
<a name="ln8064">  { &quot;Gray45&quot;, RGB_(0x73, 0x73, 0x73) },</a>
<a name="ln8065">  { &quot;Gray46&quot;, RGB_(0x75, 0x75, 0x75) },</a>
<a name="ln8066">  { &quot;Gray47&quot;, RGB_(0x78, 0x78, 0x78) },</a>
<a name="ln8067">  { &quot;Gray48&quot;, RGB_(0x7a, 0x7a, 0x7a) },</a>
<a name="ln8068">  { &quot;Gray49&quot;, RGB_(0x7d, 0x7d, 0x7d) },</a>
<a name="ln8069">  { &quot;Gray5&quot;, RGB_(0xd, 0xd, 0xd) },</a>
<a name="ln8070">  { &quot;Gray50&quot;, RGB_(0x7f, 0x7f, 0x7f) },</a>
<a name="ln8071">  { &quot;Gray51&quot;, RGB_(0x82, 0x82, 0x82) },</a>
<a name="ln8072">  { &quot;Gray52&quot;, RGB_(0x85, 0x85, 0x85) },</a>
<a name="ln8073">  { &quot;Gray53&quot;, RGB_(0x87, 0x87, 0x87) },</a>
<a name="ln8074">  { &quot;Gray54&quot;, RGB_(0x8a, 0x8a, 0x8a) },</a>
<a name="ln8075">  { &quot;Gray55&quot;, RGB_(0x8c, 0x8c, 0x8c) },</a>
<a name="ln8076">  { &quot;Gray56&quot;, RGB_(0x8f, 0x8f, 0x8f) },</a>
<a name="ln8077">  { &quot;Gray57&quot;, RGB_(0x91, 0x91, 0x91) },</a>
<a name="ln8078">  { &quot;Gray58&quot;, RGB_(0x94, 0x94, 0x94) },</a>
<a name="ln8079">  { &quot;Gray59&quot;, RGB_(0x96, 0x96, 0x96) },</a>
<a name="ln8080">  { &quot;Gray6&quot;, RGB_(0xf, 0xf, 0xf) },</a>
<a name="ln8081">  { &quot;Gray60&quot;, RGB_(0x99, 0x99, 0x99) },</a>
<a name="ln8082">  { &quot;Gray61&quot;, RGB_(0x9c, 0x9c, 0x9c) },</a>
<a name="ln8083">  { &quot;Gray62&quot;, RGB_(0x9e, 0x9e, 0x9e) },</a>
<a name="ln8084">  { &quot;Gray63&quot;, RGB_(0xa1, 0xa1, 0xa1) },</a>
<a name="ln8085">  { &quot;Gray64&quot;, RGB_(0xa3, 0xa3, 0xa3) },</a>
<a name="ln8086">  { &quot;Gray65&quot;, RGB_(0xa6, 0xa6, 0xa6) },</a>
<a name="ln8087">  { &quot;Gray66&quot;, RGB_(0xa8, 0xa8, 0xa8) },</a>
<a name="ln8088">  { &quot;Gray67&quot;, RGB_(0xab, 0xab, 0xab) },</a>
<a name="ln8089">  { &quot;Gray68&quot;, RGB_(0xad, 0xad, 0xad) },</a>
<a name="ln8090">  { &quot;Gray69&quot;, RGB_(0xb0, 0xb0, 0xb0) },</a>
<a name="ln8091">  { &quot;Gray7&quot;, RGB_(0x12, 0x12, 0x12) },</a>
<a name="ln8092">  { &quot;Gray70&quot;, RGB_(0xb3, 0xb3, 0xb3) },</a>
<a name="ln8093">  { &quot;Gray71&quot;, RGB_(0xb5, 0xb5, 0xb5) },</a>
<a name="ln8094">  { &quot;Gray72&quot;, RGB_(0xb8, 0xb8, 0xb8) },</a>
<a name="ln8095">  { &quot;Gray73&quot;, RGB_(0xba, 0xba, 0xba) },</a>
<a name="ln8096">  { &quot;Gray74&quot;, RGB_(0xbd, 0xbd, 0xbd) },</a>
<a name="ln8097">  { &quot;Gray75&quot;, RGB_(0xbf, 0xbf, 0xbf) },</a>
<a name="ln8098">  { &quot;Gray76&quot;, RGB_(0xc2, 0xc2, 0xc2) },</a>
<a name="ln8099">  { &quot;Gray77&quot;, RGB_(0xc4, 0xc4, 0xc4) },</a>
<a name="ln8100">  { &quot;Gray78&quot;, RGB_(0xc7, 0xc7, 0xc7) },</a>
<a name="ln8101">  { &quot;Gray79&quot;, RGB_(0xc9, 0xc9, 0xc9) },</a>
<a name="ln8102">  { &quot;Gray8&quot;, RGB_(0x14, 0x14, 0x14) },</a>
<a name="ln8103">  { &quot;Gray80&quot;, RGB_(0xcc, 0xcc, 0xcc) },</a>
<a name="ln8104">  { &quot;Gray81&quot;, RGB_(0xcf, 0xcf, 0xcf) },</a>
<a name="ln8105">  { &quot;Gray82&quot;, RGB_(0xd1, 0xd1, 0xd1) },</a>
<a name="ln8106">  { &quot;Gray83&quot;, RGB_(0xd4, 0xd4, 0xd4) },</a>
<a name="ln8107">  { &quot;Gray84&quot;, RGB_(0xd6, 0xd6, 0xd6) },</a>
<a name="ln8108">  { &quot;Gray85&quot;, RGB_(0xd9, 0xd9, 0xd9) },</a>
<a name="ln8109">  { &quot;Gray86&quot;, RGB_(0xdb, 0xdb, 0xdb) },</a>
<a name="ln8110">  { &quot;Gray87&quot;, RGB_(0xde, 0xde, 0xde) },</a>
<a name="ln8111">  { &quot;Gray88&quot;, RGB_(0xe0, 0xe0, 0xe0) },</a>
<a name="ln8112">  { &quot;Gray89&quot;, RGB_(0xe3, 0xe3, 0xe3) },</a>
<a name="ln8113">  { &quot;Gray9&quot;, RGB_(0x17, 0x17, 0x17) },</a>
<a name="ln8114">  { &quot;Gray90&quot;, RGB_(0xe5, 0xe5, 0xe5) },</a>
<a name="ln8115">  { &quot;Gray91&quot;, RGB_(0xe8, 0xe8, 0xe8) },</a>
<a name="ln8116">  { &quot;Gray92&quot;, RGB_(0xeb, 0xeb, 0xeb) },</a>
<a name="ln8117">  { &quot;Gray93&quot;, RGB_(0xed, 0xed, 0xed) },</a>
<a name="ln8118">  { &quot;Gray94&quot;, RGB_(0xf0, 0xf0, 0xf0) },</a>
<a name="ln8119">  { &quot;Gray95&quot;, RGB_(0xf2, 0xf2, 0xf2) },</a>
<a name="ln8120">  { &quot;Gray96&quot;, RGB_(0xf5, 0xf5, 0xf5) },</a>
<a name="ln8121">  { &quot;Gray97&quot;, RGB_(0xf7, 0xf7, 0xf7) },</a>
<a name="ln8122">  { &quot;Gray98&quot;, RGB_(0xfa, 0xfa, 0xfa) },</a>
<a name="ln8123">  { &quot;Gray99&quot;, RGB_(0xfc, 0xfc, 0xfc) },</a>
<a name="ln8124">  { &quot;Green&quot;, RGB_(0x00, 0x80, 0x00) },</a>
<a name="ln8125">  { &quot;Green1&quot;, RGB_(0x0, 0xff, 0x0) },</a>
<a name="ln8126">  { &quot;Green2&quot;, RGB_(0x0, 0xee, 0x0) },</a>
<a name="ln8127">  { &quot;Green3&quot;, RGB_(0x0, 0xcd, 0x0) },</a>
<a name="ln8128">  { &quot;Green4&quot;, RGB_(0x0, 0x8b, 0x0) },</a>
<a name="ln8129">  { &quot;GreenYellow&quot;, RGB_(0xad, 0xff, 0x2f) },</a>
<a name="ln8130">  { &quot;Grey&quot;, RGB_(0x80, 0x80, 0x80) },</a>
<a name="ln8131">  { &quot;Grey0&quot;, RGB_(0x0, 0x0, 0x0) },</a>
<a name="ln8132">  { &quot;Grey1&quot;, RGB_(0x3, 0x3, 0x3) },</a>
<a name="ln8133">  { &quot;Grey10&quot;, RGB_(0x1a, 0x1a, 0x1a) },</a>
<a name="ln8134">  { &quot;Grey100&quot;, RGB_(0xff, 0xff, 0xff) },</a>
<a name="ln8135">  { &quot;Grey11&quot;, RGB_(0x1c, 0x1c, 0x1c) },</a>
<a name="ln8136">  { &quot;Grey12&quot;, RGB_(0x1f, 0x1f, 0x1f) },</a>
<a name="ln8137">  { &quot;Grey13&quot;, RGB_(0x21, 0x21, 0x21) },</a>
<a name="ln8138">  { &quot;Grey14&quot;, RGB_(0x24, 0x24, 0x24) },</a>
<a name="ln8139">  { &quot;Grey15&quot;, RGB_(0x26, 0x26, 0x26) },</a>
<a name="ln8140">  { &quot;Grey16&quot;, RGB_(0x29, 0x29, 0x29) },</a>
<a name="ln8141">  { &quot;Grey17&quot;, RGB_(0x2b, 0x2b, 0x2b) },</a>
<a name="ln8142">  { &quot;Grey18&quot;, RGB_(0x2e, 0x2e, 0x2e) },</a>
<a name="ln8143">  { &quot;Grey19&quot;, RGB_(0x30, 0x30, 0x30) },</a>
<a name="ln8144">  { &quot;Grey2&quot;, RGB_(0x5, 0x5, 0x5) },</a>
<a name="ln8145">  { &quot;Grey20&quot;, RGB_(0x33, 0x33, 0x33) },</a>
<a name="ln8146">  { &quot;Grey21&quot;, RGB_(0x36, 0x36, 0x36) },</a>
<a name="ln8147">  { &quot;Grey22&quot;, RGB_(0x38, 0x38, 0x38) },</a>
<a name="ln8148">  { &quot;Grey23&quot;, RGB_(0x3b, 0x3b, 0x3b) },</a>
<a name="ln8149">  { &quot;Grey24&quot;, RGB_(0x3d, 0x3d, 0x3d) },</a>
<a name="ln8150">  { &quot;Grey25&quot;, RGB_(0x40, 0x40, 0x40) },</a>
<a name="ln8151">  { &quot;Grey26&quot;, RGB_(0x42, 0x42, 0x42) },</a>
<a name="ln8152">  { &quot;Grey27&quot;, RGB_(0x45, 0x45, 0x45) },</a>
<a name="ln8153">  { &quot;Grey28&quot;, RGB_(0x47, 0x47, 0x47) },</a>
<a name="ln8154">  { &quot;Grey29&quot;, RGB_(0x4a, 0x4a, 0x4a) },</a>
<a name="ln8155">  { &quot;Grey3&quot;, RGB_(0x8, 0x8, 0x8) },</a>
<a name="ln8156">  { &quot;Grey30&quot;, RGB_(0x4d, 0x4d, 0x4d) },</a>
<a name="ln8157">  { &quot;Grey31&quot;, RGB_(0x4f, 0x4f, 0x4f) },</a>
<a name="ln8158">  { &quot;Grey32&quot;, RGB_(0x52, 0x52, 0x52) },</a>
<a name="ln8159">  { &quot;Grey33&quot;, RGB_(0x54, 0x54, 0x54) },</a>
<a name="ln8160">  { &quot;Grey34&quot;, RGB_(0x57, 0x57, 0x57) },</a>
<a name="ln8161">  { &quot;Grey35&quot;, RGB_(0x59, 0x59, 0x59) },</a>
<a name="ln8162">  { &quot;Grey36&quot;, RGB_(0x5c, 0x5c, 0x5c) },</a>
<a name="ln8163">  { &quot;Grey37&quot;, RGB_(0x5e, 0x5e, 0x5e) },</a>
<a name="ln8164">  { &quot;Grey38&quot;, RGB_(0x61, 0x61, 0x61) },</a>
<a name="ln8165">  { &quot;Grey39&quot;, RGB_(0x63, 0x63, 0x63) },</a>
<a name="ln8166">  { &quot;Grey4&quot;, RGB_(0xa, 0xa, 0xa) },</a>
<a name="ln8167">  { &quot;Grey40&quot;, RGB_(0x66, 0x66, 0x66) },</a>
<a name="ln8168">  { &quot;Grey41&quot;, RGB_(0x69, 0x69, 0x69) },</a>
<a name="ln8169">  { &quot;Grey42&quot;, RGB_(0x6b, 0x6b, 0x6b) },</a>
<a name="ln8170">  { &quot;Grey43&quot;, RGB_(0x6e, 0x6e, 0x6e) },</a>
<a name="ln8171">  { &quot;Grey44&quot;, RGB_(0x70, 0x70, 0x70) },</a>
<a name="ln8172">  { &quot;Grey45&quot;, RGB_(0x73, 0x73, 0x73) },</a>
<a name="ln8173">  { &quot;Grey46&quot;, RGB_(0x75, 0x75, 0x75) },</a>
<a name="ln8174">  { &quot;Grey47&quot;, RGB_(0x78, 0x78, 0x78) },</a>
<a name="ln8175">  { &quot;Grey48&quot;, RGB_(0x7a, 0x7a, 0x7a) },</a>
<a name="ln8176">  { &quot;Grey49&quot;, RGB_(0x7d, 0x7d, 0x7d) },</a>
<a name="ln8177">  { &quot;Grey5&quot;, RGB_(0xd, 0xd, 0xd) },</a>
<a name="ln8178">  { &quot;Grey50&quot;, RGB_(0x7f, 0x7f, 0x7f) },</a>
<a name="ln8179">  { &quot;Grey51&quot;, RGB_(0x82, 0x82, 0x82) },</a>
<a name="ln8180">  { &quot;Grey52&quot;, RGB_(0x85, 0x85, 0x85) },</a>
<a name="ln8181">  { &quot;Grey53&quot;, RGB_(0x87, 0x87, 0x87) },</a>
<a name="ln8182">  { &quot;Grey54&quot;, RGB_(0x8a, 0x8a, 0x8a) },</a>
<a name="ln8183">  { &quot;Grey55&quot;, RGB_(0x8c, 0x8c, 0x8c) },</a>
<a name="ln8184">  { &quot;Grey56&quot;, RGB_(0x8f, 0x8f, 0x8f) },</a>
<a name="ln8185">  { &quot;Grey57&quot;, RGB_(0x91, 0x91, 0x91) },</a>
<a name="ln8186">  { &quot;Grey58&quot;, RGB_(0x94, 0x94, 0x94) },</a>
<a name="ln8187">  { &quot;Grey59&quot;, RGB_(0x96, 0x96, 0x96) },</a>
<a name="ln8188">  { &quot;Grey6&quot;, RGB_(0xf, 0xf, 0xf) },</a>
<a name="ln8189">  { &quot;Grey60&quot;, RGB_(0x99, 0x99, 0x99) },</a>
<a name="ln8190">  { &quot;Grey61&quot;, RGB_(0x9c, 0x9c, 0x9c) },</a>
<a name="ln8191">  { &quot;Grey62&quot;, RGB_(0x9e, 0x9e, 0x9e) },</a>
<a name="ln8192">  { &quot;Grey63&quot;, RGB_(0xa1, 0xa1, 0xa1) },</a>
<a name="ln8193">  { &quot;Grey64&quot;, RGB_(0xa3, 0xa3, 0xa3) },</a>
<a name="ln8194">  { &quot;Grey65&quot;, RGB_(0xa6, 0xa6, 0xa6) },</a>
<a name="ln8195">  { &quot;Grey66&quot;, RGB_(0xa8, 0xa8, 0xa8) },</a>
<a name="ln8196">  { &quot;Grey67&quot;, RGB_(0xab, 0xab, 0xab) },</a>
<a name="ln8197">  { &quot;Grey68&quot;, RGB_(0xad, 0xad, 0xad) },</a>
<a name="ln8198">  { &quot;Grey69&quot;, RGB_(0xb0, 0xb0, 0xb0) },</a>
<a name="ln8199">  { &quot;Grey7&quot;, RGB_(0x12, 0x12, 0x12) },</a>
<a name="ln8200">  { &quot;Grey70&quot;, RGB_(0xb3, 0xb3, 0xb3) },</a>
<a name="ln8201">  { &quot;Grey71&quot;, RGB_(0xb5, 0xb5, 0xb5) },</a>
<a name="ln8202">  { &quot;Grey72&quot;, RGB_(0xb8, 0xb8, 0xb8) },</a>
<a name="ln8203">  { &quot;Grey73&quot;, RGB_(0xba, 0xba, 0xba) },</a>
<a name="ln8204">  { &quot;Grey74&quot;, RGB_(0xbd, 0xbd, 0xbd) },</a>
<a name="ln8205">  { &quot;Grey75&quot;, RGB_(0xbf, 0xbf, 0xbf) },</a>
<a name="ln8206">  { &quot;Grey76&quot;, RGB_(0xc2, 0xc2, 0xc2) },</a>
<a name="ln8207">  { &quot;Grey77&quot;, RGB_(0xc4, 0xc4, 0xc4) },</a>
<a name="ln8208">  { &quot;Grey78&quot;, RGB_(0xc7, 0xc7, 0xc7) },</a>
<a name="ln8209">  { &quot;Grey79&quot;, RGB_(0xc9, 0xc9, 0xc9) },</a>
<a name="ln8210">  { &quot;Grey8&quot;, RGB_(0x14, 0x14, 0x14) },</a>
<a name="ln8211">  { &quot;Grey80&quot;, RGB_(0xcc, 0xcc, 0xcc) },</a>
<a name="ln8212">  { &quot;Grey81&quot;, RGB_(0xcf, 0xcf, 0xcf) },</a>
<a name="ln8213">  { &quot;Grey82&quot;, RGB_(0xd1, 0xd1, 0xd1) },</a>
<a name="ln8214">  { &quot;Grey83&quot;, RGB_(0xd4, 0xd4, 0xd4) },</a>
<a name="ln8215">  { &quot;Grey84&quot;, RGB_(0xd6, 0xd6, 0xd6) },</a>
<a name="ln8216">  { &quot;Grey85&quot;, RGB_(0xd9, 0xd9, 0xd9) },</a>
<a name="ln8217">  { &quot;Grey86&quot;, RGB_(0xdb, 0xdb, 0xdb) },</a>
<a name="ln8218">  { &quot;Grey87&quot;, RGB_(0xde, 0xde, 0xde) },</a>
<a name="ln8219">  { &quot;Grey88&quot;, RGB_(0xe0, 0xe0, 0xe0) },</a>
<a name="ln8220">  { &quot;Grey89&quot;, RGB_(0xe3, 0xe3, 0xe3) },</a>
<a name="ln8221">  { &quot;Grey9&quot;, RGB_(0x17, 0x17, 0x17) },</a>
<a name="ln8222">  { &quot;Grey90&quot;, RGB_(0xe5, 0xe5, 0xe5) },</a>
<a name="ln8223">  { &quot;Grey91&quot;, RGB_(0xe8, 0xe8, 0xe8) },</a>
<a name="ln8224">  { &quot;Grey92&quot;, RGB_(0xeb, 0xeb, 0xeb) },</a>
<a name="ln8225">  { &quot;Grey93&quot;, RGB_(0xed, 0xed, 0xed) },</a>
<a name="ln8226">  { &quot;Grey94&quot;, RGB_(0xf0, 0xf0, 0xf0) },</a>
<a name="ln8227">  { &quot;Grey95&quot;, RGB_(0xf2, 0xf2, 0xf2) },</a>
<a name="ln8228">  { &quot;Grey96&quot;, RGB_(0xf5, 0xf5, 0xf5) },</a>
<a name="ln8229">  { &quot;Grey97&quot;, RGB_(0xf7, 0xf7, 0xf7) },</a>
<a name="ln8230">  { &quot;Grey98&quot;, RGB_(0xfa, 0xfa, 0xfa) },</a>
<a name="ln8231">  { &quot;Grey99&quot;, RGB_(0xfc, 0xfc, 0xfc) },</a>
<a name="ln8232">  { &quot;Honeydew&quot;, RGB_(0xf0, 0xff, 0xf0) },</a>
<a name="ln8233">  { &quot;Honeydew1&quot;, RGB_(0xf0, 0xff, 0xf0) },</a>
<a name="ln8234">  { &quot;Honeydew2&quot;, RGB_(0xe0, 0xee, 0xe0) },</a>
<a name="ln8235">  { &quot;Honeydew3&quot;, RGB_(0xc1, 0xcd, 0xc1) },</a>
<a name="ln8236">  { &quot;Honeydew4&quot;, RGB_(0x83, 0x8b, 0x83) },</a>
<a name="ln8237">  { &quot;HotPink&quot;, RGB_(0xff, 0x69, 0xb4) },</a>
<a name="ln8238">  { &quot;HotPink1&quot;, RGB_(0xff, 0x6e, 0xb4) },</a>
<a name="ln8239">  { &quot;HotPink2&quot;, RGB_(0xee, 0x6a, 0xa7) },</a>
<a name="ln8240">  { &quot;HotPink3&quot;, RGB_(0xcd, 0x60, 0x90) },</a>
<a name="ln8241">  { &quot;HotPink4&quot;, RGB_(0x8b, 0x3a, 0x62) },</a>
<a name="ln8242">  { &quot;IndianRed&quot;, RGB_(0xcd, 0x5c, 0x5c) },</a>
<a name="ln8243">  { &quot;IndianRed1&quot;, RGB_(0xff, 0x6a, 0x6a) },</a>
<a name="ln8244">  { &quot;IndianRed2&quot;, RGB_(0xee, 0x63, 0x63) },</a>
<a name="ln8245">  { &quot;IndianRed3&quot;, RGB_(0xcd, 0x55, 0x55) },</a>
<a name="ln8246">  { &quot;IndianRed4&quot;, RGB_(0x8b, 0x3a, 0x3a) },</a>
<a name="ln8247">  { &quot;Indigo&quot;, RGB_(0x4b, 0x00, 0x82) },</a>
<a name="ln8248">  { &quot;Ivory&quot;, RGB_(0xff, 0xff, 0xf0) },</a>
<a name="ln8249">  { &quot;Ivory1&quot;, RGB_(0xff, 0xff, 0xf0) },</a>
<a name="ln8250">  { &quot;Ivory2&quot;, RGB_(0xee, 0xee, 0xe0) },</a>
<a name="ln8251">  { &quot;Ivory3&quot;, RGB_(0xcd, 0xcd, 0xc1) },</a>
<a name="ln8252">  { &quot;Ivory4&quot;, RGB_(0x8b, 0x8b, 0x83) },</a>
<a name="ln8253">  { &quot;Khaki&quot;, RGB_(0xf0, 0xe6, 0x8c) },</a>
<a name="ln8254">  { &quot;Khaki1&quot;, RGB_(0xff, 0xf6, 0x8f) },</a>
<a name="ln8255">  { &quot;Khaki2&quot;, RGB_(0xee, 0xe6, 0x85) },</a>
<a name="ln8256">  { &quot;Khaki3&quot;, RGB_(0xcd, 0xc6, 0x73) },</a>
<a name="ln8257">  { &quot;Khaki4&quot;, RGB_(0x8b, 0x86, 0x4e) },</a>
<a name="ln8258">  { &quot;Lavender&quot;, RGB_(0xe6, 0xe6, 0xfa) },</a>
<a name="ln8259">  { &quot;LavenderBlush&quot;, RGB_(0xff, 0xf0, 0xf5) },</a>
<a name="ln8260">  { &quot;LavenderBlush1&quot;, RGB_(0xff, 0xf0, 0xf5) },</a>
<a name="ln8261">  { &quot;LavenderBlush2&quot;, RGB_(0xee, 0xe0, 0xe5) },</a>
<a name="ln8262">  { &quot;LavenderBlush3&quot;, RGB_(0xcd, 0xc1, 0xc5) },</a>
<a name="ln8263">  { &quot;LavenderBlush4&quot;, RGB_(0x8b, 0x83, 0x86) },</a>
<a name="ln8264">  { &quot;LawnGreen&quot;, RGB_(0x7c, 0xfc, 0x00) },</a>
<a name="ln8265">  { &quot;LemonChiffon&quot;, RGB_(0xff, 0xfa, 0xcd) },</a>
<a name="ln8266">  { &quot;LemonChiffon1&quot;, RGB_(0xff, 0xfa, 0xcd) },</a>
<a name="ln8267">  { &quot;LemonChiffon2&quot;, RGB_(0xee, 0xe9, 0xbf) },</a>
<a name="ln8268">  { &quot;LemonChiffon3&quot;, RGB_(0xcd, 0xc9, 0xa5) },</a>
<a name="ln8269">  { &quot;LemonChiffon4&quot;, RGB_(0x8b, 0x89, 0x70) },</a>
<a name="ln8270">  { &quot;LightBlue&quot;, RGB_(0xad, 0xd8, 0xe6) },</a>
<a name="ln8271">  { &quot;LightBlue1&quot;, RGB_(0xbf, 0xef, 0xff) },</a>
<a name="ln8272">  { &quot;LightBlue2&quot;, RGB_(0xb2, 0xdf, 0xee) },</a>
<a name="ln8273">  { &quot;LightBlue3&quot;, RGB_(0x9a, 0xc0, 0xcd) },</a>
<a name="ln8274">  { &quot;LightBlue4&quot;, RGB_(0x68, 0x83, 0x8b) },</a>
<a name="ln8275">  { &quot;LightCoral&quot;, RGB_(0xf0, 0x80, 0x80) },</a>
<a name="ln8276">  { &quot;LightCyan&quot;, RGB_(0xe0, 0xff, 0xff) },</a>
<a name="ln8277">  { &quot;LightCyan1&quot;, RGB_(0xe0, 0xff, 0xff) },</a>
<a name="ln8278">  { &quot;LightCyan2&quot;, RGB_(0xd1, 0xee, 0xee) },</a>
<a name="ln8279">  { &quot;LightCyan3&quot;, RGB_(0xb4, 0xcd, 0xcd) },</a>
<a name="ln8280">  { &quot;LightCyan4&quot;, RGB_(0x7a, 0x8b, 0x8b) },</a>
<a name="ln8281">  { &quot;LightGoldenrod&quot;, RGB_(0xee, 0xdd, 0x82) },</a>
<a name="ln8282">  { &quot;LightGoldenrod1&quot;, RGB_(0xff, 0xec, 0x8b) },</a>
<a name="ln8283">  { &quot;LightGoldenrod2&quot;, RGB_(0xee, 0xdc, 0x82) },</a>
<a name="ln8284">  { &quot;LightGoldenrod3&quot;, RGB_(0xcd, 0xbe, 0x70) },</a>
<a name="ln8285">  { &quot;LightGoldenrod4&quot;, RGB_(0x8b, 0x81, 0x4c) },</a>
<a name="ln8286">  { &quot;LightGoldenRodYellow&quot;, RGB_(0xfa, 0xfa, 0xd2) },</a>
<a name="ln8287">  { &quot;LightGray&quot;, RGB_(0xd3, 0xd3, 0xd3) },</a>
<a name="ln8288">  { &quot;LightGreen&quot;, RGB_(0x90, 0xee, 0x90) },</a>
<a name="ln8289">  { &quot;LightGrey&quot;, RGB_(0xd3, 0xd3, 0xd3) },</a>
<a name="ln8290">  { &quot;LightMagenta&quot;, RGB_(0xff, 0xbb, 0xff) },</a>
<a name="ln8291">  { &quot;LightPink&quot;, RGB_(0xff, 0xb6, 0xc1) },</a>
<a name="ln8292">  { &quot;LightPink1&quot;, RGB_(0xff, 0xae, 0xb9) },</a>
<a name="ln8293">  { &quot;LightPink2&quot;, RGB_(0xee, 0xa2, 0xad) },</a>
<a name="ln8294">  { &quot;LightPink3&quot;, RGB_(0xcd, 0x8c, 0x95) },</a>
<a name="ln8295">  { &quot;LightPink4&quot;, RGB_(0x8b, 0x5f, 0x65) },</a>
<a name="ln8296">  { &quot;LightRed&quot;, RGB_(0xff, 0xbb, 0xbb) },</a>
<a name="ln8297">  { &quot;LightSalmon&quot;, RGB_(0xff, 0xa0, 0x7a) },</a>
<a name="ln8298">  { &quot;LightSalmon1&quot;, RGB_(0xff, 0xa0, 0x7a) },</a>
<a name="ln8299">  { &quot;LightSalmon2&quot;, RGB_(0xee, 0x95, 0x72) },</a>
<a name="ln8300">  { &quot;LightSalmon3&quot;, RGB_(0xcd, 0x81, 0x62) },</a>
<a name="ln8301">  { &quot;LightSalmon4&quot;, RGB_(0x8b, 0x57, 0x42) },</a>
<a name="ln8302">  { &quot;LightSeaGreen&quot;, RGB_(0x20, 0xb2, 0xaa) },</a>
<a name="ln8303">  { &quot;LightSkyBlue&quot;, RGB_(0x87, 0xce, 0xfa) },</a>
<a name="ln8304">  { &quot;LightSkyBlue1&quot;, RGB_(0xb0, 0xe2, 0xff) },</a>
<a name="ln8305">  { &quot;LightSkyBlue2&quot;, RGB_(0xa4, 0xd3, 0xee) },</a>
<a name="ln8306">  { &quot;LightSkyBlue3&quot;, RGB_(0x8d, 0xb6, 0xcd) },</a>
<a name="ln8307">  { &quot;LightSkyBlue4&quot;, RGB_(0x60, 0x7b, 0x8b) },</a>
<a name="ln8308">  { &quot;LightSlateBlue&quot;, RGB_(0x84, 0x70, 0xff) },</a>
<a name="ln8309">  { &quot;LightSlateGray&quot;, RGB_(0x77, 0x88, 0x99) },</a>
<a name="ln8310">  { &quot;LightSlateGrey&quot;, RGB_(0x77, 0x88, 0x99) },</a>
<a name="ln8311">  { &quot;LightSteelBlue&quot;, RGB_(0xb0, 0xc4, 0xde) },</a>
<a name="ln8312">  { &quot;LightSteelBlue1&quot;, RGB_(0xca, 0xe1, 0xff) },</a>
<a name="ln8313">  { &quot;LightSteelBlue2&quot;, RGB_(0xbc, 0xd2, 0xee) },</a>
<a name="ln8314">  { &quot;LightSteelBlue3&quot;, RGB_(0xa2, 0xb5, 0xcd) },</a>
<a name="ln8315">  { &quot;LightSteelBlue4&quot;, RGB_(0x6e, 0x7b, 0x8b) },</a>
<a name="ln8316">  { &quot;LightYellow&quot;, RGB_(0xff, 0xff, 0xe0) },</a>
<a name="ln8317">  { &quot;LightYellow1&quot;, RGB_(0xff, 0xff, 0xe0) },</a>
<a name="ln8318">  { &quot;LightYellow2&quot;, RGB_(0xee, 0xee, 0xd1) },</a>
<a name="ln8319">  { &quot;LightYellow3&quot;, RGB_(0xcd, 0xcd, 0xb4) },</a>
<a name="ln8320">  { &quot;LightYellow4&quot;, RGB_(0x8b, 0x8b, 0x7a) },</a>
<a name="ln8321">  { &quot;Lime&quot;, RGB_(0x00, 0xff, 0x00) },</a>
<a name="ln8322">  { &quot;LimeGreen&quot;, RGB_(0x32, 0xcd, 0x32) },</a>
<a name="ln8323">  { &quot;Linen&quot;, RGB_(0xfa, 0xf0, 0xe6) },</a>
<a name="ln8324">  { &quot;Magenta&quot;, RGB_(0xff, 0x00, 0xff) },</a>
<a name="ln8325">  { &quot;Magenta1&quot;, RGB_(0xff, 0x0, 0xff) },</a>
<a name="ln8326">  { &quot;Magenta2&quot;, RGB_(0xee, 0x0, 0xee) },</a>
<a name="ln8327">  { &quot;Magenta3&quot;, RGB_(0xcd, 0x0, 0xcd) },</a>
<a name="ln8328">  { &quot;Magenta4&quot;, RGB_(0x8b, 0x0, 0x8b) },</a>
<a name="ln8329">  { &quot;Maroon&quot;, RGB_(0x80, 0x00, 0x00) },</a>
<a name="ln8330">  { &quot;Maroon1&quot;, RGB_(0xff, 0x34, 0xb3) },</a>
<a name="ln8331">  { &quot;Maroon2&quot;, RGB_(0xee, 0x30, 0xa7) },</a>
<a name="ln8332">  { &quot;Maroon3&quot;, RGB_(0xcd, 0x29, 0x90) },</a>
<a name="ln8333">  { &quot;Maroon4&quot;, RGB_(0x8b, 0x1c, 0x62) },</a>
<a name="ln8334">  { &quot;MediumAquamarine&quot;, RGB_(0x66, 0xcd, 0xaa) },</a>
<a name="ln8335">  { &quot;MediumBlue&quot;, RGB_(0x00, 0x00, 0xcd) },</a>
<a name="ln8336">  { &quot;MediumOrchid&quot;, RGB_(0xba, 0x55, 0xd3) },</a>
<a name="ln8337">  { &quot;MediumOrchid1&quot;, RGB_(0xe0, 0x66, 0xff) },</a>
<a name="ln8338">  { &quot;MediumOrchid2&quot;, RGB_(0xd1, 0x5f, 0xee) },</a>
<a name="ln8339">  { &quot;MediumOrchid3&quot;, RGB_(0xb4, 0x52, 0xcd) },</a>
<a name="ln8340">  { &quot;MediumOrchid4&quot;, RGB_(0x7a, 0x37, 0x8b) },</a>
<a name="ln8341">  { &quot;MediumPurple&quot;, RGB_(0x93, 0x70, 0xdb) },</a>
<a name="ln8342">  { &quot;MediumPurple1&quot;, RGB_(0xab, 0x82, 0xff) },</a>
<a name="ln8343">  { &quot;MediumPurple2&quot;, RGB_(0x9f, 0x79, 0xee) },</a>
<a name="ln8344">  { &quot;MediumPurple3&quot;, RGB_(0x89, 0x68, 0xcd) },</a>
<a name="ln8345">  { &quot;MediumPurple4&quot;, RGB_(0x5d, 0x47, 0x8b) },</a>
<a name="ln8346">  { &quot;MediumSeaGreen&quot;, RGB_(0x3c, 0xb3, 0x71) },</a>
<a name="ln8347">  { &quot;MediumSlateBlue&quot;, RGB_(0x7b, 0x68, 0xee) },</a>
<a name="ln8348">  { &quot;MediumSpringGreen&quot;, RGB_(0x00, 0xfa, 0x9a) },</a>
<a name="ln8349">  { &quot;MediumTurquoise&quot;, RGB_(0x48, 0xd1, 0xcc) },</a>
<a name="ln8350">  { &quot;MediumVioletRed&quot;, RGB_(0xc7, 0x15, 0x85) },</a>
<a name="ln8351">  { &quot;MidnightBlue&quot;, RGB_(0x19, 0x19, 0x70) },</a>
<a name="ln8352">  { &quot;MintCream&quot;, RGB_(0xf5, 0xff, 0xfa) },</a>
<a name="ln8353">  { &quot;MistyRose&quot;, RGB_(0xff, 0xe4, 0xe1) },</a>
<a name="ln8354">  { &quot;MistyRose1&quot;, RGB_(0xff, 0xe4, 0xe1) },</a>
<a name="ln8355">  { &quot;MistyRose2&quot;, RGB_(0xee, 0xd5, 0xd2) },</a>
<a name="ln8356">  { &quot;MistyRose3&quot;, RGB_(0xcd, 0xb7, 0xb5) },</a>
<a name="ln8357">  { &quot;MistyRose4&quot;, RGB_(0x8b, 0x7d, 0x7b) },</a>
<a name="ln8358">  { &quot;Moccasin&quot;, RGB_(0xff, 0xe4, 0xb5) },</a>
<a name="ln8359">  { &quot;NavajoWhite&quot;, RGB_(0xff, 0xde, 0xad) },</a>
<a name="ln8360">  { &quot;NavajoWhite1&quot;, RGB_(0xff, 0xde, 0xad) },</a>
<a name="ln8361">  { &quot;NavajoWhite2&quot;, RGB_(0xee, 0xcf, 0xa1) },</a>
<a name="ln8362">  { &quot;NavajoWhite3&quot;, RGB_(0xcd, 0xb3, 0x8b) },</a>
<a name="ln8363">  { &quot;NavajoWhite4&quot;, RGB_(0x8b, 0x79, 0x5e) },</a>
<a name="ln8364">  { &quot;Navy&quot;, RGB_(0x00, 0x00, 0x80) },</a>
<a name="ln8365">  { &quot;NavyBlue&quot;, RGB_(0x0, 0x0, 0x80) },</a>
<a name="ln8366">  { &quot;OldLace&quot;, RGB_(0xfd, 0xf5, 0xe6) },</a>
<a name="ln8367">  { &quot;Olive&quot;, RGB_(0x80, 0x80, 0x00) },</a>
<a name="ln8368">  { &quot;OliveDrab&quot;, RGB_(0x6b, 0x8e, 0x23) },</a>
<a name="ln8369">  { &quot;OliveDrab1&quot;, RGB_(0xc0, 0xff, 0x3e) },</a>
<a name="ln8370">  { &quot;OliveDrab2&quot;, RGB_(0xb3, 0xee, 0x3a) },</a>
<a name="ln8371">  { &quot;OliveDrab3&quot;, RGB_(0x9a, 0xcd, 0x32) },</a>
<a name="ln8372">  { &quot;OliveDrab4&quot;, RGB_(0x69, 0x8b, 0x22) },</a>
<a name="ln8373">  { &quot;Orange&quot;, RGB_(0xff, 0xa5, 0x00) },</a>
<a name="ln8374">  { &quot;Orange1&quot;, RGB_(0xff, 0xa5, 0x0) },</a>
<a name="ln8375">  { &quot;Orange2&quot;, RGB_(0xee, 0x9a, 0x0) },</a>
<a name="ln8376">  { &quot;Orange3&quot;, RGB_(0xcd, 0x85, 0x0) },</a>
<a name="ln8377">  { &quot;Orange4&quot;, RGB_(0x8b, 0x5a, 0x0) },</a>
<a name="ln8378">  { &quot;OrangeRed&quot;, RGB_(0xff, 0x45, 0x00) },</a>
<a name="ln8379">  { &quot;OrangeRed1&quot;, RGB_(0xff, 0x45, 0x0) },</a>
<a name="ln8380">  { &quot;OrangeRed2&quot;, RGB_(0xee, 0x40, 0x0) },</a>
<a name="ln8381">  { &quot;OrangeRed3&quot;, RGB_(0xcd, 0x37, 0x0) },</a>
<a name="ln8382">  { &quot;OrangeRed4&quot;, RGB_(0x8b, 0x25, 0x0) },</a>
<a name="ln8383">  { &quot;Orchid&quot;, RGB_(0xda, 0x70, 0xd6) },</a>
<a name="ln8384">  { &quot;Orchid1&quot;, RGB_(0xff, 0x83, 0xfa) },</a>
<a name="ln8385">  { &quot;Orchid2&quot;, RGB_(0xee, 0x7a, 0xe9) },</a>
<a name="ln8386">  { &quot;Orchid3&quot;, RGB_(0xcd, 0x69, 0xc9) },</a>
<a name="ln8387">  { &quot;Orchid4&quot;, RGB_(0x8b, 0x47, 0x89) },</a>
<a name="ln8388">  { &quot;PaleGoldenRod&quot;, RGB_(0xee, 0xe8, 0xaa) },</a>
<a name="ln8389">  { &quot;PaleGreen&quot;, RGB_(0x98, 0xfb, 0x98) },</a>
<a name="ln8390">  { &quot;PaleGreen1&quot;, RGB_(0x9a, 0xff, 0x9a) },</a>
<a name="ln8391">  { &quot;PaleGreen2&quot;, RGB_(0x90, 0xee, 0x90) },</a>
<a name="ln8392">  { &quot;PaleGreen3&quot;, RGB_(0x7c, 0xcd, 0x7c) },</a>
<a name="ln8393">  { &quot;PaleGreen4&quot;, RGB_(0x54, 0x8b, 0x54) },</a>
<a name="ln8394">  { &quot;PaleTurquoise&quot;, RGB_(0xaf, 0xee, 0xee) },</a>
<a name="ln8395">  { &quot;PaleTurquoise1&quot;, RGB_(0xbb, 0xff, 0xff) },</a>
<a name="ln8396">  { &quot;PaleTurquoise2&quot;, RGB_(0xae, 0xee, 0xee) },</a>
<a name="ln8397">  { &quot;PaleTurquoise3&quot;, RGB_(0x96, 0xcd, 0xcd) },</a>
<a name="ln8398">  { &quot;PaleTurquoise4&quot;, RGB_(0x66, 0x8b, 0x8b) },</a>
<a name="ln8399">  { &quot;PaleVioletRed&quot;, RGB_(0xdb, 0x70, 0x93) },</a>
<a name="ln8400">  { &quot;PaleVioletRed1&quot;, RGB_(0xff, 0x82, 0xab) },</a>
<a name="ln8401">  { &quot;PaleVioletRed2&quot;, RGB_(0xee, 0x79, 0x9f) },</a>
<a name="ln8402">  { &quot;PaleVioletRed3&quot;, RGB_(0xcd, 0x68, 0x89) },</a>
<a name="ln8403">  { &quot;PaleVioletRed4&quot;, RGB_(0x8b, 0x47, 0x5d) },</a>
<a name="ln8404">  { &quot;PapayaWhip&quot;, RGB_(0xff, 0xef, 0xd5) },</a>
<a name="ln8405">  { &quot;PeachPuff&quot;, RGB_(0xff, 0xda, 0xb9) },</a>
<a name="ln8406">  { &quot;PeachPuff1&quot;, RGB_(0xff, 0xda, 0xb9) },</a>
<a name="ln8407">  { &quot;PeachPuff2&quot;, RGB_(0xee, 0xcb, 0xad) },</a>
<a name="ln8408">  { &quot;PeachPuff3&quot;, RGB_(0xcd, 0xaf, 0x95) },</a>
<a name="ln8409">  { &quot;PeachPuff4&quot;, RGB_(0x8b, 0x77, 0x65) },</a>
<a name="ln8410">  { &quot;Peru&quot;, RGB_(0xcd, 0x85, 0x3f) },</a>
<a name="ln8411">  { &quot;Pink&quot;, RGB_(0xff, 0xc0, 0xcb) },</a>
<a name="ln8412">  { &quot;Pink1&quot;, RGB_(0xff, 0xb5, 0xc5) },</a>
<a name="ln8413">  { &quot;Pink2&quot;, RGB_(0xee, 0xa9, 0xb8) },</a>
<a name="ln8414">  { &quot;Pink3&quot;, RGB_(0xcd, 0x91, 0x9e) },</a>
<a name="ln8415">  { &quot;Pink4&quot;, RGB_(0x8b, 0x63, 0x6c) },</a>
<a name="ln8416">  { &quot;Plum&quot;, RGB_(0xdd, 0xa0, 0xdd) },</a>
<a name="ln8417">  { &quot;Plum1&quot;, RGB_(0xff, 0xbb, 0xff) },</a>
<a name="ln8418">  { &quot;Plum2&quot;, RGB_(0xee, 0xae, 0xee) },</a>
<a name="ln8419">  { &quot;Plum3&quot;, RGB_(0xcd, 0x96, 0xcd) },</a>
<a name="ln8420">  { &quot;Plum4&quot;, RGB_(0x8b, 0x66, 0x8b) },</a>
<a name="ln8421">  { &quot;PowderBlue&quot;, RGB_(0xb0, 0xe0, 0xe6) },</a>
<a name="ln8422">  { &quot;Purple&quot;, RGB_(0x80, 0x00, 0x80) },</a>
<a name="ln8423">  { &quot;Purple1&quot;, RGB_(0x9b, 0x30, 0xff) },</a>
<a name="ln8424">  { &quot;Purple2&quot;, RGB_(0x91, 0x2c, 0xee) },</a>
<a name="ln8425">  { &quot;Purple3&quot;, RGB_(0x7d, 0x26, 0xcd) },</a>
<a name="ln8426">  { &quot;Purple4&quot;, RGB_(0x55, 0x1a, 0x8b) },</a>
<a name="ln8427">  { &quot;RebeccaPurple&quot;, RGB_(0x66, 0x33, 0x99) },</a>
<a name="ln8428">  { &quot;Red&quot;, RGB_(0xff, 0x00, 0x00) },</a>
<a name="ln8429">  { &quot;Red1&quot;, RGB_(0xff, 0x0, 0x0) },</a>
<a name="ln8430">  { &quot;Red2&quot;, RGB_(0xee, 0x0, 0x0) },</a>
<a name="ln8431">  { &quot;Red3&quot;, RGB_(0xcd, 0x0, 0x0) },</a>
<a name="ln8432">  { &quot;Red4&quot;, RGB_(0x8b, 0x0, 0x0) },</a>
<a name="ln8433">  { &quot;RosyBrown&quot;, RGB_(0xbc, 0x8f, 0x8f) },</a>
<a name="ln8434">  { &quot;RosyBrown1&quot;, RGB_(0xff, 0xc1, 0xc1) },</a>
<a name="ln8435">  { &quot;RosyBrown2&quot;, RGB_(0xee, 0xb4, 0xb4) },</a>
<a name="ln8436">  { &quot;RosyBrown3&quot;, RGB_(0xcd, 0x9b, 0x9b) },</a>
<a name="ln8437">  { &quot;RosyBrown4&quot;, RGB_(0x8b, 0x69, 0x69) },</a>
<a name="ln8438">  { &quot;RoyalBlue&quot;, RGB_(0x41, 0x69, 0xe1) },</a>
<a name="ln8439">  { &quot;RoyalBlue1&quot;, RGB_(0x48, 0x76, 0xff) },</a>
<a name="ln8440">  { &quot;RoyalBlue2&quot;, RGB_(0x43, 0x6e, 0xee) },</a>
<a name="ln8441">  { &quot;RoyalBlue3&quot;, RGB_(0x3a, 0x5f, 0xcd) },</a>
<a name="ln8442">  { &quot;RoyalBlue4&quot;, RGB_(0x27, 0x40, 0x8b) },</a>
<a name="ln8443">  { &quot;SaddleBrown&quot;, RGB_(0x8b, 0x45, 0x13) },</a>
<a name="ln8444">  { &quot;Salmon&quot;, RGB_(0xfa, 0x80, 0x72) },</a>
<a name="ln8445">  { &quot;Salmon1&quot;, RGB_(0xff, 0x8c, 0x69) },</a>
<a name="ln8446">  { &quot;Salmon2&quot;, RGB_(0xee, 0x82, 0x62) },</a>
<a name="ln8447">  { &quot;Salmon3&quot;, RGB_(0xcd, 0x70, 0x54) },</a>
<a name="ln8448">  { &quot;Salmon4&quot;, RGB_(0x8b, 0x4c, 0x39) },</a>
<a name="ln8449">  { &quot;SandyBrown&quot;, RGB_(0xf4, 0xa4, 0x60) },</a>
<a name="ln8450">  { &quot;SeaGreen&quot;, RGB_(0x2e, 0x8b, 0x57) },</a>
<a name="ln8451">  { &quot;SeaGreen1&quot;, RGB_(0x54, 0xff, 0x9f) },</a>
<a name="ln8452">  { &quot;SeaGreen2&quot;, RGB_(0x4e, 0xee, 0x94) },</a>
<a name="ln8453">  { &quot;SeaGreen3&quot;, RGB_(0x43, 0xcd, 0x80) },</a>
<a name="ln8454">  { &quot;SeaGreen4&quot;, RGB_(0x2e, 0x8b, 0x57) },</a>
<a name="ln8455">  { &quot;SeaShell&quot;, RGB_(0xff, 0xf5, 0xee) },</a>
<a name="ln8456">  { &quot;Seashell1&quot;, RGB_(0xff, 0xf5, 0xee) },</a>
<a name="ln8457">  { &quot;Seashell2&quot;, RGB_(0xee, 0xe5, 0xde) },</a>
<a name="ln8458">  { &quot;Seashell3&quot;, RGB_(0xcd, 0xc5, 0xbf) },</a>
<a name="ln8459">  { &quot;Seashell4&quot;, RGB_(0x8b, 0x86, 0x82) },</a>
<a name="ln8460">  { &quot;Sienna&quot;, RGB_(0xa0, 0x52, 0x2d) },</a>
<a name="ln8461">  { &quot;Sienna1&quot;, RGB_(0xff, 0x82, 0x47) },</a>
<a name="ln8462">  { &quot;Sienna2&quot;, RGB_(0xee, 0x79, 0x42) },</a>
<a name="ln8463">  { &quot;Sienna3&quot;, RGB_(0xcd, 0x68, 0x39) },</a>
<a name="ln8464">  { &quot;Sienna4&quot;, RGB_(0x8b, 0x47, 0x26) },</a>
<a name="ln8465">  { &quot;Silver&quot;, RGB_(0xc0, 0xc0, 0xc0) },</a>
<a name="ln8466">  { &quot;SkyBlue&quot;, RGB_(0x87, 0xce, 0xeb) },</a>
<a name="ln8467">  { &quot;SkyBlue1&quot;, RGB_(0x87, 0xce, 0xff) },</a>
<a name="ln8468">  { &quot;SkyBlue2&quot;, RGB_(0x7e, 0xc0, 0xee) },</a>
<a name="ln8469">  { &quot;SkyBlue3&quot;, RGB_(0x6c, 0xa6, 0xcd) },</a>
<a name="ln8470">  { &quot;SkyBlue4&quot;, RGB_(0x4a, 0x70, 0x8b) },</a>
<a name="ln8471">  { &quot;SlateBlue&quot;, RGB_(0x6a, 0x5a, 0xcd) },</a>
<a name="ln8472">  { &quot;SlateBlue1&quot;, RGB_(0x83, 0x6f, 0xff) },</a>
<a name="ln8473">  { &quot;SlateBlue2&quot;, RGB_(0x7a, 0x67, 0xee) },</a>
<a name="ln8474">  { &quot;SlateBlue3&quot;, RGB_(0x69, 0x59, 0xcd) },</a>
<a name="ln8475">  { &quot;SlateBlue4&quot;, RGB_(0x47, 0x3c, 0x8b) },</a>
<a name="ln8476">  { &quot;SlateGray&quot;, RGB_(0x70, 0x80, 0x90) },</a>
<a name="ln8477">  { &quot;SlateGray1&quot;, RGB_(0xc6, 0xe2, 0xff) },</a>
<a name="ln8478">  { &quot;SlateGray2&quot;, RGB_(0xb9, 0xd3, 0xee) },</a>
<a name="ln8479">  { &quot;SlateGray3&quot;, RGB_(0x9f, 0xb6, 0xcd) },</a>
<a name="ln8480">  { &quot;SlateGray4&quot;, RGB_(0x6c, 0x7b, 0x8b) },</a>
<a name="ln8481">  { &quot;SlateGrey&quot;, RGB_(0x70, 0x80, 0x90) },</a>
<a name="ln8482">  { &quot;Snow&quot;, RGB_(0xff, 0xfa, 0xfa) },</a>
<a name="ln8483">  { &quot;Snow1&quot;, RGB_(0xff, 0xfa, 0xfa) },</a>
<a name="ln8484">  { &quot;Snow2&quot;, RGB_(0xee, 0xe9, 0xe9) },</a>
<a name="ln8485">  { &quot;Snow3&quot;, RGB_(0xcd, 0xc9, 0xc9) },</a>
<a name="ln8486">  { &quot;Snow4&quot;, RGB_(0x8b, 0x89, 0x89) },</a>
<a name="ln8487">  { &quot;SpringGreen&quot;, RGB_(0x00, 0xff, 0x7f) },</a>
<a name="ln8488">  { &quot;SpringGreen1&quot;, RGB_(0x0, 0xff, 0x7f) },</a>
<a name="ln8489">  { &quot;SpringGreen2&quot;, RGB_(0x0, 0xee, 0x76) },</a>
<a name="ln8490">  { &quot;SpringGreen3&quot;, RGB_(0x0, 0xcd, 0x66) },</a>
<a name="ln8491">  { &quot;SpringGreen4&quot;, RGB_(0x0, 0x8b, 0x45) },</a>
<a name="ln8492">  { &quot;SteelBlue&quot;, RGB_(0x46, 0x82, 0xb4) },</a>
<a name="ln8493">  { &quot;SteelBlue1&quot;, RGB_(0x63, 0xb8, 0xff) },</a>
<a name="ln8494">  { &quot;SteelBlue2&quot;, RGB_(0x5c, 0xac, 0xee) },</a>
<a name="ln8495">  { &quot;SteelBlue3&quot;, RGB_(0x4f, 0x94, 0xcd) },</a>
<a name="ln8496">  { &quot;SteelBlue4&quot;, RGB_(0x36, 0x64, 0x8b) },</a>
<a name="ln8497">  { &quot;Tan&quot;, RGB_(0xd2, 0xb4, 0x8c) },</a>
<a name="ln8498">  { &quot;Tan1&quot;, RGB_(0xff, 0xa5, 0x4f) },</a>
<a name="ln8499">  { &quot;Tan2&quot;, RGB_(0xee, 0x9a, 0x49) },</a>
<a name="ln8500">  { &quot;Tan3&quot;, RGB_(0xcd, 0x85, 0x3f) },</a>
<a name="ln8501">  { &quot;Tan4&quot;, RGB_(0x8b, 0x5a, 0x2b) },</a>
<a name="ln8502">  { &quot;Teal&quot;, RGB_(0x00, 0x80, 0x80) },</a>
<a name="ln8503">  { &quot;Thistle&quot;, RGB_(0xd8, 0xbf, 0xd8) },</a>
<a name="ln8504">  { &quot;Thistle1&quot;, RGB_(0xff, 0xe1, 0xff) },</a>
<a name="ln8505">  { &quot;Thistle2&quot;, RGB_(0xee, 0xd2, 0xee) },</a>
<a name="ln8506">  { &quot;Thistle3&quot;, RGB_(0xcd, 0xb5, 0xcd) },</a>
<a name="ln8507">  { &quot;Thistle4&quot;, RGB_(0x8b, 0x7b, 0x8b) },</a>
<a name="ln8508">  { &quot;Tomato&quot;, RGB_(0xff, 0x63, 0x47) },</a>
<a name="ln8509">  { &quot;Tomato1&quot;, RGB_(0xff, 0x63, 0x47) },</a>
<a name="ln8510">  { &quot;Tomato2&quot;, RGB_(0xee, 0x5c, 0x42) },</a>
<a name="ln8511">  { &quot;Tomato3&quot;, RGB_(0xcd, 0x4f, 0x39) },</a>
<a name="ln8512">  { &quot;Tomato4&quot;, RGB_(0x8b, 0x36, 0x26) },</a>
<a name="ln8513">  { &quot;Turquoise&quot;, RGB_(0x40, 0xe0, 0xd0) },</a>
<a name="ln8514">  { &quot;Turquoise1&quot;, RGB_(0x0, 0xf5, 0xff) },</a>
<a name="ln8515">  { &quot;Turquoise2&quot;, RGB_(0x0, 0xe5, 0xee) },</a>
<a name="ln8516">  { &quot;Turquoise3&quot;, RGB_(0x0, 0xc5, 0xcd) },</a>
<a name="ln8517">  { &quot;Turquoise4&quot;, RGB_(0x0, 0x86, 0x8b) },</a>
<a name="ln8518">  { &quot;Violet&quot;, RGB_(0xee, 0x82, 0xee) },</a>
<a name="ln8519">  { &quot;VioletRed&quot;, RGB_(0xd0, 0x20, 0x90) },</a>
<a name="ln8520">  { &quot;VioletRed1&quot;, RGB_(0xff, 0x3e, 0x96) },</a>
<a name="ln8521">  { &quot;VioletRed2&quot;, RGB_(0xee, 0x3a, 0x8c) },</a>
<a name="ln8522">  { &quot;VioletRed3&quot;, RGB_(0xcd, 0x32, 0x78) },</a>
<a name="ln8523">  { &quot;VioletRed4&quot;, RGB_(0x8b, 0x22, 0x52) },</a>
<a name="ln8524">  { &quot;WebGray&quot;, RGB_(0x80, 0x80, 0x80) },</a>
<a name="ln8525">  { &quot;WebGreen&quot;, RGB_(0x0, 0x80, 0x0) },</a>
<a name="ln8526">  { &quot;WebGrey&quot;, RGB_(0x80, 0x80, 0x80) },</a>
<a name="ln8527">  { &quot;WebMaroon&quot;, RGB_(0x80, 0x0, 0x0) },</a>
<a name="ln8528">  { &quot;WebPurple&quot;, RGB_(0x80, 0x0, 0x80) },</a>
<a name="ln8529">  { &quot;Wheat&quot;, RGB_(0xf5, 0xde, 0xb3) },</a>
<a name="ln8530">  { &quot;Wheat1&quot;, RGB_(0xff, 0xe7, 0xba) },</a>
<a name="ln8531">  { &quot;Wheat2&quot;, RGB_(0xee, 0xd8, 0xae) },</a>
<a name="ln8532">  { &quot;Wheat3&quot;, RGB_(0xcd, 0xba, 0x96) },</a>
<a name="ln8533">  { &quot;Wheat4&quot;, RGB_(0x8b, 0x7e, 0x66) },</a>
<a name="ln8534">  { &quot;White&quot;, RGB_(0xff, 0xff, 0xff) },</a>
<a name="ln8535">  { &quot;WhiteSmoke&quot;, RGB_(0xf5, 0xf5, 0xf5) },</a>
<a name="ln8536">  { &quot;X11Gray&quot;, RGB_(0xbe, 0xbe, 0xbe) },</a>
<a name="ln8537">  { &quot;X11Green&quot;, RGB_(0x0, 0xff, 0x0) },</a>
<a name="ln8538">  { &quot;X11Grey&quot;, RGB_(0xbe, 0xbe, 0xbe) },</a>
<a name="ln8539">  { &quot;X11Maroon&quot;, RGB_(0xb0, 0x30, 0x60) },</a>
<a name="ln8540">  { &quot;X11Purple&quot;, RGB_(0xa0, 0x20, 0xf0) },</a>
<a name="ln8541">  { &quot;Yellow&quot;, RGB_(0xff, 0xff, 0x00) },</a>
<a name="ln8542">  { &quot;Yellow1&quot;, RGB_(0xff, 0xff, 0x0) },</a>
<a name="ln8543">  { &quot;Yellow2&quot;, RGB_(0xee, 0xee, 0x0) },</a>
<a name="ln8544">  { &quot;Yellow3&quot;, RGB_(0xcd, 0xcd, 0x0) },</a>
<a name="ln8545">  { &quot;Yellow4&quot;, RGB_(0x8b, 0x8b, 0x0) },</a>
<a name="ln8546">  { &quot;YellowGreen&quot;, RGB_(0x9a, 0xcd, 0x32) },</a>
<a name="ln8547">  { NULL, 0 },</a>
<a name="ln8548">};</a>
<a name="ln8549"> </a>
<a name="ln8550"> </a>
<a name="ln8551">/// Translate to RgbValue if \p name is an hex value (e.g. #XXXXXX),</a>
<a name="ln8552">/// else look into color_name_table to translate a color name to  its</a>
<a name="ln8553">/// hex value</a>
<a name="ln8554">///</a>
<a name="ln8555">/// @param[in] name string value to convert to RGB</a>
<a name="ln8556">/// return the hex value or -1 if could not find a correct value</a>
<a name="ln8557">RgbValue name_to_color(const char *name)</a>
<a name="ln8558">{</a>
<a name="ln8559"> </a>
<a name="ln8560">  if (name[0] == '#' &amp;&amp; isxdigit(name[1]) &amp;&amp; isxdigit(name[2])</a>
<a name="ln8561">      &amp;&amp; isxdigit(name[3]) &amp;&amp; isxdigit(name[4]) &amp;&amp; isxdigit(name[5])</a>
<a name="ln8562">      &amp;&amp; isxdigit(name[6]) &amp;&amp; name[7] == NUL) {</a>
<a name="ln8563">    // rgb hex string</a>
<a name="ln8564">    return strtol((char *)(name + 1), NULL, 16);</a>
<a name="ln8565">  } else if (!STRICMP(name, &quot;bg&quot;) || !STRICMP(name, &quot;background&quot;)) {</a>
<a name="ln8566">    return normal_bg;</a>
<a name="ln8567">  } else if (!STRICMP(name, &quot;fg&quot;) || !STRICMP(name, &quot;foreground&quot;)) {</a>
<a name="ln8568">    return normal_fg;</a>
<a name="ln8569">  }</a>
<a name="ln8570"> </a>
<a name="ln8571">  for (int i = 0; color_name_table[i].name != NULL; i++) {</a>
<a name="ln8572">    if (!STRICMP(name, color_name_table[i].name)) {</a>
<a name="ln8573">      return color_name_table[i].color;</a>
<a name="ln8574">    }</a>
<a name="ln8575">  }</a>
<a name="ln8576"> </a>
<a name="ln8577">  return -1;</a>
<a name="ln8578">}</a>
<a name="ln8579"> </a>
<a name="ln8580"> </a>
<a name="ln8581">/**************************************</a>
<a name="ln8582">*  End of Highlighting stuff	      *</a>
<a name="ln8583">**************************************/</a>

</code></pre>
<div class="balloon" rel="3361"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'arg_end' should be checked here.</p></div>
<div class="balloon" rel="3550"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'arg_end' should be checked here.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
