
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ex_cmds2.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/// @file ex_cmds2.c</a>
<a name="ln5">///</a>
<a name="ln6">/// Some more functions for command line commands</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;assert.h&gt;</a>
<a name="ln9">#include &lt;inttypes.h&gt;</a>
<a name="ln10">#include &lt;stdbool.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12">#include &lt;fcntl.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;nvim/vim.h&quot;</a>
<a name="ln15">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln16">#ifdef HAVE_LOCALE_H</a>
<a name="ln17"># include &lt;locale.h&gt;</a>
<a name="ln18">#endif</a>
<a name="ln19">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln20">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln21">#include &quot;nvim/change.h&quot;</a>
<a name="ln22">#include &quot;nvim/charset.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln24">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln25">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln28">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln29">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln30">#include &quot;nvim/mark.h&quot;</a>
<a name="ln31">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln32">#include &quot;nvim/memline.h&quot;</a>
<a name="ln33">#include &quot;nvim/message.h&quot;</a>
<a name="ln34">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln35">#include &quot;nvim/garray.h&quot;</a>
<a name="ln36">#include &quot;nvim/memory.h&quot;</a>
<a name="ln37">#include &quot;nvim/move.h&quot;</a>
<a name="ln38">#include &quot;nvim/normal.h&quot;</a>
<a name="ln39">#include &quot;nvim/ops.h&quot;</a>
<a name="ln40">#include &quot;nvim/option.h&quot;</a>
<a name="ln41">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln42">#include &quot;nvim/path.h&quot;</a>
<a name="ln43">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln44">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln45">#include &quot;nvim/screen.h&quot;</a>
<a name="ln46">#include &quot;nvim/strings.h&quot;</a>
<a name="ln47">#include &quot;nvim/undo.h&quot;</a>
<a name="ln48">#include &quot;nvim/version.h&quot;</a>
<a name="ln49">#include &quot;nvim/window.h&quot;</a>
<a name="ln50">#include &quot;nvim/profile.h&quot;</a>
<a name="ln51">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln52">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln53">#include &quot;nvim/os/fs_defs.h&quot;</a>
<a name="ln54">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln55">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln56"> </a>
<a name="ln57"> </a>
<a name="ln58">/// Growarray to store info about already sourced scripts.</a>
<a name="ln59">/// Also store the dev/ino, so that we don't have to stat() each</a>
<a name="ln60">/// script when going through the list.</a>
<a name="ln61">typedef struct scriptitem_S {</a>
<a name="ln62">  char_u      *sn_name;</a>
<a name="ln63">  bool file_id_valid;</a>
<a name="ln64">  FileID file_id;</a>
<a name="ln65">  bool sn_prof_on;              ///&lt; true when script is/was profiled</a>
<a name="ln66">  bool sn_pr_force;             ///&lt; forceit: profile functions in this script</a>
<a name="ln67">  proftime_T sn_pr_child;       ///&lt; time set when going into first child</a>
<a name="ln68">  int sn_pr_nest;               ///&lt; nesting for sn_pr_child</a>
<a name="ln69">  // profiling the script as a whole</a>
<a name="ln70">  int sn_pr_count;              ///&lt; nr of times sourced</a>
<a name="ln71">  proftime_T sn_pr_total;       ///&lt; time spent in script + children</a>
<a name="ln72">  proftime_T sn_pr_self;        ///&lt; time spent in script itself</a>
<a name="ln73">  proftime_T sn_pr_start;       ///&lt; time at script start</a>
<a name="ln74">  proftime_T sn_pr_children;    ///&lt; time in children after script start</a>
<a name="ln75">  // profiling the script per line</a>
<a name="ln76">  garray_T sn_prl_ga;           ///&lt; things stored for every line</a>
<a name="ln77">  proftime_T sn_prl_start;      ///&lt; start time for current line</a>
<a name="ln78">  proftime_T sn_prl_children;   ///&lt; time spent in children for this line</a>
<a name="ln79">  proftime_T sn_prl_wait;       ///&lt; wait start time for current line</a>
<a name="ln80">  linenr_T sn_prl_idx;          ///&lt; index of line being timed; -1 if none</a>
<a name="ln81">  int sn_prl_execed;            ///&lt; line being timed was executed</a>
<a name="ln82">} scriptitem_T;</a>
<a name="ln83"> </a>
<a name="ln84">static garray_T script_items = { 0, 0, sizeof(scriptitem_T), 4, NULL };</a>
<a name="ln85">#define SCRIPT_ITEM(id) (((scriptitem_T *)script_items.ga_data)[(id) - 1])</a>
<a name="ln86"> </a>
<a name="ln87">// Struct used in sn_prl_ga for every line of a script.</a>
<a name="ln88">typedef struct sn_prl_S {</a>
<a name="ln89">  int snp_count;                ///&lt; nr of times line was executed</a>
<a name="ln90">  proftime_T sn_prl_total;      ///&lt; time spent in a line + children</a>
<a name="ln91">  proftime_T sn_prl_self;       ///&lt; time spent in a line itself</a>
<a name="ln92">} sn_prl_T;</a>
<a name="ln93"> </a>
<a name="ln94">/// Structure used to store info for each sourced file.</a>
<a name="ln95">/// It is shared between do_source() and getsourceline().</a>
<a name="ln96">/// This is required, because it needs to be handed to do_cmdline() and</a>
<a name="ln97">/// sourcing can be done recursively.</a>
<a name="ln98">struct source_cookie {</a>
<a name="ln99">  FILE *fp;                     ///&lt; opened file for sourcing</a>
<a name="ln100">  char_u *nextline;             ///&lt; if not NULL: line that was read ahead</a>
<a name="ln101">  linenr_T sourcing_lnum;       ///&lt; line number of the source file</a>
<a name="ln102">  int finished;                 ///&lt; &quot;:finish&quot; used</a>
<a name="ln103">#if defined(USE_CRNL)</a>
<a name="ln104">  int fileformat;               ///&lt; EOL_UNKNOWN, EOL_UNIX or EOL_DOS</a>
<a name="ln105">  bool error;                   ///&lt; true if LF found after CR-LF</a>
<a name="ln106">#endif</a>
<a name="ln107">  linenr_T breakpoint;          ///&lt; next line with breakpoint or zero</a>
<a name="ln108">  char_u *fname;                ///&lt; name of sourced file</a>
<a name="ln109">  int dbg_tick;                 ///&lt; debug_tick when breakpoint was set</a>
<a name="ln110">  int level;                    ///&lt; top nesting level of sourced file</a>
<a name="ln111">  vimconv_T conv;               ///&lt; type of conversion</a>
<a name="ln112">};</a>
<a name="ln113"> </a>
<a name="ln114">#  define PRL_ITEM(si, idx)     (((sn_prl_T *)(si)-&gt;sn_prl_ga.ga_data)[(idx)])</a>
<a name="ln115"> </a>
<a name="ln116">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln117"># include &quot;ex_cmds2.c.generated.h&quot;</a>
<a name="ln118">#endif</a>
<a name="ln119"> </a>
<a name="ln120">/// batch mode debugging: don't save and restore typeahead.</a>
<a name="ln121">static bool debug_greedy = false;</a>
<a name="ln122"> </a>
<a name="ln123">static char *debug_oldval = NULL;  // old and newval for debug expressions</a>
<a name="ln124">static char *debug_newval = NULL;</a>
<a name="ln125"> </a>
<a name="ln126">/// Debug mode. Repeatedly get Ex commands, until told to continue normal</a>
<a name="ln127">/// execution.</a>
<a name="ln128">void do_debug(char_u *cmd)</a>
<a name="ln129">{</a>
<a name="ln130">  int save_msg_scroll = msg_scroll;</a>
<a name="ln131">  int save_State = State;</a>
<a name="ln132">  int save_did_emsg = did_emsg;</a>
<a name="ln133">  const bool save_cmd_silent = cmd_silent;</a>
<a name="ln134">  int save_msg_silent = msg_silent;</a>
<a name="ln135">  int save_emsg_silent = emsg_silent;</a>
<a name="ln136">  int save_redir_off = redir_off;</a>
<a name="ln137">  tasave_T typeaheadbuf;</a>
<a name="ln138">  bool typeahead_saved = false;</a>
<a name="ln139">  int save_ignore_script = 0;</a>
<a name="ln140">  int save_ex_normal_busy;</a>
<a name="ln141">  int n;</a>
<a name="ln142">  char_u      *cmdline = NULL;</a>
<a name="ln143">  char_u      *p;</a>
<a name="ln144">  char        *tail = NULL;</a>
<a name="ln145">  static int last_cmd = 0;</a>
<a name="ln146">#define CMD_CONT        1</a>
<a name="ln147">#define CMD_NEXT        2</a>
<a name="ln148">#define CMD_STEP        3</a>
<a name="ln149">#define CMD_FINISH      4</a>
<a name="ln150">#define CMD_QUIT        5</a>
<a name="ln151">#define CMD_INTERRUPT   6</a>
<a name="ln152">#define CMD_BACKTRACE   7</a>
<a name="ln153">#define CMD_FRAME       8</a>
<a name="ln154">#define CMD_UP          9</a>
<a name="ln155">#define CMD_DOWN        10</a>
<a name="ln156"> </a>
<a name="ln157"> </a>
<a name="ln158">  RedrawingDisabled++;          // don't redisplay the window</a>
<a name="ln159">  no_wait_return++;             // don't wait for return</a>
<a name="ln160">  did_emsg = false;             // don't use error from debugged stuff</a>
<a name="ln161">  cmd_silent = false;           // display commands</a>
<a name="ln162">  msg_silent = false;           // display messages</a>
<a name="ln163">  emsg_silent = false;          // display error messages</a>
<a name="ln164">  redir_off = true;             // don't redirect debug commands</a>
<a name="ln165"> </a>
<a name="ln166">  State = NORMAL;</a>
<a name="ln167">  debug_mode = true;</a>
<a name="ln168"> </a>
<a name="ln169">  if (!debug_did_msg) {</a>
<a name="ln170">    MSG(_(&quot;Entering Debug mode.  Type \&quot;cont\&quot; to continue.&quot;));</a>
<a name="ln171">  }</a>
<a name="ln172">  if (debug_oldval != NULL) {</a>
<a name="ln173">    smsg(_(&quot;Oldval = \&quot;%s\&quot;&quot;), debug_oldval);</a>
<a name="ln174">    xfree(debug_oldval);</a>
<a name="ln175">    debug_oldval = NULL;</a>
<a name="ln176">  }</a>
<a name="ln177">  if (debug_newval != NULL) {</a>
<a name="ln178">    smsg(_(&quot;Newval = \&quot;%s\&quot;&quot;), debug_newval);</a>
<a name="ln179">    xfree(debug_newval);</a>
<a name="ln180">    debug_newval = NULL;</a>
<a name="ln181">  }</a>
<a name="ln182">  if (sourcing_name != NULL) {</a>
<a name="ln183">    msg(sourcing_name);</a>
<a name="ln184">  }</a>
<a name="ln185">  if (sourcing_lnum != 0) {</a>
<a name="ln186">    smsg(_(&quot;line %&quot; PRId64 &quot;: %s&quot;), (int64_t)sourcing_lnum, cmd);</a>
<a name="ln187">  } else {</a>
<a name="ln188">    smsg(_(&quot;cmd: %s&quot;), cmd);</a>
<a name="ln189">  }</a>
<a name="ln190">  // Repeat getting a command and executing it.</a>
<a name="ln191">  for (;; ) {</a>
<a name="ln192">    msg_scroll = true;</a>
<a name="ln193">    need_wait_return = false;</a>
<a name="ln194">    // Save the current typeahead buffer and replace it with an empty one.</a>
<a name="ln195">    // This makes sure we get input from the user here and don't interfere</a>
<a name="ln196">    // with the commands being executed.  Reset &quot;ex_normal_busy&quot; to avoid</a>
<a name="ln197">    // the side effects of using &quot;:normal&quot;. Save the stuff buffer and make</a>
<a name="ln198">    // it empty. Set ignore_script to avoid reading from script input.</a>
<a name="ln199">    save_ex_normal_busy = ex_normal_busy;</a>
<a name="ln200">    ex_normal_busy = 0;</a>
<a name="ln201">    if (!debug_greedy) {</a>
<a name="ln202">      save_typeahead(&amp;typeaheadbuf);</a>
<a name="ln203">      typeahead_saved = true;</a>
<a name="ln204">      save_ignore_script = ignore_script;</a>
<a name="ln205">      ignore_script = true;</a>
<a name="ln206">    }</a>
<a name="ln207"> </a>
<a name="ln208">    xfree(cmdline);</a>
<a name="ln209">    cmdline = (char_u *)getcmdline_prompt('&gt;', NULL, 0, EXPAND_NOTHING, NULL,</a>
<a name="ln210">                                          CALLBACK_NONE);</a>
<a name="ln211"> </a>
<a name="ln212">    if (typeahead_saved) {</a>
<a name="ln213">      restore_typeahead(&amp;typeaheadbuf);</a>
<a name="ln214">      ignore_script = save_ignore_script;</a>
<a name="ln215">    }</a>
<a name="ln216">    ex_normal_busy = save_ex_normal_busy;</a>
<a name="ln217"> </a>
<a name="ln218">    cmdline_row = msg_row;</a>
<a name="ln219">    msg_starthere();</a>
<a name="ln220">    if (cmdline != NULL) {</a>
<a name="ln221">      // If this is a debug command, set &quot;last_cmd&quot;.</a>
<a name="ln222">      // If not, reset &quot;last_cmd&quot;.</a>
<a name="ln223">      // For a blank line use previous command.</a>
<a name="ln224">      p = skipwhite(cmdline);</a>
<a name="ln225">      if (*p != NUL) {</a>
<a name="ln226">        switch (*p) {</a>
<a name="ln227">        case 'c': last_cmd = CMD_CONT;</a>
<a name="ln228">          tail = &quot;ont&quot;;</a>
<a name="ln229">          break;</a>
<a name="ln230">        case 'n': last_cmd = CMD_NEXT;</a>
<a name="ln231">          tail = &quot;ext&quot;;</a>
<a name="ln232">          break;</a>
<a name="ln233">        case 's': last_cmd = CMD_STEP;</a>
<a name="ln234">          tail = &quot;tep&quot;;</a>
<a name="ln235">          break;</a>
<a name="ln236">        case 'f':</a>
<a name="ln237">          last_cmd = 0;</a>
<a name="ln238">          if (p[1] == 'r') {</a>
<a name="ln239">            last_cmd = CMD_FRAME;</a>
<a name="ln240">            tail = &quot;rame&quot;;</a>
<a name="ln241">          } else {</a>
<a name="ln242">            last_cmd = CMD_FINISH;</a>
<a name="ln243">            tail = &quot;inish&quot;;</a>
<a name="ln244">          }</a>
<a name="ln245">          break;</a>
<a name="ln246">        case 'q': last_cmd = CMD_QUIT;</a>
<a name="ln247">          tail = &quot;uit&quot;;</a>
<a name="ln248">          break;</a>
<a name="ln249">        case 'i': last_cmd = CMD_INTERRUPT;</a>
<a name="ln250">          tail = &quot;nterrupt&quot;;</a>
<a name="ln251">          break;</a>
<a name="ln252">        case 'b':</a>
<a name="ln253">          last_cmd = CMD_BACKTRACE;</a>
<a name="ln254">          if (p[1] == 't') {</a>
<a name="ln255">            tail = &quot;t&quot;;</a>
<a name="ln256">          } else {</a>
<a name="ln257">            tail = &quot;acktrace&quot;;</a>
<a name="ln258">          }</a>
<a name="ln259">          break;</a>
<a name="ln260">        case 'w':</a>
<a name="ln261">          last_cmd = CMD_BACKTRACE;</a>
<a name="ln262">          tail = &quot;here&quot;;</a>
<a name="ln263">          break;</a>
<a name="ln264">        case 'u':</a>
<a name="ln265">          last_cmd = CMD_UP;</a>
<a name="ln266">          tail = &quot;p&quot;;</a>
<a name="ln267">          break;</a>
<a name="ln268">        case 'd':</a>
<a name="ln269">          last_cmd = CMD_DOWN;</a>
<a name="ln270">          tail = &quot;own&quot;;</a>
<a name="ln271">          break;</a>
<a name="ln272">        default: last_cmd = 0;</a>
<a name="ln273">        }</a>
<a name="ln274">        if (last_cmd != 0) {</a>
<a name="ln275">          // Check that the tail matches.</a>
<a name="ln276">          p++;</a>
<a name="ln277">          while (*p != NUL &amp;&amp; *p == *tail) {</a>
<a name="ln278">            p++;</a>
<a name="ln279">            tail++;</a>
<a name="ln280">          }</a>
<a name="ln281">          if (ASCII_ISALPHA(*p) &amp;&amp; last_cmd != CMD_FRAME) {</a>
<a name="ln282">            last_cmd = 0;</a>
<a name="ln283">          }</a>
<a name="ln284">        }</a>
<a name="ln285">      }</a>
<a name="ln286"> </a>
<a name="ln287">      if (last_cmd != 0) {</a>
<a name="ln288">        // Execute debug command: decided where to break next and return.</a>
<a name="ln289">        switch (last_cmd) {</a>
<a name="ln290">        case CMD_CONT:</a>
<a name="ln291">          debug_break_level = -1;</a>
<a name="ln292">          break;</a>
<a name="ln293">        case CMD_NEXT:</a>
<a name="ln294">          debug_break_level = ex_nesting_level;</a>
<a name="ln295">          break;</a>
<a name="ln296">        case CMD_STEP:</a>
<a name="ln297">          debug_break_level = 9999;</a>
<a name="ln298">          break;</a>
<a name="ln299">        case CMD_FINISH:</a>
<a name="ln300">          debug_break_level = ex_nesting_level - 1;</a>
<a name="ln301">          break;</a>
<a name="ln302">        case CMD_QUIT:</a>
<a name="ln303">          got_int = true;</a>
<a name="ln304">          debug_break_level = -1;</a>
<a name="ln305">          break;</a>
<a name="ln306">        case CMD_INTERRUPT:</a>
<a name="ln307">          got_int = true;</a>
<a name="ln308">          debug_break_level = 9999;</a>
<a name="ln309">          // Do not repeat &quot;&gt;interrupt&quot; cmd, continue stepping.</a>
<a name="ln310">          last_cmd = CMD_STEP;</a>
<a name="ln311">          break;</a>
<a name="ln312">        case CMD_BACKTRACE:</a>
<a name="ln313">          do_showbacktrace(cmd);</a>
<a name="ln314">          continue;</a>
<a name="ln315">        case CMD_FRAME:</a>
<a name="ln316">          if (*p == NUL) {</a>
<a name="ln317">            do_showbacktrace(cmd);</a>
<a name="ln318">          } else {</a>
<a name="ln319">            p = skipwhite(p);</a>
<a name="ln320">            do_setdebugtracelevel(p);</a>
<a name="ln321">          }</a>
<a name="ln322">          continue;</a>
<a name="ln323">        case CMD_UP:</a>
<a name="ln324">          debug_backtrace_level++;</a>
<a name="ln325">          do_checkbacktracelevel();</a>
<a name="ln326">          continue;</a>
<a name="ln327">        case CMD_DOWN:</a>
<a name="ln328">          debug_backtrace_level--;</a>
<a name="ln329">          do_checkbacktracelevel();</a>
<a name="ln330">          continue;</a>
<a name="ln331">        }</a>
<a name="ln332">        // Going out reset backtrace_level</a>
<a name="ln333">        debug_backtrace_level = 0;</a>
<a name="ln334">        break;</a>
<a name="ln335">      }</a>
<a name="ln336"> </a>
<a name="ln337">      // don't debug this command</a>
<a name="ln338">      n = debug_break_level;</a>
<a name="ln339">      debug_break_level = -1;</a>
<a name="ln340">      (void)do_cmdline(cmdline, getexline, NULL,</a>
<a name="ln341">                       DOCMD_VERBOSE|DOCMD_EXCRESET);</a>
<a name="ln342">      debug_break_level = n;</a>
<a name="ln343">    }</a>
<a name="ln344">    lines_left = (int)(Rows - 1);</a>
<a name="ln345">  }</a>
<a name="ln346">  xfree(cmdline);</a>
<a name="ln347"> </a>
<a name="ln348">  RedrawingDisabled--;</a>
<a name="ln349">  no_wait_return--;</a>
<a name="ln350">  redraw_all_later(NOT_VALID);</a>
<a name="ln351">  need_wait_return = false;</a>
<a name="ln352">  msg_scroll = save_msg_scroll;</a>
<a name="ln353">  lines_left = (int)(Rows - 1);</a>
<a name="ln354">  State = save_State;</a>
<a name="ln355">  debug_mode = false;</a>
<a name="ln356">  did_emsg = save_did_emsg;</a>
<a name="ln357">  cmd_silent = save_cmd_silent;</a>
<a name="ln358">  msg_silent = save_msg_silent;</a>
<a name="ln359">  emsg_silent = save_emsg_silent;</a>
<a name="ln360">  redir_off = save_redir_off;</a>
<a name="ln361"> </a>
<a name="ln362">  // Only print the message again when typing a command before coming back here.</a>
<a name="ln363">  debug_did_msg = true;</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">static int get_maxbacktrace_level(void)</a>
<a name="ln367">{</a>
<a name="ln368">  int maxbacktrace = 0;</a>
<a name="ln369"> </a>
<a name="ln370">  if (sourcing_name != NULL) {</a>
<a name="ln371">    char *p = (char *)sourcing_name;</a>
<a name="ln372">    char *q;</a>
<a name="ln373">    while ((q = strstr(p, &quot;..&quot;)) != NULL) {</a>
<a name="ln374">      p = q + 2;</a>
<a name="ln375">      maxbacktrace++;</a>
<a name="ln376">    }</a>
<a name="ln377">  }</a>
<a name="ln378">  return maxbacktrace;</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381">static void do_setdebugtracelevel(char_u *arg)</a>
<a name="ln382">{</a>
<a name="ln383">  int level = atoi((char *)arg);</a>
<a name="ln384">  if (*arg == '+' || level &lt; 0) {</a>
<a name="ln385">    debug_backtrace_level += level;</a>
<a name="ln386">  } else {</a>
<a name="ln387">    debug_backtrace_level = level;</a>
<a name="ln388">  }</a>
<a name="ln389"> </a>
<a name="ln390">  do_checkbacktracelevel();</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">static void do_checkbacktracelevel(void)</a>
<a name="ln394">{</a>
<a name="ln395">  if (debug_backtrace_level &lt; 0) {</a>
<a name="ln396">    debug_backtrace_level = 0;</a>
<a name="ln397">    MSG(_(&quot;frame is zero&quot;));</a>
<a name="ln398">  } else {</a>
<a name="ln399">    int max = get_maxbacktrace_level();</a>
<a name="ln400">    if (debug_backtrace_level &gt; max) {</a>
<a name="ln401">      debug_backtrace_level = max;</a>
<a name="ln402">      smsg(_(&quot;frame at highest level: %d&quot;), max);</a>
<a name="ln403">    }</a>
<a name="ln404">  }</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407">static void do_showbacktrace(char_u *cmd)</a>
<a name="ln408">{</a>
<a name="ln409">  if (sourcing_name != NULL) {</a>
<a name="ln410">    int i = 0;</a>
<a name="ln411">    int max = get_maxbacktrace_level();</a>
<a name="ln412">    char *cur = (char *)sourcing_name;</a>
<a name="ln413">    while (!got_int) {</a>
<a name="ln414">      char *next = strstr(cur, &quot;..&quot;);</a>
<a name="ln415">      if (next != NULL) {</a>
<a name="ln416">        *next = NUL;</a>
<a name="ln417">      }</a>
<a name="ln418">      if (i == max - debug_backtrace_level) {</a>
<a name="ln419">        smsg(&quot;-&gt;%d %s&quot;, max - i, cur);</a>
<a name="ln420">      } else {</a>
<a name="ln421">        smsg(&quot;  %d %s&quot;, max - i, cur);</a>
<a name="ln422">      }</a>
<a name="ln423">      i++;</a>
<a name="ln424">      if (next == NULL) {</a>
<a name="ln425">        break;</a>
<a name="ln426">      }</a>
<a name="ln427">      *next = '.';</a>
<a name="ln428">      cur = next + 2;</a>
<a name="ln429">    }</a>
<a name="ln430">  }</a>
<a name="ln431">  if (sourcing_lnum != 0) {</a>
<a name="ln432">    smsg(_(&quot;line %&quot; PRId64 &quot;: %s&quot;), (int64_t)sourcing_lnum, cmd);</a>
<a name="ln433">  } else {</a>
<a name="ln434">    smsg(_(&quot;cmd: %s&quot;), cmd);</a>
<a name="ln435">  }</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438"> </a>
<a name="ln439">/// &quot;:debug&quot;.</a>
<a name="ln440">void ex_debug(exarg_T *eap)</a>
<a name="ln441">{</a>
<a name="ln442">  int debug_break_level_save = debug_break_level;</a>
<a name="ln443"> </a>
<a name="ln444">  debug_break_level = 9999;</a>
<a name="ln445">  do_cmdline_cmd((char *)eap-&gt;arg);</a>
<a name="ln446">  debug_break_level = debug_break_level_save;</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">static char_u   *debug_breakpoint_name = NULL;</a>
<a name="ln450">static linenr_T debug_breakpoint_lnum;</a>
<a name="ln451"> </a>
<a name="ln452">/// When debugging or a breakpoint is set on a skipped command, no debug prompt</a>
<a name="ln453">/// is shown by do_one_cmd().  This situation is indicated by debug_skipped, and</a>
<a name="ln454">/// debug_skipped_name is then set to the source name in the breakpoint case. If</a>
<a name="ln455">/// a skipped command decides itself that a debug prompt should be displayed, it</a>
<a name="ln456">/// can do so by calling dbg_check_skipped().</a>
<a name="ln457">static int debug_skipped;</a>
<a name="ln458">static char_u   *debug_skipped_name;</a>
<a name="ln459"> </a>
<a name="ln460">/// Go to debug mode when a breakpoint was encountered or &quot;ex_nesting_level&quot; is</a>
<a name="ln461">/// at or below the break level.  But only when the line is actually</a>
<a name="ln462">/// executed.  Return true and set breakpoint_name for skipped commands that</a>
<a name="ln463">/// decide to execute something themselves.</a>
<a name="ln464">/// Called from do_one_cmd() before executing a command.</a>
<a name="ln465">void dbg_check_breakpoint(exarg_T *eap)</a>
<a name="ln466">{</a>
<a name="ln467">  char_u      *p;</a>
<a name="ln468"> </a>
<a name="ln469">  debug_skipped = false;</a>
<a name="ln470">  if (debug_breakpoint_name != NULL) {</a>
<a name="ln471">    if (!eap-&gt;skip) {</a>
<a name="ln472">      // replace K_SNR with &quot;&lt;SNR&gt;&quot;</a>
<a name="ln473">      if (debug_breakpoint_name[0] == K_SPECIAL</a>
<a name="ln474">          &amp;&amp; debug_breakpoint_name[1] == KS_EXTRA</a>
<a name="ln475">          &amp;&amp; debug_breakpoint_name[2] == (int)KE_SNR) {</a>
<a name="ln476">        p = (char_u *)&quot;&lt;SNR&gt;&quot;;</a>
<a name="ln477">      } else {</a>
<a name="ln478">        p = (char_u *)&quot;&quot;;</a>
<a name="ln479">      }</a>
<a name="ln480">      smsg(_(&quot;Breakpoint in \&quot;%s%s\&quot; line %&quot; PRId64),</a>
<a name="ln481">           p,</a>
<a name="ln482">           debug_breakpoint_name + (*p == NUL ? 0 : 3),</a>
<a name="ln483">           (int64_t)debug_breakpoint_lnum);</a>
<a name="ln484">      debug_breakpoint_name = NULL;</a>
<a name="ln485">      do_debug(eap-&gt;cmd);</a>
<a name="ln486">    } else {</a>
<a name="ln487">      debug_skipped = true;</a>
<a name="ln488">      debug_skipped_name = debug_breakpoint_name;</a>
<a name="ln489">      debug_breakpoint_name = NULL;</a>
<a name="ln490">    }</a>
<a name="ln491">  } else if (ex_nesting_level &lt;= debug_break_level) {</a>
<a name="ln492">    if (!eap-&gt;skip) {</a>
<a name="ln493">      do_debug(eap-&gt;cmd);</a>
<a name="ln494">    } else {</a>
<a name="ln495">      debug_skipped = true;</a>
<a name="ln496">      debug_skipped_name = NULL;</a>
<a name="ln497">    }</a>
<a name="ln498">  }</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">/// Go to debug mode if skipped by dbg_check_breakpoint() because eap-&gt;skip was</a>
<a name="ln502">/// set.</a>
<a name="ln503">///</a>
<a name="ln504">/// @return true when the debug mode is entered this time.</a>
<a name="ln505">bool dbg_check_skipped(exarg_T *eap)</a>
<a name="ln506">{</a>
<a name="ln507">  int prev_got_int;</a>
<a name="ln508"> </a>
<a name="ln509">  if (debug_skipped) {</a>
<a name="ln510">    // Save the value of got_int and reset it.  We don't want a previous</a>
<a name="ln511">    // interruption cause flushing the input buffer.</a>
<a name="ln512">    prev_got_int = got_int;</a>
<a name="ln513">    got_int = false;</a>
<a name="ln514">    debug_breakpoint_name = debug_skipped_name;</a>
<a name="ln515">    // eap-&gt;skip is true</a>
<a name="ln516">    eap-&gt;skip = false;</a>
<a name="ln517">    dbg_check_breakpoint(eap);</a>
<a name="ln518">    eap-&gt;skip = true;</a>
<a name="ln519">    got_int |= prev_got_int;</a>
<a name="ln520">    return true;</a>
<a name="ln521">  }</a>
<a name="ln522">  return false;</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525">/// The list of breakpoints: dbg_breakp.</a>
<a name="ln526">/// This is a grow-array of structs.</a>
<a name="ln527">struct debuggy {</a>
<a name="ln528">  int dbg_nr;                   ///&lt; breakpoint number</a>
<a name="ln529">  int dbg_type;                 ///&lt; DBG_FUNC or DBG_FILE or DBG_EXPR</a>
<a name="ln530">  char_u *dbg_name;             ///&lt; function, expression or file name</a>
<a name="ln531">  regprog_T *dbg_prog;          ///&lt; regexp program</a>
<a name="ln532">  linenr_T dbg_lnum;            ///&lt; line number in function or file</a>
<a name="ln533">  int dbg_forceit;              ///&lt; ! used</a>
<a name="ln534">  typval_T *dbg_val;            ///&lt; last result of watchexpression</a>
<a name="ln535">  int dbg_level;                ///&lt; stored nested level for expr</a>
<a name="ln536">};</a>
<a name="ln537"> </a>
<a name="ln538">static garray_T dbg_breakp = { 0, 0, sizeof(struct debuggy), 4, NULL };</a>
<a name="ln539">#define BREAKP(idx)             (((struct debuggy *)dbg_breakp.ga_data)[idx])</a>
<a name="ln540">#define DEBUGGY(gap, idx)       (((struct debuggy *)gap-&gt;ga_data)[idx])</a>
<a name="ln541">static int last_breakp = 0;     // nr of last defined breakpoint</a>
<a name="ln542"> </a>
<a name="ln543">// Profiling uses file and func names similar to breakpoints.</a>
<a name="ln544">static garray_T prof_ga = { 0, 0, sizeof(struct debuggy), 4, NULL };</a>
<a name="ln545">#define DBG_FUNC        1</a>
<a name="ln546">#define DBG_FILE        2</a>
<a name="ln547">#define DBG_EXPR        3</a>
<a name="ln548"> </a>
<a name="ln549"> </a>
<a name="ln550">/// Parse the arguments of &quot;:profile&quot;, &quot;:breakadd&quot; or &quot;:breakdel&quot; and put them</a>
<a name="ln551">/// in the entry just after the last one in dbg_breakp.  Note that &quot;dbg_name&quot;</a>
<a name="ln552">/// is allocated.</a>
<a name="ln553">/// Returns FAIL for failure.</a>
<a name="ln554">///</a>
<a name="ln555">/// @param arg</a>
<a name="ln556">/// @param gap  either &amp;dbg_breakp or &amp;prof_ga</a>
<a name="ln557">static int dbg_parsearg(char_u *arg, garray_T *gap)</a>
<a name="ln558">{</a>
<a name="ln559">  char_u      *p = arg;</a>
<a name="ln560">  char_u      *q;</a>
<a name="ln561">  struct debuggy *bp;</a>
<a name="ln562">  bool here = false;</a>
<a name="ln563"> </a>
<a name="ln564">  ga_grow(gap, 1);</a>
<a name="ln565"> </a>
<a name="ln566">  bp = &amp;DEBUGGY(gap, gap-&gt;ga_len);</a>
<a name="ln567"> </a>
<a name="ln568">  // Find &quot;func&quot; or &quot;file&quot;.</a>
<a name="ln569">  if (STRNCMP(p, &quot;func&quot;, 4) == 0) {</a>
<a name="ln570">    bp-&gt;dbg_type = DBG_FUNC;</a>
<a name="ln571">  } else if (STRNCMP(p, &quot;file&quot;, 4) == 0) {</a>
<a name="ln572">    bp-&gt;dbg_type = DBG_FILE;</a>
<a name="ln573">  } else if (gap != &amp;prof_ga &amp;&amp; STRNCMP(p, &quot;here&quot;, 4) == 0) {</a>
<a name="ln574">    if (curbuf-&gt;b_ffname == NULL) {</a>
<a name="ln575">      EMSG(_(e_noname));</a>
<a name="ln576">      return FAIL;</a>
<a name="ln577">    }</a>
<a name="ln578">    bp-&gt;dbg_type = DBG_FILE;</a>
<a name="ln579">    here = true;</a>
<a name="ln580">  } else if (gap != &amp;prof_ga &amp;&amp; STRNCMP(p, &quot;expr&quot;, 4) == 0) {</a>
<a name="ln581">    bp-&gt;dbg_type = DBG_EXPR;</a>
<a name="ln582">  } else {</a>
<a name="ln583">    EMSG2(_(e_invarg2), p);</a>
<a name="ln584">    return FAIL;</a>
<a name="ln585">  }</a>
<a name="ln586">  p = skipwhite(p + 4);</a>
<a name="ln587"> </a>
<a name="ln588">  // Find optional line number.</a>
<a name="ln589">  if (here) {</a>
<a name="ln590">    bp-&gt;dbg_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln591">  } else if (gap != &amp;prof_ga &amp;&amp; ascii_isdigit(*p)) {</a>
<a name="ln592">    bp-&gt;dbg_lnum = getdigits_long(&amp;p, true, 0);</a>
<a name="ln593">    p = skipwhite(p);</a>
<a name="ln594">  } else {</a>
<a name="ln595">    bp-&gt;dbg_lnum = 0;</a>
<a name="ln596">  }</a>
<a name="ln597"> </a>
<a name="ln598">  // Find the function or file name.  Don't accept a function name with ().</a>
<a name="ln599">  if ((!here &amp;&amp; *p == NUL)</a>
<a name="ln600">      || (here &amp;&amp; *p != NUL)</a>
<a name="ln601">      || (bp-&gt;dbg_type == DBG_FUNC &amp;&amp; strstr((char *)p, &quot;()&quot;) != NULL)) {</a>
<a name="ln602">    EMSG2(_(e_invarg2), arg);</a>
<a name="ln603">    return FAIL;</a>
<a name="ln604">  }</a>
<a name="ln605"> </a>
<a name="ln606">  if (bp-&gt;dbg_type == DBG_FUNC) {</a>
<a name="ln607">    bp-&gt;dbg_name = vim_strsave(p);</a>
<a name="ln608">  } else if (here) {</a>
<a name="ln609">    bp-&gt;dbg_name = vim_strsave(curbuf-&gt;b_ffname);</a>
<a name="ln610">  } else if (bp-&gt;dbg_type == DBG_EXPR) {</a>
<a name="ln611">    bp-&gt;dbg_name = vim_strsave(p);</a>
<a name="ln612">    bp-&gt;dbg_val = eval_expr(bp-&gt;dbg_name);</a>
<a name="ln613">  } else {</a>
<a name="ln614">    // Expand the file name in the same way as do_source().  This means</a>
<a name="ln615">    // doing it twice, so that $DIR/file gets expanded when $DIR is</a>
<a name="ln616">    // &quot;~/dir&quot;.</a>
<a name="ln617">    q = expand_env_save(p);</a>
<a name="ln618">    if (q == NULL) {</a>
<a name="ln619">      return FAIL;</a>
<a name="ln620">    }</a>
<a name="ln621">    p = expand_env_save(q);</a>
<a name="ln622">    xfree(q);</a>
<a name="ln623">    if (p == NULL) {</a>
<a name="ln624">      return FAIL;</a>
<a name="ln625">    }</a>
<a name="ln626">    if (*p != '*') {</a>
<a name="ln627">      bp-&gt;dbg_name = (char_u *)fix_fname((char *)p);</a>
<a name="ln628">      xfree(p);</a>
<a name="ln629">    } else {</a>
<a name="ln630">      bp-&gt;dbg_name = p;</a>
<a name="ln631">    }</a>
<a name="ln632">  }</a>
<a name="ln633"> </a>
<a name="ln634">  if (bp-&gt;dbg_name == NULL) {</a>
<a name="ln635">    return FAIL;</a>
<a name="ln636">  }</a>
<a name="ln637">  return OK;</a>
<a name="ln638">}</a>
<a name="ln639"> </a>
<a name="ln640">/// &quot;:breakadd&quot;.  Also used for &quot;:profile&quot;.</a>
<a name="ln641">void ex_breakadd(exarg_T *eap)</a>
<a name="ln642">{</a>
<a name="ln643">  struct debuggy *bp;</a>
<a name="ln644">  garray_T    *gap;</a>
<a name="ln645"> </a>
<a name="ln646">  gap = &amp;dbg_breakp;</a>
<a name="ln647">  if (eap-&gt;cmdidx == CMD_profile) {</a>
<a name="ln648">    gap = &amp;prof_ga;</a>
<a name="ln649">  }</a>
<a name="ln650"> </a>
<a name="ln651">  if (dbg_parsearg(eap-&gt;arg, gap) == OK) {</a>
<a name="ln652">    bp = &amp;DEBUGGY(gap, gap-&gt;ga_len);</a>
<a name="ln653">    bp-&gt;dbg_forceit = eap-&gt;forceit;</a>
<a name="ln654"> </a>
<a name="ln655">    if (bp-&gt;dbg_type != DBG_EXPR) {</a>
<a name="ln656">      char_u *pat = file_pat_to_reg_pat(bp-&gt;dbg_name, NULL, NULL, false);</a>
<a name="ln657">      if (pat != NULL) {</a>
<a name="ln658">        bp-&gt;dbg_prog = vim_regcomp(pat, RE_MAGIC + RE_STRING);</a>
<a name="ln659">        xfree(pat);</a>
<a name="ln660">      }</a>
<a name="ln661">      if (pat == NULL || bp-&gt;dbg_prog == NULL) {</a>
<a name="ln662">        xfree(bp-&gt;dbg_name);</a>
<a name="ln663">      } else {</a>
<a name="ln664">        if (bp-&gt;dbg_lnum == 0) {           // default line number is 1</a>
<a name="ln665">          bp-&gt;dbg_lnum = 1;</a>
<a name="ln666">        }</a>
<a name="ln667">        if (eap-&gt;cmdidx != CMD_profile) {</a>
<a name="ln668">          DEBUGGY(gap, gap-&gt;ga_len).dbg_nr = ++last_breakp;</a>
<a name="ln669">          debug_tick++;</a>
<a name="ln670">        }</a>
<a name="ln671">        gap-&gt;ga_len++;</a>
<a name="ln672">      }</a>
<a name="ln673">    } else {</a>
<a name="ln674">      // DBG_EXPR</a>
<a name="ln675">      DEBUGGY(gap, gap-&gt;ga_len++).dbg_nr = ++last_breakp;</a>
<a name="ln676">      debug_tick++;</a>
<a name="ln677">    }</a>
<a name="ln678">  }</a>
<a name="ln679">}</a>
<a name="ln680"> </a>
<a name="ln681">/// &quot;:debuggreedy&quot;.</a>
<a name="ln682">void ex_debuggreedy(exarg_T *eap)</a>
<a name="ln683">{</a>
<a name="ln684">  if (eap-&gt;addr_count == 0 || eap-&gt;line2 != 0) {</a>
<a name="ln685">    debug_greedy = true;</a>
<a name="ln686">  } else {</a>
<a name="ln687">    debug_greedy = false;</a>
<a name="ln688">  }</a>
<a name="ln689">}</a>
<a name="ln690"> </a>
<a name="ln691">/// &quot;:breakdel&quot; and &quot;:profdel&quot;.</a>
<a name="ln692">void ex_breakdel(exarg_T *eap)</a>
<a name="ln693">{</a>
<a name="ln694">  struct debuggy *bp, *bpi;</a>
<a name="ln695">  int nr;</a>
<a name="ln696">  int todel = -1;</a>
<a name="ln697">  bool del_all = false;</a>
<a name="ln698">  linenr_T best_lnum = 0;</a>
<a name="ln699">  garray_T    *gap;</a>
<a name="ln700"> </a>
<a name="ln701">  gap = &amp;dbg_breakp;</a>
<a name="ln702">  if (eap-&gt;cmdidx == CMD_profdel) {</a>
<a name="ln703">    gap = &amp;prof_ga;</a>
<a name="ln704">  }</a>
<a name="ln705"> </a>
<a name="ln706">  if (ascii_isdigit(*eap-&gt;arg)) {</a>
<a name="ln707">    // &quot;:breakdel {nr}&quot;</a>
<a name="ln708">    nr = atoi((char *)eap-&gt;arg);</a>
<a name="ln709">    for (int i = 0; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln710">      if (DEBUGGY(gap, i).dbg_nr == nr) {</a>
<a name="ln711">        todel = i;</a>
<a name="ln712">        break;</a>
<a name="ln713">      }</a>
<a name="ln714">    }</a>
<a name="ln715">  } else if (*eap-&gt;arg == '*') {</a>
<a name="ln716">    todel = 0;</a>
<a name="ln717">    del_all = true;</a>
<a name="ln718">  } else {</a>
<a name="ln719">    // &quot;:breakdel {func|file|expr} [lnum] {name}&quot;</a>
<a name="ln720">    if (dbg_parsearg(eap-&gt;arg, gap) == FAIL) {</a>
<a name="ln721">      return;</a>
<a name="ln722">    }</a>
<a name="ln723">    bp = &amp;DEBUGGY(gap, gap-&gt;ga_len);</a>
<a name="ln724">    for (int i = 0; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln725">      bpi = &amp;DEBUGGY(gap, i);</a>
<a name="ln726">      if (bp-&gt;dbg_type == bpi-&gt;dbg_type</a>
<a name="ln727">          &amp;&amp; STRCMP(bp-&gt;dbg_name, bpi-&gt;dbg_name) == 0</a>
<a name="ln728">          &amp;&amp; (bp-&gt;dbg_lnum == bpi-&gt;dbg_lnum</a>
<a name="ln729">              || (bp-&gt;dbg_lnum == 0</a>
<a name="ln730">                  &amp;&amp; (best_lnum == 0</a>
<a name="ln731">                      || bpi-&gt;dbg_lnum &lt; best_lnum)))) {</a>
<a name="ln732">        todel = i;</a>
<a name="ln733">        best_lnum = bpi-&gt;dbg_lnum;</a>
<a name="ln734">      }</a>
<a name="ln735">    }</a>
<a name="ln736">    xfree(bp-&gt;dbg_name);</a>
<a name="ln737">  }</a>
<a name="ln738"> </a>
<a name="ln739">  if (todel &lt; 0) {</a>
<a name="ln740">    EMSG2(_(&quot;E161: Breakpoint not found: %s&quot;), eap-&gt;arg);</a>
<a name="ln741">  } else {</a>
<a name="ln742">    while (!GA_EMPTY(gap)) {</a>
<a name="ln743">      xfree(DEBUGGY(gap, todel).dbg_name);</a>
<a name="ln744">      if (DEBUGGY(gap, todel).dbg_type == DBG_EXPR</a>
<a name="ln745">          &amp;&amp; DEBUGGY(gap, todel).dbg_val != NULL) {</a>
<a name="ln746">        tv_free(DEBUGGY(gap, todel).dbg_val);</a>
<a name="ln747">      }</a>
<a name="ln748">      vim_regfree(DEBUGGY(gap, todel).dbg_prog);</a>
<a name="ln749">      gap-&gt;ga_len--;</a>
<a name="ln750">      if (todel &lt; gap-&gt;ga_len) {</a>
<a name="ln751">        memmove(&amp;DEBUGGY(gap, todel), &amp;DEBUGGY(gap, todel + 1),</a>
<a name="ln752">                (size_t)(gap-&gt;ga_len - todel) * sizeof(struct debuggy));</a>
<a name="ln753">      }</a>
<a name="ln754">      if (eap-&gt;cmdidx == CMD_breakdel) {</a>
<a name="ln755">        debug_tick++;</a>
<a name="ln756">      }</a>
<a name="ln757">      if (!del_all) {</a>
<a name="ln758">        break;</a>
<a name="ln759">      }</a>
<a name="ln760">    }</a>
<a name="ln761"> </a>
<a name="ln762">    // If all breakpoints were removed clear the array.</a>
<a name="ln763">    if (GA_EMPTY(gap)) {</a>
<a name="ln764">      ga_clear(gap);</a>
<a name="ln765">    }</a>
<a name="ln766">  }</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">/// &quot;:breaklist&quot;.</a>
<a name="ln770">void ex_breaklist(exarg_T *eap)</a>
<a name="ln771">{</a>
<a name="ln772">  struct debuggy *bp;</a>
<a name="ln773"> </a>
<a name="ln774">  if (GA_EMPTY(&amp;dbg_breakp)) {</a>
<a name="ln775">    MSG(_(&quot;No breakpoints defined&quot;));</a>
<a name="ln776">  } else {</a>
<a name="ln777">    for (int i = 0; i &lt; dbg_breakp.ga_len; i++) {</a>
<a name="ln778">      bp = &amp;BREAKP(i);</a>
<a name="ln779">      if (bp-&gt;dbg_type == DBG_FILE) {</a>
<a name="ln780">        home_replace(NULL, bp-&gt;dbg_name, NameBuff, MAXPATHL, true);</a>
<a name="ln781">      }</a>
<a name="ln782">      if (bp-&gt;dbg_type != DBG_EXPR) {</a>
<a name="ln783">        smsg(_(&quot;%3d  %s %s  line %&quot; PRId64),</a>
<a name="ln784">             bp-&gt;dbg_nr,</a>
<a name="ln785">             bp-&gt;dbg_type == DBG_FUNC ? &quot;func&quot; : &quot;file&quot;,</a>
<a name="ln786">             bp-&gt;dbg_type == DBG_FUNC ? bp-&gt;dbg_name : NameBuff,</a>
<a name="ln787">             (int64_t)bp-&gt;dbg_lnum);</a>
<a name="ln788">      } else {</a>
<a name="ln789">        smsg(_(&quot;%3d  expr %s&quot;), bp-&gt;dbg_nr, bp-&gt;dbg_name);</a>
<a name="ln790">      }</a>
<a name="ln791">    }</a>
<a name="ln792">  }</a>
<a name="ln793">}</a>
<a name="ln794"> </a>
<a name="ln795">/// Find a breakpoint for a function or sourced file.</a>
<a name="ln796">/// Returns line number at which to break; zero when no matching breakpoint.</a>
<a name="ln797">linenr_T</a>
<a name="ln798">dbg_find_breakpoint(</a>
<a name="ln799">    bool file,             // true for a file, false for a function</a>
<a name="ln800">    char_u *fname,         // file or function name</a>
<a name="ln801">    linenr_T after         // after this line number</a>
<a name="ln802">)</a>
<a name="ln803">{</a>
<a name="ln804">  return debuggy_find(file, fname, after, &amp;dbg_breakp, NULL);</a>
<a name="ln805">}</a>
<a name="ln806"> </a>
<a name="ln807">/// @param file     true for a file, false for a function</a>
<a name="ln808">/// @param fname    file or function name</a>
<a name="ln809">/// @param fp[out]  forceit</a>
<a name="ln810">///</a>
<a name="ln811">/// @returns true if profiling is on for a function or sourced file.</a>
<a name="ln812">bool has_profiling(bool file, char_u *fname, bool *fp)</a>
<a name="ln813">{</a>
<a name="ln814">  return debuggy_find(file, fname, (linenr_T)0, &amp;prof_ga, fp)</a>
<a name="ln815">         != (linenr_T)0;</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818">/// Common code for dbg_find_breakpoint() and has_profiling().</a>
<a name="ln819">static linenr_T</a>
<a name="ln820">debuggy_find(</a>
<a name="ln821">    bool file,            // true for a file, false for a function</a>
<a name="ln822">    char_u *fname,        // file or function name</a>
<a name="ln823">    linenr_T after,       // after this line number</a>
<a name="ln824">    garray_T *gap,        // either &amp;dbg_breakp or &amp;prof_ga</a>
<a name="ln825">    bool *fp              // if not NULL: return forceit</a>
<a name="ln826">)</a>
<a name="ln827">{</a>
<a name="ln828">  struct debuggy *bp;</a>
<a name="ln829">  linenr_T lnum = 0;</a>
<a name="ln830">  char_u      *name = fname;</a>
<a name="ln831">  int prev_got_int;</a>
<a name="ln832"> </a>
<a name="ln833">  // Return quickly when there are no breakpoints.</a>
<a name="ln834">  if (GA_EMPTY(gap)) {</a>
<a name="ln835">    return (linenr_T)0;</a>
<a name="ln836">  }</a>
<a name="ln837"> </a>
<a name="ln838">  // Replace K_SNR in function name with &quot;&lt;SNR&gt;&quot;.</a>
<a name="ln839">  if (!file &amp;&amp; fname[0] == K_SPECIAL) {</a>
<a name="ln840">    name = xmalloc(STRLEN(fname) + 3);</a>
<a name="ln841">    STRCPY(name, &quot;&lt;SNR&gt;&quot;);</a>
<a name="ln842">    STRCPY(name + 5, fname + 3);</a>
<a name="ln843">  }</a>
<a name="ln844"> </a>
<a name="ln845">  for (int i = 0; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln846">    // Skip entries that are not useful or are for a line that is beyond</a>
<a name="ln847">    // an already found breakpoint.</a>
<a name="ln848">    bp = &amp;DEBUGGY(gap, i);</a>
<a name="ln849">    if ((bp-&gt;dbg_type == DBG_FILE) == file</a>
<a name="ln850">        &amp;&amp; bp-&gt;dbg_type != DBG_EXPR</a>
<a name="ln851">        &amp;&amp; (gap == &amp;prof_ga</a>
<a name="ln852">            || (bp-&gt;dbg_lnum &gt; after &amp;&amp; (lnum == 0 || bp-&gt;dbg_lnum &lt; lnum)))) {</a>
<a name="ln853">      // Save the value of got_int and reset it.  We don't want a</a>
<a name="ln854">      // previous interruption cancel matching, only hitting CTRL-C</a>
<a name="ln855">      // while matching should abort it.</a>
<a name="ln856">      prev_got_int = got_int;</a>
<a name="ln857">      got_int = false;</a>
<a name="ln858">      if (vim_regexec_prog(&amp;bp-&gt;dbg_prog, false, name, (colnr_T)0)) {</a>
<a name="ln859">        lnum = bp-&gt;dbg_lnum;</a>
<a name="ln860">        if (fp != NULL) {</a>
<a name="ln861">          *fp = bp-&gt;dbg_forceit;</a>
<a name="ln862">        }</a>
<a name="ln863">      }</a>
<a name="ln864">      got_int |= prev_got_int;</a>
<a name="ln865">    } else if (bp-&gt;dbg_type == DBG_EXPR) {</a>
<a name="ln866">      bool line = false;</a>
<a name="ln867"> </a>
<a name="ln868">      prev_got_int = got_int;</a>
<a name="ln869">      got_int = false;</a>
<a name="ln870"> </a>
<a name="ln871">      typval_T *tv = eval_expr(bp-&gt;dbg_name);</a>
<a name="ln872">      if (tv != NULL) {</a>
<a name="ln873">        if (bp-&gt;dbg_val == NULL) {</a>
<a name="ln874">          debug_oldval = typval_tostring(NULL);</a>
<a name="ln875">          bp-&gt;dbg_val = tv;</a>
<a name="ln876">          debug_newval = typval_tostring(bp-&gt;dbg_val);</a>
<a name="ln877">          line = true;</a>
<a name="ln878">        } else {</a>
<a name="ln879">          if (typval_compare(tv, bp-&gt;dbg_val, EXPR_IS, false) == OK</a>
<a name="ln880">              &amp;&amp; tv-&gt;vval.v_number == false) {</a>
<a name="ln881">            line = true;</a>
<a name="ln882">            debug_oldval = typval_tostring(bp-&gt;dbg_val);</a>
<a name="ln883">            // Need to evaluate again, typval_compare() overwrites &quot;tv&quot;.</a>
<a name="ln884">            typval_T *v = eval_expr(bp-&gt;dbg_name);</a>
<a name="ln885">            debug_newval = typval_tostring(v);</a>
<a name="ln886">            tv_free(bp-&gt;dbg_val);</a>
<a name="ln887">            bp-&gt;dbg_val = v;</a>
<a name="ln888">          }</a>
<a name="ln889">          tv_free(tv);</a>
<a name="ln890">        }</a>
<a name="ln891">      } else if (bp-&gt;dbg_val != NULL) {</a>
<a name="ln892">        debug_oldval = typval_tostring(bp-&gt;dbg_val);</a>
<a name="ln893">        debug_newval = typval_tostring(NULL);</a>
<a name="ln894">        tv_free(bp-&gt;dbg_val);</a>
<a name="ln895">        bp-&gt;dbg_val = NULL;</a>
<a name="ln896">        line = true;</a>
<a name="ln897">      }</a>
<a name="ln898"> </a>
<a name="ln899">      if (line) {</a>
<a name="ln900">        lnum = after &gt; 0 ? after : 1;</a>
<a name="ln901">        break;</a>
<a name="ln902">      }</a>
<a name="ln903"> </a>
<a name="ln904">      got_int |= prev_got_int;</a>
<a name="ln905">    }</a>
<a name="ln906">  }</a>
<a name="ln907">  if (name != fname) {</a>
<a name="ln908">    xfree(name);</a>
<a name="ln909">  }</a>
<a name="ln910"> </a>
<a name="ln911">  return lnum;</a>
<a name="ln912">}</a>
<a name="ln913"> </a>
<a name="ln914">/// Called when a breakpoint was encountered.</a>
<a name="ln915">void dbg_breakpoint(char_u *name, linenr_T lnum)</a>
<a name="ln916">{</a>
<a name="ln917">  // We need to check if this line is actually executed in do_one_cmd()</a>
<a name="ln918">  debug_breakpoint_name = name;</a>
<a name="ln919">  debug_breakpoint_lnum = lnum;</a>
<a name="ln920">}</a>
<a name="ln921"> </a>
<a name="ln922">static char_u   *profile_fname = NULL;</a>
<a name="ln923"> </a>
<a name="ln924">/// &quot;:profile cmd args&quot;</a>
<a name="ln925">void ex_profile(exarg_T *eap)</a>
<a name="ln926">{</a>
<a name="ln927">  static proftime_T pause_time;</a>
<a name="ln928"> </a>
<a name="ln929">  char_u      *e;</a>
<a name="ln930">  int len;</a>
<a name="ln931"> </a>
<a name="ln932">  e = skiptowhite(eap-&gt;arg);</a>
<a name="ln933">  len = (int)(e - eap-&gt;arg);</a>
<a name="ln934">  e = skipwhite(e);</a>
<a name="ln935"> </a>
<a name="ln936">  if (len == 5 &amp;&amp; STRNCMP(eap-&gt;arg, &quot;start&quot;, 5) == 0 &amp;&amp; *e != NUL) {</a>
<a name="ln937">    xfree(profile_fname);</a>
<a name="ln938">    profile_fname = expand_env_save_opt(e, true);</a>
<a name="ln939">    do_profiling = PROF_YES;</a>
<a name="ln940">    profile_set_wait(profile_zero());</a>
<a name="ln941">    set_vim_var_nr(VV_PROFILING, 1L);</a>
<a name="ln942">  } else if (do_profiling == PROF_NONE) {</a>
<a name="ln943">    EMSG(_(&quot;E750: First use \&quot;:profile start {fname}\&quot;&quot;));</a>
<a name="ln944">  } else if (STRCMP(eap-&gt;arg, &quot;stop&quot;) == 0) {</a>
<a name="ln945">    profile_dump();</a>
<a name="ln946">    do_profiling = PROF_NONE;</a>
<a name="ln947">    set_vim_var_nr(VV_PROFILING, 0L);</a>
<a name="ln948">    profile_reset();</a>
<a name="ln949">  } else if (STRCMP(eap-&gt;arg, &quot;pause&quot;) == 0) {</a>
<a name="ln950">    if (do_profiling == PROF_YES) {</a>
<a name="ln951">      pause_time = profile_start();</a>
<a name="ln952">    }</a>
<a name="ln953">    do_profiling = PROF_PAUSED;</a>
<a name="ln954">  } else if (STRCMP(eap-&gt;arg, &quot;continue&quot;) == 0) {</a>
<a name="ln955">    if (do_profiling == PROF_PAUSED) {</a>
<a name="ln956">      pause_time = profile_end(pause_time);</a>
<a name="ln957">      profile_set_wait(profile_add(profile_get_wait(), pause_time));</a>
<a name="ln958">    }</a>
<a name="ln959">    do_profiling = PROF_YES;</a>
<a name="ln960">  } else if (STRCMP(eap-&gt;arg, &quot;dump&quot;) == 0) {</a>
<a name="ln961">    profile_dump();</a>
<a name="ln962">  } else {</a>
<a name="ln963">    // The rest is similar to &quot;:breakadd&quot;.</a>
<a name="ln964">    ex_breakadd(eap);</a>
<a name="ln965">  }</a>
<a name="ln966">}</a>
<a name="ln967"> </a>
<a name="ln968">void ex_python(exarg_T *eap)</a>
<a name="ln969">{</a>
<a name="ln970">  script_host_execute(&quot;python&quot;, eap);</a>
<a name="ln971">}</a>
<a name="ln972"> </a>
<a name="ln973">void ex_pyfile(exarg_T *eap)</a>
<a name="ln974">{</a>
<a name="ln975">  script_host_execute_file(&quot;python&quot;, eap);</a>
<a name="ln976">}</a>
<a name="ln977"> </a>
<a name="ln978">void ex_pydo(exarg_T *eap)</a>
<a name="ln979">{</a>
<a name="ln980">  script_host_do_range(&quot;python&quot;, eap);</a>
<a name="ln981">}</a>
<a name="ln982"> </a>
<a name="ln983">void ex_ruby(exarg_T *eap)</a>
<a name="ln984">{</a>
<a name="ln985">  script_host_execute(&quot;ruby&quot;, eap);</a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988">void ex_rubyfile(exarg_T *eap)</a>
<a name="ln989">{</a>
<a name="ln990">  script_host_execute_file(&quot;ruby&quot;, eap);</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993">void ex_rubydo(exarg_T *eap)</a>
<a name="ln994">{</a>
<a name="ln995">  script_host_do_range(&quot;ruby&quot;, eap);</a>
<a name="ln996">}</a>
<a name="ln997"> </a>
<a name="ln998">void ex_python3(exarg_T *eap)</a>
<a name="ln999">{</a>
<a name="ln1000">  script_host_execute(&quot;python3&quot;, eap);</a>
<a name="ln1001">}</a>
<a name="ln1002"> </a>
<a name="ln1003">void ex_py3file(exarg_T *eap)</a>
<a name="ln1004">{</a>
<a name="ln1005">  script_host_execute_file(&quot;python3&quot;, eap);</a>
<a name="ln1006">}</a>
<a name="ln1007"> </a>
<a name="ln1008">void ex_pydo3(exarg_T *eap)</a>
<a name="ln1009">{</a>
<a name="ln1010">  script_host_do_range(&quot;python3&quot;, eap);</a>
<a name="ln1011">}</a>
<a name="ln1012"> </a>
<a name="ln1013">void ex_perl(exarg_T *eap)</a>
<a name="ln1014">{</a>
<a name="ln1015">  script_host_execute(&quot;perl&quot;, eap);</a>
<a name="ln1016">}</a>
<a name="ln1017"> </a>
<a name="ln1018">void ex_perlfile(exarg_T *eap)</a>
<a name="ln1019">{</a>
<a name="ln1020">  script_host_execute_file(&quot;perl&quot;, eap);</a>
<a name="ln1021">}</a>
<a name="ln1022"> </a>
<a name="ln1023">void ex_perldo(exarg_T *eap)</a>
<a name="ln1024">{</a>
<a name="ln1025">  script_host_do_range(&quot;perl&quot;, eap);</a>
<a name="ln1026">}</a>
<a name="ln1027"> </a>
<a name="ln1028">// Command line expansion for :profile.</a>
<a name="ln1029">static enum {</a>
<a name="ln1030">  PEXP_SUBCMD,          ///&lt; expand :profile sub-commands</a>
<a name="ln1031">  PEXP_FUNC             ///&lt; expand :profile func {funcname}</a>
<a name="ln1032">} pexpand_what;</a>
<a name="ln1033"> </a>
<a name="ln1034">static char *pexpand_cmds[] = {</a>
<a name="ln1035">  &quot;continue&quot;,</a>
<a name="ln1036">  &quot;dump&quot;,</a>
<a name="ln1037">  &quot;file&quot;,</a>
<a name="ln1038">  &quot;func&quot;,</a>
<a name="ln1039">  &quot;pause&quot;,</a>
<a name="ln1040">  &quot;start&quot;,</a>
<a name="ln1041">  &quot;stop&quot;,</a>
<a name="ln1042">  NULL</a>
<a name="ln1043">};</a>
<a name="ln1044"> </a>
<a name="ln1045">/// Function given to ExpandGeneric() to obtain the profile command</a>
<a name="ln1046">/// specific expansion.</a>
<a name="ln1047">char_u *get_profile_name(expand_T *xp, int idx)</a>
<a name="ln1048">{</a>
<a name="ln1049">  switch (pexpand_what) {</a>
<a name="ln1050">  case PEXP_SUBCMD:</a>
<a name="ln1051">    return (char_u *)pexpand_cmds[idx];</a>
<a name="ln1052">  // case PEXP_FUNC: TODO</a>
<a name="ln1053">  default:</a>
<a name="ln1054">    return NULL;</a>
<a name="ln1055">  }</a>
<a name="ln1056">}</a>
<a name="ln1057"> </a>
<a name="ln1058">/// Handle command line completion for :profile command.</a>
<a name="ln1059">void set_context_in_profile_cmd(expand_T *xp, const char *arg)</a>
<a name="ln1060">{</a>
<a name="ln1061">  // Default: expand subcommands.</a>
<a name="ln1062">  xp-&gt;xp_context = EXPAND_PROFILE;</a>
<a name="ln1063">  pexpand_what = PEXP_SUBCMD;</a>
<a name="ln1064">  xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln1065"> </a>
<a name="ln1066">  char_u *const end_subcmd = skiptowhite((const char_u *)arg);</a>
<a name="ln1067">  if (*end_subcmd == NUL) {</a>
<a name="ln1068">    return;</a>
<a name="ln1069">  }</a>
<a name="ln1070"> </a>
<a name="ln1071">  if ((const char *)end_subcmd - arg == 5 &amp;&amp; strncmp(arg, &quot;start&quot;, 5) == 0) {</a>
<a name="ln1072">    xp-&gt;xp_context = EXPAND_FILES;</a>
<a name="ln1073">    xp-&gt;xp_pattern = skipwhite((const char_u *)end_subcmd);</a>
<a name="ln1074">    return;</a>
<a name="ln1075">  }</a>
<a name="ln1076"> </a>
<a name="ln1077">  // TODO(tarruda): expand function names after &quot;func&quot;</a>
<a name="ln1078">  xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln1079">}</a>
<a name="ln1080"> </a>
<a name="ln1081">/// Dump the profiling info.</a>
<a name="ln1082">void profile_dump(void)</a>
<a name="ln1083">{</a>
<a name="ln1084">  FILE        *fd;</a>
<a name="ln1085"> </a>
<a name="ln1086">  if (profile_fname != NULL) {</a>
<a name="ln1087">    fd = os_fopen((char *)profile_fname, &quot;w&quot;);</a>
<a name="ln1088">    if (fd == NULL) {</a>
<a name="ln1089">      EMSG2(_(e_notopen), profile_fname);</a>
<a name="ln1090">    } else {</a>
<a name="ln1091">      script_dump_profile(fd);</a>
<a name="ln1092">      func_dump_profile(fd);</a>
<a name="ln1093">      fclose(fd);</a>
<a name="ln1094">    }</a>
<a name="ln1095">  }</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">/// Reset all profiling information.</a>
<a name="ln1099">static void profile_reset(void)</a>
<a name="ln1100">{</a>
<a name="ln1101">  // Reset sourced files.</a>
<a name="ln1102">  for (int id = 1; id &lt;= script_items.ga_len; id++) {</a>
<a name="ln1103">    scriptitem_T *si = &amp;SCRIPT_ITEM(id);</a>
<a name="ln1104">    if (si-&gt;sn_prof_on) {</a>
<a name="ln1105">      si-&gt;sn_prof_on      = false;</a>
<a name="ln1106">      si-&gt;sn_pr_force     = false;</a>
<a name="ln1107">      si-&gt;sn_pr_child     = profile_zero();</a>
<a name="ln1108">      si-&gt;sn_pr_nest      = 0;</a>
<a name="ln1109">      si-&gt;sn_pr_count     = 0;</a>
<a name="ln1110">      si-&gt;sn_pr_total     = profile_zero();</a>
<a name="ln1111">      si-&gt;sn_pr_self      = profile_zero();</a>
<a name="ln1112">      si-&gt;sn_pr_start     = profile_zero();</a>
<a name="ln1113">      si-&gt;sn_pr_children  = profile_zero();</a>
<a name="ln1114">      ga_clear(&amp;si-&gt;sn_prl_ga);</a>
<a name="ln1115">      si-&gt;sn_prl_start    = profile_zero();</a>
<a name="ln1116">      si-&gt;sn_prl_children = profile_zero();</a>
<a name="ln1117">      si-&gt;sn_prl_wait     = profile_zero();</a>
<a name="ln1118">      si-&gt;sn_prl_idx      = -1;</a>
<a name="ln1119">      si-&gt;sn_prl_execed   = 0;</a>
<a name="ln1120">    }</a>
<a name="ln1121">  }</a>
<a name="ln1122"> </a>
<a name="ln1123">  // Reset functions.</a>
<a name="ln1124">  size_t      n  = func_hashtab.ht_used;</a>
<a name="ln1125">  hashitem_T *hi = func_hashtab.ht_array;</a>
<a name="ln1126"> </a>
<a name="ln1127">  for (; n &gt; (size_t)0; hi++) {</a>
<a name="ln1128">    if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1129">      n--;</a>
<a name="ln1130">      ufunc_T *uf = HI2UF(hi);</a>
<a name="ln1131">      if (uf-&gt;uf_prof_initialized) {</a>
<a name="ln1132">        uf-&gt;uf_profiling    = 0;</a>
<a name="ln1133">        uf-&gt;uf_tm_count     = 0;</a>
<a name="ln1134">        uf-&gt;uf_tm_total     = profile_zero();</a>
<a name="ln1135">        uf-&gt;uf_tm_self      = profile_zero();</a>
<a name="ln1136">        uf-&gt;uf_tm_children  = profile_zero();</a>
<a name="ln1137"> </a>
<a name="ln1138">        for (int i = 0; i &lt; uf-&gt;uf_lines.ga_len; i++) {</a>
<a name="ln1139">          uf-&gt;uf_tml_count[i] = 0;</a>
<a name="ln1140">          uf-&gt;uf_tml_total[i] = uf-&gt;uf_tml_self[i] = 0;</a>
<a name="ln1141">        }</a>
<a name="ln1142"> </a>
<a name="ln1143">        uf-&gt;uf_tml_start    = profile_zero();</a>
<a name="ln1144">        uf-&gt;uf_tml_children = profile_zero();</a>
<a name="ln1145">        uf-&gt;uf_tml_wait     = profile_zero();</a>
<a name="ln1146">        uf-&gt;uf_tml_idx      = -1;</a>
<a name="ln1147">        uf-&gt;uf_tml_execed   = 0;</a>
<a name="ln1148">      }</a>
<a name="ln1149">    }</a>
<a name="ln1150">  }</a>
<a name="ln1151"> </a>
<a name="ln1152">  XFREE_CLEAR(profile_fname);</a>
<a name="ln1153">}</a>
<a name="ln1154"> </a>
<a name="ln1155">/// Start profiling a script.</a>
<a name="ln1156">static void profile_init(scriptitem_T *si)</a>
<a name="ln1157">{</a>
<a name="ln1158">  si-&gt;sn_pr_count = 0;</a>
<a name="ln1159">  si-&gt;sn_pr_total = profile_zero();</a>
<a name="ln1160">  si-&gt;sn_pr_self = profile_zero();</a>
<a name="ln1161"> </a>
<a name="ln1162">  ga_init(&amp;si-&gt;sn_prl_ga, sizeof(sn_prl_T), 100);</a>
<a name="ln1163">  si-&gt;sn_prl_idx = -1;</a>
<a name="ln1164">  si-&gt;sn_prof_on = true;</a>
<a name="ln1165">  si-&gt;sn_pr_nest = 0;</a>
<a name="ln1166">}</a>
<a name="ln1167"> </a>
<a name="ln1168">/// Save time when starting to invoke another script or function.</a>
<a name="ln1169">void script_prof_save(</a>
<a name="ln1170">    proftime_T  *tm             // place to store wait time</a>
<a name="ln1171">)</a>
<a name="ln1172">{</a>
<a name="ln1173">  scriptitem_T    *si;</a>
<a name="ln1174"> </a>
<a name="ln1175">  if (current_sctx.sc_sid &gt; 0 &amp;&amp; current_sctx.sc_sid &lt;= script_items.ga_len) {</a>
<a name="ln1176">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln1177">    if (si-&gt;sn_prof_on &amp;&amp; si-&gt;sn_pr_nest++ == 0) {</a>
<a name="ln1178">      si-&gt;sn_pr_child = profile_start();</a>
<a name="ln1179">    }</a>
<a name="ln1180">  }</a>
<a name="ln1181">  *tm = profile_get_wait();</a>
<a name="ln1182">}</a>
<a name="ln1183"> </a>
<a name="ln1184">/// Count time spent in children after invoking another script or function.</a>
<a name="ln1185">void script_prof_restore(proftime_T *tm)</a>
<a name="ln1186">{</a>
<a name="ln1187">  scriptitem_T    *si;</a>
<a name="ln1188"> </a>
<a name="ln1189">  if (current_sctx.sc_sid &gt; 0 &amp;&amp; current_sctx.sc_sid &lt;= script_items.ga_len) {</a>
<a name="ln1190">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln1191">    if (si-&gt;sn_prof_on &amp;&amp; --si-&gt;sn_pr_nest == 0) {</a>
<a name="ln1192">      si-&gt;sn_pr_child = profile_end(si-&gt;sn_pr_child);</a>
<a name="ln1193">      // don't count wait time</a>
<a name="ln1194">      si-&gt;sn_pr_child = profile_sub_wait(*tm, si-&gt;sn_pr_child);</a>
<a name="ln1195">      si-&gt;sn_pr_children = profile_add(si-&gt;sn_pr_children, si-&gt;sn_pr_child);</a>
<a name="ln1196">      si-&gt;sn_prl_children = profile_add(si-&gt;sn_prl_children, si-&gt;sn_pr_child);</a>
<a name="ln1197">    }</a>
<a name="ln1198">  }</a>
<a name="ln1199">}</a>
<a name="ln1200"> </a>
<a name="ln1201">static proftime_T inchar_time;</a>
<a name="ln1202"> </a>
<a name="ln1203">/// Called when starting to wait for the user to type a character.</a>
<a name="ln1204">void prof_inchar_enter(void)</a>
<a name="ln1205">{</a>
<a name="ln1206">  inchar_time = profile_start();</a>
<a name="ln1207">}</a>
<a name="ln1208"> </a>
<a name="ln1209">/// Called when finished waiting for the user to type a character.</a>
<a name="ln1210">void prof_inchar_exit(void)</a>
<a name="ln1211">{</a>
<a name="ln1212">  inchar_time = profile_end(inchar_time);</a>
<a name="ln1213">  profile_set_wait(profile_add(profile_get_wait(), inchar_time));</a>
<a name="ln1214">}</a>
<a name="ln1215"> </a>
<a name="ln1216">/// Dump the profiling results for all scripts in file &quot;fd&quot;.</a>
<a name="ln1217">static void script_dump_profile(FILE *fd)</a>
<a name="ln1218">{</a>
<a name="ln1219">  scriptitem_T    *si;</a>
<a name="ln1220">  FILE            *sfd;</a>
<a name="ln1221">  sn_prl_T        *pp;</a>
<a name="ln1222"> </a>
<a name="ln1223">  for (int id = 1; id &lt;= script_items.ga_len; id++) {</a>
<a name="ln1224">    si = &amp;SCRIPT_ITEM(id);</a>
<a name="ln1225">    if (si-&gt;sn_prof_on) {</a>
<a name="ln1226">      fprintf(fd, &quot;SCRIPT  %s\n&quot;, si-&gt;sn_name);</a>
<a name="ln1227">      if (si-&gt;sn_pr_count == 1) {</a>
<a name="ln1228">        fprintf(fd, &quot;Sourced 1 time\n&quot;);</a>
<a name="ln1229">      } else {</a>
<a name="ln1230">        fprintf(fd, &quot;Sourced %d times\n&quot;, si-&gt;sn_pr_count);</a>
<a name="ln1231">      }</a>
<a name="ln1232">      fprintf(fd, &quot;Total time: %s\n&quot;, profile_msg(si-&gt;sn_pr_total));</a>
<a name="ln1233">      fprintf(fd, &quot; Self time: %s\n&quot;, profile_msg(si-&gt;sn_pr_self));</a>
<a name="ln1234">      fprintf(fd, &quot;\n&quot;);</a>
<a name="ln1235">      fprintf(fd, &quot;count  total (s)   self (s)\n&quot;);</a>
<a name="ln1236"> </a>
<a name="ln1237">      sfd = os_fopen((char *)si-&gt;sn_name, &quot;r&quot;);</a>
<a name="ln1238">      if (sfd == NULL) {</a>
<a name="ln1239">        fprintf(fd, &quot;Cannot open file!\n&quot;);</a>
<a name="ln1240">      } else {</a>
<a name="ln1241">        // Keep going till the end of file, so that trailing</a>
<a name="ln1242">        // continuation lines are listed.</a>
<a name="ln1243">        for (int i = 0; ; i++) {</a>
<a name="ln1244">          if (vim_fgets(IObuff, IOSIZE, sfd)) {</a>
<a name="ln1245">            break;</a>
<a name="ln1246">          }</a>
<a name="ln1247">          // When a line has been truncated, append NL, taking care</a>
<a name="ln1248">          // of multi-byte characters .</a>
<a name="ln1249">          if (IObuff[IOSIZE - 2] != NUL &amp;&amp; IObuff[IOSIZE - 2] != NL) {</a>
<a name="ln1250">            int n = IOSIZE - 2;</a>
<a name="ln1251"> </a>
<a name="ln1252">            // Move to the first byte of this char.</a>
<a name="ln1253">            // utf_head_off() doesn't work, because it checks</a>
<a name="ln1254">            // for a truncated character.</a>
<a name="ln1255">            while (n &gt; 0 &amp;&amp; (IObuff[n] &amp; 0xc0) == 0x80) {</a>
<a name="ln1256">              n--;</a>
<a name="ln1257">            }</a>
<a name="ln1258"> </a>
<a name="ln1259">            IObuff[n] = NL;</a>
<a name="ln1260">            IObuff[n + 1] = NUL;</a>
<a name="ln1261">          }</a>
<a name="ln1262">          if (i &lt; si-&gt;sn_prl_ga.ga_len</a>
<a name="ln1263">              &amp;&amp; (pp = &amp;PRL_ITEM(si, i))-&gt;snp_count &gt; 0) {</a>
<a name="ln1264">            fprintf(fd, &quot;%5d &quot;, pp-&gt;snp_count);</a>
<a name="ln1265">            if (profile_equal(pp-&gt;sn_prl_total, pp-&gt;sn_prl_self)) {</a>
<a name="ln1266">              fprintf(fd, &quot;           &quot;);</a>
<a name="ln1267">            } else {</a>
<a name="ln1268">              fprintf(fd, &quot;%s &quot;, profile_msg(pp-&gt;sn_prl_total));</a>
<a name="ln1269">            }</a>
<a name="ln1270">            fprintf(fd, &quot;%s &quot;, profile_msg(pp-&gt;sn_prl_self));</a>
<a name="ln1271">          } else {</a>
<a name="ln1272">            fprintf(fd, &quot;                            &quot;);</a>
<a name="ln1273">          }</a>
<a name="ln1274">          fprintf(fd, &quot;%s&quot;, IObuff);</a>
<a name="ln1275">        }</a>
<a name="ln1276">        fclose(sfd);</a>
<a name="ln1277">      }</a>
<a name="ln1278">      fprintf(fd, &quot;\n&quot;);</a>
<a name="ln1279">    }</a>
<a name="ln1280">  }</a>
<a name="ln1281">}</a>
<a name="ln1282"> </a>
<a name="ln1283">/// Return true when a function defined in the current script should be</a>
<a name="ln1284">/// profiled.</a>
<a name="ln1285">bool prof_def_func(void)</a>
<a name="ln1286">{</a>
<a name="ln1287">  if (current_sctx.sc_sid &gt; 0) {</a>
<a name="ln1288">    return SCRIPT_ITEM(current_sctx.sc_sid).sn_pr_force;</a>
<a name="ln1289">  }</a>
<a name="ln1290">  return false;</a>
<a name="ln1291">}</a>
<a name="ln1292"> </a>
<a name="ln1293">/// If 'autowrite' option set, try to write the file.</a>
<a name="ln1294">/// Careful: autocommands may make &quot;buf&quot; invalid!</a>
<a name="ln1295">///</a>
<a name="ln1296">/// @return FAIL for failure, OK otherwise</a>
<a name="ln1297">int autowrite(buf_T *buf, int forceit)</a>
<a name="ln1298">{</a>
<a name="ln1299">  int r;</a>
<a name="ln1300">  bufref_T bufref;</a>
<a name="ln1301"> </a>
<a name="ln1302">  if (!(p_aw || p_awa) || !p_write</a>
<a name="ln1303">      // never autowrite a &quot;nofile&quot; or &quot;nowrite&quot; buffer</a>
<a name="ln1304">      || bt_dontwrite(buf)</a>
<a name="ln1305">      || (!forceit &amp;&amp; buf-&gt;b_p_ro) || buf-&gt;b_ffname == NULL) {</a>
<a name="ln1306">    return FAIL;</a>
<a name="ln1307">  }</a>
<a name="ln1308">  set_bufref(&amp;bufref, buf);</a>
<a name="ln1309">  r = buf_write_all(buf, forceit);</a>
<a name="ln1310"> </a>
<a name="ln1311">  // Writing may succeed but the buffer still changed, e.g., when there is a</a>
<a name="ln1312">  // conversion error.  We do want to return FAIL then.</a>
<a name="ln1313">  if (bufref_valid(&amp;bufref) &amp;&amp; bufIsChanged(buf)) {</a>
<a name="ln1314">    r = FAIL;</a>
<a name="ln1315">  }</a>
<a name="ln1316">  return r;</a>
<a name="ln1317">}</a>
<a name="ln1318"> </a>
<a name="ln1319">/// Flush all buffers, except the ones that are readonly or are never written.</a>
<a name="ln1320">void autowrite_all(void)</a>
<a name="ln1321">{</a>
<a name="ln1322">  if (!(p_aw || p_awa) || !p_write) {</a>
<a name="ln1323">    return;</a>
<a name="ln1324">  }</a>
<a name="ln1325"> </a>
<a name="ln1326">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1327">    if (bufIsChanged(buf) &amp;&amp; !buf-&gt;b_p_ro &amp;&amp; !bt_dontwrite(buf)) {</a>
<a name="ln1328">      bufref_T bufref;</a>
<a name="ln1329">      set_bufref(&amp;bufref, buf);</a>
<a name="ln1330">      (void)buf_write_all(buf, false);</a>
<a name="ln1331">      // an autocommand may have deleted the buffer</a>
<a name="ln1332">      if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1333">        buf = firstbuf;</a>
<a name="ln1334">      }</a>
<a name="ln1335">    }</a>
<a name="ln1336">  }</a>
<a name="ln1337">}</a>
<a name="ln1338"> </a>
<a name="ln1339">/// Return true if buffer was changed and cannot be abandoned.</a>
<a name="ln1340">/// For flags use the CCGD_ values.</a>
<a name="ln1341">bool check_changed(buf_T *buf, int flags)</a>
<a name="ln1342">{</a>
<a name="ln1343">  int forceit = (flags &amp; CCGD_FORCEIT);</a>
<a name="ln1344">  bufref_T bufref;</a>
<a name="ln1345">  set_bufref(&amp;bufref, buf);</a>
<a name="ln1346"> </a>
<a name="ln1347">  if (!forceit</a>
<a name="ln1348">      &amp;&amp; bufIsChanged(buf)</a>
<a name="ln1349">      &amp;&amp; ((flags &amp; CCGD_MULTWIN) || buf-&gt;b_nwindows &lt;= 1)</a>
<a name="ln1350">      &amp;&amp; (!(flags &amp; CCGD_AW) || autowrite(buf, forceit) == FAIL)) {</a>
<a name="ln1351">    if ((p_confirm || cmdmod.confirm) &amp;&amp; p_write) {</a>
<a name="ln1352">      int count = 0;</a>
<a name="ln1353"> </a>
<a name="ln1354">      if (flags &amp; CCGD_ALLBUF) {</a>
<a name="ln1355">        FOR_ALL_BUFFERS(buf2) {</a>
<a name="ln1356">          if (bufIsChanged(buf2) &amp;&amp; (buf2-&gt;b_ffname != NULL)) {</a>
<a name="ln1357">            count++;</a>
<a name="ln1358">          }</a>
<a name="ln1359">        }</a>
<a name="ln1360">      }</a>
<a name="ln1361">      if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1362">        // Autocommand deleted buffer, oops!  It's not changed now.</a>
<a name="ln1363">        return false;</a>
<a name="ln1364">      }</a>
<a name="ln1365">      dialog_changed(buf, count &gt; 1);</a>
<a name="ln1366">      if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1367">        // Autocommand deleted buffer, oops!  It's not changed now.</a>
<a name="ln1368">        return false;</a>
<a name="ln1369">      }</a>
<a name="ln1370">      return bufIsChanged(buf);</a>
<a name="ln1371">    }</a>
<a name="ln1372">    if (flags &amp; CCGD_EXCMD) {</a>
<a name="ln1373">      no_write_message();</a>
<a name="ln1374">    } else {</a>
<a name="ln1375">      no_write_message_nobang(curbuf);</a>
<a name="ln1376">    }</a>
<a name="ln1377">    return true;</a>
<a name="ln1378">  }</a>
<a name="ln1379">  return false;</a>
<a name="ln1380">}</a>
<a name="ln1381"> </a>
<a name="ln1382"> </a>
<a name="ln1383"> </a>
<a name="ln1384">/// Ask the user what to do when abandoning a changed buffer.</a>
<a name="ln1385">/// Must check 'write' option first!</a>
<a name="ln1386">///</a>
<a name="ln1387">/// @param buf</a>
<a name="ln1388">/// @param checkall may abandon all changed buffers</a>
<a name="ln1389">void dialog_changed(buf_T *buf, bool checkall)</a>
<a name="ln1390">{</a>
<a name="ln1391">  char_u buff[DIALOG_MSG_SIZE];</a>
<a name="ln1392">  int ret;</a>
<a name="ln1393">  // Init ea pseudo-structure, this is needed for the check_overwrite()</a>
<a name="ln1394">  // function.</a>
<a name="ln1395">  exarg_T ea = {</a>
<a name="ln1396">    .append = false,</a>
<a name="ln1397">    .forceit = false,</a>
<a name="ln1398">  };</a>
<a name="ln1399"> </a>
<a name="ln1400">  dialog_msg(buff, _(&quot;Save changes to \&quot;%s\&quot;?&quot;), buf-&gt;b_fname);</a>
<a name="ln1401">  if (checkall) {</a>
<a name="ln1402">    ret = vim_dialog_yesnoallcancel(VIM_QUESTION, NULL, buff, 1);</a>
<a name="ln1403">  } else {</a>
<a name="ln1404">    ret = vim_dialog_yesnocancel(VIM_QUESTION, NULL, buff, 1);</a>
<a name="ln1405">  }</a>
<a name="ln1406"> </a>
<a name="ln1407">  if (ret == VIM_YES) {</a>
<a name="ln1408">    if (buf-&gt;b_fname != NULL</a>
<a name="ln1409">        &amp;&amp; check_overwrite(&amp;ea,</a>
<a name="ln1410">                           buf,</a>
<a name="ln1411">                           buf-&gt;b_fname,</a>
<a name="ln1412">                           buf-&gt;b_ffname,</a>
<a name="ln1413">                           false) == OK) {</a>
<a name="ln1414">      // didn't hit Cancel</a>
<a name="ln1415">      (void)buf_write_all(buf, false);</a>
<a name="ln1416">    }</a>
<a name="ln1417">  } else if (ret == VIM_NO) {</a>
<a name="ln1418">    unchanged(buf, true, false);</a>
<a name="ln1419">  } else if (ret == VIM_ALL) {</a>
<a name="ln1420">    // Write all modified files that can be written.</a>
<a name="ln1421">    // Skip readonly buffers, these need to be confirmed</a>
<a name="ln1422">    // individually.</a>
<a name="ln1423">    FOR_ALL_BUFFERS(buf2) {</a>
<a name="ln1424">      if (bufIsChanged(buf2) &amp;&amp; (buf2-&gt;b_ffname != NULL) &amp;&amp; !buf2-&gt;b_p_ro) {</a>
<a name="ln1425">        bufref_T bufref;</a>
<a name="ln1426">        set_bufref(&amp;bufref, buf2);</a>
<a name="ln1427"> </a>
<a name="ln1428">        if (buf2-&gt;b_fname != NULL</a>
<a name="ln1429">            &amp;&amp; check_overwrite(&amp;ea, buf2, buf2-&gt;b_fname,</a>
<a name="ln1430">                               buf2-&gt;b_ffname, false) == OK) {</a>
<a name="ln1431">          // didn't hit Cancel</a>
<a name="ln1432">          (void)buf_write_all(buf2, false);</a>
<a name="ln1433">        }</a>
<a name="ln1434">        // an autocommand may have deleted the buffer</a>
<a name="ln1435">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1436">          buf2 = firstbuf;</a>
<a name="ln1437">        }</a>
<a name="ln1438">      }</a>
<a name="ln1439">    }</a>
<a name="ln1440">  } else if (ret == VIM_DISCARDALL) {</a>
<a name="ln1441">    // mark all buffers as unchanged</a>
<a name="ln1442">    FOR_ALL_BUFFERS(buf2) {</a>
<a name="ln1443">      unchanged(buf2, true, false);</a>
<a name="ln1444">    }</a>
<a name="ln1445">  }</a>
<a name="ln1446">}</a>
<a name="ln1447"> </a>
<a name="ln1448">/// Ask the user whether to close the terminal buffer or not.</a>
<a name="ln1449">///</a>
<a name="ln1450">/// @param buf The terminal buffer.</a>
<a name="ln1451">/// @return bool Whether to close the buffer or not.</a>
<a name="ln1452">bool dialog_close_terminal(buf_T *buf)</a>
<a name="ln1453">{</a>
<a name="ln1454">  char_u buff[DIALOG_MSG_SIZE];</a>
<a name="ln1455"> </a>
<a name="ln1456">  dialog_msg(buff, _(&quot;Close \&quot;%s\&quot;?&quot;),</a>
<a name="ln1457">             (buf-&gt;b_fname != NULL) ? buf-&gt;b_fname : (char_u *)&quot;?&quot;);</a>
<a name="ln1458"> </a>
<a name="ln1459">  int ret = vim_dialog_yesnocancel(VIM_QUESTION, NULL, buff, 1);</a>
<a name="ln1460"> </a>
<a name="ln1461">  return (ret == VIM_YES) ? true : false;</a>
<a name="ln1462">}</a>
<a name="ln1463"> </a>
<a name="ln1464">/// Return true if the buffer &quot;buf&quot; can be abandoned, either by making it</a>
<a name="ln1465">/// hidden, autowriting it or unloading it.</a>
<a name="ln1466">bool can_abandon(buf_T *buf, int forceit)</a>
<a name="ln1467">{</a>
<a name="ln1468">  return buf_hide(buf)</a>
<a name="ln1469">         || !bufIsChanged(buf)</a>
<a name="ln1470">         || buf-&gt;b_nwindows &gt; 1</a>
<a name="ln1471">         || autowrite(buf, forceit) == OK</a>
<a name="ln1472">         || forceit;</a>
<a name="ln1473">}</a>
<a name="ln1474"> </a>
<a name="ln1475"> </a>
<a name="ln1476">/// Add a buffer number to &quot;bufnrs&quot;, unless it's already there.</a>
<a name="ln1477">static void add_bufnum(int *bufnrs, int *bufnump, int nr)</a>
<a name="ln1478">{</a>
<a name="ln1479">  int i;</a>
<a name="ln1480"> </a>
<a name="ln1481">  for (i = 0; i &lt; *bufnump; i++) {</a>
<a name="ln1482">    if (bufnrs[i] == nr) {</a>
<a name="ln1483">      return;</a>
<a name="ln1484">    }</a>
<a name="ln1485">  }</a>
<a name="ln1486">  bufnrs[*bufnump] = nr;</a>
<a name="ln1487">  *bufnump = *bufnump + 1;</a>
<a name="ln1488">}</a>
<a name="ln1489"> </a>
<a name="ln1490">/// Check if any buffer was changed and cannot be abandoned.</a>
<a name="ln1491">/// That changed buffer becomes the current buffer.</a>
<a name="ln1492">/// When &quot;unload&quot; is true the current buffer is unloaded instead of making it</a>
<a name="ln1493">/// hidden.  This is used for &quot;:q!&quot;.</a>
<a name="ln1494">///</a>
<a name="ln1495">/// @param[in] hidden specifies whether to check only hidden buffers.</a>
<a name="ln1496">/// @param[in] unload specifies whether to unload, instead of hide, the buffer.</a>
<a name="ln1497">///</a>
<a name="ln1498">/// @returns          true if any buffer is changed and cannot be abandoned</a>
<a name="ln1499">bool check_changed_any(bool hidden, bool unload)</a>
<a name="ln1500">{</a>
<a name="ln1501">  bool ret = false;</a>
<a name="ln1502">  int save;</a>
<a name="ln1503">  int i;</a>
<a name="ln1504">  int bufnum = 0;</a>
<a name="ln1505">  size_t bufcount = 0;</a>
<a name="ln1506">  int         *bufnrs;</a>
<a name="ln1507"> </a>
<a name="ln1508">  // Make a list of all buffers, with the most important ones first.</a>
<a name="ln1509">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1510">    bufcount++;</a>
<a name="ln1511">  }</a>
<a name="ln1512"> </a>
<a name="ln1513">  if (bufcount == 0) {</a>
<a name="ln1514">    return false;</a>
<a name="ln1515">  }</a>
<a name="ln1516"> </a>
<a name="ln1517">  bufnrs = xmalloc(sizeof(*bufnrs) * bufcount);</a>
<a name="ln1518"> </a>
<a name="ln1519">  // curbuf</a>
<a name="ln1520">  bufnrs[bufnum++] = curbuf-&gt;b_fnum;</a>
<a name="ln1521"> </a>
<a name="ln1522">  // buffers in current tab</a>
<a name="ln1523">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln1524">    if (wp-&gt;w_buffer != curbuf) {</a>
<a name="ln1525">      add_bufnum(bufnrs, &amp;bufnum, wp-&gt;w_buffer-&gt;b_fnum);</a>
<a name="ln1526">    }</a>
<a name="ln1527">  }</a>
<a name="ln1528"> </a>
<a name="ln1529">  // buffers in other tabs</a>
<a name="ln1530">  FOR_ALL_TABS(tp) {</a>
<a name="ln1531">    if (tp != curtab) {</a>
<a name="ln1532">      FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln1533">        add_bufnum(bufnrs, &amp;bufnum, wp-&gt;w_buffer-&gt;b_fnum);</a>
<a name="ln1534">      }</a>
<a name="ln1535">    }</a>
<a name="ln1536">  }</a>
<a name="ln1537"> </a>
<a name="ln1538">  // any other buffer</a>
<a name="ln1539">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1540">    add_bufnum(bufnrs, &amp;bufnum, buf-&gt;b_fnum);</a>
<a name="ln1541">  }</a>
<a name="ln1542"> </a>
<a name="ln1543">  buf_T *buf = NULL;</a>
<a name="ln1544">  for (i = 0; i &lt; bufnum; i++) {</a>
<a name="ln1545">    buf = buflist_findnr(bufnrs[i]);</a>
<a name="ln1546">    if (buf == NULL) {</a>
<a name="ln1547">      continue;</a>
<a name="ln1548">    }</a>
<a name="ln1549">    if ((!hidden || buf-&gt;b_nwindows == 0) &amp;&amp; bufIsChanged(buf)) {</a>
<a name="ln1550">      bufref_T bufref;</a>
<a name="ln1551">      set_bufref(&amp;bufref, buf);</a>
<a name="ln1552"> </a>
<a name="ln1553">      // Try auto-writing the buffer.  If this fails but the buffer no</a>
<a name="ln1554">      // longer exists it's not changed, that's OK.</a>
<a name="ln1555">      if (check_changed(buf, (p_awa ? CCGD_AW : 0)</a>
<a name="ln1556">                        | CCGD_MULTWIN</a>
<a name="ln1557">                        | CCGD_ALLBUF) &amp;&amp; bufref_valid(&amp;bufref)) {</a>
<a name="ln1558">        break;    // didn't save - still changes</a>
<a name="ln1559">      }</a>
<a name="ln1560">    }</a>
<a name="ln1561">  }</a>
<a name="ln1562"> </a>
<a name="ln1563">  if (i &gt;= bufnum) {</a>
<a name="ln1564">    goto theend;</a>
<a name="ln1565">  }</a>
<a name="ln1566"> </a>
<a name="ln1567">  // Get here if &quot;buf&quot; cannot be abandoned.</a>
<a name="ln1568">  ret = true;</a>
<a name="ln1569">  exiting = false;</a>
<a name="ln1570">  // When &quot;:confirm&quot; used, don't give an error message.</a>
<a name="ln1571">  if (!(p_confirm || cmdmod.confirm)) {</a>
<a name="ln1572">    // There must be a wait_return for this message, do_buffer()</a>
<a name="ln1573">    // may cause a redraw.  But wait_return() is a no-op when vgetc()</a>
<a name="ln1574">    // is busy (Quit used from window menu), then make sure we don't</a>
<a name="ln1575">    // cause a scroll up.</a>
<a name="ln1576">    if (vgetc_busy &gt; 0) {</a>
<a name="ln1577">      msg_row = cmdline_row;</a>
<a name="ln1578">      msg_col = 0;</a>
<a name="ln1579">      msg_didout = false;</a>
<a name="ln1580">    }</a>
<a name="ln1581">    if ((buf-&gt;terminal &amp;&amp; channel_job_running((uint64_t)buf-&gt;b_p_channel))</a>
<a name="ln1582">        ? EMSG2(_(&quot;E947: Job still running in buffer \&quot;%s\&quot;&quot;), buf-&gt;b_fname)</a>
<a name="ln1583">        : EMSG2(_(&quot;E162: No write since last change for buffer \&quot;%s\&quot;&quot;),</a>
<a name="ln1584">                buf_spname(buf) != NULL ? buf_spname(buf) : buf-&gt;b_fname)) {</a>
<a name="ln1585">      save = no_wait_return;</a>
<a name="ln1586">      no_wait_return = false;</a>
<a name="ln1587">      wait_return(false);</a>
<a name="ln1588">      no_wait_return = save;</a>
<a name="ln1589">    }</a>
<a name="ln1590">  }</a>
<a name="ln1591"> </a>
<a name="ln1592">  // Try to find a window that contains the buffer.</a>
<a name="ln1593">  if (buf != curbuf) {</a>
<a name="ln1594">    FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln1595">      if (wp-&gt;w_buffer == buf) {</a>
<a name="ln1596">        bufref_T bufref;</a>
<a name="ln1597">        set_bufref(&amp;bufref, buf);</a>
<a name="ln1598">        goto_tabpage_win(tp, wp);</a>
<a name="ln1599">        // Paranoia: did autocmds wipe out the buffer with changes?</a>
<a name="ln1600">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1601">          goto theend;</a>
<a name="ln1602">        }</a>
<a name="ln1603">        goto buf_found;</a>
<a name="ln1604">      }</a>
<a name="ln1605">    }</a>
<a name="ln1606">  }</a>
<a name="ln1607">buf_found:</a>
<a name="ln1608"> </a>
<a name="ln1609">  // Open the changed buffer in the current window.</a>
<a name="ln1610">  if (buf != curbuf) {</a>
<a name="ln1611">    set_curbuf(buf, unload ? DOBUF_UNLOAD : DOBUF_GOTO);</a>
<a name="ln1612">  }</a>
<a name="ln1613"> </a>
<a name="ln1614">theend:</a>
<a name="ln1615">  xfree(bufnrs);</a>
<a name="ln1616">  return ret;</a>
<a name="ln1617">}</a>
<a name="ln1618"> </a>
<a name="ln1619">/// Return FAIL if there is no file name, OK if there is one.</a>
<a name="ln1620">/// Give error message for FAIL.</a>
<a name="ln1621">int check_fname(void)</a>
<a name="ln1622">{</a>
<a name="ln1623">  if (curbuf-&gt;b_ffname == NULL) {</a>
<a name="ln1624">    EMSG(_(e_noname));</a>
<a name="ln1625">    return FAIL;</a>
<a name="ln1626">  }</a>
<a name="ln1627">  return OK;</a>
<a name="ln1628">}</a>
<a name="ln1629"> </a>
<a name="ln1630">/// Flush the contents of a buffer, unless it has no file name.</a>
<a name="ln1631">///</a>
<a name="ln1632">/// @return FAIL for failure, OK otherwise</a>
<a name="ln1633">int buf_write_all(buf_T *buf, int forceit)</a>
<a name="ln1634">{</a>
<a name="ln1635">  int retval;</a>
<a name="ln1636">  buf_T       *old_curbuf = curbuf;</a>
<a name="ln1637"> </a>
<a name="ln1638">  retval = (buf_write(buf, buf-&gt;b_ffname, buf-&gt;b_fname,</a>
<a name="ln1639">                      (linenr_T)1, buf-&gt;b_ml.ml_line_count, NULL,</a>
<a name="ln1640">                      false, forceit, true, false));</a>
<a name="ln1641">  if (curbuf != old_curbuf) {</a>
<a name="ln1642">    msg_source(HL_ATTR(HLF_W));</a>
<a name="ln1643">    MSG(_(&quot;Warning: Entered other buffer unexpectedly (check autocommands)&quot;));</a>
<a name="ln1644">  }</a>
<a name="ln1645">  return retval;</a>
<a name="ln1646">}</a>
<a name="ln1647"> </a>
<a name="ln1648">/// Code to handle the argument list.</a>
<a name="ln1649"> </a>
<a name="ln1650">#define AL_SET  1</a>
<a name="ln1651">#define AL_ADD  2</a>
<a name="ln1652">#define AL_DEL  3</a>
<a name="ln1653"> </a>
<a name="ln1654">/// Isolate one argument, taking backticks.</a>
<a name="ln1655">/// Changes the argument in-place, puts a NUL after it.  Backticks remain.</a>
<a name="ln1656">/// Return a pointer to the start of the next argument.</a>
<a name="ln1657">static char_u *do_one_arg(char_u *str)</a>
<a name="ln1658">{</a>
<a name="ln1659">  char_u      *p;</a>
<a name="ln1660">  bool inbacktick;</a>
<a name="ln1661"> </a>
<a name="ln1662">  inbacktick = false;</a>
<a name="ln1663">  for (p = str; *str; str++) {</a>
<a name="ln1664">    // When the backslash is used for escaping the special meaning of a</a>
<a name="ln1665">    // character we need to keep it until wildcard expansion.</a>
<a name="ln1666">    if (rem_backslash(str)) {</a>
<a name="ln1667">      *p++ = *str++;</a>
<a name="ln1668">      *p++ = *str;</a>
<a name="ln1669">    } else {</a>
<a name="ln1670">      // An item ends at a space not in backticks</a>
<a name="ln1671">      if (!inbacktick &amp;&amp; ascii_isspace(*str)) {</a>
<a name="ln1672">        break;</a>
<a name="ln1673">      }</a>
<a name="ln1674">      if (*str == '`') {</a>
<a name="ln1675">        inbacktick ^= true;</a>
<a name="ln1676">      }</a>
<a name="ln1677">      *p++ = *str;</a>
<a name="ln1678">    }</a>
<a name="ln1679">  }</a>
<a name="ln1680">  str = skipwhite(str);</a>
<a name="ln1681">  *p = NUL;</a>
<a name="ln1682"> </a>
<a name="ln1683">  return str;</a>
<a name="ln1684">}</a>
<a name="ln1685"> </a>
<a name="ln1686">/// Separate the arguments in &quot;str&quot; and return a list of pointers in the</a>
<a name="ln1687">/// growarray &quot;gap&quot;.</a>
<a name="ln1688">static void get_arglist(garray_T *gap, char_u *str, int escaped)</a>
<a name="ln1689">{</a>
<a name="ln1690">  ga_init(gap, (int)sizeof(char_u *), 20);</a>
<a name="ln1691">  while (*str != NUL) {</a>
<a name="ln1692">    GA_APPEND(char_u *, gap, str);</a>
<a name="ln1693"> </a>
<a name="ln1694">    // If str is escaped, don't handle backslashes or spaces</a>
<a name="ln1695">    if (!escaped) {</a>
<a name="ln1696">      return;</a>
<a name="ln1697">    }</a>
<a name="ln1698"> </a>
<a name="ln1699">    // Isolate one argument, change it in-place, put a NUL after it.</a>
<a name="ln1700">    str = do_one_arg(str);</a>
<a name="ln1701">  }</a>
<a name="ln1702">}</a>
<a name="ln1703"> </a>
<a name="ln1704">/// Parse a list of arguments (file names), expand them and return in</a>
<a name="ln1705">/// &quot;fnames[fcountp]&quot;.  When &quot;wig&quot; is true, removes files matching 'wildignore'.</a>
<a name="ln1706">///</a>
<a name="ln1707">/// @return FAIL or OK.</a>
<a name="ln1708">int get_arglist_exp(char_u *str, int *fcountp, char_u ***fnamesp, bool wig)</a>
<a name="ln1709">{</a>
<a name="ln1710">  garray_T ga;</a>
<a name="ln1711">  int i;</a>
<a name="ln1712"> </a>
<a name="ln1713">  get_arglist(&amp;ga, str, true);</a>
<a name="ln1714"> </a>
<a name="ln1715">  if (wig) {</a>
<a name="ln1716">    i = expand_wildcards(ga.ga_len, (char_u **)ga.ga_data,</a>
<a name="ln1717">                         fcountp, fnamesp, EW_FILE|EW_NOTFOUND|EW_NOTWILD);</a>
<a name="ln1718">  } else {</a>
<a name="ln1719">    i = gen_expand_wildcards(ga.ga_len, (char_u **)ga.ga_data,</a>
<a name="ln1720">                             fcountp, fnamesp, EW_FILE|EW_NOTFOUND|EW_NOTWILD);</a>
<a name="ln1721">  }</a>
<a name="ln1722"> </a>
<a name="ln1723">  ga_clear(&amp;ga);</a>
<a name="ln1724">  return i;</a>
<a name="ln1725">}</a>
<a name="ln1726"> </a>
<a name="ln1727"> </a>
<a name="ln1728">/// @param str</a>
<a name="ln1729">/// @param what</a>
<a name="ln1730">///         AL_SET: Redefine the argument list to 'str'.</a>
<a name="ln1731">///         AL_ADD: add files in 'str' to the argument list after &quot;after&quot;.</a>
<a name="ln1732">///         AL_DEL: remove files in 'str' from the argument list.</a>
<a name="ln1733">/// @param after</a>
<a name="ln1734">///         0 means before first one</a>
<a name="ln1735">/// @param will_edit  will edit added argument</a>
<a name="ln1736">///</a>
<a name="ln1737">/// @return FAIL for failure, OK otherwise.</a>
<a name="ln1738">static int do_arglist(char_u *str, int what, int after, bool will_edit)</a>
<a name="ln1739">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1740">{</a>
<a name="ln1741">  garray_T new_ga;</a>
<a name="ln1742">  int exp_count;</a>
<a name="ln1743">  char_u      **exp_files;</a>
<a name="ln1744">  char_u      *p;</a>
<a name="ln1745">  int match;</a>
<a name="ln1746">  int arg_escaped = true;</a>
<a name="ln1747"> </a>
<a name="ln1748">  // Set default argument for &quot;:argadd&quot; command.</a>
<a name="ln1749">  if (what == AL_ADD &amp;&amp; *str == NUL) {</a>
<a name="ln1750">    if (curbuf-&gt;b_ffname == NULL) {</a>
<a name="ln1751">      return FAIL;</a>
<a name="ln1752">    }</a>
<a name="ln1753">    str = curbuf-&gt;b_fname;</a>
<a name="ln1754">    arg_escaped = false;</a>
<a name="ln1755">  }</a>
<a name="ln1756"> </a>
<a name="ln1757">  // Collect all file name arguments in &quot;new_ga&quot;.</a>
<a name="ln1758">  get_arglist(&amp;new_ga, str, arg_escaped);</a>
<a name="ln1759"> </a>
<a name="ln1760">  if (what == AL_DEL) {</a>
<a name="ln1761">    regmatch_T regmatch;</a>
<a name="ln1762">    bool didone;</a>
<a name="ln1763"> </a>
<a name="ln1764">    // Delete the items: use each item as a regexp and find a match in the</a>
<a name="ln1765">    // argument list.</a>
<a name="ln1766">    regmatch.rm_ic = p_fic;     // ignore case when 'fileignorecase' is set</a>
<a name="ln1767">    for (int i = 0; i &lt; new_ga.ga_len &amp;&amp; !got_int; i++) {</a>
<a name="ln1768">      p = ((char_u **)new_ga.ga_data)[i];</a>
<a name="ln1769">      p = file_pat_to_reg_pat(p, NULL, NULL, false);</a>
<a name="ln1770">      if (p == NULL) {</a>
<a name="ln1771">        break;</a>
<a name="ln1772">      }</a>
<a name="ln1773">      regmatch.regprog = vim_regcomp(p, p_magic ? RE_MAGIC : 0);</a>
<a name="ln1774">      if (regmatch.regprog == NULL) {</a>
<a name="ln1775">        xfree(p);</a>
<a name="ln1776">        break;</a>
<a name="ln1777">      }</a>
<a name="ln1778"> </a>
<a name="ln1779">      didone = false;</a>
<a name="ln1780">      for (match = 0; match &lt; ARGCOUNT; match++) {</a>
<a name="ln1781">        if (vim_regexec(&amp;regmatch, alist_name(&amp;ARGLIST[match]),</a>
<a name="ln1782">                        (colnr_T)0)) {</a>
<a name="ln1783">          didone = true;</a>
<a name="ln1784">          xfree(ARGLIST[match].ae_fname);</a>
<a name="ln1785">          memmove(ARGLIST + match, ARGLIST + match + 1,</a>
<a name="ln1786">                  (size_t)(ARGCOUNT - match - 1) * sizeof(aentry_T));</a>
<a name="ln1787">          ALIST(curwin)-&gt;al_ga.ga_len--;</a>
<a name="ln1788">          if (curwin-&gt;w_arg_idx &gt; match) {</a>
<a name="ln1789">            curwin-&gt;w_arg_idx--;</a>
<a name="ln1790">          }</a>
<a name="ln1791">          match--;</a>
<a name="ln1792">        }</a>
<a name="ln1793">      }</a>
<a name="ln1794"> </a>
<a name="ln1795">      vim_regfree(regmatch.regprog);</a>
<a name="ln1796">      xfree(p);</a>
<a name="ln1797">      if (!didone) {</a>
<a name="ln1798">        EMSG2(_(e_nomatch2), ((char_u **)new_ga.ga_data)[i]);</a>
<a name="ln1799">      }</a>
<a name="ln1800">    }</a>
<a name="ln1801">    ga_clear(&amp;new_ga);</a>
<a name="ln1802">  } else {</a>
<a name="ln1803">    int i = expand_wildcards(new_ga.ga_len, (char_u **)new_ga.ga_data,</a>
<a name="ln1804">                             &amp;exp_count, &amp;exp_files,</a>
<a name="ln1805">                             EW_DIR|EW_FILE|EW_ADDSLASH|EW_NOTFOUND);</a>
<a name="ln1806">    ga_clear(&amp;new_ga);</a>
<a name="ln1807">    if (i == FAIL || exp_count == 0) {</a>
<a name="ln1808">      EMSG(_(e_nomatch));</a>
<a name="ln1809">      return FAIL;</a>
<a name="ln1810">    }</a>
<a name="ln1811"> </a>
<a name="ln1812">    if (what == AL_ADD) {</a>
<a name="ln1813">      alist_add_list(exp_count, exp_files, after, will_edit);</a>
<a name="ln1814">      xfree(exp_files);</a>
<a name="ln1815">    } else {</a>
<a name="ln1816">      assert(what == AL_SET);</a>
<a name="ln1817">      alist_set(ALIST(curwin), exp_count, exp_files, will_edit, NULL, 0);</a>
<a name="ln1818">    }</a>
<a name="ln1819">  }</a>
<a name="ln1820"> </a>
<a name="ln1821">  alist_check_arg_idx();</a>
<a name="ln1822"> </a>
<a name="ln1823">  return OK;</a>
<a name="ln1824">}</a>
<a name="ln1825"> </a>
<a name="ln1826">/// Check the validity of the arg_idx for each other window.</a>
<a name="ln1827">static void alist_check_arg_idx(void)</a>
<a name="ln1828">{</a>
<a name="ln1829">  FOR_ALL_TAB_WINDOWS(tp, win) {</a>
<a name="ln1830">    if (win-&gt;w_alist == curwin-&gt;w_alist) {</a>
<a name="ln1831">      check_arg_idx(win);</a>
<a name="ln1832">    }</a>
<a name="ln1833">  }</a>
<a name="ln1834">}</a>
<a name="ln1835"> </a>
<a name="ln1836">/// Return true if window &quot;win&quot; is editing the file at the current argument</a>
<a name="ln1837">/// index.</a>
<a name="ln1838">static bool editing_arg_idx(win_T *win)</a>
<a name="ln1839">{</a>
<a name="ln1840">  return !(win-&gt;w_arg_idx &gt;= WARGCOUNT(win)</a>
<a name="ln1841">           || (win-&gt;w_buffer-&gt;b_fnum</a>
<a name="ln1842">               != WARGLIST(win)[win-&gt;w_arg_idx].ae_fnum</a>
<a name="ln1843">               &amp;&amp; (win-&gt;w_buffer-&gt;b_ffname == NULL</a>
<a name="ln1844">                   || !(path_full_compare(</a>
<a name="ln1845">                       alist_name(&amp;WARGLIST(win)[win-&gt;w_arg_idx]),</a>
<a name="ln1846">                       win-&gt;w_buffer-&gt;b_ffname, true, true) &amp; kEqualFiles))));</a>
<a name="ln1847">}</a>
<a name="ln1848"> </a>
<a name="ln1849">/// Check if window &quot;win&quot; is editing the w_arg_idx file in its argument list.</a>
<a name="ln1850">void check_arg_idx(win_T *win)</a>
<a name="ln1851">{</a>
<a name="ln1852">  if (WARGCOUNT(win) &gt; 1 &amp;&amp; !editing_arg_idx(win)) {</a>
<a name="ln1853">    // We are not editing the current entry in the argument list.</a>
<a name="ln1854">    // Set &quot;arg_had_last&quot; if we are editing the last one.</a>
<a name="ln1855">    win-&gt;w_arg_idx_invalid = true;</a>
<a name="ln1856">    if (win-&gt;w_arg_idx != WARGCOUNT(win) - 1</a>
<a name="ln1857">        &amp;&amp; arg_had_last == false</a>
<a name="ln1858">        &amp;&amp; ALIST(win) == &amp;global_alist</a>
<a name="ln1859">        &amp;&amp; GARGCOUNT &gt; 0</a>
<a name="ln1860">        &amp;&amp; win-&gt;w_arg_idx &lt; GARGCOUNT</a>
<a name="ln1861">        &amp;&amp; (win-&gt;w_buffer-&gt;b_fnum == GARGLIST[GARGCOUNT - 1].ae_fnum</a>
<a name="ln1862">            || (win-&gt;w_buffer-&gt;b_ffname != NULL</a>
<a name="ln1863">                &amp;&amp; (path_full_compare(alist_name(&amp;GARGLIST[GARGCOUNT - 1]),</a>
<a name="ln1864">                                      win-&gt;w_buffer-&gt;b_ffname, true, true)</a>
<a name="ln1865">                    &amp; kEqualFiles)))) {</a>
<a name="ln1866">      arg_had_last = true;</a>
<a name="ln1867">    }</a>
<a name="ln1868">  } else {</a>
<a name="ln1869">    // We are editing the current entry in the argument list.</a>
<a name="ln1870">    // Set &quot;arg_had_last&quot; if it's also the last one</a>
<a name="ln1871">    win-&gt;w_arg_idx_invalid = false;</a>
<a name="ln1872">    if (win-&gt;w_arg_idx == WARGCOUNT(win) - 1</a>
<a name="ln1873">        &amp;&amp; win-&gt;w_alist == &amp;global_alist) {</a>
<a name="ln1874">      arg_had_last = true;</a>
<a name="ln1875">    }</a>
<a name="ln1876">  }</a>
<a name="ln1877">}</a>
<a name="ln1878"> </a>
<a name="ln1879">/// &quot;:args&quot;, &quot;:argslocal&quot; and &quot;:argsglobal&quot;.</a>
<a name="ln1880">void ex_args(exarg_T *eap)</a>
<a name="ln1881">{</a>
<a name="ln1882">  if (eap-&gt;cmdidx != CMD_args) {</a>
<a name="ln1883">    alist_unlink(ALIST(curwin));</a>
<a name="ln1884">    if (eap-&gt;cmdidx == CMD_argglobal) {</a>
<a name="ln1885">      ALIST(curwin) = &amp;global_alist;</a>
<a name="ln1886">    } else {     // eap-&gt;cmdidx == CMD_arglocal</a>
<a name="ln1887">      alist_new();</a>
<a name="ln1888">    }</a>
<a name="ln1889">  }</a>
<a name="ln1890"> </a>
<a name="ln1891">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln1892">    // &quot;:args file ..&quot;: define new argument list, handle like &quot;:next&quot;</a>
<a name="ln1893">    // Also for &quot;:argslocal file ..&quot; and &quot;:argsglobal file ..&quot;.</a>
<a name="ln1894">    ex_next(eap);</a>
<a name="ln1895">  } else if (eap-&gt;cmdidx == CMD_args) {</a>
<a name="ln1896">    // &quot;:args&quot;: list arguments.</a>
<a name="ln1897">    if (ARGCOUNT &gt; 0) {</a>
<a name="ln1898">      char_u **items = xmalloc(sizeof(char_u *) * (size_t)ARGCOUNT);</a>
<a name="ln1899">      // Overwrite the command, for a short list there is no scrolling</a>
<a name="ln1900">      // required and no wait_return().</a>
<a name="ln1901">      gotocmdline(true);</a>
<a name="ln1902">      for (int i = 0; i &lt; ARGCOUNT; i++) {</a>
<a name="ln1903">        items[i] = alist_name(&amp;ARGLIST[i]);</a>
<a name="ln1904">      }</a>
<a name="ln1905">      list_in_columns(items, ARGCOUNT, curwin-&gt;w_arg_idx);</a>
<a name="ln1906">      xfree(items);</a>
<a name="ln1907">    }</a>
<a name="ln1908">  } else if (eap-&gt;cmdidx == CMD_arglocal) {</a>
<a name="ln1909">    garray_T        *gap = &amp;curwin-&gt;w_alist-&gt;al_ga;</a>
<a name="ln1910"> </a>
<a name="ln1911">    // &quot;:argslocal&quot;: make a local copy of the global argument list.</a>
<a name="ln1912">    ga_grow(gap, GARGCOUNT);</a>
<a name="ln1913">    for (int i = 0; i &lt; GARGCOUNT; i++) {</a>
<a name="ln1914">      if (GARGLIST[i].ae_fname != NULL) {</a>
<a name="ln1915">        AARGLIST(curwin-&gt;w_alist)[gap-&gt;ga_len].ae_fname =</a>
<a name="ln1916">          vim_strsave(GARGLIST[i].ae_fname);</a>
<a name="ln1917">        AARGLIST(curwin-&gt;w_alist)[gap-&gt;ga_len].ae_fnum =</a>
<a name="ln1918">          GARGLIST[i].ae_fnum;</a>
<a name="ln1919">        gap-&gt;ga_len++;</a>
<a name="ln1920">      }</a>
<a name="ln1921">    }</a>
<a name="ln1922">  }</a>
<a name="ln1923">}</a>
<a name="ln1924"> </a>
<a name="ln1925">/// &quot;:previous&quot;, &quot;:sprevious&quot;, &quot;:Next&quot; and &quot;:sNext&quot;.</a>
<a name="ln1926">void ex_previous(exarg_T *eap)</a>
<a name="ln1927">{</a>
<a name="ln1928">  // If past the last one already, go to the last one.</a>
<a name="ln1929">  if (curwin-&gt;w_arg_idx - (int)eap-&gt;line2 &gt;= ARGCOUNT) {</a>
<a name="ln1930">    do_argfile(eap, ARGCOUNT - 1);</a>
<a name="ln1931">  } else {</a>
<a name="ln1932">    do_argfile(eap, curwin-&gt;w_arg_idx - (int)eap-&gt;line2);</a>
<a name="ln1933">  }</a>
<a name="ln1934">}</a>
<a name="ln1935"> </a>
<a name="ln1936">/// &quot;:rewind&quot;, &quot;:first&quot;, &quot;:sfirst&quot; and &quot;:srewind&quot;.</a>
<a name="ln1937">void ex_rewind(exarg_T *eap)</a>
<a name="ln1938">{</a>
<a name="ln1939">  do_argfile(eap, 0);</a>
<a name="ln1940">}</a>
<a name="ln1941"> </a>
<a name="ln1942">/// &quot;:last&quot; and &quot;:slast&quot;.</a>
<a name="ln1943">void ex_last(exarg_T *eap)</a>
<a name="ln1944">{</a>
<a name="ln1945">  do_argfile(eap, ARGCOUNT - 1);</a>
<a name="ln1946">}</a>
<a name="ln1947"> </a>
<a name="ln1948">/// &quot;:argument&quot; and &quot;:sargument&quot;.</a>
<a name="ln1949">void ex_argument(exarg_T *eap)</a>
<a name="ln1950">{</a>
<a name="ln1951">  int i;</a>
<a name="ln1952"> </a>
<a name="ln1953">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln1954">    i = (int)eap-&gt;line2 - 1;</a>
<a name="ln1955">  } else {</a>
<a name="ln1956">    i = curwin-&gt;w_arg_idx;</a>
<a name="ln1957">  }</a>
<a name="ln1958">  do_argfile(eap, i);</a>
<a name="ln1959">}</a>
<a name="ln1960"> </a>
<a name="ln1961">/// Edit file &quot;argn&quot; of the argument lists.</a>
<a name="ln1962">void do_argfile(exarg_T *eap, int argn)</a>
<a name="ln1963">{</a>
<a name="ln1964">  int other;</a>
<a name="ln1965">  char_u      *p;</a>
<a name="ln1966">  int old_arg_idx = curwin-&gt;w_arg_idx;</a>
<a name="ln1967"> </a>
<a name="ln1968">  if (argn &lt; 0 || argn &gt;= ARGCOUNT) {</a>
<a name="ln1969">    if (ARGCOUNT &lt;= 1) {</a>
<a name="ln1970">      EMSG(_(&quot;E163: There is only one file to edit&quot;));</a>
<a name="ln1971">    } else if (argn &lt; 0) {</a>
<a name="ln1972">      EMSG(_(&quot;E164: Cannot go before first file&quot;));</a>
<a name="ln1973">    } else {</a>
<a name="ln1974">      EMSG(_(&quot;E165: Cannot go beyond last file&quot;));</a>
<a name="ln1975">    }</a>
<a name="ln1976">  } else {</a>
<a name="ln1977">    setpcmark();</a>
<a name="ln1978"> </a>
<a name="ln1979">    // split window or create new tab page first</a>
<a name="ln1980">    if (*eap-&gt;cmd == 's' || cmdmod.tab != 0) {</a>
<a name="ln1981">      if (win_split(0, 0) == FAIL) {</a>
<a name="ln1982">        return;</a>
<a name="ln1983">      }</a>
<a name="ln1984">      RESET_BINDING(curwin);</a>
<a name="ln1985">    } else {</a>
<a name="ln1986">      // if 'hidden' set, only check for changed file when re-editing</a>
<a name="ln1987">      // the same buffer</a>
<a name="ln1988">      other = true;</a>
<a name="ln1989">      if (buf_hide(curbuf)) {</a>
<a name="ln1990">        p = (char_u *)fix_fname((char *)alist_name(&amp;ARGLIST[argn]));</a>
<a name="ln1991">        other = otherfile(p);</a>
<a name="ln1992">        xfree(p);</a>
<a name="ln1993">      }</a>
<a name="ln1994">      if ((!buf_hide(curbuf) || !other)</a>
<a name="ln1995">          &amp;&amp; check_changed(curbuf, CCGD_AW</a>
<a name="ln1996">                           | (other ? 0 : CCGD_MULTWIN)</a>
<a name="ln1997">                           | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln1998">                           | CCGD_EXCMD)) {</a>
<a name="ln1999">        return;</a>
<a name="ln2000">      }</a>
<a name="ln2001">    }</a>
<a name="ln2002"> </a>
<a name="ln2003">    curwin-&gt;w_arg_idx = argn;</a>
<a name="ln2004">    if (argn == ARGCOUNT - 1</a>
<a name="ln2005">        &amp;&amp; curwin-&gt;w_alist == &amp;global_alist) {</a>
<a name="ln2006">      arg_had_last = true;</a>
<a name="ln2007">    }</a>
<a name="ln2008"> </a>
<a name="ln2009">    // Edit the file; always use the last known line number.</a>
<a name="ln2010">    // When it fails (e.g. Abort for already edited file) restore the</a>
<a name="ln2011">    // argument index.</a>
<a name="ln2012">    if (do_ecmd(0, alist_name(&amp;ARGLIST[curwin-&gt;w_arg_idx]), NULL,</a>
<a name="ln2013">                eap, ECMD_LAST,</a>
<a name="ln2014">                (buf_hide(curwin-&gt;w_buffer) ? ECMD_HIDE : 0)</a>
<a name="ln2015">                + (eap-&gt;forceit ? ECMD_FORCEIT : 0), curwin) == FAIL) {</a>
<a name="ln2016">      curwin-&gt;w_arg_idx = old_arg_idx;</a>
<a name="ln2017">    } else if (eap-&gt;cmdidx != CMD_argdo) {</a>
<a name="ln2018">      // like Vi: set the mark where the cursor is in the file.</a>
<a name="ln2019">      setmark('\'');</a>
<a name="ln2020">    }</a>
<a name="ln2021">  }</a>
<a name="ln2022">}</a>
<a name="ln2023"> </a>
<a name="ln2024">/// &quot;:next&quot;, and commands that behave like it.</a>
<a name="ln2025">void ex_next(exarg_T *eap)</a>
<a name="ln2026">{</a>
<a name="ln2027">  int i;</a>
<a name="ln2028"> </a>
<a name="ln2029">  // check for changed buffer now, if this fails the argument list is not</a>
<a name="ln2030">  // redefined.</a>
<a name="ln2031">  if (buf_hide(curbuf)</a>
<a name="ln2032">      || eap-&gt;cmdidx == CMD_snext</a>
<a name="ln2033">      || !check_changed(curbuf, CCGD_AW</a>
<a name="ln2034">                        | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln2035">                        | CCGD_EXCMD)) {</a>
<a name="ln2036">    if (*eap-&gt;arg != NUL) {                 // redefine file list</a>
<a name="ln2037">      if (do_arglist(eap-&gt;arg, AL_SET, 0, true) == FAIL) {</a>
<a name="ln2038">        return;</a>
<a name="ln2039">      }</a>
<a name="ln2040">      i = 0;</a>
<a name="ln2041">    } else {</a>
<a name="ln2042">      i = curwin-&gt;w_arg_idx + (int)eap-&gt;line2;</a>
<a name="ln2043">    }</a>
<a name="ln2044">    do_argfile(eap, i);</a>
<a name="ln2045">  }</a>
<a name="ln2046">}</a>
<a name="ln2047"> </a>
<a name="ln2048">/// &quot;:argedit&quot;</a>
<a name="ln2049">void ex_argedit(exarg_T *eap)</a>
<a name="ln2050">{</a>
<a name="ln2051">  int i = eap-&gt;addr_count ? (int)eap-&gt;line2 : curwin-&gt;w_arg_idx + 1;</a>
<a name="ln2052">  // Whether curbuf will be reused, curbuf-&gt;b_ffname will be set.</a>
<a name="ln2053">  bool curbuf_is_reusable = curbuf_reusable();</a>
<a name="ln2054"> </a>
<a name="ln2055">  if (do_arglist(eap-&gt;arg, AL_ADD, i, true) == FAIL) {</a>
<a name="ln2056">    return;</a>
<a name="ln2057">  }</a>
<a name="ln2058">  maketitle();</a>
<a name="ln2059"> </a>
<a name="ln2060">  if (curwin-&gt;w_arg_idx == 0</a>
<a name="ln2061">      &amp;&amp; (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY)</a>
<a name="ln2062">      &amp;&amp; (curbuf-&gt;b_ffname == NULL || curbuf_is_reusable)) {</a>
<a name="ln2063">    i = 0;</a>
<a name="ln2064">  }</a>
<a name="ln2065">  // Edit the argument.</a>
<a name="ln2066">  if (i &lt; ARGCOUNT) {</a>
<a name="ln2067">    do_argfile(eap, i);</a>
<a name="ln2068">  }</a>
<a name="ln2069">}</a>
<a name="ln2070"> </a>
<a name="ln2071">/// &quot;:argadd&quot;</a>
<a name="ln2072">void ex_argadd(exarg_T *eap)</a>
<a name="ln2073">{</a>
<a name="ln2074">  do_arglist(eap-&gt;arg, AL_ADD,</a>
<a name="ln2075">             eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : curwin-&gt;w_arg_idx + 1,</a>
<a name="ln2076">             false);</a>
<a name="ln2077">  maketitle();</a>
<a name="ln2078">}</a>
<a name="ln2079"> </a>
<a name="ln2080">/// &quot;:argdelete&quot;</a>
<a name="ln2081">void ex_argdelete(exarg_T *eap)</a>
<a name="ln2082">{</a>
<a name="ln2083">  if (eap-&gt;addr_count &gt; 0 || *eap-&gt;arg == NUL) {</a>
<a name="ln2084">    // &quot;:argdel&quot; works like &quot;:.argdel&quot;</a>
<a name="ln2085">    if (eap-&gt;addr_count == 0) {</a>
<a name="ln2086">      if (curwin-&gt;w_arg_idx &gt;= ARGCOUNT) {</a>
<a name="ln2087">        EMSG(_(&quot;E610: No argument to delete&quot;));</a>
<a name="ln2088">        return;</a>
<a name="ln2089">      }</a>
<a name="ln2090">      eap-&gt;line1 = eap-&gt;line2 = curwin-&gt;w_arg_idx + 1;</a>
<a name="ln2091">    } else if (eap-&gt;line2 &gt; ARGCOUNT) {</a>
<a name="ln2092">      // &quot;:1,4argdel&quot;: Delete all arguments in the range.</a>
<a name="ln2093">      eap-&gt;line2 = ARGCOUNT;</a>
<a name="ln2094">    }</a>
<a name="ln2095">    linenr_T n = eap-&gt;line2 - eap-&gt;line1 + 1;</a>
<a name="ln2096">    if (*eap-&gt;arg != NUL) {</a>
<a name="ln2097">      // Can't have both a range and an argument.</a>
<a name="ln2098">      EMSG(_(e_invarg));</a>
<a name="ln2099">    } else if (n &lt;= 0) {</a>
<a name="ln2100">      // Don't give an error for &quot;:%argdel&quot; if the list is empty.</a>
<a name="ln2101">      if (eap-&gt;line1 != 1 || eap-&gt;line2 != 0) {</a>
<a name="ln2102">        EMSG(_(e_invrange));</a>
<a name="ln2103">      }</a>
<a name="ln2104">    } else {</a>
<a name="ln2105">      for (linenr_T i = eap-&gt;line1; i &lt;= eap-&gt;line2; i++) {</a>
<a name="ln2106">        xfree(ARGLIST[i - 1].ae_fname);</a>
<a name="ln2107">      }</a>
<a name="ln2108">      memmove(ARGLIST + eap-&gt;line1 - 1, ARGLIST + eap-&gt;line2,</a>
<a name="ln2109">              (size_t)(ARGCOUNT - eap-&gt;line2) * sizeof(aentry_T));</a>
<a name="ln2110">      ALIST(curwin)-&gt;al_ga.ga_len -= (int)n;</a>
<a name="ln2111">      if (curwin-&gt;w_arg_idx &gt;= eap-&gt;line2) {</a>
<a name="ln2112">        curwin-&gt;w_arg_idx -= (int)n;</a>
<a name="ln2113">      } else if (curwin-&gt;w_arg_idx &gt; eap-&gt;line1) {</a>
<a name="ln2114">        curwin-&gt;w_arg_idx = (int)eap-&gt;line1;</a>
<a name="ln2115">      }</a>
<a name="ln2116">      if (ARGCOUNT == 0) {</a>
<a name="ln2117">          curwin-&gt;w_arg_idx = 0;</a>
<a name="ln2118">      } else if (curwin-&gt;w_arg_idx &gt;= ARGCOUNT) {</a>
<a name="ln2119">          curwin-&gt;w_arg_idx = ARGCOUNT - 1;</a>
<a name="ln2120">      }</a>
<a name="ln2121">    }</a>
<a name="ln2122">  } else {</a>
<a name="ln2123">    do_arglist(eap-&gt;arg, AL_DEL, 0, false);</a>
<a name="ln2124">  }</a>
<a name="ln2125">  maketitle();</a>
<a name="ln2126">}</a>
<a name="ln2127"> </a>
<a name="ln2128">/// &quot;:argdo&quot;, &quot;:windo&quot;, &quot;:bufdo&quot;, &quot;:tabdo&quot;, &quot;:cdo&quot;, &quot;:ldo&quot;, &quot;:cfdo&quot; and &quot;:lfdo&quot;</a>
<a name="ln2129">void ex_listdo(exarg_T *eap)</a>
<a name="ln2130">{</a>
<a name="ln2131">  int i;</a>
<a name="ln2132">  win_T       *wp;</a>
<a name="ln2133">  tabpage_T   *tp;</a>
<a name="ln2134">  int next_fnum = 0;</a>
<a name="ln2135">  char_u      *save_ei = NULL;</a>
<a name="ln2136">  char_u      *p_shm_save;</a>
<a name="ln2137"> </a>
<a name="ln2138">  if (eap-&gt;cmdidx != CMD_windo &amp;&amp; eap-&gt;cmdidx != CMD_tabdo) {</a>
<a name="ln2139">    // Don't do syntax HL autocommands.  Skipping the syntax file is a</a>
<a name="ln2140">    // great speed improvement.</a>
<a name="ln2141">    save_ei = au_event_disable(&quot;,Syntax&quot;);</a>
<a name="ln2142"> </a>
<a name="ln2143">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2144">      buf-&gt;b_flags &amp;= ~BF_SYN_SET;</a>
<a name="ln2145">    }</a>
<a name="ln2146">  }</a>
<a name="ln2147"> </a>
<a name="ln2148">  if (eap-&gt;cmdidx == CMD_windo</a>
<a name="ln2149">      || eap-&gt;cmdidx == CMD_tabdo</a>
<a name="ln2150">      || buf_hide(curbuf)</a>
<a name="ln2151">      || !check_changed(curbuf, CCGD_AW</a>
<a name="ln2152">                        | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln2153">                        | CCGD_EXCMD)) {</a>
<a name="ln2154">    i = 0;</a>
<a name="ln2155">    // start at the eap-&gt;line1 argument/window/buffer</a>
<a name="ln2156">    wp = firstwin;</a>
<a name="ln2157">    tp = first_tabpage;</a>
<a name="ln2158">    switch (eap-&gt;cmdidx) {</a>
<a name="ln2159">    case CMD_windo:</a>
<a name="ln2160">      for (; wp != NULL &amp;&amp; i + 1 &lt; eap-&gt;line1; wp = wp-&gt;w_next) {</a>
<a name="ln2161">        i++;</a>
<a name="ln2162">      }</a>
<a name="ln2163">      break;</a>
<a name="ln2164">    case CMD_tabdo:</a>
<a name="ln2165">      for (; tp != NULL &amp;&amp; i + 1 &lt; eap-&gt;line1; tp = tp-&gt;tp_next) {</a>
<a name="ln2166">        i++;</a>
<a name="ln2167">      }</a>
<a name="ln2168">      break;</a>
<a name="ln2169">    case CMD_argdo:</a>
<a name="ln2170">      i = (int)eap-&gt;line1 - 1;</a>
<a name="ln2171">      break;</a>
<a name="ln2172">    default:</a>
<a name="ln2173">      break;</a>
<a name="ln2174">    }</a>
<a name="ln2175"> </a>
<a name="ln2176">    buf_T *buf = curbuf;</a>
<a name="ln2177">    size_t qf_size = 0;</a>
<a name="ln2178"> </a>
<a name="ln2179">    // set pcmark now</a>
<a name="ln2180">    if (eap-&gt;cmdidx == CMD_bufdo) {</a>
<a name="ln2181">      // Advance to the first listed buffer after &quot;eap-&gt;line1&quot;.</a>
<a name="ln2182">      for (buf = firstbuf;</a>
<a name="ln2183">           buf != NULL &amp;&amp; (buf-&gt;b_fnum &lt; eap-&gt;line1 || !buf-&gt;b_p_bl);</a>
<a name="ln2184">           buf = buf-&gt;b_next) {</a>
<a name="ln2185">        if (buf-&gt;b_fnum &gt; eap-&gt;line2) {</a>
<a name="ln2186">          buf = NULL;</a>
<a name="ln2187">          break;</a>
<a name="ln2188">        }</a>
<a name="ln2189">      }</a>
<a name="ln2190">      if (buf != NULL) {</a>
<a name="ln2191">        goto_buffer(eap, DOBUF_FIRST, FORWARD, buf-&gt;b_fnum);</a>
<a name="ln2192">      }</a>
<a name="ln2193">    } else if (eap-&gt;cmdidx == CMD_cdo || eap-&gt;cmdidx == CMD_ldo</a>
<a name="ln2194">               || eap-&gt;cmdidx == CMD_cfdo || eap-&gt;cmdidx == CMD_lfdo) {</a>
<a name="ln2195">      qf_size = qf_get_valid_size(eap);</a>
<a name="ln2196">      assert(eap-&gt;line1 &gt;= 0);</a>
<a name="ln2197">      if (qf_size == 0 || (size_t)eap-&gt;line1 &gt; qf_size) {</a>
<a name="ln2198">        buf = NULL;</a>
<a name="ln2199">      } else {</a>
<a name="ln2200">        ex_cc(eap);</a>
<a name="ln2201"> </a>
<a name="ln2202">        buf = curbuf;</a>
<a name="ln2203">        i = (int)eap-&gt;line1 - 1;</a>
<a name="ln2204">        if (eap-&gt;addr_count &lt;= 0) {</a>
<a name="ln2205">          // Default to all quickfix/location list entries.</a>
<a name="ln2206">          assert(qf_size &lt; MAXLNUM);</a>
<a name="ln2207">          eap-&gt;line2 = (linenr_T)qf_size;</a>
<a name="ln2208">        }</a>
<a name="ln2209">      }</a>
<a name="ln2210">    } else {</a>
<a name="ln2211">      setpcmark();</a>
<a name="ln2212">    }</a>
<a name="ln2213">    listcmd_busy = true;            // avoids setting pcmark below</a>
<a name="ln2214"> </a>
<a name="ln2215">    while (!got_int &amp;&amp; buf != NULL) {</a>
<a name="ln2216">      if (eap-&gt;cmdidx == CMD_argdo) {</a>
<a name="ln2217">        // go to argument &quot;i&quot;</a>
<a name="ln2218">        if (i == ARGCOUNT) {</a>
<a name="ln2219">          break;</a>
<a name="ln2220">        }</a>
<a name="ln2221">        // Don't call do_argfile() when already there, it will try</a>
<a name="ln2222">        // reloading the file.</a>
<a name="ln2223">        if (curwin-&gt;w_arg_idx != i || !editing_arg_idx(curwin)) {</a>
<a name="ln2224">          // Clear 'shm' to avoid that the file message overwrites</a>
<a name="ln2225">          // any output from the command.</a>
<a name="ln2226">          p_shm_save = vim_strsave(p_shm);</a>
<a name="ln2227">          set_option_value(&quot;shm&quot;, 0L, &quot;&quot;, 0);</a>
<a name="ln2228">          do_argfile(eap, i);</a>
<a name="ln2229">          set_option_value(&quot;shm&quot;, 0L, (char *)p_shm_save, 0);</a>
<a name="ln2230">          xfree(p_shm_save);</a>
<a name="ln2231">        }</a>
<a name="ln2232">        if (curwin-&gt;w_arg_idx != i) {</a>
<a name="ln2233">          break;</a>
<a name="ln2234">        }</a>
<a name="ln2235">      } else if (eap-&gt;cmdidx == CMD_windo) {</a>
<a name="ln2236">        // go to window &quot;wp&quot;</a>
<a name="ln2237">        if (!win_valid(wp)) {</a>
<a name="ln2238">          break;</a>
<a name="ln2239">        }</a>
<a name="ln2240">        assert(wp);</a>
<a name="ln2241">        win_goto(wp);</a>
<a name="ln2242">        if (curwin != wp) {</a>
<a name="ln2243">          break;    // something must be wrong</a>
<a name="ln2244">        }</a>
<a name="ln2245">        wp = curwin-&gt;w_next;</a>
<a name="ln2246">      } else if (eap-&gt;cmdidx == CMD_tabdo) {</a>
<a name="ln2247">        // go to window &quot;tp&quot;</a>
<a name="ln2248">        if (!valid_tabpage(tp)) {</a>
<a name="ln2249">          break;</a>
<a name="ln2250">        }</a>
<a name="ln2251">        assert(tp);</a>
<a name="ln2252">        goto_tabpage_tp(tp, true, true);</a>
<a name="ln2253">        tp = tp-&gt;tp_next;</a>
<a name="ln2254">      } else if (eap-&gt;cmdidx == CMD_bufdo) {</a>
<a name="ln2255">        // Remember the number of the next listed buffer, in case</a>
<a name="ln2256">        // &quot;:bwipe&quot; is used or autocommands do something strange.</a>
<a name="ln2257">        next_fnum = -1;</a>
<a name="ln2258">        for (buf_T *bp = curbuf-&gt;b_next; bp != NULL; bp = bp-&gt;b_next) {</a>
<a name="ln2259">          if (bp-&gt;b_p_bl) {</a>
<a name="ln2260">            next_fnum = bp-&gt;b_fnum;</a>
<a name="ln2261">            break;</a>
<a name="ln2262">          }</a>
<a name="ln2263">        }</a>
<a name="ln2264">      }</a>
<a name="ln2265"> </a>
<a name="ln2266">      i++;</a>
<a name="ln2267">      // execute the command</a>
<a name="ln2268">      do_cmdline(eap-&gt;arg, eap-&gt;getline, eap-&gt;cookie,</a>
<a name="ln2269">                 DOCMD_VERBOSE + DOCMD_NOWAIT);</a>
<a name="ln2270"> </a>
<a name="ln2271">      if (eap-&gt;cmdidx == CMD_bufdo) {</a>
<a name="ln2272">        // Done?</a>
<a name="ln2273">        if (next_fnum &lt; 0 || next_fnum &gt; eap-&gt;line2) {</a>
<a name="ln2274">          break;</a>
<a name="ln2275">        }</a>
<a name="ln2276"> </a>
<a name="ln2277">        // Check if the buffer still exists.</a>
<a name="ln2278">        bool buf_still_exists = false;</a>
<a name="ln2279">        FOR_ALL_BUFFERS(bp) {</a>
<a name="ln2280">          if (bp-&gt;b_fnum == next_fnum) {</a>
<a name="ln2281">            buf_still_exists = true;</a>
<a name="ln2282">            break;</a>
<a name="ln2283">          }</a>
<a name="ln2284">        }</a>
<a name="ln2285">        if (!buf_still_exists) {</a>
<a name="ln2286">          break;</a>
<a name="ln2287">        }</a>
<a name="ln2288"> </a>
<a name="ln2289">        // Go to the next buffer.  Clear 'shm' to avoid that the file</a>
<a name="ln2290">        // message overwrites any output from the command.</a>
<a name="ln2291">        p_shm_save = vim_strsave(p_shm);</a>
<a name="ln2292">        set_option_value(&quot;shm&quot;, 0L, &quot;&quot;, 0);</a>
<a name="ln2293">        goto_buffer(eap, DOBUF_FIRST, FORWARD, next_fnum);</a>
<a name="ln2294">        set_option_value(&quot;shm&quot;, 0L, (char *)p_shm_save, 0);</a>
<a name="ln2295">        xfree(p_shm_save);</a>
<a name="ln2296"> </a>
<a name="ln2297">        // If autocommands took us elsewhere, quit here.</a>
<a name="ln2298">        if (curbuf-&gt;b_fnum != next_fnum) {</a>
<a name="ln2299">          break;</a>
<a name="ln2300">        }</a>
<a name="ln2301">      }</a>
<a name="ln2302"> </a>
<a name="ln2303">      if (eap-&gt;cmdidx == CMD_cdo || eap-&gt;cmdidx == CMD_ldo</a>
<a name="ln2304">          || eap-&gt;cmdidx == CMD_cfdo || eap-&gt;cmdidx == CMD_lfdo) {</a>
<a name="ln2305">        assert(i &gt;= 0);</a>
<a name="ln2306">        if ((size_t)i &gt;= qf_size || i &gt;= eap-&gt;line2) {</a>
<a name="ln2307">          break;</a>
<a name="ln2308">        }</a>
<a name="ln2309"> </a>
<a name="ln2310">        size_t qf_idx = qf_get_cur_idx(eap);</a>
<a name="ln2311"> </a>
<a name="ln2312">        ex_cnext(eap);</a>
<a name="ln2313"> </a>
<a name="ln2314">        // If jumping to the next quickfix entry fails, quit here.</a>
<a name="ln2315">        if (qf_get_cur_idx(eap) == qf_idx) {</a>
<a name="ln2316">          break;</a>
<a name="ln2317">        }</a>
<a name="ln2318">      }</a>
<a name="ln2319"> </a>
<a name="ln2320">      if (eap-&gt;cmdidx == CMD_windo) {</a>
<a name="ln2321">        validate_cursor();              // cursor may have moved</a>
<a name="ln2322">        // required when 'scrollbind' has been set</a>
<a name="ln2323">        if (curwin-&gt;w_p_scb) {</a>
<a name="ln2324">          do_check_scrollbind(true);</a>
<a name="ln2325">        }</a>
<a name="ln2326">      }</a>
<a name="ln2327">      if (eap-&gt;cmdidx == CMD_windo || eap-&gt;cmdidx == CMD_tabdo) {</a>
<a name="ln2328">        if (i + 1 &gt; eap-&gt;line2) {</a>
<a name="ln2329">          break;</a>
<a name="ln2330">        }</a>
<a name="ln2331">      }</a>
<a name="ln2332">      if (eap-&gt;cmdidx == CMD_argdo &amp;&amp; i &gt;= eap-&gt;line2) {</a>
<a name="ln2333">        break;</a>
<a name="ln2334">      }</a>
<a name="ln2335">    }</a>
<a name="ln2336">    listcmd_busy = false;</a>
<a name="ln2337">  }</a>
<a name="ln2338"> </a>
<a name="ln2339">  if (save_ei != NULL) {</a>
<a name="ln2340">    buf_T *bnext;</a>
<a name="ln2341">    aco_save_T aco;</a>
<a name="ln2342"> </a>
<a name="ln2343">    au_event_restore(save_ei);</a>
<a name="ln2344"> </a>
<a name="ln2345">    for (buf_T *buf = firstbuf; buf != NULL; buf = bnext) {</a>
<a name="ln2346">      bnext = buf-&gt;b_next;</a>
<a name="ln2347">      if (buf-&gt;b_nwindows &gt; 0 &amp;&amp; (buf-&gt;b_flags &amp; BF_SYN_SET)) {</a>
<a name="ln2348">        buf-&gt;b_flags &amp;= ~BF_SYN_SET;</a>
<a name="ln2349"> </a>
<a name="ln2350">        // buffer was opened while Syntax autocommands were disabled,</a>
<a name="ln2351">        // need to trigger them now.</a>
<a name="ln2352">        if (buf == curbuf) {</a>
<a name="ln2353">          apply_autocmds(EVENT_SYNTAX, curbuf-&gt;b_p_syn,</a>
<a name="ln2354">                         curbuf-&gt;b_fname, true, curbuf);</a>
<a name="ln2355">        } else {</a>
<a name="ln2356">          aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln2357">          apply_autocmds(EVENT_SYNTAX, buf-&gt;b_p_syn,</a>
<a name="ln2358">                         buf-&gt;b_fname, true, buf);</a>
<a name="ln2359">          aucmd_restbuf(&amp;aco);</a>
<a name="ln2360">        }</a>
<a name="ln2361"> </a>
<a name="ln2362">        // start over, in case autocommands messed things up.</a>
<a name="ln2363">        bnext = firstbuf;</a>
<a name="ln2364">      }</a>
<a name="ln2365">    }</a>
<a name="ln2366">  }</a>
<a name="ln2367">}</a>
<a name="ln2368"> </a>
<a name="ln2369">/// Add files[count] to the arglist of the current window after arg &quot;after&quot;.</a>
<a name="ln2370">/// The file names in files[count] must have been allocated and are taken over.</a>
<a name="ln2371">/// Files[] itself is not taken over.</a>
<a name="ln2372">///</a>
<a name="ln2373">/// @param after: where to add: 0 = before first one</a>
<a name="ln2374">/// @param will_edit  will edit adding argument</a>
<a name="ln2375">static void alist_add_list(int count, char_u **files, int after, bool will_edit)</a>
<a name="ln2376">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2377">{</a>
<a name="ln2378">  int old_argcount = ARGCOUNT;</a>
<a name="ln2379">  ga_grow(&amp;ALIST(curwin)-&gt;al_ga, count);</a>
<a name="ln2380">  {</a>
<a name="ln2381">    if (after &lt; 0) {</a>
<a name="ln2382">      after = 0;</a>
<a name="ln2383">    }</a>
<a name="ln2384">    if (after &gt; ARGCOUNT) {</a>
<a name="ln2385">      after = ARGCOUNT;</a>
<a name="ln2386">    }</a>
<a name="ln2387">    if (after &lt; ARGCOUNT) {</a>
<a name="ln2388">      memmove(&amp;(ARGLIST[after + count]), &amp;(ARGLIST[after]),</a>
<a name="ln2389">              (size_t)(ARGCOUNT - after) * sizeof(aentry_T));</a>
<a name="ln2390">    }</a>
<a name="ln2391">    for (int i = 0; i &lt; count; i++) {</a>
<a name="ln2392">      const int flags = BLN_LISTED | (will_edit ? BLN_CURBUF : 0);</a>
<a name="ln2393">      ARGLIST[after + i].ae_fname = files[i];</a>
<a name="ln2394">      ARGLIST[after + i].ae_fnum = buflist_add(files[i], flags);</a>
<a name="ln2395">    }</a>
<a name="ln2396">    ALIST(curwin)-&gt;al_ga.ga_len += count;</a>
<a name="ln2397">    if (old_argcount &gt; 0 &amp;&amp; curwin-&gt;w_arg_idx &gt;= after) {</a>
<a name="ln2398">      curwin-&gt;w_arg_idx += count;</a>
<a name="ln2399">    }</a>
<a name="ln2400">    return;</a>
<a name="ln2401">  }</a>
<a name="ln2402">}</a>
<a name="ln2403"> </a>
<a name="ln2404">// Function given to ExpandGeneric() to obtain the possible arguments of the</a>
<a name="ln2405">// argedit and argdelete commands.</a>
<a name="ln2406">char_u *get_arglist_name(expand_T *xp FUNC_ATTR_UNUSED, int idx)</a>
<a name="ln2407">{</a>
<a name="ln2408">  if (idx &gt;= ARGCOUNT) {</a>
<a name="ln2409">    return NULL;</a>
<a name="ln2410">  }</a>
<a name="ln2411">  return alist_name(&amp;ARGLIST[idx]);</a>
<a name="ln2412">}</a>
<a name="ln2413"> </a>
<a name="ln2414">/// &quot;:compiler[!] {name}&quot;</a>
<a name="ln2415">void ex_compiler(exarg_T *eap)</a>
<a name="ln2416">{</a>
<a name="ln2417">  char_u      *buf;</a>
<a name="ln2418">  char_u      *old_cur_comp = NULL;</a>
<a name="ln2419">  char_u      *p;</a>
<a name="ln2420"> </a>
<a name="ln2421">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln2422">    // List all compiler scripts.</a>
<a name="ln2423">    do_cmdline_cmd(&quot;echo globpath(&amp;rtp, 'compiler/*.vim')&quot;);  // NOLINT</a>
<a name="ln2424">  } else {</a>
<a name="ln2425">    size_t bufsize = STRLEN(eap-&gt;arg) + 14;</a>
<a name="ln2426">    buf = xmalloc(bufsize);</a>
<a name="ln2427">    if (eap-&gt;forceit) {</a>
<a name="ln2428">      // &quot;:compiler! {name}&quot; sets global options</a>
<a name="ln2429">      do_cmdline_cmd(&quot;command -nargs=* CompilerSet set &lt;args&gt;&quot;);</a>
<a name="ln2430">    } else {</a>
<a name="ln2431">      // &quot;:compiler! {name}&quot; sets local options.</a>
<a name="ln2432">      // To remain backwards compatible &quot;current_compiler&quot; is always</a>
<a name="ln2433">      // used.  A user's compiler plugin may set it, the distributed</a>
<a name="ln2434">      // plugin will then skip the settings.  Afterwards set</a>
<a name="ln2435">      // &quot;b:current_compiler&quot; and restore &quot;current_compiler&quot;.</a>
<a name="ln2436">      // Explicitly prepend &quot;g:&quot; to make it work in a function.</a>
<a name="ln2437">      old_cur_comp = get_var_value(&quot;g:current_compiler&quot;);</a>
<a name="ln2438">      if (old_cur_comp != NULL) {</a>
<a name="ln2439">        old_cur_comp = vim_strsave(old_cur_comp);</a>
<a name="ln2440">      }</a>
<a name="ln2441">      do_cmdline_cmd(&quot;command -nargs=* CompilerSet setlocal &lt;args&gt;&quot;);</a>
<a name="ln2442">    }</a>
<a name="ln2443">    do_unlet(S_LEN(&quot;g:current_compiler&quot;), true);</a>
<a name="ln2444">    do_unlet(S_LEN(&quot;b:current_compiler&quot;), true);</a>
<a name="ln2445"> </a>
<a name="ln2446">    snprintf((char *)buf, bufsize, &quot;compiler/%s.vim&quot;, eap-&gt;arg);</a>
<a name="ln2447">    if (source_in_path(p_rtp, buf, DIP_ALL) == FAIL) {</a>
<a name="ln2448">      EMSG2(_(&quot;E666: compiler not supported: %s&quot;), eap-&gt;arg);</a>
<a name="ln2449">    }</a>
<a name="ln2450">    xfree(buf);</a>
<a name="ln2451"> </a>
<a name="ln2452">    do_cmdline_cmd(&quot;:delcommand CompilerSet&quot;);</a>
<a name="ln2453"> </a>
<a name="ln2454">    // Set &quot;b:current_compiler&quot; from &quot;current_compiler&quot;.</a>
<a name="ln2455">    p = get_var_value(&quot;g:current_compiler&quot;);</a>
<a name="ln2456">    if (p != NULL) {</a>
<a name="ln2457">      set_internal_string_var(&quot;b:current_compiler&quot;, p);</a>
<a name="ln2458">    }</a>
<a name="ln2459"> </a>
<a name="ln2460">    // Restore &quot;current_compiler&quot; for &quot;:compiler {name}&quot;.</a>
<a name="ln2461">    if (!eap-&gt;forceit) {</a>
<a name="ln2462">      if (old_cur_comp != NULL) {</a>
<a name="ln2463">        set_internal_string_var(&quot;g:current_compiler&quot;,</a>
<a name="ln2464">                                old_cur_comp);</a>
<a name="ln2465">        xfree(old_cur_comp);</a>
<a name="ln2466">      } else {</a>
<a name="ln2467">        do_unlet(S_LEN(&quot;g:current_compiler&quot;), true);</a>
<a name="ln2468">      }</a>
<a name="ln2469">    }</a>
<a name="ln2470">  }</a>
<a name="ln2471">}</a>
<a name="ln2472"> </a>
<a name="ln2473"> </a>
<a name="ln2474">/// &quot;:options&quot;</a>
<a name="ln2475">void ex_options(exarg_T *eap)</a>
<a name="ln2476">{</a>
<a name="ln2477">  os_setenv(&quot;OPTWIN_CMD&quot;, cmdmod.tab ? &quot;tab&quot; : &quot;&quot;, 1);</a>
<a name="ln2478">  os_setenv(&quot;OPTWIN_CMD&quot;,</a>
<a name="ln2479">            cmdmod.tab ? &quot;tab&quot; :</a>
<a name="ln2480">            (cmdmod.split &amp; WSP_VERT) ? &quot;vert&quot; : &quot;&quot;, 1);</a>
<a name="ln2481">  cmd_source((char_u *)SYS_OPTWIN_FILE, NULL);</a>
<a name="ln2482">}</a>
<a name="ln2483"> </a>
<a name="ln2484">// Detect Python 3 or 2, and initialize 'pyxversion'.</a>
<a name="ln2485">void init_pyxversion(void)</a>
<a name="ln2486">{</a>
<a name="ln2487">  if (p_pyx == 0) {</a>
<a name="ln2488">    if (eval_has_provider(&quot;python3&quot;)) {</a>
<a name="ln2489">      p_pyx = 3;</a>
<a name="ln2490">    } else if (eval_has_provider(&quot;python&quot;)) {</a>
<a name="ln2491">      p_pyx = 2;</a>
<a name="ln2492">    }</a>
<a name="ln2493">  }</a>
<a name="ln2494">}</a>
<a name="ln2495"> </a>
<a name="ln2496">// Does a file contain one of the following strings at the beginning of any</a>
<a name="ln2497">// line?</a>
<a name="ln2498">// &quot;#!(any string)python2&quot;  =&gt; returns 2</a>
<a name="ln2499">// &quot;#!(any string)python3&quot;  =&gt; returns 3</a>
<a name="ln2500">// &quot;# requires python 2.x&quot;  =&gt; returns 2</a>
<a name="ln2501">// &quot;# requires python 3.x&quot;  =&gt; returns 3</a>
<a name="ln2502">// otherwise return 0.</a>
<a name="ln2503">static int requires_py_version(char_u *filename)</a>
<a name="ln2504">{</a>
<a name="ln2505">  FILE      *file;</a>
<a name="ln2506">  int       requires_py_version = 0;</a>
<a name="ln2507">  int       i, lines;</a>
<a name="ln2508"> </a>
<a name="ln2509">  lines = (int)p_mls;</a>
<a name="ln2510">  if (lines &lt; 0) {</a>
<a name="ln2511">    lines = 5;</a>
<a name="ln2512">  }</a>
<a name="ln2513"> </a>
<a name="ln2514">  file = os_fopen((char *)filename, &quot;r&quot;);</a>
<a name="ln2515">  if (file != NULL) {</a>
<a name="ln2516">    for (i = 0; i &lt; lines; i++) {</a>
<a name="ln2517">      if (vim_fgets(IObuff, IOSIZE, file)) {</a>
<a name="ln2518">        break;</a>
<a name="ln2519">      }</a>
<a name="ln2520">      if (i == 0 &amp;&amp; IObuff[0] == '#' &amp;&amp; IObuff[1] == '!') {</a>
<a name="ln2521">        // Check shebang.</a>
<a name="ln2522">        if (strstr((char *)IObuff + 2, &quot;python2&quot;) != NULL) {</a>
<a name="ln2523">          requires_py_version = 2;</a>
<a name="ln2524">          break;</a>
<a name="ln2525">        }</a>
<a name="ln2526">        if (strstr((char *)IObuff + 2, &quot;python3&quot;) != NULL) {</a>
<a name="ln2527">          requires_py_version = 3;</a>
<a name="ln2528">          break;</a>
<a name="ln2529">        }</a>
<a name="ln2530">      }</a>
<a name="ln2531">      IObuff[21] = '\0';</a>
<a name="ln2532">      if (STRCMP(&quot;# requires python 2.x&quot;, IObuff) == 0) {</a>
<a name="ln2533">        requires_py_version = 2;</a>
<a name="ln2534">        break;</a>
<a name="ln2535">      }</a>
<a name="ln2536">      if (STRCMP(&quot;# requires python 3.x&quot;, IObuff) == 0) {</a>
<a name="ln2537">        requires_py_version = 3;</a>
<a name="ln2538">        break;</a>
<a name="ln2539">      }</a>
<a name="ln2540">    }</a>
<a name="ln2541">    fclose(file);</a>
<a name="ln2542">  }</a>
<a name="ln2543">  return requires_py_version;</a>
<a name="ln2544">}</a>
<a name="ln2545"> </a>
<a name="ln2546"> </a>
<a name="ln2547">// Source a python file using the requested python version.</a>
<a name="ln2548">static void source_pyx_file(exarg_T *eap, char_u *fname)</a>
<a name="ln2549">{</a>
<a name="ln2550">  exarg_T ex;</a>
<a name="ln2551">  long int v = requires_py_version(fname);</a>
<a name="ln2552"> </a>
<a name="ln2553">  init_pyxversion();</a>
<a name="ln2554">  if (v == 0) {</a>
<a name="ln2555">    // user didn't choose a preference, 'pyx' is used</a>
<a name="ln2556">    v = p_pyx;</a>
<a name="ln2557">  }</a>
<a name="ln2558"> </a>
<a name="ln2559">  // now source, if required python version is not supported show</a>
<a name="ln2560">  // unobtrusive message.</a>
<a name="ln2561">  if (eap == NULL) {</a>
<a name="ln2562">    memset(&amp;ex, 0, sizeof(ex));</a>
<a name="ln2563">  } else {</a>
<a name="ln2564">    ex = *eap;</a>
<a name="ln2565">  }</a>
<a name="ln2566">  ex.arg = fname;</a>
<a name="ln2567">  ex.cmd = (char_u *)(v == 2 ? &quot;pyfile&quot; : &quot;pyfile3&quot;);</a>
<a name="ln2568"> </a>
<a name="ln2569">  if (v == 2) {</a>
<a name="ln2570">    ex_pyfile(&amp;ex);</a>
<a name="ln2571">  } else {</a>
<a name="ln2572">    ex_py3file(&amp;ex);</a>
<a name="ln2573">  }</a>
<a name="ln2574">}</a>
<a name="ln2575"> </a>
<a name="ln2576">// &quot;:pyxfile {fname}&quot;</a>
<a name="ln2577">void ex_pyxfile(exarg_T *eap)</a>
<a name="ln2578">{</a>
<a name="ln2579">  source_pyx_file(eap, eap-&gt;arg);</a>
<a name="ln2580">}</a>
<a name="ln2581"> </a>
<a name="ln2582">// &quot;:pyx&quot;</a>
<a name="ln2583">void ex_pyx(exarg_T *eap)</a>
<a name="ln2584">{</a>
<a name="ln2585">  init_pyxversion();</a>
<a name="ln2586">  if (p_pyx == 2) {</a>
<a name="ln2587">    ex_python(eap);</a>
<a name="ln2588">  } else {</a>
<a name="ln2589">    ex_python3(eap);</a>
<a name="ln2590">  }</a>
<a name="ln2591">}</a>
<a name="ln2592"> </a>
<a name="ln2593">// &quot;:pyxdo&quot;</a>
<a name="ln2594">void ex_pyxdo(exarg_T *eap)</a>
<a name="ln2595">{</a>
<a name="ln2596">  init_pyxversion();</a>
<a name="ln2597">  if (p_pyx == 2) {</a>
<a name="ln2598">    ex_pydo(eap);</a>
<a name="ln2599">  } else {</a>
<a name="ln2600">    ex_pydo3(eap);</a>
<a name="ln2601">  }</a>
<a name="ln2602">}</a>
<a name="ln2603"> </a>
<a name="ln2604">/// &quot;:source [{fname}]&quot;</a>
<a name="ln2605">void ex_source(exarg_T *eap)</a>
<a name="ln2606">{</a>
<a name="ln2607">  cmd_source(eap-&gt;arg, eap);</a>
<a name="ln2608">}</a>
<a name="ln2609"> </a>
<a name="ln2610">static void cmd_source(char_u *fname, exarg_T *eap)</a>
<a name="ln2611">{</a>
<a name="ln2612">  if (eap != NULL &amp;&amp; *fname == NUL) {</a>
<a name="ln2613">    cmd_source_buffer(eap);</a>
<a name="ln2614">  } else if (eap != NULL &amp;&amp; eap-&gt;forceit) {</a>
<a name="ln2615">    // &quot;:source!&quot;: read Normal mode commands</a>
<a name="ln2616">    // Need to execute the commands directly.  This is required at least</a>
<a name="ln2617">    // for:</a>
<a name="ln2618">    // - &quot;:g&quot; command busy</a>
<a name="ln2619">    // - after &quot;:argdo&quot;, &quot;:windo&quot; or &quot;:bufdo&quot;</a>
<a name="ln2620">    // - another command follows</a>
<a name="ln2621">    // - inside a loop</a>
<a name="ln2622">    openscript(fname, global_busy || listcmd_busy || eap-&gt;nextcmd != NULL</a>
<a name="ln2623">               || eap-&gt;cstack-&gt;cs_idx &gt;= 0);</a>
<a name="ln2624"> </a>
<a name="ln2625">    // &quot;:source&quot; read ex commands</a>
<a name="ln2626">  } else if (do_source(fname, false, DOSO_NONE) == FAIL) {</a>
<a name="ln2627">    EMSG2(_(e_notopen), fname);</a>
<a name="ln2628">  }</a>
<a name="ln2629">}</a>
<a name="ln2630"> </a>
<a name="ln2631">typedef struct {</a>
<a name="ln2632">  linenr_T curr_lnum;</a>
<a name="ln2633">  const linenr_T final_lnum;</a>
<a name="ln2634">} GetBufferLineCookie;</a>
<a name="ln2635"> </a>
<a name="ln2636">/// Get one line from the current selection in the buffer.</a>
<a name="ln2637">/// Called by do_cmdline() when it's called from cmd_source_buffer().</a>
<a name="ln2638">///</a>
<a name="ln2639">/// @return pointer to allocated line, or NULL for end-of-file or</a>
<a name="ln2640">///         some error.</a>
<a name="ln2641">static char_u *get_buffer_line(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln2642">{</a>
<a name="ln2643">  GetBufferLineCookie *p = cookie;</a>
<a name="ln2644">  if (p-&gt;curr_lnum &gt; p-&gt;final_lnum) {</a>
<a name="ln2645">    return NULL;</a>
<a name="ln2646">  }</a>
<a name="ln2647">  char_u *curr_line = ml_get(p-&gt;curr_lnum);</a>
<a name="ln2648">  p-&gt;curr_lnum++;</a>
<a name="ln2649">  return (char_u *)xstrdup((const char *)curr_line);</a>
<a name="ln2650">}</a>
<a name="ln2651"> </a>
<a name="ln2652">static void cmd_source_buffer(const exarg_T *eap)</a>
<a name="ln2653">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2654">{</a>
<a name="ln2655">  GetBufferLineCookie cookie = {</a>
<a name="ln2656">      .curr_lnum = eap-&gt;line1,</a>
<a name="ln2657">      .final_lnum = eap-&gt;line2,</a>
<a name="ln2658">  };</a>
<a name="ln2659">  source_using_linegetter((void *)&amp;cookie, get_buffer_line,</a>
<a name="ln2660">                          &quot;:source (no file)&quot;);</a>
<a name="ln2661">}</a>
<a name="ln2662"> </a>
<a name="ln2663">/// &quot;:source&quot; and associated commands.</a>
<a name="ln2664">///</a>
<a name="ln2665">/// @return address holding the next breakpoint line for a source cookie</a>
<a name="ln2666">linenr_T *source_breakpoint(void *cookie)</a>
<a name="ln2667">{</a>
<a name="ln2668">  return &amp;((struct source_cookie *)cookie)-&gt;breakpoint;</a>
<a name="ln2669">}</a>
<a name="ln2670"> </a>
<a name="ln2671">/// Return the address holding the debug tick for a source cookie.</a>
<a name="ln2672">int *source_dbg_tick(void *cookie)</a>
<a name="ln2673">{</a>
<a name="ln2674">  return &amp;((struct source_cookie *)cookie)-&gt;dbg_tick;</a>
<a name="ln2675">}</a>
<a name="ln2676"> </a>
<a name="ln2677">/// Return the nesting level for a source cookie.</a>
<a name="ln2678">int source_level(void *cookie)</a>
<a name="ln2679">{</a>
<a name="ln2680">  return ((struct source_cookie *)cookie)-&gt;level;</a>
<a name="ln2681">}</a>
<a name="ln2682"> </a>
<a name="ln2683">/// Special function to open a file without handle inheritance.</a>
<a name="ln2684">/// If possible the handle is closed on exec().</a>
<a name="ln2685">static FILE *fopen_noinh_readbin(char *filename)</a>
<a name="ln2686">{</a>
<a name="ln2687">#ifdef WIN32</a>
<a name="ln2688">  int fd_tmp = os_open(filename, O_RDONLY | O_BINARY | O_NOINHERIT, 0);</a>
<a name="ln2689">#else</a>
<a name="ln2690">  int fd_tmp = os_open(filename, O_RDONLY, 0);</a>
<a name="ln2691">#endif</a>
<a name="ln2692"> </a>
<a name="ln2693">  if (fd_tmp &lt; 0) {</a>
<a name="ln2694">    return NULL;</a>
<a name="ln2695">  }</a>
<a name="ln2696"> </a>
<a name="ln2697">  (void)os_set_cloexec(fd_tmp);</a>
<a name="ln2698"> </a>
<a name="ln2699">  return fdopen(fd_tmp, READBIN);</a>
<a name="ln2700">}</a>
<a name="ln2701"> </a>
<a name="ln2702">typedef struct {</a>
<a name="ln2703">  char_u *buf;</a>
<a name="ln2704">  size_t offset;</a>
<a name="ln2705">} GetStrLineCookie;</a>
<a name="ln2706"> </a>
<a name="ln2707">/// Get one full line from a sourced string (in-memory, no file).</a>
<a name="ln2708">/// Called by do_cmdline() when it's called from do_source_str().</a>
<a name="ln2709">///</a>
<a name="ln2710">/// @return pointer to allocated line, or NULL for end-of-file or</a>
<a name="ln2711">///         some error.</a>
<a name="ln2712">static char_u *get_str_line(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln2713">{</a>
<a name="ln2714">  GetStrLineCookie *p = cookie;</a>
<a name="ln2715">  size_t i = p-&gt;offset;</a>
<a name="ln2716">  if (strlen((char *)p-&gt;buf) &lt;= p-&gt;offset) {</a>
<a name="ln2717">    return NULL;</a>
<a name="ln2718">  }</a>
<a name="ln2719">  while (!(p-&gt;buf[i] == '\n' || p-&gt;buf[i] == '\0')) {</a>
<a name="ln2720">    i++;</a>
<a name="ln2721">  }</a>
<a name="ln2722">  char buf[2046];</a>
<a name="ln2723">  char *dst;</a>
<a name="ln2724">  dst = xstpncpy(buf, (char *)p-&gt;buf + p-&gt;offset, i - p-&gt;offset);</a>
<a name="ln2725">  if ((uint32_t)(dst - buf) != i - p-&gt;offset) {</a>
<a name="ln2726">    smsg(_(&quot;:source error parsing command %s&quot;), p-&gt;buf);</a>
<a name="ln2727">    return NULL;</a>
<a name="ln2728">  }</a>
<a name="ln2729">  buf[i - p-&gt;offset] = '\0';</a>
<a name="ln2730">  p-&gt;offset = i + 1;</a>
<a name="ln2731">  return (char_u *)xstrdup(buf);</a>
<a name="ln2732">}</a>
<a name="ln2733"> </a>
<a name="ln2734">static int source_using_linegetter(void *cookie,</a>
<a name="ln2735">                                   LineGetter fgetline,</a>
<a name="ln2736">                                   const char *traceback_name)</a>
<a name="ln2737">{</a>
<a name="ln2738">  char_u *save_sourcing_name = sourcing_name;</a>
<a name="ln2739">  linenr_T save_sourcing_lnum = sourcing_lnum;</a>
<a name="ln2740">  char_u sourcing_name_buf[256];</a>
<a name="ln2741">  if (save_sourcing_name == NULL) {</a>
<a name="ln2742">    sourcing_name = (char_u *)traceback_name;</a>
<a name="ln2743">  } else {</a>
<a name="ln2744">    snprintf((char *)sourcing_name_buf, sizeof(sourcing_name_buf),</a>
<a name="ln2745">             &quot;%s called at %s:%&quot;PRIdLINENR, traceback_name, save_sourcing_name,</a>
<a name="ln2746">             save_sourcing_lnum);</a>
<a name="ln2747">    sourcing_name = sourcing_name_buf;</a>
<a name="ln2748">  }</a>
<a name="ln2749">  sourcing_lnum = 0;</a>
<a name="ln2750"> </a>
<a name="ln2751">  const sctx_T save_current_sctx = current_sctx;</a>
<a name="ln2752">  current_sctx.sc_sid = SID_STR;</a>
<a name="ln2753">  current_sctx.sc_seq = 0;</a>
<a name="ln2754">  current_sctx.sc_lnum = save_sourcing_lnum;</a>
<a name="ln2755">  funccal_entry_T entry;</a>
<a name="ln2756">  save_funccal(&amp;entry);</a>
<a name="ln2757">  int retval = do_cmdline(NULL, fgetline, cookie,</a>
<a name="ln2758">                          DOCMD_VERBOSE | DOCMD_NOWAIT | DOCMD_REPEAT);</a>
<a name="ln2759">  sourcing_lnum = save_sourcing_lnum;</a>
<a name="ln2760">  sourcing_name = save_sourcing_name;</a>
<a name="ln2761">  current_sctx = save_current_sctx;</a>
<a name="ln2762">  restore_funccal();</a>
<a name="ln2763">  return retval;</a>
<a name="ln2764">}</a>
<a name="ln2765"> </a>
<a name="ln2766">/// Executes lines in `src` as Ex commands.</a>
<a name="ln2767">///</a>
<a name="ln2768">/// @see do_source()</a>
<a name="ln2769">int do_source_str(const char *cmd, const char *traceback_name)</a>
<a name="ln2770">{</a>
<a name="ln2771">  GetStrLineCookie cookie = {</a>
<a name="ln2772">      .buf = (char_u *)cmd,</a>
<a name="ln2773">      .offset = 0,</a>
<a name="ln2774">  };</a>
<a name="ln2775">  return source_using_linegetter((void *)&amp;cookie, get_str_line, traceback_name);</a>
<a name="ln2776">}</a>
<a name="ln2777"> </a>
<a name="ln2778">/// Reads the file `fname` and executes its lines as Ex commands.</a>
<a name="ln2779">///</a>
<a name="ln2780">/// This function may be called recursively!</a>
<a name="ln2781">///</a>
<a name="ln2782">/// @see do_source_str</a>
<a name="ln2783">///</a>
<a name="ln2784">/// @param fname</a>
<a name="ln2785">/// @param check_other  check for .vimrc and _vimrc</a>
<a name="ln2786">/// @param is_vimrc     DOSO_ value</a>
<a name="ln2787">///</a>
<a name="ln2788">/// @return FAIL if file could not be opened, OK otherwise</a>
<a name="ln2789">int do_source(char_u *fname, int check_other, int is_vimrc)</a>
<a name="ln2790">{</a>
<a name="ln2791">  struct source_cookie cookie;</a>
<a name="ln2792">  char_u                  *save_sourcing_name;</a>
<a name="ln2793">  linenr_T save_sourcing_lnum;</a>
<a name="ln2794">  char_u                  *p;</a>
<a name="ln2795">  char_u                  *fname_exp;</a>
<a name="ln2796">  char_u                  *firstline = NULL;</a>
<a name="ln2797">  int retval = FAIL;</a>
<a name="ln2798">  static scid_T last_current_SID = 0;</a>
<a name="ln2799">  static int last_current_SID_seq = 0;</a>
<a name="ln2800">  int save_debug_break_level = debug_break_level;</a>
<a name="ln2801">  scriptitem_T            *si = NULL;</a>
<a name="ln2802">  proftime_T wait_start;</a>
<a name="ln2803">  bool trigger_source_post = false;</a>
<a name="ln2804"> </a>
<a name="ln2805">  p = expand_env_save(fname);</a>
<a name="ln2806">  if (p == NULL) {</a>
<a name="ln2807">    return retval;</a>
<a name="ln2808">  }</a>
<a name="ln2809">  fname_exp = (char_u *)fix_fname((char *)p);</a>
<a name="ln2810">  xfree(p);</a>
<a name="ln2811">  if (fname_exp == NULL) {</a>
<a name="ln2812">    return retval;</a>
<a name="ln2813">  }</a>
<a name="ln2814">  if (os_isdir(fname_exp)) {</a>
<a name="ln2815">    smsg(_(&quot;Cannot source a directory: \&quot;%s\&quot;&quot;), fname);</a>
<a name="ln2816">    goto theend;</a>
<a name="ln2817">  }</a>
<a name="ln2818"> </a>
<a name="ln2819">  // Apply SourceCmd autocommands, they should get the file and source it.</a>
<a name="ln2820">  if (has_autocmd(EVENT_SOURCECMD, fname_exp, NULL)</a>
<a name="ln2821">      &amp;&amp; apply_autocmds(EVENT_SOURCECMD, fname_exp, fname_exp,</a>
<a name="ln2822">                        false, curbuf)) {</a>
<a name="ln2823">    retval = aborting() ? FAIL : OK;</a>
<a name="ln2824">    if (retval == OK) {</a>
<a name="ln2825">      // Apply SourcePost autocommands.</a>
<a name="ln2826">      apply_autocmds(EVENT_SOURCEPOST, fname_exp, fname_exp, false, curbuf);</a>
<a name="ln2827">    }</a>
<a name="ln2828">    goto theend;</a>
<a name="ln2829">  }</a>
<a name="ln2830"> </a>
<a name="ln2831">  // Apply SourcePre autocommands, they may get the file.</a>
<a name="ln2832">  apply_autocmds(EVENT_SOURCEPRE, fname_exp, fname_exp, false, curbuf);</a>
<a name="ln2833"> </a>
<a name="ln2834">  cookie.fp = fopen_noinh_readbin((char *)fname_exp);</a>
<a name="ln2835">  if (cookie.fp == NULL &amp;&amp; check_other) {</a>
<a name="ln2836">    // Try again, replacing file name &quot;.vimrc&quot; by &quot;_vimrc&quot; or vice versa,</a>
<a name="ln2837">    // and &quot;.exrc&quot; by &quot;_exrc&quot; or vice versa.</a>
<a name="ln2838">    p = path_tail(fname_exp);</a>
<a name="ln2839">    if ((*p == '.' || *p == '_')</a>
<a name="ln2840">        &amp;&amp; (STRICMP(p + 1, &quot;nvimrc&quot;) == 0 || STRICMP(p + 1, &quot;exrc&quot;) == 0)) {</a>
<a name="ln2841">      *p = (*p == '_') ? '.' : '_';</a>
<a name="ln2842">      cookie.fp = fopen_noinh_readbin((char *)fname_exp);</a>
<a name="ln2843">    }</a>
<a name="ln2844">  }</a>
<a name="ln2845"> </a>
<a name="ln2846">  if (cookie.fp == NULL) {</a>
<a name="ln2847">    if (p_verbose &gt; 0) {</a>
<a name="ln2848">      verbose_enter();</a>
<a name="ln2849">      if (sourcing_name == NULL) {</a>
<a name="ln2850">        smsg(_(&quot;could not source \&quot;%s\&quot;&quot;), fname);</a>
<a name="ln2851">      } else {</a>
<a name="ln2852">        smsg(_(&quot;line %&quot; PRId64 &quot;: could not source \&quot;%s\&quot;&quot;),</a>
<a name="ln2853">             (int64_t)sourcing_lnum, fname);</a>
<a name="ln2854">      }</a>
<a name="ln2855">      verbose_leave();</a>
<a name="ln2856">    }</a>
<a name="ln2857">    goto theend;</a>
<a name="ln2858">  }</a>
<a name="ln2859"> </a>
<a name="ln2860">  // The file exists.</a>
<a name="ln2861">  // - In verbose mode, give a message.</a>
<a name="ln2862">  // - For a vimrc file, may want to call vimrc_found().</a>
<a name="ln2863">  if (p_verbose &gt; 1) {</a>
<a name="ln2864">    verbose_enter();</a>
<a name="ln2865">    if (sourcing_name == NULL) {</a>
<a name="ln2866">      smsg(_(&quot;sourcing \&quot;%s\&quot;&quot;), fname);</a>
<a name="ln2867">    } else {</a>
<a name="ln2868">      smsg(_(&quot;line %&quot; PRId64 &quot;: sourcing \&quot;%s\&quot;&quot;),</a>
<a name="ln2869">           (int64_t)sourcing_lnum, fname);</a>
<a name="ln2870">    }</a>
<a name="ln2871">    verbose_leave();</a>
<a name="ln2872">  }</a>
<a name="ln2873">  if (is_vimrc == DOSO_VIMRC) {</a>
<a name="ln2874">    vimrc_found(fname_exp, (char_u *)&quot;MYVIMRC&quot;);</a>
<a name="ln2875">  }</a>
<a name="ln2876"> </a>
<a name="ln2877">#ifdef USE_CRNL</a>
<a name="ln2878">  // If no automatic file format: Set default to CR-NL.</a>
<a name="ln2879">  if (*p_ffs == NUL) {</a>
<a name="ln2880">    cookie.fileformat = EOL_DOS;</a>
<a name="ln2881">  } else {</a>
<a name="ln2882">    cookie.fileformat = EOL_UNKNOWN;</a>
<a name="ln2883">  }</a>
<a name="ln2884">  cookie.error = false;</a>
<a name="ln2885">#endif</a>
<a name="ln2886"> </a>
<a name="ln2887">  cookie.nextline = NULL;</a>
<a name="ln2888">  cookie.sourcing_lnum = 0;</a>
<a name="ln2889">  cookie.finished = false;</a>
<a name="ln2890"> </a>
<a name="ln2891">  // Check if this script has a breakpoint.</a>
<a name="ln2892">  cookie.breakpoint = dbg_find_breakpoint(true, fname_exp, (linenr_T)0);</a>
<a name="ln2893">  cookie.fname = fname_exp;</a>
<a name="ln2894">  cookie.dbg_tick = debug_tick;</a>
<a name="ln2895"> </a>
<a name="ln2896">  cookie.level = ex_nesting_level;</a>
<a name="ln2897"> </a>
<a name="ln2898">  // Keep the sourcing name/lnum, for recursive calls.</a>
<a name="ln2899">  save_sourcing_name = sourcing_name;</a>
<a name="ln2900">  sourcing_name = fname_exp;</a>
<a name="ln2901">  save_sourcing_lnum = sourcing_lnum;</a>
<a name="ln2902">  sourcing_lnum = 0;</a>
<a name="ln2903"> </a>
<a name="ln2904">  // start measuring script load time if --startuptime was passed and</a>
<a name="ln2905">  // time_fd was successfully opened afterwards.</a>
<a name="ln2906">  proftime_T rel_time;</a>
<a name="ln2907">  proftime_T start_time;</a>
<a name="ln2908">  FILE * const l_time_fd = time_fd;</a>
<a name="ln2909">  if (l_time_fd != NULL) {</a>
<a name="ln2910">    time_push(&amp;rel_time, &amp;start_time);</a>
<a name="ln2911">  }</a>
<a name="ln2912"> </a>
<a name="ln2913">  const int l_do_profiling = do_profiling;</a>
<a name="ln2914">  if (l_do_profiling == PROF_YES) {</a>
<a name="ln2915">    prof_child_enter(&amp;wait_start);    // entering a child now</a>
<a name="ln2916">  }</a>
<a name="ln2917"> </a>
<a name="ln2918">  // Don't use local function variables, if called from a function.</a>
<a name="ln2919">  // Also starts profiling timer for nested script.</a>
<a name="ln2920">  funccal_entry_T funccalp_entry;</a>
<a name="ln2921">  save_funccal(&amp;funccalp_entry);</a>
<a name="ln2922"> </a>
<a name="ln2923">  // Check if this script was sourced before to finds its SID.</a>
<a name="ln2924">  // If it's new, generate a new SID.</a>
<a name="ln2925">  // Always use a new sequence number.</a>
<a name="ln2926">  const sctx_T save_current_sctx = current_sctx;</a>
<a name="ln2927">  current_sctx.sc_seq = ++last_current_SID_seq;</a>
<a name="ln2928">  current_sctx.sc_lnum = 0;</a>
<a name="ln2929">  FileID file_id;</a>
<a name="ln2930">  bool file_id_ok = os_fileid((char *)fname_exp, &amp;file_id);</a>
<a name="ln2931">  assert(script_items.ga_len &gt;= 0);</a>
<a name="ln2932">  for (current_sctx.sc_sid = script_items.ga_len; current_sctx.sc_sid &gt; 0;</a>
<a name="ln2933">       current_sctx.sc_sid--) {</a>
<a name="ln2934">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln2935">    // Compare dev/ino when possible, it catches symbolic links.</a>
<a name="ln2936">    // Also compare file names, the inode may change when the file was edited.</a>
<a name="ln2937">    bool file_id_equal = file_id_ok &amp;&amp; si-&gt;file_id_valid</a>
<a name="ln2938">                         &amp;&amp; os_fileid_equal(&amp;(si-&gt;file_id), &amp;file_id);</a>
<a name="ln2939">    if (si-&gt;sn_name != NULL</a>
<a name="ln2940">        &amp;&amp; (file_id_equal || fnamecmp(si-&gt;sn_name, fname_exp) == 0)) {</a>
<a name="ln2941">      break;</a>
<a name="ln2942">    }</a>
<a name="ln2943">  }</a>
<a name="ln2944">  if (current_sctx.sc_sid == 0) {</a>
<a name="ln2945">    current_sctx.sc_sid = ++last_current_SID;</a>
<a name="ln2946">    ga_grow(&amp;script_items, (int)(current_sctx.sc_sid - script_items.ga_len));</a>
<a name="ln2947">    while (script_items.ga_len &lt; current_sctx.sc_sid) {</a>
<a name="ln2948">      script_items.ga_len++;</a>
<a name="ln2949">      SCRIPT_ITEM(script_items.ga_len).sn_name = NULL;</a>
<a name="ln2950">      SCRIPT_ITEM(script_items.ga_len).sn_prof_on = false;</a>
<a name="ln2951">    }</a>
<a name="ln2952">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln2953">    si-&gt;sn_name = fname_exp;</a>
<a name="ln2954">    fname_exp = vim_strsave(si-&gt;sn_name);  // used for autocmd</a>
<a name="ln2955">    if (file_id_ok) {</a>
<a name="ln2956">      si-&gt;file_id_valid = true;</a>
<a name="ln2957">      si-&gt;file_id = file_id;</a>
<a name="ln2958">    } else {</a>
<a name="ln2959">      si-&gt;file_id_valid = false;</a>
<a name="ln2960">    }</a>
<a name="ln2961"> </a>
<a name="ln2962">    // Allocate the local script variables to use for this script.</a>
<a name="ln2963">    new_script_vars(current_sctx.sc_sid);</a>
<a name="ln2964">  }</a>
<a name="ln2965"> </a>
<a name="ln2966">  if (l_do_profiling == PROF_YES) {</a>
<a name="ln2967">    bool forceit;</a>
<a name="ln2968"> </a>
<a name="ln2969">    // Check if we do profiling for this script.</a>
<a name="ln2970">    if (!si-&gt;sn_prof_on &amp;&amp; has_profiling(true, si-&gt;sn_name, &amp;forceit)) {</a>
<a name="ln2971">      profile_init(si);</a>
<a name="ln2972">      si-&gt;sn_pr_force = forceit;</a>
<a name="ln2973">    }</a>
<a name="ln2974">    if (si-&gt;sn_prof_on) {</a>
<a name="ln2975">      si-&gt;sn_pr_count++;</a>
<a name="ln2976">      si-&gt;sn_pr_start = profile_start();</a>
<a name="ln2977">      si-&gt;sn_pr_children = profile_zero();</a>
<a name="ln2978">    }</a>
<a name="ln2979">  }</a>
<a name="ln2980"> </a>
<a name="ln2981">  cookie.conv.vc_type = CONV_NONE;              // no conversion</a>
<a name="ln2982"> </a>
<a name="ln2983">  // Read the first line so we can check for a UTF-8 BOM.</a>
<a name="ln2984">  firstline = getsourceline(0, (void *)&amp;cookie, 0, true);</a>
<a name="ln2985">  if (firstline != NULL &amp;&amp; STRLEN(firstline) &gt;= 3 &amp;&amp; firstline[0] == 0xef</a>
<a name="ln2986">      &amp;&amp; firstline[1] == 0xbb &amp;&amp; firstline[2] == 0xbf) {</a>
<a name="ln2987">    // Found BOM; setup conversion, skip over BOM and recode the line.</a>
<a name="ln2988">    convert_setup(&amp;cookie.conv, (char_u *)&quot;utf-8&quot;, p_enc);</a>
<a name="ln2989">    p = string_convert(&amp;cookie.conv, firstline + 3, NULL);</a>
<a name="ln2990">    if (p == NULL) {</a>
<a name="ln2991">      p = vim_strsave(firstline + 3);</a>
<a name="ln2992">    }</a>
<a name="ln2993">    xfree(firstline);</a>
<a name="ln2994">    firstline = p;</a>
<a name="ln2995">  }</a>
<a name="ln2996"> </a>
<a name="ln2997">  // Call do_cmdline, which will call getsourceline() to get the lines.</a>
<a name="ln2998">  do_cmdline(firstline, getsourceline, (void *)&amp;cookie,</a>
<a name="ln2999">             DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_REPEAT);</a>
<a name="ln3000">  retval = OK;</a>
<a name="ln3001"> </a>
<a name="ln3002">  if (l_do_profiling == PROF_YES) {</a>
<a name="ln3003">    // Get &quot;si&quot; again, &quot;script_items&quot; may have been reallocated.</a>
<a name="ln3004">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln3005">    if (si-&gt;sn_prof_on) {</a>
<a name="ln3006">      si-&gt;sn_pr_start = profile_end(si-&gt;sn_pr_start);</a>
<a name="ln3007">      si-&gt;sn_pr_start = profile_sub_wait(wait_start, si-&gt;sn_pr_start);</a>
<a name="ln3008">      si-&gt;sn_pr_total = profile_add(si-&gt;sn_pr_total, si-&gt;sn_pr_start);</a>
<a name="ln3009">      si-&gt;sn_pr_self = profile_self(si-&gt;sn_pr_self, si-&gt;sn_pr_start,</a>
<a name="ln3010">                                    si-&gt;sn_pr_children);</a>
<a name="ln3011">    }</a>
<a name="ln3012">  }</a>
<a name="ln3013"> </a>
<a name="ln3014">  if (got_int) {</a>
<a name="ln3015">    EMSG(_(e_interr));</a>
<a name="ln3016">  }</a>
<a name="ln3017">  sourcing_name = save_sourcing_name;</a>
<a name="ln3018">  sourcing_lnum = save_sourcing_lnum;</a>
<a name="ln3019">  if (p_verbose &gt; 1) {</a>
<a name="ln3020">    verbose_enter();</a>
<a name="ln3021">    smsg(_(&quot;finished sourcing %s&quot;), fname);</a>
<a name="ln3022">    if (sourcing_name != NULL) {</a>
<a name="ln3023">      smsg(_(&quot;continuing in %s&quot;), sourcing_name);</a>
<a name="ln3024">    }</a>
<a name="ln3025">    verbose_leave();</a>
<a name="ln3026">  }</a>
<a name="ln3027"> </a>
<a name="ln3028">  if (l_time_fd != NULL) {</a>
<a name="ln3029">    vim_snprintf((char *)IObuff, IOSIZE, &quot;sourcing %s&quot;, fname);</a>
<a name="ln3030">    time_msg((char *)IObuff, &amp;start_time);</a>
<a name="ln3031">    time_pop(rel_time);</a>
<a name="ln3032">  }</a>
<a name="ln3033"> </a>
<a name="ln3034">  if (!got_int) {</a>
<a name="ln3035">    trigger_source_post = true;</a>
<a name="ln3036">  }</a>
<a name="ln3037"> </a>
<a name="ln3038">  // After a &quot;finish&quot; in debug mode, need to break at first command of next</a>
<a name="ln3039">  // sourced file.</a>
<a name="ln3040">  if (save_debug_break_level &gt; ex_nesting_level</a>
<a name="ln3041">      &amp;&amp; debug_break_level == ex_nesting_level) {</a>
<a name="ln3042">    debug_break_level++;</a>
<a name="ln3043">  }</a>
<a name="ln3044"> </a>
<a name="ln3045">  current_sctx = save_current_sctx;</a>
<a name="ln3046">  restore_funccal();</a>
<a name="ln3047">  if (l_do_profiling == PROF_YES) {</a>
<a name="ln3048">    prof_child_exit(&amp;wait_start);    // leaving a child now</a>
<a name="ln3049">  }</a>
<a name="ln3050">  fclose(cookie.fp);</a>
<a name="ln3051">  xfree(cookie.nextline);</a>
<a name="ln3052">  xfree(firstline);</a>
<a name="ln3053">  convert_setup(&amp;cookie.conv, NULL, NULL);</a>
<a name="ln3054"> </a>
<a name="ln3055">  if (trigger_source_post) {</a>
<a name="ln3056">    apply_autocmds(EVENT_SOURCEPOST, fname_exp, fname_exp, false, curbuf);</a>
<a name="ln3057">  }</a>
<a name="ln3058"> </a>
<a name="ln3059">theend:</a>
<a name="ln3060">  xfree(fname_exp);</a>
<a name="ln3061">  return retval;</a>
<a name="ln3062">}</a>
<a name="ln3063"> </a>
<a name="ln3064"> </a>
<a name="ln3065">/// &quot;:scriptnames&quot;</a>
<a name="ln3066">void ex_scriptnames(exarg_T *eap)</a>
<a name="ln3067">{</a>
<a name="ln3068">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln3069">    // :script {scriptId}: edit the script</a>
<a name="ln3070">    if (eap-&gt;line2 &lt; 1 || eap-&gt;line2 &gt; script_items.ga_len) {</a>
<a name="ln3071">      EMSG(_(e_invarg));</a>
<a name="ln3072">    } else {</a>
<a name="ln3073">      eap-&gt;arg = SCRIPT_ITEM(eap-&gt;line2).sn_name;</a>
<a name="ln3074">      do_exedit(eap, NULL);</a>
<a name="ln3075">    }</a>
<a name="ln3076">    return;</a>
<a name="ln3077">  }</a>
<a name="ln3078"> </a>
<a name="ln3079">  for (int i = 1; i &lt;= script_items.ga_len &amp;&amp; !got_int; i++) {</a>
<a name="ln3080">    if (SCRIPT_ITEM(i).sn_name != NULL) {</a>
<a name="ln3081">      home_replace(NULL, SCRIPT_ITEM(i).sn_name,</a>
<a name="ln3082">                   NameBuff, MAXPATHL, true);</a>
<a name="ln3083">      smsg(&quot;%3d: %s&quot;, i, NameBuff);</a>
<a name="ln3084">    }</a>
<a name="ln3085">  }</a>
<a name="ln3086">}</a>
<a name="ln3087"> </a>
<a name="ln3088"># if defined(BACKSLASH_IN_FILENAME)</a>
<a name="ln3089">/// Fix slashes in the list of script names for 'shellslash'.</a>
<a name="ln3090">void scriptnames_slash_adjust(void)</a>
<a name="ln3091">{</a>
<a name="ln3092">  for (int i = 1; i &lt;= script_items.ga_len; i++) {</a>
<a name="ln3093">    if (SCRIPT_ITEM(i).sn_name != NULL) {</a>
<a name="ln3094">      slash_adjust(SCRIPT_ITEM(i).sn_name);</a>
<a name="ln3095">    }</a>
<a name="ln3096">  }</a>
<a name="ln3097">}</a>
<a name="ln3098"> </a>
<a name="ln3099"># endif</a>
<a name="ln3100"> </a>
<a name="ln3101">/// Get a pointer to a script name.  Used for &quot;:verbose set&quot;.</a>
<a name="ln3102">/// Message appended to &quot;Last set from &quot;</a>
<a name="ln3103">char_u *get_scriptname(LastSet last_set, bool *should_free)</a>
<a name="ln3104">{</a>
<a name="ln3105">  *should_free = false;</a>
<a name="ln3106"> </a>
<a name="ln3107">  switch (last_set.script_ctx.sc_sid) {</a>
<a name="ln3108">    case SID_MODELINE:</a>
<a name="ln3109">      return (char_u *)_(&quot;modeline&quot;);</a>
<a name="ln3110">    case SID_CMDARG:</a>
<a name="ln3111">      return (char_u *)_(&quot;--cmd argument&quot;);</a>
<a name="ln3112">    case SID_CARG:</a>
<a name="ln3113">      return (char_u *)_(&quot;-c argument&quot;);</a>
<a name="ln3114">    case SID_ENV:</a>
<a name="ln3115">      return (char_u *)_(&quot;environment variable&quot;);</a>
<a name="ln3116">    case SID_ERROR:</a>
<a name="ln3117">      return (char_u *)_(&quot;error handler&quot;);</a>
<a name="ln3118">    case SID_WINLAYOUT:</a>
<a name="ln3119">      return (char_u *)_(&quot;changed window size&quot;);</a>
<a name="ln3120">    case SID_LUA:</a>
<a name="ln3121">      return (char_u *)_(&quot;Lua&quot;);</a>
<a name="ln3122">    case SID_API_CLIENT:</a>
<a name="ln3123">      vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln3124">                   _(&quot;API client (channel id %&quot; PRIu64 &quot;)&quot;),</a>
<a name="ln3125">                   last_set.channel_id);</a>
<a name="ln3126">      return IObuff;</a>
<a name="ln3127">    case SID_STR:</a>
<a name="ln3128">      return (char_u *)_(&quot;anonymous :source&quot;);</a>
<a name="ln3129">    default:</a>
<a name="ln3130">      *should_free = true;</a>
<a name="ln3131">      return home_replace_save(NULL,</a>
<a name="ln3132">                               SCRIPT_ITEM(last_set.script_ctx.sc_sid).sn_name);</a>
<a name="ln3133">  }</a>
<a name="ln3134">}</a>
<a name="ln3135"> </a>
<a name="ln3136"># if defined(EXITFREE)</a>
<a name="ln3137">void free_scriptnames(void)</a>
<a name="ln3138">{</a>
<a name="ln3139">  profile_reset();</a>
<a name="ln3140"> </a>
<a name="ln3141"># define FREE_SCRIPTNAME(item) xfree((item)-&gt;sn_name)</a>
<a name="ln3142">  GA_DEEP_CLEAR(&amp;script_items, scriptitem_T, FREE_SCRIPTNAME);</a>
<a name="ln3143">}</a>
<a name="ln3144"># endif</a>
<a name="ln3145"> </a>
<a name="ln3146">linenr_T get_sourced_lnum(LineGetter fgetline, void *cookie)</a>
<a name="ln3147">{</a>
<a name="ln3148">    return fgetline == getsourceline</a>
<a name="ln3149">        ? ((struct source_cookie *)cookie)-&gt;sourcing_lnum</a>
<a name="ln3150">        : sourcing_lnum;</a>
<a name="ln3151">}</a>
<a name="ln3152"> </a>
<a name="ln3153"> </a>
<a name="ln3154">/// Get one full line from a sourced file.</a>
<a name="ln3155">/// Called by do_cmdline() when it's called from do_source().</a>
<a name="ln3156">///</a>
<a name="ln3157">/// @return pointer to the line in allocated memory, or NULL for end-of-file or</a>
<a name="ln3158">///         some error.</a>
<a name="ln3159">char_u *getsourceline(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln3160">{</a>
<a name="ln3161">  struct source_cookie *sp = (struct source_cookie *)cookie;</a>
<a name="ln3162">  char_u *line;</a>
<a name="ln3163">  char_u *p;</a>
<a name="ln3164"> </a>
<a name="ln3165">  // If breakpoints have been added/deleted need to check for it.</a>
<a name="ln3166">  if (sp-&gt;dbg_tick &lt; debug_tick) {</a>
<a name="ln3167">    sp-&gt;breakpoint = dbg_find_breakpoint(true, sp-&gt;fname, sourcing_lnum);</a>
<a name="ln3168">    sp-&gt;dbg_tick = debug_tick;</a>
<a name="ln3169">  }</a>
<a name="ln3170">  if (do_profiling == PROF_YES) {</a>
<a name="ln3171">    script_line_end();</a>
<a name="ln3172">  }</a>
<a name="ln3173">  // Set the current sourcing line number.</a>
<a name="ln3174">  sourcing_lnum = sp-&gt;sourcing_lnum + 1;</a>
<a name="ln3175">  // Get current line.  If there is a read-ahead line, use it, otherwise get</a>
<a name="ln3176">  // one now.</a>
<a name="ln3177">  if (sp-&gt;finished) {</a>
<a name="ln3178">    line = NULL;</a>
<a name="ln3179">  } else if (sp-&gt;nextline == NULL) {</a>
<a name="ln3180">    line = get_one_sourceline(sp);</a>
<a name="ln3181">  } else {</a>
<a name="ln3182">    line = sp-&gt;nextline;</a>
<a name="ln3183">    sp-&gt;nextline = NULL;</a>
<a name="ln3184">    sp-&gt;sourcing_lnum++;</a>
<a name="ln3185">  }</a>
<a name="ln3186">  if (line != NULL &amp;&amp; do_profiling == PROF_YES) {</a>
<a name="ln3187">    script_line_start();</a>
<a name="ln3188">  }</a>
<a name="ln3189"> </a>
<a name="ln3190">  // Only concatenate lines starting with a \ when 'cpoptions' doesn't</a>
<a name="ln3191">  // contain the 'C' flag.</a>
<a name="ln3192">  if (line != NULL &amp;&amp; do_concat &amp;&amp; (vim_strchr(p_cpo, CPO_CONCAT) == NULL)) {</a>
<a name="ln3193">    // compensate for the one line read-ahead</a>
<a name="ln3194">    sp-&gt;sourcing_lnum--;</a>
<a name="ln3195"> </a>
<a name="ln3196">    // Get the next line and concatenate it when it starts with a</a>
<a name="ln3197">    // backslash. We always need to read the next line, keep it in</a>
<a name="ln3198">    // sp-&gt;nextline.</a>
<a name="ln3199">    // Also check for a comment in between continuation lines: &quot;\ .</a>
<a name="ln3200">    sp-&gt;nextline = get_one_sourceline(sp);</a>
<a name="ln3201">    if (sp-&gt;nextline != NULL</a>
<a name="ln3202">        &amp;&amp; (*(p = skipwhite(sp-&gt;nextline)) == '\\'</a>
<a name="ln3203">            || (p[0] == '&quot;' &amp;&amp; p[1] == '\\' &amp;&amp; p[2] == ' '))) {</a>
<a name="ln3204">      garray_T ga;</a>
<a name="ln3205"> </a>
<a name="ln3206">      ga_init(&amp;ga, (int)sizeof(char_u), 400);</a>
<a name="ln3207">      ga_concat(&amp;ga, line);</a>
<a name="ln3208">      if (*p == '\\') {</a>
<a name="ln3209">        ga_concat(&amp;ga, p + 1);</a>
<a name="ln3210">      }</a>
<a name="ln3211">      for (;; ) {</a>
<a name="ln3212">        xfree(sp-&gt;nextline);</a>
<a name="ln3213">        sp-&gt;nextline = get_one_sourceline(sp);</a>
<a name="ln3214">        if (sp-&gt;nextline == NULL) {</a>
<a name="ln3215">          break;</a>
<a name="ln3216">        }</a>
<a name="ln3217">        p = skipwhite(sp-&gt;nextline);</a>
<a name="ln3218">        if (*p == '\\') {</a>
<a name="ln3219">          // Adjust the growsize to the current length to speed up</a>
<a name="ln3220">          // concatenating many lines.</a>
<a name="ln3221">          if (ga.ga_len &gt; 400) {</a>
<a name="ln3222">            ga_set_growsize(&amp;ga, (ga.ga_len &gt; 8000) ? 8000 : ga.ga_len);</a>
<a name="ln3223">          }</a>
<a name="ln3224">          ga_concat(&amp;ga, p + 1);</a>
<a name="ln3225">        } else if (p[0] != '&quot;' || p[1] != '\\' || p[2] != ' ') {</a>
<a name="ln3226">          break;</a>
<a name="ln3227">        }</a>
<a name="ln3228">      }</a>
<a name="ln3229">      ga_append(&amp;ga, NUL);</a>
<a name="ln3230">      xfree(line);</a>
<a name="ln3231">      line = ga.ga_data;</a>
<a name="ln3232">    }</a>
<a name="ln3233">  }</a>
<a name="ln3234"> </a>
<a name="ln3235">  if (line != NULL &amp;&amp; sp-&gt;conv.vc_type != CONV_NONE) {</a>
<a name="ln3236">    char_u  *s;</a>
<a name="ln3237"> </a>
<a name="ln3238">    // Convert the encoding of the script line.</a>
<a name="ln3239">    s = string_convert(&amp;sp-&gt;conv, line, NULL);</a>
<a name="ln3240">    if (s != NULL) {</a>
<a name="ln3241">      xfree(line);</a>
<a name="ln3242">      line = s;</a>
<a name="ln3243">    }</a>
<a name="ln3244">  }</a>
<a name="ln3245"> </a>
<a name="ln3246">  // Did we encounter a breakpoint?</a>
<a name="ln3247">  if (sp-&gt;breakpoint != 0 &amp;&amp; sp-&gt;breakpoint &lt;= sourcing_lnum) {</a>
<a name="ln3248">    dbg_breakpoint(sp-&gt;fname, sourcing_lnum);</a>
<a name="ln3249">    // Find next breakpoint.</a>
<a name="ln3250">    sp-&gt;breakpoint = dbg_find_breakpoint(true, sp-&gt;fname, sourcing_lnum);</a>
<a name="ln3251">    sp-&gt;dbg_tick = debug_tick;</a>
<a name="ln3252">  }</a>
<a name="ln3253"> </a>
<a name="ln3254">  return line;</a>
<a name="ln3255">}</a>
<a name="ln3256"> </a>
<a name="ln3257">static char_u *get_one_sourceline(struct source_cookie *sp)</a>
<a name="ln3258">{</a>
<a name="ln3259">  garray_T ga;</a>
<a name="ln3260">  int len;</a>
<a name="ln3261">  int c;</a>
<a name="ln3262">  char_u              *buf;</a>
<a name="ln3263">#ifdef USE_CRNL</a>
<a name="ln3264">  int has_cr;                           // CR-LF found</a>
<a name="ln3265">#endif</a>
<a name="ln3266">  bool have_read = false;</a>
<a name="ln3267"> </a>
<a name="ln3268">  // use a growarray to store the sourced line</a>
<a name="ln3269">  ga_init(&amp;ga, 1, 250);</a>
<a name="ln3270"> </a>
<a name="ln3271">  // Loop until there is a finished line (or end-of-file).</a>
<a name="ln3272">  sp-&gt;sourcing_lnum++;</a>
<a name="ln3273">  for (;; ) {</a>
<a name="ln3274">    // make room to read at least 120 (more) characters</a>
<a name="ln3275">    ga_grow(&amp;ga, 120);</a>
<a name="ln3276">    buf = (char_u *)ga.ga_data;</a>
<a name="ln3277"> </a>
<a name="ln3278">retry:</a>
<a name="ln3279">    errno = 0;</a>
<a name="ln3280">    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,</a>
<a name="ln3281">              sp-&gt;fp) == NULL) {</a>
<a name="ln3282">      if (errno == EINTR) {</a>
<a name="ln3283">        goto retry;</a>
<a name="ln3284">      }</a>
<a name="ln3285"> </a>
<a name="ln3286">      break;</a>
<a name="ln3287">    }</a>
<a name="ln3288">    len = ga.ga_len + (int)STRLEN(buf + ga.ga_len);</a>
<a name="ln3289">#ifdef USE_CRNL</a>
<a name="ln3290">    // Ignore a trailing CTRL-Z, when in Dos mode. Only recognize the</a>
<a name="ln3291">    // CTRL-Z by its own, or after a NL.</a>
<a name="ln3292">    if ((len == 1 || (len &gt;= 2 &amp;&amp; buf[len - 2] == '\n'))</a>
<a name="ln3293">        &amp;&amp; sp-&gt;fileformat == EOL_DOS</a>
<a name="ln3294">        &amp;&amp; buf[len - 1] == Ctrl_Z) {</a>
<a name="ln3295">      buf[len - 1] = NUL;</a>
<a name="ln3296">      break;</a>
<a name="ln3297">    }</a>
<a name="ln3298">#endif</a>
<a name="ln3299"> </a>
<a name="ln3300">    have_read = true;</a>
<a name="ln3301">    ga.ga_len = len;</a>
<a name="ln3302"> </a>
<a name="ln3303">    // If the line was longer than the buffer, read more.</a>
<a name="ln3304">    if (ga.ga_maxlen - ga.ga_len == 1 &amp;&amp; buf[len - 1] != '\n') {</a>
<a name="ln3305">      continue;</a>
<a name="ln3306">    }</a>
<a name="ln3307"> </a>
<a name="ln3308">    if (len &gt;= 1 &amp;&amp; buf[len - 1] == '\n') {     // remove trailing NL</a>
<a name="ln3309">#ifdef USE_CRNL</a>
<a name="ln3310">      has_cr = (len &gt;= 2 &amp;&amp; buf[len - 2] == '\r');</a>
<a name="ln3311">      if (sp-&gt;fileformat == EOL_UNKNOWN) {</a>
<a name="ln3312">        if (has_cr) {</a>
<a name="ln3313">          sp-&gt;fileformat = EOL_DOS;</a>
<a name="ln3314">        } else {</a>
<a name="ln3315">          sp-&gt;fileformat = EOL_UNIX;</a>
<a name="ln3316">        }</a>
<a name="ln3317">      }</a>
<a name="ln3318"> </a>
<a name="ln3319">      if (sp-&gt;fileformat == EOL_DOS) {</a>
<a name="ln3320">        if (has_cr) {               // replace trailing CR</a>
<a name="ln3321">          buf[len - 2] = '\n';</a>
<a name="ln3322">          len--;</a>
<a name="ln3323">          ga.ga_len--;</a>
<a name="ln3324">        } else {          // lines like &quot;:map xx yy^M&quot; will have failed</a>
<a name="ln3325">          if (!sp-&gt;error) {</a>
<a name="ln3326">            msg_source(HL_ATTR(HLF_W));</a>
<a name="ln3327">            EMSG(_(&quot;W15: Warning: Wrong line separator, ^M may be missing&quot;));</a>
<a name="ln3328">          }</a>
<a name="ln3329">          sp-&gt;error = true;</a>
<a name="ln3330">          sp-&gt;fileformat = EOL_UNIX;</a>
<a name="ln3331">        }</a>
<a name="ln3332">      }</a>
<a name="ln3333">#endif</a>
<a name="ln3334">      // The '\n' is escaped if there is an odd number of ^V's just</a>
<a name="ln3335">      // before it, first set &quot;c&quot; just before the 'V's and then check</a>
<a name="ln3336">      // len&amp;c parities (is faster than ((len-c)%2 == 0)) -- Acevedo</a>
<a name="ln3337">      for (c = len - 2; c &gt;= 0 &amp;&amp; buf[c] == Ctrl_V; c--) {}</a>
<a name="ln3338">      if ((len &amp; 1) != (c &amp; 1)) {       // escaped NL, read more</a>
<a name="ln3339">        sp-&gt;sourcing_lnum++;</a>
<a name="ln3340">        continue;</a>
<a name="ln3341">      }</a>
<a name="ln3342"> </a>
<a name="ln3343">      buf[len - 1] = NUL;               // remove the NL</a>
<a name="ln3344">    }</a>
<a name="ln3345"> </a>
<a name="ln3346">    // Check for ^C here now and then, so recursive :so can be broken.</a>
<a name="ln3347">    line_breakcheck();</a>
<a name="ln3348">    break;</a>
<a name="ln3349">  }</a>
<a name="ln3350"> </a>
<a name="ln3351">  if (have_read) {</a>
<a name="ln3352">    return (char_u *)ga.ga_data;</a>
<a name="ln3353">  }</a>
<a name="ln3354"> </a>
<a name="ln3355">  xfree(ga.ga_data);</a>
<a name="ln3356">  return NULL;</a>
<a name="ln3357">}</a>
<a name="ln3358"> </a>
<a name="ln3359">/// Called when starting to read a script line.</a>
<a name="ln3360">/// &quot;sourcing_lnum&quot; must be correct!</a>
<a name="ln3361">/// When skipping lines it may not actually be executed, but we won't find out</a>
<a name="ln3362">/// until later and we need to store the time now.</a>
<a name="ln3363">void script_line_start(void)</a>
<a name="ln3364">{</a>
<a name="ln3365">  scriptitem_T    *si;</a>
<a name="ln3366">  sn_prl_T        *pp;</a>
<a name="ln3367"> </a>
<a name="ln3368">  if (current_sctx.sc_sid &lt;= 0 || current_sctx.sc_sid &gt; script_items.ga_len) {</a>
<a name="ln3369">    return;</a>
<a name="ln3370">  }</a>
<a name="ln3371">  si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln3372">  if (si-&gt;sn_prof_on &amp;&amp; sourcing_lnum &gt;= 1) {</a>
<a name="ln3373">    // Grow the array before starting the timer, so that the time spent</a>
<a name="ln3374">    // here isn't counted.</a>
<a name="ln3375">    (void)ga_grow(&amp;si-&gt;sn_prl_ga,</a>
<a name="ln3376">                  (int)(sourcing_lnum - si-&gt;sn_prl_ga.ga_len));</a>
<a name="ln3377">    si-&gt;sn_prl_idx = sourcing_lnum - 1;</a>
<a name="ln3378">    while (si-&gt;sn_prl_ga.ga_len &lt;= si-&gt;sn_prl_idx</a>
<a name="ln3379">           &amp;&amp; si-&gt;sn_prl_ga.ga_len &lt; si-&gt;sn_prl_ga.ga_maxlen) {</a>
<a name="ln3380">      // Zero counters for a line that was not used before.</a>
<a name="ln3381">      pp = &amp;PRL_ITEM(si, si-&gt;sn_prl_ga.ga_len);</a>
<a name="ln3382">      pp-&gt;snp_count = 0;</a>
<a name="ln3383">      pp-&gt;sn_prl_total = profile_zero();</a>
<a name="ln3384">      pp-&gt;sn_prl_self = profile_zero();</a>
<a name="ln3385">      si-&gt;sn_prl_ga.ga_len++;</a>
<a name="ln3386">    }</a>
<a name="ln3387">    si-&gt;sn_prl_execed = false;</a>
<a name="ln3388">    si-&gt;sn_prl_start = profile_start();</a>
<a name="ln3389">    si-&gt;sn_prl_children = profile_zero();</a>
<a name="ln3390">    si-&gt;sn_prl_wait = profile_get_wait();</a>
<a name="ln3391">  }</a>
<a name="ln3392">}</a>
<a name="ln3393"> </a>
<a name="ln3394">/// Called when actually executing a function line.</a>
<a name="ln3395">void script_line_exec(void)</a>
<a name="ln3396">{</a>
<a name="ln3397">  scriptitem_T    *si;</a>
<a name="ln3398"> </a>
<a name="ln3399">  if (current_sctx.sc_sid &lt;= 0 || current_sctx.sc_sid &gt; script_items.ga_len) {</a>
<a name="ln3400">    return;</a>
<a name="ln3401">  }</a>
<a name="ln3402">  si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln3403">  if (si-&gt;sn_prof_on &amp;&amp; si-&gt;sn_prl_idx &gt;= 0) {</a>
<a name="ln3404">    si-&gt;sn_prl_execed = true;</a>
<a name="ln3405">  }</a>
<a name="ln3406">}</a>
<a name="ln3407"> </a>
<a name="ln3408">/// Called when done with a function line.</a>
<a name="ln3409">void script_line_end(void)</a>
<a name="ln3410">{</a>
<a name="ln3411">  scriptitem_T    *si;</a>
<a name="ln3412">  sn_prl_T        *pp;</a>
<a name="ln3413"> </a>
<a name="ln3414">  if (current_sctx.sc_sid &lt;= 0 || current_sctx.sc_sid &gt; script_items.ga_len) {</a>
<a name="ln3415">    return;</a>
<a name="ln3416">  }</a>
<a name="ln3417">  si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln3418">  if (si-&gt;sn_prof_on &amp;&amp; si-&gt;sn_prl_idx &gt;= 0</a>
<a name="ln3419">      &amp;&amp; si-&gt;sn_prl_idx &lt; si-&gt;sn_prl_ga.ga_len) {</a>
<a name="ln3420">    if (si-&gt;sn_prl_execed) {</a>
<a name="ln3421">      pp = &amp;PRL_ITEM(si, si-&gt;sn_prl_idx);</a>
<a name="ln3422">      pp-&gt;snp_count++;</a>
<a name="ln3423">      si-&gt;sn_prl_start = profile_end(si-&gt;sn_prl_start);</a>
<a name="ln3424">      si-&gt;sn_prl_start = profile_sub_wait(si-&gt;sn_prl_wait, si-&gt;sn_prl_start);</a>
<a name="ln3425">      pp-&gt;sn_prl_total = profile_add(pp-&gt;sn_prl_total, si-&gt;sn_prl_start);</a>
<a name="ln3426">      pp-&gt;sn_prl_self = profile_self(pp-&gt;sn_prl_self, si-&gt;sn_prl_start,</a>
<a name="ln3427">                                     si-&gt;sn_prl_children);</a>
<a name="ln3428">    }</a>
<a name="ln3429">    si-&gt;sn_prl_idx = -1;</a>
<a name="ln3430">  }</a>
<a name="ln3431">}</a>
<a name="ln3432"> </a>
<a name="ln3433">/// &quot;:scriptencoding&quot;: Set encoding conversion for a sourced script.</a>
<a name="ln3434">/// Without the multi-byte feature it's simply ignored.</a>
<a name="ln3435">void ex_scriptencoding(exarg_T *eap)</a>
<a name="ln3436">{</a>
<a name="ln3437">  struct source_cookie        *sp;</a>
<a name="ln3438">  char_u                      *name;</a>
<a name="ln3439"> </a>
<a name="ln3440">  if (!getline_equal(eap-&gt;getline, eap-&gt;cookie, getsourceline)) {</a>
<a name="ln3441">    EMSG(_(&quot;E167: :scriptencoding used outside of a sourced file&quot;));</a>
<a name="ln3442">    return;</a>
<a name="ln3443">  }</a>
<a name="ln3444"> </a>
<a name="ln3445">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln3446">    name = enc_canonize(eap-&gt;arg);</a>
<a name="ln3447">  } else {</a>
<a name="ln3448">    name = eap-&gt;arg;</a>
<a name="ln3449">  }</a>
<a name="ln3450"> </a>
<a name="ln3451">  // Setup for conversion from the specified encoding to 'encoding'.</a>
<a name="ln3452">  sp = (struct source_cookie *)getline_cookie(eap-&gt;getline, eap-&gt;cookie);</a>
<a name="ln3453">  convert_setup(&amp;sp-&gt;conv, name, p_enc);</a>
<a name="ln3454"> </a>
<a name="ln3455">  if (name != eap-&gt;arg) {</a>
<a name="ln3456">    xfree(name);</a>
<a name="ln3457">  }</a>
<a name="ln3458">}</a>
<a name="ln3459"> </a>
<a name="ln3460">/// &quot;:finish&quot;: Mark a sourced file as finished.</a>
<a name="ln3461">void ex_finish(exarg_T *eap)</a>
<a name="ln3462">{</a>
<a name="ln3463">  if (getline_equal(eap-&gt;getline, eap-&gt;cookie, getsourceline)) {</a>
<a name="ln3464">    do_finish(eap, false);</a>
<a name="ln3465">  } else {</a>
<a name="ln3466">    EMSG(_(&quot;E168: :finish used outside of a sourced file&quot;));</a>
<a name="ln3467">  }</a>
<a name="ln3468">}</a>
<a name="ln3469"> </a>
<a name="ln3470">/// Mark a sourced file as finished.  Possibly makes the &quot;:finish&quot; pending.</a>
<a name="ln3471">/// Also called for a pending finish at the &quot;:endtry&quot; or after returning from</a>
<a name="ln3472">/// an extra do_cmdline().  &quot;reanimate&quot; is used in the latter case.</a>
<a name="ln3473">void do_finish(exarg_T *eap, int reanimate)</a>
<a name="ln3474">{</a>
<a name="ln3475">  int idx;</a>
<a name="ln3476"> </a>
<a name="ln3477">  if (reanimate) {</a>
<a name="ln3478">    ((struct source_cookie *)getline_cookie(eap-&gt;getline,</a>
<a name="ln3479">                                            eap-&gt;cookie))-&gt;finished = false;</a>
<a name="ln3480">  }</a>
<a name="ln3481"> </a>
<a name="ln3482">  // Cleanup (and inactivate) conditionals, but stop when a try conditional</a>
<a name="ln3483">  // not in its finally clause (which then is to be executed next) is found.</a>
<a name="ln3484">  // In this case, make the &quot;:finish&quot; pending for execution at the &quot;:endtry&quot;.</a>
<a name="ln3485">  // Otherwise, finish normally.</a>
<a name="ln3486">  idx = cleanup_conditionals(eap-&gt;cstack, 0, true);</a>
<a name="ln3487">  if (idx &gt;= 0) {</a>
<a name="ln3488">    eap-&gt;cstack-&gt;cs_pending[idx] = CSTP_FINISH;</a>
<a name="ln3489">    report_make_pending(CSTP_FINISH, NULL);</a>
<a name="ln3490">  } else {</a>
<a name="ln3491">    ((struct source_cookie *)getline_cookie(eap-&gt;getline,</a>
<a name="ln3492">                                            eap-&gt;cookie))-&gt;finished = true;</a>
<a name="ln3493">  }</a>
<a name="ln3494">}</a>
<a name="ln3495"> </a>
<a name="ln3496"> </a>
<a name="ln3497">/// Return true when a sourced file had the &quot;:finish&quot; command: Don't give error</a>
<a name="ln3498">/// message for missing &quot;:endif&quot;.</a>
<a name="ln3499">/// Return false when not sourcing a file.</a>
<a name="ln3500">bool source_finished(LineGetter fgetline, void *cookie)</a>
<a name="ln3501">{</a>
<a name="ln3502">  return getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln3503">         &amp;&amp; ((struct source_cookie *)getline_cookie(</a>
<a name="ln3504">             fgetline, cookie))-&gt;finished;</a>
<a name="ln3505">}</a>
<a name="ln3506"> </a>
<a name="ln3507">/// &quot;:checktime [buffer]&quot;</a>
<a name="ln3508">void ex_checktime(exarg_T *eap)</a>
<a name="ln3509">{</a>
<a name="ln3510">  buf_T       *buf;</a>
<a name="ln3511">  int save_no_check_timestamps = no_check_timestamps;</a>
<a name="ln3512"> </a>
<a name="ln3513">  no_check_timestamps = 0;</a>
<a name="ln3514">  if (eap-&gt;addr_count == 0) {    // default is all buffers</a>
<a name="ln3515">    check_timestamps(false);</a>
<a name="ln3516">  } else {</a>
<a name="ln3517">    buf = buflist_findnr((int)eap-&gt;line2);</a>
<a name="ln3518">    if (buf != NULL) {           // cannot happen?</a>
<a name="ln3519">      (void)buf_check_timestamp(buf);</a>
<a name="ln3520">    }</a>
<a name="ln3521">  }</a>
<a name="ln3522">  no_check_timestamps = save_no_check_timestamps;</a>
<a name="ln3523">}</a>
<a name="ln3524"> </a>
<a name="ln3525">#if defined(HAVE_LOCALE_H)</a>
<a name="ln3526"># define HAVE_GET_LOCALE_VAL</a>
<a name="ln3527"> </a>
<a name="ln3528">static char *get_locale_val(int what)</a>
<a name="ln3529">{</a>
<a name="ln3530">  // Obtain the locale value from the libraries.</a>
<a name="ln3531">  char *loc = setlocale(what, NULL);</a>
<a name="ln3532"> </a>
<a name="ln3533">  return loc;</a>
<a name="ln3534">}</a>
<a name="ln3535">#endif</a>
<a name="ln3536"> </a>
<a name="ln3537">// Return true when &quot;lang&quot; starts with a valid language name.</a>
<a name="ln3538">// Rejects NULL, empty string, &quot;C&quot;, &quot;C.UTF-8&quot; and others.</a>
<a name="ln3539">static bool is_valid_mess_lang(char *lang)</a>
<a name="ln3540">{</a>
<a name="ln3541">  return lang != NULL &amp;&amp; ASCII_ISALPHA(lang[0]) &amp;&amp; ASCII_ISALPHA(lang[1]);</a>
<a name="ln3542">}</a>
<a name="ln3543"> </a>
<a name="ln3544">/// Obtain the current messages language.  Used to set the default for</a>
<a name="ln3545">/// 'helplang'.  May return NULL or an empty string.</a>
<a name="ln3546">char *get_mess_lang(void)</a>
<a name="ln3547">{</a>
<a name="ln3548">  char *p;</a>
<a name="ln3549"> </a>
<a name="ln3550"># ifdef HAVE_GET_LOCALE_VAL</a>
<a name="ln3551">#  if defined(LC_MESSAGES)</a>
<a name="ln3552">  p = get_locale_val(LC_MESSAGES);</a>
<a name="ln3553">#  else</a>
<a name="ln3554">  // This is necessary for Win32, where LC_MESSAGES is not defined and $LANG</a>
<a name="ln3555">  // may be set to the LCID number.  LC_COLLATE is the best guess, LC_TIME</a>
<a name="ln3556">  // and LC_MONETARY may be set differently for a Japanese working in the</a>
<a name="ln3557">  // US.</a>
<a name="ln3558">  p = get_locale_val(LC_COLLATE);</a>
<a name="ln3559">#  endif</a>
<a name="ln3560"># else</a>
<a name="ln3561">  p = os_getenv(&quot;LC_ALL&quot;);</a>
<a name="ln3562">  if (!is_valid_mess_lang(p)) {</a>
<a name="ln3563">    p = os_getenv(&quot;LC_MESSAGES&quot;);</a>
<a name="ln3564">    if (!is_valid_mess_lang(p)) {</a>
<a name="ln3565">      p = os_getenv(&quot;LANG&quot;);</a>
<a name="ln3566">    }</a>
<a name="ln3567">  }</a>
<a name="ln3568"># endif</a>
<a name="ln3569">  return is_valid_mess_lang(p) ? p : NULL;</a>
<a name="ln3570">}</a>
<a name="ln3571"> </a>
<a name="ln3572">// Complicated #if; matches with where get_mess_env() is used below.</a>
<a name="ln3573">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3574">/// Get the language used for messages from the environment.</a>
<a name="ln3575">static char_u *get_mess_env(void)</a>
<a name="ln3576">{</a>
<a name="ln3577">  char_u      *p;</a>
<a name="ln3578"> </a>
<a name="ln3579">  p = (char_u *)os_getenv(&quot;LC_ALL&quot;);</a>
<a name="ln3580">  if (p == NULL) {</a>
<a name="ln3581">    p = (char_u *)os_getenv(&quot;LC_MESSAGES&quot;);</a>
<a name="ln3582">    if (p == NULL) {</a>
<a name="ln3583">      p = (char_u *)os_getenv(&quot;LANG&quot;);</a>
<a name="ln3584">      if (p != NULL &amp;&amp; ascii_isdigit(*p)) {</a>
<a name="ln3585">        p = NULL;                       // ignore something like &quot;1043&quot;</a>
<a name="ln3586">      }</a>
<a name="ln3587"># ifdef HAVE_GET_LOCALE_VAL</a>
<a name="ln3588">      if (p == NULL) {</a>
<a name="ln3589">        p = (char_u *)get_locale_val(LC_CTYPE);</a>
<a name="ln3590">      }</a>
<a name="ln3591"># endif</a>
<a name="ln3592">    }</a>
<a name="ln3593">  }</a>
<a name="ln3594">  return p;</a>
<a name="ln3595">}</a>
<a name="ln3596"> </a>
<a name="ln3597">#endif</a>
<a name="ln3598"> </a>
<a name="ln3599"> </a>
<a name="ln3600">/// Set the &quot;v:lang&quot; variable according to the current locale setting.</a>
<a name="ln3601">/// Also do &quot;v:lc_time&quot;and &quot;v:ctype&quot;.</a>
<a name="ln3602">void set_lang_var(void)</a>
<a name="ln3603">{</a>
<a name="ln3604">  const char *loc;</a>
<a name="ln3605"> </a>
<a name="ln3606"># ifdef HAVE_GET_LOCALE_VAL</a>
<a name="ln3607">  loc = get_locale_val(LC_CTYPE);</a>
<a name="ln3608"># else</a>
<a name="ln3609">  // setlocale() not supported: use the default value</a>
<a name="ln3610">  loc = &quot;C&quot;;</a>
<a name="ln3611"># endif</a>
<a name="ln3612">  set_vim_var_string(VV_CTYPE, loc, -1);</a>
<a name="ln3613"> </a>
<a name="ln3614">  // When LC_MESSAGES isn't defined use the value from $LC_MESSAGES, fall</a>
<a name="ln3615">  // back to LC_CTYPE if it's empty.</a>
<a name="ln3616"># ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3617">  loc = (char *)get_mess_env();</a>
<a name="ln3618"># elif defined(LC_MESSAGES)</a>
<a name="ln3619">  loc = get_locale_val(LC_MESSAGES);</a>
<a name="ln3620"># else</a>
<a name="ln3621">  // In Windows LC_MESSAGES is not defined fallback to LC_CTYPE</a>
<a name="ln3622">  loc = get_locale_val(LC_CTYPE);</a>
<a name="ln3623"># endif</a>
<a name="ln3624">  set_vim_var_string(VV_LANG, loc, -1);</a>
<a name="ln3625"> </a>
<a name="ln3626"># ifdef HAVE_GET_LOCALE_VAL</a>
<a name="ln3627">  loc = get_locale_val(LC_TIME);</a>
<a name="ln3628"># endif</a>
<a name="ln3629">  set_vim_var_string(VV_LC_TIME, loc, -1);</a>
<a name="ln3630">}</a>
<a name="ln3631"> </a>
<a name="ln3632">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3633">///</a>
<a name="ln3634">/// &quot;:language&quot;:  Set the language (locale).</a>
<a name="ln3635">///</a>
<a name="ln3636">/// @param eap</a>
<a name="ln3637">///</a>
<a name="ln3638">void ex_language(exarg_T *eap)</a>
<a name="ln3639">{</a>
<a name="ln3640">  char        *loc;</a>
<a name="ln3641">  char_u      *p;</a>
<a name="ln3642">  char_u      *name;</a>
<a name="ln3643">  int what = LC_ALL;</a>
<a name="ln3644">  char        *whatstr = &quot;&quot;;</a>
<a name="ln3645">#ifdef LC_MESSAGES</a>
<a name="ln3646"># define VIM_LC_MESSAGES LC_MESSAGES</a>
<a name="ln3647">#else</a>
<a name="ln3648"># define VIM_LC_MESSAGES 6789</a>
<a name="ln3649">#endif</a>
<a name="ln3650"> </a>
<a name="ln3651">  name = eap-&gt;arg;</a>
<a name="ln3652"> </a>
<a name="ln3653">  // Check for &quot;messages {name}&quot;, &quot;ctype {name}&quot; or &quot;time {name}&quot; argument.</a>
<a name="ln3654">  // Allow abbreviation, but require at least 3 characters to avoid</a>
<a name="ln3655">  // confusion with a two letter language name &quot;me&quot; or &quot;ct&quot;.</a>
<a name="ln3656">  p = skiptowhite(eap-&gt;arg);</a>
<a name="ln3657">  if ((*p == NUL || ascii_iswhite(*p)) &amp;&amp; p - eap-&gt;arg &gt;= 3) {</a>
<a name="ln3658">    if (STRNICMP(eap-&gt;arg, &quot;messages&quot;, p - eap-&gt;arg) == 0) {</a>
<a name="ln3659">      what = VIM_LC_MESSAGES;</a>
<a name="ln3660">      name = skipwhite(p);</a>
<a name="ln3661">      whatstr = &quot;messages &quot;;</a>
<a name="ln3662">    } else if (STRNICMP(eap-&gt;arg, &quot;ctype&quot;, p - eap-&gt;arg) == 0) {</a>
<a name="ln3663">      what = LC_CTYPE;</a>
<a name="ln3664">      name = skipwhite(p);</a>
<a name="ln3665">      whatstr = &quot;ctype &quot;;</a>
<a name="ln3666">    } else if (STRNICMP(eap-&gt;arg, &quot;time&quot;, p - eap-&gt;arg) == 0) {</a>
<a name="ln3667">      what = LC_TIME;</a>
<a name="ln3668">      name = skipwhite(p);</a>
<a name="ln3669">      whatstr = &quot;time &quot;;</a>
<a name="ln3670">    }</a>
<a name="ln3671">  }</a>
<a name="ln3672"> </a>
<a name="ln3673">  if (*name == NUL) {</a>
<a name="ln3674">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3675">    if (what == VIM_LC_MESSAGES) {</a>
<a name="ln3676">      p = get_mess_env();</a>
<a name="ln3677">    } else {</a>
<a name="ln3678">#endif</a>
<a name="ln3679">      p = (char_u *)setlocale(what, NULL);</a>
<a name="ln3680">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3681">    }</a>
<a name="ln3682">#endif</a>
<a name="ln3683">    if (p == NULL || *p == NUL) {</a>
<a name="ln3684">      p = (char_u *)&quot;Unknown&quot;;</a>
<a name="ln3685">    }</a>
<a name="ln3686">    smsg(_(&quot;Current %slanguage: \&quot;%s\&quot;&quot;), whatstr, p);</a>
<a name="ln3687">  } else {</a>
<a name="ln3688">#ifndef LC_MESSAGES</a>
<a name="ln3689">    if (what == VIM_LC_MESSAGES) {</a>
<a name="ln3690">      loc = &quot;&quot;;</a>
<a name="ln3691">    } else {</a>
<a name="ln3692">#endif</a>
<a name="ln3693">      loc = setlocale(what, (char *)name);</a>
<a name="ln3694">#ifdef LC_NUMERIC</a>
<a name="ln3695">      // Make sure strtod() uses a decimal point, not a comma.</a>
<a name="ln3696">      setlocale(LC_NUMERIC, &quot;C&quot;);</a>
<a name="ln3697">#endif</a>
<a name="ln3698">#ifndef LC_MESSAGES</a>
<a name="ln3699">    }</a>
<a name="ln3700">#endif</a>
<a name="ln3701">    if (loc == NULL) {</a>
<a name="ln3702">      EMSG2(_(&quot;E197: Cannot set language to \&quot;%s\&quot;&quot;), name);</a>
<a name="ln3703">    } else {</a>
<a name="ln3704">#ifdef HAVE_NL_MSG_CAT_CNTR</a>
<a name="ln3705">      // Need to do this for GNU gettext, otherwise cached translations</a>
<a name="ln3706">      // will be used again.</a>
<a name="ln3707">      extern int _nl_msg_cat_cntr;</a>
<a name="ln3708"> </a>
<a name="ln3709">      _nl_msg_cat_cntr++;</a>
<a name="ln3710">#endif</a>
<a name="ln3711">      // Reset $LC_ALL, otherwise it would overrule everything.</a>
<a name="ln3712">      os_setenv(&quot;LC_ALL&quot;, &quot;&quot;, 1);</a>
<a name="ln3713"> </a>
<a name="ln3714">      if (what != LC_TIME) {</a>
<a name="ln3715">        // Tell gettext() what to translate to.  It apparently doesn't</a>
<a name="ln3716">        // use the currently effective locale.</a>
<a name="ln3717">        if (what == LC_ALL) {</a>
<a name="ln3718">          os_setenv(&quot;LANG&quot;, (char *)name, 1);</a>
<a name="ln3719"> </a>
<a name="ln3720">          // Clear $LANGUAGE because GNU gettext uses it.</a>
<a name="ln3721">          os_setenv(&quot;LANGUAGE&quot;, &quot;&quot;, 1);</a>
<a name="ln3722">        }</a>
<a name="ln3723">        if (what != LC_CTYPE) {</a>
<a name="ln3724">          os_setenv(&quot;LC_MESSAGES&quot;, (char *)name, 1);</a>
<a name="ln3725">          set_helplang_default((char *)name);</a>
<a name="ln3726">        }</a>
<a name="ln3727">      }</a>
<a name="ln3728"> </a>
<a name="ln3729">      // Set v:lang, v:lc_time and v:ctype to the final result.</a>
<a name="ln3730">      set_lang_var();</a>
<a name="ln3731">      maketitle();</a>
<a name="ln3732">    }</a>
<a name="ln3733">  }</a>
<a name="ln3734">}</a>
<a name="ln3735"> </a>
<a name="ln3736"> </a>
<a name="ln3737">static char_u **locales = NULL;       // Array of all available locales</a>
<a name="ln3738"> </a>
<a name="ln3739">#ifndef WIN32</a>
<a name="ln3740">static bool did_init_locales = false;</a>
<a name="ln3741"> </a>
<a name="ln3742">/// Return an array of strings for all available locales + NULL for the</a>
<a name="ln3743">/// last element.  Return NULL in case of error.</a>
<a name="ln3744">static char_u **find_locales(void)</a>
<a name="ln3745">{</a>
<a name="ln3746">  garray_T locales_ga;</a>
<a name="ln3747">  char_u      *loc;</a>
<a name="ln3748">  char *saveptr = NULL;</a>
<a name="ln3749"> </a>
<a name="ln3750">  // Find all available locales by running command &quot;locale -a&quot;.  If this</a>
<a name="ln3751">  // doesn't work we won't have completion.</a>
<a name="ln3752">  char_u *locale_a = get_cmd_output((char_u *)&quot;locale -a&quot;, NULL,</a>
<a name="ln3753">                                    kShellOptSilent, NULL);</a>
<a name="ln3754">  if (locale_a == NULL) {</a>
<a name="ln3755">    return NULL;</a>
<a name="ln3756">  }</a>
<a name="ln3757">  ga_init(&amp;locales_ga, sizeof(char_u *), 20);</a>
<a name="ln3758"> </a>
<a name="ln3759">  // Transform locale_a string where each locale is separated by &quot;\n&quot;</a>
<a name="ln3760">  // into an array of locale strings.</a>
<a name="ln3761">  loc = (char_u *)os_strtok((char *)locale_a, &quot;\n&quot;, &amp;saveptr);</a>
<a name="ln3762"> </a>
<a name="ln3763">  while (loc != NULL) {</a>
<a name="ln3764">    loc = vim_strsave(loc);</a>
<a name="ln3765">    GA_APPEND(char_u *, &amp;locales_ga, loc);</a>
<a name="ln3766">    loc = (char_u *)os_strtok(NULL, &quot;\n&quot;, &amp;saveptr);</a>
<a name="ln3767">  }</a>
<a name="ln3768">  xfree(locale_a);</a>
<a name="ln3769">  // Guarantee that .ga_data is NULL terminated</a>
<a name="ln3770">  ga_grow(&amp;locales_ga, 1);</a>
<a name="ln3771">  ((char_u **)locales_ga.ga_data)[locales_ga.ga_len] = NULL;</a>
<a name="ln3772">  return (char_u **)locales_ga.ga_data;</a>
<a name="ln3773">}</a>
<a name="ln3774">#endif</a>
<a name="ln3775"> </a>
<a name="ln3776">/// Lazy initialization of all available locales.</a>
<a name="ln3777">static void init_locales(void)</a>
<a name="ln3778">{</a>
<a name="ln3779">#ifndef WIN32</a>
<a name="ln3780">  if (!did_init_locales) {</a>
<a name="ln3781">    did_init_locales = true;</a>
<a name="ln3782">    locales = find_locales();</a>
<a name="ln3783">  }</a>
<a name="ln3784">#endif</a>
<a name="ln3785">}</a>
<a name="ln3786"> </a>
<a name="ln3787">#  if defined(EXITFREE)</a>
<a name="ln3788">void free_locales(void)</a>
<a name="ln3789">{</a>
<a name="ln3790">  int i;</a>
<a name="ln3791">  if (locales != NULL) {</a>
<a name="ln3792">    for (i = 0; locales[i] != NULL; i++) {</a>
<a name="ln3793">      xfree(locales[i]);</a>
<a name="ln3794">    }</a>
<a name="ln3795">    XFREE_CLEAR(locales);</a>
<a name="ln3796">  }</a>
<a name="ln3797">}</a>
<a name="ln3798"> </a>
<a name="ln3799">#  endif</a>
<a name="ln3800"> </a>
<a name="ln3801">/// Function given to ExpandGeneric() to obtain the possible arguments of the</a>
<a name="ln3802">/// &quot;:language&quot; command.</a>
<a name="ln3803">char_u *get_lang_arg(expand_T *xp, int idx)</a>
<a name="ln3804">{</a>
<a name="ln3805">  if (idx == 0) {</a>
<a name="ln3806">    return (char_u *)&quot;messages&quot;;</a>
<a name="ln3807">  }</a>
<a name="ln3808">  if (idx == 1) {</a>
<a name="ln3809">    return (char_u *)&quot;ctype&quot;;</a>
<a name="ln3810">  }</a>
<a name="ln3811">  if (idx == 2) {</a>
<a name="ln3812">    return (char_u *)&quot;time&quot;;</a>
<a name="ln3813">  }</a>
<a name="ln3814"> </a>
<a name="ln3815">  init_locales();</a>
<a name="ln3816">  if (locales == NULL) {</a>
<a name="ln3817">    return NULL;</a>
<a name="ln3818">  }</a>
<a name="ln3819">  return locales[idx - 3];</a>
<a name="ln3820">}</a>
<a name="ln3821"> </a>
<a name="ln3822">/// Function given to ExpandGeneric() to obtain the available locales.</a>
<a name="ln3823">char_u *get_locales(expand_T *xp, int idx)</a>
<a name="ln3824">{</a>
<a name="ln3825">  init_locales();</a>
<a name="ln3826">  if (locales == NULL) {</a>
<a name="ln3827">    return NULL;</a>
<a name="ln3828">  }</a>
<a name="ln3829">  return locales[idx];</a>
<a name="ln3830">}</a>
<a name="ln3831"> </a>
<a name="ln3832">#endif</a>
<a name="ln3833"> </a>
<a name="ln3834"> </a>
<a name="ln3835">static void script_host_execute(char *name, exarg_T *eap)</a>
<a name="ln3836">{</a>
<a name="ln3837">  size_t len;</a>
<a name="ln3838">  char *const script = script_get(eap, &amp;len);</a>
<a name="ln3839"> </a>
<a name="ln3840">  if (script != NULL) {</a>
<a name="ln3841">    list_T *const args = tv_list_alloc(3);</a>
<a name="ln3842">    // script</a>
<a name="ln3843">    tv_list_append_allocated_string(args, script);</a>
<a name="ln3844">    // current range</a>
<a name="ln3845">    tv_list_append_number(args, (int)eap-&gt;line1);</a>
<a name="ln3846">    tv_list_append_number(args, (int)eap-&gt;line2);</a>
<a name="ln3847"> </a>
<a name="ln3848">    (void)eval_call_provider(name, &quot;execute&quot;, args, true);</a>
<a name="ln3849">  }</a>
<a name="ln3850">}</a>
<a name="ln3851"> </a>
<a name="ln3852">static void script_host_execute_file(char *name, exarg_T *eap)</a>
<a name="ln3853">{</a>
<a name="ln3854">  if (!eap-&gt;skip) {</a>
<a name="ln3855">    uint8_t buffer[MAXPATHL];</a>
<a name="ln3856">    vim_FullName((char *)eap-&gt;arg, (char *)buffer, sizeof(buffer), false);</a>
<a name="ln3857"> </a>
<a name="ln3858">    list_T *args = tv_list_alloc(3);</a>
<a name="ln3859">    // filename</a>
<a name="ln3860">    tv_list_append_string(args, (const char *)buffer, -1);</a>
<a name="ln3861">    // current range</a>
<a name="ln3862">    tv_list_append_number(args, (int)eap-&gt;line1);</a>
<a name="ln3863">    tv_list_append_number(args, (int)eap-&gt;line2);</a>
<a name="ln3864">    (void)eval_call_provider(name, &quot;execute_file&quot;, args, true);</a>
<a name="ln3865">  }</a>
<a name="ln3866">}</a>
<a name="ln3867"> </a>
<a name="ln3868">static void script_host_do_range(char *name, exarg_T *eap)</a>
<a name="ln3869">{</a>
<a name="ln3870">  if (!eap-&gt;skip) {</a>
<a name="ln3871">    list_T *args = tv_list_alloc(3);</a>
<a name="ln3872">    tv_list_append_number(args, (int)eap-&gt;line1);</a>
<a name="ln3873">    tv_list_append_number(args, (int)eap-&gt;line2);</a>
<a name="ln3874">    tv_list_append_string(args, (const char *)eap-&gt;arg, -1);</a>
<a name="ln3875">    (void)eval_call_provider(name, &quot;do_range&quot;, args, true);</a>
<a name="ln3876">  }</a>
<a name="ln3877">}</a>
<a name="ln3878"> </a>
<a name="ln3879">/// &quot;:drop&quot;</a>
<a name="ln3880">/// Opens the first argument in a window.  When there are two or more arguments</a>
<a name="ln3881">/// the argument list is redefined.</a>
<a name="ln3882">void ex_drop(exarg_T   *eap)</a>
<a name="ln3883">{</a>
<a name="ln3884">  bool split = false;</a>
<a name="ln3885">  buf_T *buf;</a>
<a name="ln3886"> </a>
<a name="ln3887">  // Check if the first argument is already being edited in a window.  If</a>
<a name="ln3888">  // so, jump to that window.</a>
<a name="ln3889">  // We would actually need to check all arguments, but that's complicated</a>
<a name="ln3890">  // and mostly only one file is dropped.</a>
<a name="ln3891">  // This also ignores wildcards, since it is very unlikely the user is</a>
<a name="ln3892">  // editing a file name with a wildcard character.</a>
<a name="ln3893">  do_arglist(eap-&gt;arg, AL_SET, 0, false);</a>
<a name="ln3894"> </a>
<a name="ln3895">  // Expanding wildcards may result in an empty argument list.  E.g. when</a>
<a name="ln3896">  // editing &quot;foo.pyc&quot; and &quot;.pyc&quot; is in 'wildignore'.  Assume that we</a>
<a name="ln3897">  // already did an error message for this.</a>
<a name="ln3898">  if (ARGCOUNT == 0) {</a>
<a name="ln3899">    return;</a>
<a name="ln3900">  }</a>
<a name="ln3901"> </a>
<a name="ln3902">  if (cmdmod.tab) {</a>
<a name="ln3903">    // &quot;:tab drop file ...&quot;: open a tab for each argument that isn't</a>
<a name="ln3904">    // edited in a window yet.  It's like &quot;:tab all&quot; but without closing</a>
<a name="ln3905">    // windows or tabs.</a>
<a name="ln3906">    ex_all(eap);</a>
<a name="ln3907">  } else {</a>
<a name="ln3908">    // &quot;:drop file ...&quot;: Edit the first argument.  Jump to an existing</a>
<a name="ln3909">    // window if possible, edit in current window if the current buffer</a>
<a name="ln3910">    // can be abandoned, otherwise open a new window.</a>
<a name="ln3911">    buf = buflist_findnr(ARGLIST[0].ae_fnum);</a>
<a name="ln3912"> </a>
<a name="ln3913">    FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln3914">      if (wp-&gt;w_buffer == buf) {</a>
<a name="ln3915">        goto_tabpage_win(tp, wp);</a>
<a name="ln3916">        curwin-&gt;w_arg_idx = 0;</a>
<a name="ln3917">        if (!bufIsChanged(curbuf)) {</a>
<a name="ln3918">          const int save_ar = curbuf-&gt;b_p_ar;</a>
<a name="ln3919"> </a>
<a name="ln3920">          // reload the file if it is newer</a>
<a name="ln3921">          curbuf-&gt;b_p_ar = 1;</a>
<a name="ln3922">          buf_check_timestamp(curbuf);</a>
<a name="ln3923">          curbuf-&gt;b_p_ar = save_ar;</a>
<a name="ln3924">        }</a>
<a name="ln3925">        return;</a>
<a name="ln3926">      }</a>
<a name="ln3927">    }</a>
<a name="ln3928"> </a>
<a name="ln3929">    // Check whether the current buffer is changed. If so, we will need</a>
<a name="ln3930">    // to split the current window or data could be lost.</a>
<a name="ln3931">    // Skip the check if the 'hidden' option is set, as in this case the</a>
<a name="ln3932">    // buffer won't be lost.</a>
<a name="ln3933">    if (!buf_hide(curbuf)) {</a>
<a name="ln3934">      emsg_off++;</a>
<a name="ln3935">      split = check_changed(curbuf, CCGD_AW | CCGD_EXCMD);</a>
<a name="ln3936">      emsg_off--;</a>
<a name="ln3937">    }</a>
<a name="ln3938"> </a>
<a name="ln3939">    // Fake a &quot;:sfirst&quot; or &quot;:first&quot; command edit the first argument.</a>
<a name="ln3940">    if (split) {</a>
<a name="ln3941">      eap-&gt;cmdidx = CMD_sfirst;</a>
<a name="ln3942">      eap-&gt;cmd[0] = 's';</a>
<a name="ln3943">    } else {</a>
<a name="ln3944">      eap-&gt;cmdidx = CMD_first;</a>
<a name="ln3945">    }</a>
<a name="ln3946">    ex_rewind(eap);</a>
<a name="ln3947">  }</a>
<a name="ln3948">}</a>

</code></pre>
<div class="balloon" rel="2747"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v507/" target="_blank">V507</a> Pointer to local array 'sourcing_name_buf' is stored outside the scope of this array. Such a pointer will become invalid.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
