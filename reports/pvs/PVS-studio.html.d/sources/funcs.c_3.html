
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>funcs.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;float.h&gt;</a>
<a name="ln5">#include &lt;math.h&gt;</a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln8">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln9">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln10">#include &quot;nvim/assert.h&quot;</a>
<a name="ln11">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln12">#include &quot;nvim/change.h&quot;</a>
<a name="ln13">#include &quot;nvim/channel.h&quot;</a>
<a name="ln14">#include &quot;nvim/charset.h&quot;</a>
<a name="ln15">#include &quot;nvim/context.h&quot;</a>
<a name="ln16">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln17">#include &quot;nvim/diff.h&quot;</a>
<a name="ln18">#include &quot;nvim/edit.h&quot;</a>
<a name="ln19">#include &quot;nvim/eval.h&quot;</a>
<a name="ln20">#include &quot;nvim/eval/decode.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval/encode.h&quot;</a>
<a name="ln22">#include &quot;nvim/eval/executor.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval/funcs.h&quot;</a>
<a name="ln24">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln25">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln28">#include &quot;nvim/file_search.h&quot;</a>
<a name="ln29">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln30">#include &quot;nvim/fold.h&quot;</a>
<a name="ln31">#include &quot;nvim/if_cscope.h&quot;</a>
<a name="ln32">#include &quot;nvim/indent.h&quot;</a>
<a name="ln33">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln34">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln35">#include &quot;nvim/macros.h&quot;</a>
<a name="ln36">#include &quot;nvim/mark.h&quot;</a>
<a name="ln37">#include &quot;nvim/math.h&quot;</a>
<a name="ln38">#include &quot;nvim/memline.h&quot;</a>
<a name="ln39">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln40">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln41">#include &quot;nvim/move.h&quot;</a>
<a name="ln42">#include &quot;nvim/msgpack_rpc/channel.h&quot;</a>
<a name="ln43">#include &quot;nvim/msgpack_rpc/server.h&quot;</a>
<a name="ln44">#include &quot;nvim/ops.h&quot;</a>
<a name="ln45">#include &quot;nvim/option.h&quot;</a>
<a name="ln46">#include &quot;nvim/os/dl.h&quot;</a>
<a name="ln47">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln48">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln49">#include &quot;nvim/path.h&quot;</a>
<a name="ln50">#include &quot;nvim/popupmnu.h&quot;</a>
<a name="ln51">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln52">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln53">#include &quot;nvim/screen.h&quot;</a>
<a name="ln54">#include &quot;nvim/search.h&quot;</a>
<a name="ln55">#include &quot;nvim/sha256.h&quot;</a>
<a name="ln56">#include &quot;nvim/sign.h&quot;</a>
<a name="ln57">#include &quot;nvim/spell.h&quot;</a>
<a name="ln58">#include &quot;nvim/state.h&quot;</a>
<a name="ln59">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln60">#include &quot;nvim/tag.h&quot;</a>
<a name="ln61">#include &quot;nvim/ui.h&quot;</a>
<a name="ln62">#include &quot;nvim/undo.h&quot;</a>
<a name="ln63">#include &quot;nvim/version.h&quot;</a>
<a name="ln64">#include &quot;nvim/vim.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66"> </a>
<a name="ln67">/// Describe data to return from find_some_match()</a>
<a name="ln68">typedef enum {</a>
<a name="ln69">  kSomeMatch,  ///&lt; Data for match().</a>
<a name="ln70">  kSomeMatchEnd,  ///&lt; Data for matchend().</a>
<a name="ln71">  kSomeMatchList,  ///&lt; Data for matchlist().</a>
<a name="ln72">  kSomeMatchStr,  ///&lt; Data for matchstr().</a>
<a name="ln73">  kSomeMatchStrPos,  ///&lt; Data for matchstrpos().</a>
<a name="ln74">} SomeMatchType;</a>
<a name="ln75"> </a>
<a name="ln76">KHASH_MAP_INIT_STR(functions, VimLFuncDef)</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln80"># include &quot;eval/funcs.c.generated.h&quot;</a>
<a name="ln81"> </a>
<a name="ln82">#ifdef _MSC_VER</a>
<a name="ln83">// This prevents MSVC from replacing the functions with intrinsics,</a>
<a name="ln84">// and causing errors when trying to get their addresses in funcs.generated.h</a>
<a name="ln85">#pragma function(ceil)</a>
<a name="ln86">#pragma function(floor)</a>
<a name="ln87">#endif</a>
<a name="ln88"> </a>
<a name="ln89">PRAGMA_DIAG_PUSH_IGNORE_MISSING_PROTOTYPES</a>
<a name="ln90">PRAGMA_DIAG_PUSH_IGNORE_IMPLICIT_FALLTHROUGH</a>
<a name="ln91">#include &quot;funcs.generated.h&quot;</a>
<a name="ln92">PRAGMA_DIAG_POP</a>
<a name="ln93">PRAGMA_DIAG_POP</a>
<a name="ln94">#endif</a>
<a name="ln95"> </a>
<a name="ln96"> </a>
<a name="ln97">static char *e_listarg = N_(&quot;E686: Argument of %s must be a List&quot;);</a>
<a name="ln98">static char *e_invalwindow = N_(&quot;E957: Invalid window number&quot;);</a>
<a name="ln99"> </a>
<a name="ln100">/// Dummy va_list for passing to vim_snprintf</a>
<a name="ln101">///</a>
<a name="ln102">/// Used because:</a>
<a name="ln103">/// - passing a NULL pointer doesn't work when va_list isn't a pointer</a>
<a name="ln104">/// - locally in the function results in a &quot;used before set&quot; warning</a>
<a name="ln105">/// - using va_start() to initialize it gives &quot;function with fixed args&quot; error</a>
<a name="ln106">static va_list dummy_ap;</a>
<a name="ln107"> </a>
<a name="ln108"> </a>
<a name="ln109">/// Function given to ExpandGeneric() to obtain the list of internal</a>
<a name="ln110">/// or user defined function names.</a>
<a name="ln111">char_u *get_function_name(expand_T *xp, int idx)</a>
<a name="ln112">{</a>
<a name="ln113">  static int intidx = -1;</a>
<a name="ln114">  char_u *name;</a>
<a name="ln115"> </a>
<a name="ln116">  if (idx == 0)</a>
<a name="ln117">    intidx = -1;</a>
<a name="ln118">  if (intidx &lt; 0) {</a>
<a name="ln119">    name = get_user_func_name(xp, idx);</a>
<a name="ln120">    if (name != NULL) {</a>
<a name="ln121">      if (*name != '&lt;' &amp;&amp; STRNCMP(&quot;g:&quot;, xp-&gt;xp_pattern, 2) == 0) {</a>
<a name="ln122">        return cat_prefix_varname('g', name);</a>
<a name="ln123">      }</a>
<a name="ln124">      return name;</a>
<a name="ln125">    }</a>
<a name="ln126">  }</a>
<a name="ln127">  while ((size_t)++intidx &lt; ARRAY_SIZE(functions)</a>
<a name="ln128">         &amp;&amp; functions[intidx].name[0] == '\0') {</a>
<a name="ln129">  }</a>
<a name="ln130"> </a>
<a name="ln131">  if ((size_t)intidx &gt;= ARRAY_SIZE(functions)) {</a>
<a name="ln132">    return NULL;</a>
<a name="ln133">  }</a>
<a name="ln134"> </a>
<a name="ln135">  const char *const key = functions[intidx].name;</a>
<a name="ln136">  const size_t key_len = strlen(key);</a>
<a name="ln137">  memcpy(IObuff, key, key_len);</a>
<a name="ln138">  IObuff[key_len] = '(';</a>
<a name="ln139">  if (functions[intidx].max_argc == 0) {</a>
<a name="ln140">    IObuff[key_len + 1] = ')';</a>
<a name="ln141">    IObuff[key_len + 2] = NUL;</a>
<a name="ln142">  } else {</a>
<a name="ln143">    IObuff[key_len + 1] = NUL;</a>
<a name="ln144">  }</a>
<a name="ln145">  return IObuff;</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">/// Function given to ExpandGeneric() to obtain the list of internal or</a>
<a name="ln149">/// user defined variable or function names.</a>
<a name="ln150">char_u *get_expr_name(expand_T *xp, int idx)</a>
<a name="ln151">{</a>
<a name="ln152">  static int intidx = -1;</a>
<a name="ln153">  char_u *name;</a>
<a name="ln154"> </a>
<a name="ln155">  if (idx == 0)</a>
<a name="ln156">    intidx = -1;</a>
<a name="ln157">  if (intidx &lt; 0) {</a>
<a name="ln158">    name = get_function_name(xp, idx);</a>
<a name="ln159">    if (name != NULL)</a>
<a name="ln160">      return name;</a>
<a name="ln161">  }</a>
<a name="ln162">  return get_user_var_name(xp, ++intidx);</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">/// Find internal function in hash functions</a>
<a name="ln166">///</a>
<a name="ln167">/// @param[in]  name  Name of the function.</a>
<a name="ln168">///</a>
<a name="ln169">/// Returns pointer to the function definition or NULL if not found.</a>
<a name="ln170">const VimLFuncDef *find_internal_func(const char *const name)</a>
<a name="ln171">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE FUNC_ATTR_NONNULL_ALL</a>
<a name="ln172">{</a>
<a name="ln173">  size_t len = strlen(name);</a>
<a name="ln174">  return find_internal_func_gperf(name, len);</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">/*</a>
<a name="ln178"> * Return TRUE for a non-zero Number and a non-empty String.</a>
<a name="ln179"> */</a>
<a name="ln180">static int non_zero_arg(typval_T *argvars)</a>
<a name="ln181">{</a>
<a name="ln182">  return ((argvars[0].v_type == VAR_NUMBER</a>
<a name="ln183">           &amp;&amp; argvars[0].vval.v_number != 0)</a>
<a name="ln184">          || (argvars[0].v_type == VAR_BOOL</a>
<a name="ln185">              &amp;&amp; argvars[0].vval.v_bool == kBoolVarTrue)</a>
<a name="ln186">          || (argvars[0].v_type == VAR_STRING</a>
<a name="ln187">              &amp;&amp; argvars[0].vval.v_string != NULL</a>
<a name="ln188">              &amp;&amp; *argvars[0].vval.v_string != NUL));</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">// Apply a floating point C function on a typval with one float_T.</a>
<a name="ln192">//</a>
<a name="ln193">// Some versions of glibc on i386 have an optimization that makes it harder to</a>
<a name="ln194">// call math functions indirectly from inside an inlined function, causing</a>
<a name="ln195">// compile-time errors. Avoid `inline` in that case. #3072</a>
<a name="ln196">static void float_op_wrapper(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln197">{</a>
<a name="ln198">  float_T f;</a>
<a name="ln199">  float_T (*function)(float_T) = (float_T (*)(float_T))fptr;</a>
<a name="ln200"> </a>
<a name="ln201">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln202">  if (tv_get_float_chk(argvars, &amp;f)) {</a>
<a name="ln203">    rettv-&gt;vval.v_float = function(f);</a>
<a name="ln204">  } else {</a>
<a name="ln205">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln206">  }</a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209">static void api_wrapper(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln210">{</a>
<a name="ln211">  if (check_secure()) {</a>
<a name="ln212">    return;</a>
<a name="ln213">  }</a>
<a name="ln214"> </a>
<a name="ln215">  ApiDispatchWrapper fn = (ApiDispatchWrapper)fptr;</a>
<a name="ln216"> </a>
<a name="ln217">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln218"> </a>
<a name="ln219">  for (typval_T *tv = argvars; tv-&gt;v_type != VAR_UNKNOWN; tv++) {</a>
<a name="ln220">    ADD(args, vim_to_object(tv));</a>
<a name="ln221">  }</a>
<a name="ln222"> </a>
<a name="ln223">  Error err = ERROR_INIT;</a>
<a name="ln224">  Object result = fn(VIML_INTERNAL_CALL, args, &amp;err);</a>
<a name="ln225"> </a>
<a name="ln226">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln227">    emsgf_multiline((const char *)e_api_error, err.msg);</a>
<a name="ln228">    goto end;</a>
<a name="ln229">  }</a>
<a name="ln230"> </a>
<a name="ln231">  if (!object_to_vim(result, rettv, &amp;err)) {</a>
<a name="ln232">    EMSG2(_(&quot;Error converting the call result: %s&quot;), err.msg);</a>
<a name="ln233">  }</a>
<a name="ln234"> </a>
<a name="ln235">end:</a>
<a name="ln236">  api_free_array(args);</a>
<a name="ln237">  api_free_object(result);</a>
<a name="ln238">  api_clear_error(&amp;err);</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241">/*</a>
<a name="ln242"> * &quot;abs(expr)&quot; function</a>
<a name="ln243"> */</a>
<a name="ln244">static void f_abs(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln245">{</a>
<a name="ln246">  if (argvars[0].v_type == VAR_FLOAT) {</a>
<a name="ln247">    float_op_wrapper(argvars, rettv, (FunPtr)&amp;fabs);</a>
<a name="ln248">  } else {</a>
<a name="ln249">    varnumber_T n;</a>
<a name="ln250">    bool error = false;</a>
<a name="ln251"> </a>
<a name="ln252">    n = tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln253">    if (error) {</a>
<a name="ln254">      rettv-&gt;vval.v_number = -1;</a>
<a name="ln255">    } else if (n &gt; 0) {</a>
<a name="ln256">      rettv-&gt;vval.v_number = n;</a>
<a name="ln257">    } else {</a>
<a name="ln258">      rettv-&gt;vval.v_number = -n;</a>
<a name="ln259">    }</a>
<a name="ln260">  }</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263">/*</a>
<a name="ln264"> * &quot;add(list, item)&quot; function</a>
<a name="ln265"> */</a>
<a name="ln266">static void f_add(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln267">{</a>
<a name="ln268">  rettv-&gt;vval.v_number = 1;  // Default: failed.</a>
<a name="ln269">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln270">    list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln271">    if (!tv_check_lock(tv_list_locked(l), N_(&quot;add() argument&quot;), TV_TRANSLATE)) {</a>
<a name="ln272">      tv_list_append_tv(l, &amp;argvars[1]);</a>
<a name="ln273">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln274">    }</a>
<a name="ln275">  } else {</a>
<a name="ln276">    EMSG(_(e_listreq));</a>
<a name="ln277">  }</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">/*</a>
<a name="ln281"> * &quot;and(expr, expr)&quot; function</a>
<a name="ln282"> */</a>
<a name="ln283">static void f_and(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln284">{</a>
<a name="ln285">  rettv-&gt;vval.v_number = tv_get_number_chk(&amp;argvars[0], NULL)</a>
<a name="ln286">                         &amp; tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln287">}</a>
<a name="ln288"> </a>
<a name="ln289"> </a>
<a name="ln290">/// &quot;api_info()&quot; function</a>
<a name="ln291">static void f_api_info(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln292">{</a>
<a name="ln293">  Dictionary metadata = api_metadata();</a>
<a name="ln294">  (void)object_to_vim(DICTIONARY_OBJ(metadata), rettv, NULL);</a>
<a name="ln295">  api_free_dictionary(metadata);</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298">// &quot;append(lnum, string/list)&quot; function</a>
<a name="ln299">static void f_append(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln300">{</a>
<a name="ln301">  const linenr_T lnum = tv_get_lnum(&amp;argvars[0]);</a>
<a name="ln302"> </a>
<a name="ln303">  set_buffer_lines(curbuf, lnum, true, &amp;argvars[1], rettv);</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">// &quot;appendbufline(buf, lnum, string/list)&quot; function</a>
<a name="ln307">static void f_appendbufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln308">{</a>
<a name="ln309">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln310">  if (buf == NULL) {</a>
<a name="ln311">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln312">  } else {</a>
<a name="ln313">    const linenr_T lnum = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln314">    set_buffer_lines(buf, lnum, true, &amp;argvars[2], rettv);</a>
<a name="ln315">  }</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">static void f_argc(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln319">{</a>
<a name="ln320">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln321">    // use the current window</a>
<a name="ln322">    rettv-&gt;vval.v_number = ARGCOUNT;</a>
<a name="ln323">  } else if (argvars[0].v_type == VAR_NUMBER</a>
<a name="ln324">             &amp;&amp; tv_get_number(&amp;argvars[0]) == -1) {</a>
<a name="ln325">    // use the global argument list</a>
<a name="ln326">    rettv-&gt;vval.v_number = GARGCOUNT;</a>
<a name="ln327">  } else {</a>
<a name="ln328">    // use the argument list of the specified window</a>
<a name="ln329">    win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln330">    if (wp != NULL) {</a>
<a name="ln331">      rettv-&gt;vval.v_number = WARGCOUNT(wp);</a>
<a name="ln332">    } else {</a>
<a name="ln333">      rettv-&gt;vval.v_number = -1;</a>
<a name="ln334">    }</a>
<a name="ln335">  }</a>
<a name="ln336">}</a>
<a name="ln337"> </a>
<a name="ln338">/*</a>
<a name="ln339"> * &quot;argidx()&quot; function</a>
<a name="ln340"> */</a>
<a name="ln341">static void f_argidx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln342">{</a>
<a name="ln343">  rettv-&gt;vval.v_number = curwin-&gt;w_arg_idx;</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346">/// &quot;arglistid&quot; function</a>
<a name="ln347">static void f_arglistid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln348">{</a>
<a name="ln349">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln350">  win_T *wp = find_tabwin(&amp;argvars[0], &amp;argvars[1]);</a>
<a name="ln351">  if (wp != NULL) {</a>
<a name="ln352">    rettv-&gt;vval.v_number = wp-&gt;w_alist-&gt;id;</a>
<a name="ln353">  }</a>
<a name="ln354">}</a>
<a name="ln355"> </a>
<a name="ln356">/*</a>
<a name="ln357"> * &quot;argv(nr)&quot; function</a>
<a name="ln358"> */</a>
<a name="ln359">static void f_argv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln360">{</a>
<a name="ln361">  aentry_T *arglist = NULL;</a>
<a name="ln362">  int argcount = -1;</a>
<a name="ln363"> </a>
<a name="ln364">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln365">    if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln366">      arglist = ARGLIST;</a>
<a name="ln367">      argcount = ARGCOUNT;</a>
<a name="ln368">    } else if (argvars[1].v_type == VAR_NUMBER</a>
<a name="ln369">               &amp;&amp; tv_get_number(&amp;argvars[1]) == -1) {</a>
<a name="ln370">      arglist = GARGLIST;</a>
<a name="ln371">      argcount = GARGCOUNT;</a>
<a name="ln372">    } else {</a>
<a name="ln373">      win_T *wp = find_win_by_nr_or_id(&amp;argvars[1]);</a>
<a name="ln374">      if (wp != NULL) {</a>
<a name="ln375">        // Use the argument list of the specified window</a>
<a name="ln376">        arglist = WARGLIST(wp);</a>
<a name="ln377">        argcount = WARGCOUNT(wp);</a>
<a name="ln378">      }</a>
<a name="ln379">    }</a>
<a name="ln380">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln381">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln382">    int idx = tv_get_number_chk(&amp;argvars[0], NULL);</a>
<a name="ln383">    if (arglist != NULL &amp;&amp; idx &gt;= 0 &amp;&amp; idx &lt; argcount) {</a>
<a name="ln384">      rettv-&gt;vval.v_string = (char_u *)xstrdup(</a>
<a name="ln385">          (const char *)alist_name(&amp;arglist[idx]));</a>
<a name="ln386">    } else if (idx == -1) {</a>
<a name="ln387">      get_arglist_as_rettv(arglist, argcount, rettv);</a>
<a name="ln388">    }</a>
<a name="ln389">  } else {</a>
<a name="ln390">    get_arglist_as_rettv(ARGLIST, ARGCOUNT, rettv);</a>
<a name="ln391">  }</a>
<a name="ln392">}</a>
<a name="ln393"> </a>
<a name="ln394">// &quot;assert_beeps(cmd [, error])&quot; function</a>
<a name="ln395">static void f_assert_beeps(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln396">{</a>
<a name="ln397">  rettv-&gt;vval.v_number = assert_beeps(argvars, false);</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">// &quot;assert_nobeep(cmd [, error])&quot; function</a>
<a name="ln401">static void f_assert_nobeep(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln402">{</a>
<a name="ln403">  rettv-&gt;vval.v_number = assert_beeps(argvars, true);</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406">// &quot;assert_equal(expected, actual[, msg])&quot; function</a>
<a name="ln407">static void f_assert_equal(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln408">{</a>
<a name="ln409">  rettv-&gt;vval.v_number = assert_equal_common(argvars, ASSERT_EQUAL);</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">// &quot;assert_equalfile(fname-one, fname-two[, msg])&quot; function</a>
<a name="ln413">static void f_assert_equalfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln414">{</a>
<a name="ln415">  rettv-&gt;vval.v_number = assert_equalfile(argvars);</a>
<a name="ln416">}</a>
<a name="ln417"> </a>
<a name="ln418">// &quot;assert_notequal(expected, actual[, msg])&quot; function</a>
<a name="ln419">static void f_assert_notequal(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln420">{</a>
<a name="ln421">  rettv-&gt;vval.v_number = assert_equal_common(argvars, ASSERT_NOTEQUAL);</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424">/// &quot;assert_report(msg)</a>
<a name="ln425">static void f_assert_report(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln426">{</a>
<a name="ln427">    garray_T ga;</a>
<a name="ln428"> </a>
<a name="ln429">    prepare_assert_error(&amp;ga);</a>
<a name="ln430">    ga_concat(&amp;ga, (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln431">    assert_error(&amp;ga);</a>
<a name="ln432">    ga_clear(&amp;ga);</a>
<a name="ln433">    rettv-&gt;vval.v_number = 1;</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436">/// &quot;assert_exception(string[, msg])&quot; function</a>
<a name="ln437">static void f_assert_exception(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln438">{</a>
<a name="ln439">  rettv-&gt;vval.v_number = assert_exception(argvars);</a>
<a name="ln440">}</a>
<a name="ln441"> </a>
<a name="ln442">/// &quot;assert_fails(cmd [, error [, msg]])&quot; function</a>
<a name="ln443">static void f_assert_fails(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln444">{</a>
<a name="ln445">  rettv-&gt;vval.v_number = assert_fails(argvars);</a>
<a name="ln446">}</a>
<a name="ln447"> </a>
<a name="ln448">// &quot;assert_false(actual[, msg])&quot; function</a>
<a name="ln449">static void f_assert_false(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln450">{</a>
<a name="ln451">  rettv-&gt;vval.v_number = assert_bool(argvars, false);</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454">/// &quot;assert_inrange(lower, upper[, msg])&quot; function</a>
<a name="ln455">static void f_assert_inrange(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln456">{</a>
<a name="ln457">  rettv-&gt;vval.v_number = assert_inrange(argvars);</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">/// &quot;assert_match(pattern, actual[, msg])&quot; function</a>
<a name="ln461">static void f_assert_match(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln462">{</a>
<a name="ln463">  rettv-&gt;vval.v_number = assert_match_common(argvars, ASSERT_MATCH);</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466">/// &quot;assert_notmatch(pattern, actual[, msg])&quot; function</a>
<a name="ln467">static void f_assert_notmatch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln468">{</a>
<a name="ln469">  rettv-&gt;vval.v_number = assert_match_common(argvars, ASSERT_NOTMATCH);</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">// &quot;assert_true(actual[, msg])&quot; function</a>
<a name="ln473">static void f_assert_true(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln474">{</a>
<a name="ln475">  rettv-&gt;vval.v_number = assert_bool(argvars, true);</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">/*</a>
<a name="ln479"> * &quot;atan2()&quot; function</a>
<a name="ln480"> */</a>
<a name="ln481">static void f_atan2(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln482">{</a>
<a name="ln483">  float_T fx;</a>
<a name="ln484">  float_T fy;</a>
<a name="ln485"> </a>
<a name="ln486">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln487">  if (tv_get_float_chk(argvars, &amp;fx) &amp;&amp; tv_get_float_chk(&amp;argvars[1], &amp;fy)) {</a>
<a name="ln488">    rettv-&gt;vval.v_float = atan2(fx, fy);</a>
<a name="ln489">  } else {</a>
<a name="ln490">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln491">  }</a>
<a name="ln492">}</a>
<a name="ln493"> </a>
<a name="ln494">/*</a>
<a name="ln495"> * &quot;browse(save, title, initdir, default)&quot; function</a>
<a name="ln496"> */</a>
<a name="ln497">static void f_browse(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln498">{</a>
<a name="ln499">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln500">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">/*</a>
<a name="ln504"> * &quot;browsedir(title, initdir)&quot; function</a>
<a name="ln505"> */</a>
<a name="ln506">static void f_browsedir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln507">{</a>
<a name="ln508">  f_browse(argvars, rettv, NULL);</a>
<a name="ln509">}</a>
<a name="ln510"> </a>
<a name="ln511"> </a>
<a name="ln512">/*</a>
<a name="ln513"> * Find a buffer by number or exact name.</a>
<a name="ln514"> */</a>
<a name="ln515">static buf_T *find_buffer(typval_T *avar)</a>
<a name="ln516">{</a>
<a name="ln517">  buf_T       *buf = NULL;</a>
<a name="ln518"> </a>
<a name="ln519">  if (avar-&gt;v_type == VAR_NUMBER)</a>
<a name="ln520">    buf = buflist_findnr((int)avar-&gt;vval.v_number);</a>
<a name="ln521">  else if (avar-&gt;v_type == VAR_STRING &amp;&amp; avar-&gt;vval.v_string != NULL) {</a>
<a name="ln522">    buf = buflist_findname_exp(avar-&gt;vval.v_string);</a>
<a name="ln523">    if (buf == NULL) {</a>
<a name="ln524">      /* No full path name match, try a match with a URL or a &quot;nofile&quot;</a>
<a name="ln525">       * buffer, these don't use the full path. */</a>
<a name="ln526">      FOR_ALL_BUFFERS(bp) {</a>
<a name="ln527">        if (bp-&gt;b_fname != NULL</a>
<a name="ln528">            &amp;&amp; (path_with_url((char *)bp-&gt;b_fname)</a>
<a name="ln529">                || bt_nofile(bp)</a>
<a name="ln530">                )</a>
<a name="ln531">            &amp;&amp; STRCMP(bp-&gt;b_fname, avar-&gt;vval.v_string) == 0) {</a>
<a name="ln532">          buf = bp;</a>
<a name="ln533">          break;</a>
<a name="ln534">        }</a>
<a name="ln535">      }</a>
<a name="ln536">    }</a>
<a name="ln537">  }</a>
<a name="ln538">  return buf;</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">// &quot;bufadd(expr)&quot; function</a>
<a name="ln542">static void f_bufadd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln543">{</a>
<a name="ln544">  char_u *name = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln545"> </a>
<a name="ln546">  rettv-&gt;vval.v_number = buflist_add(*name == NUL ? NULL : name, 0);</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549">/*</a>
<a name="ln550"> * &quot;bufexists(expr)&quot; function</a>
<a name="ln551"> */</a>
<a name="ln552">static void f_bufexists(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln553">{</a>
<a name="ln554">  rettv-&gt;vval.v_number = (find_buffer(&amp;argvars[0]) != NULL);</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557">/*</a>
<a name="ln558"> * &quot;buflisted(expr)&quot; function</a>
<a name="ln559"> */</a>
<a name="ln560">static void f_buflisted(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln561">{</a>
<a name="ln562">  buf_T       *buf;</a>
<a name="ln563"> </a>
<a name="ln564">  buf = find_buffer(&amp;argvars[0]);</a>
<a name="ln565">  rettv-&gt;vval.v_number = (buf != NULL &amp;&amp; buf-&gt;b_p_bl);</a>
<a name="ln566">}</a>
<a name="ln567"> </a>
<a name="ln568">// &quot;bufload(expr)&quot; function</a>
<a name="ln569">static void f_bufload(typval_T *argvars, typval_T *unused, FunPtr fptr)</a>
<a name="ln570">{</a>
<a name="ln571">  buf_T *buf = get_buf_arg(&amp;argvars[0]);</a>
<a name="ln572"> </a>
<a name="ln573">  if (buf != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln574">    aco_save_T aco;</a>
<a name="ln575"> </a>
<a name="ln576">    aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln577">    swap_exists_action = SEA_NONE;</a>
<a name="ln578">    open_buffer(false, NULL, 0);</a>
<a name="ln579">    aucmd_restbuf(&amp;aco);</a>
<a name="ln580">  }</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583">/*</a>
<a name="ln584"> * &quot;bufloaded(expr)&quot; function</a>
<a name="ln585"> */</a>
<a name="ln586">static void f_bufloaded(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln587">{</a>
<a name="ln588">  buf_T       *buf;</a>
<a name="ln589"> </a>
<a name="ln590">  buf = find_buffer(&amp;argvars[0]);</a>
<a name="ln591">  rettv-&gt;vval.v_number = (buf != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp != NULL);</a>
<a name="ln592">}</a>
<a name="ln593"> </a>
<a name="ln594">/*</a>
<a name="ln595"> * &quot;bufname(expr)&quot; function</a>
<a name="ln596"> */</a>
<a name="ln597">static void f_bufname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln598">{</a>
<a name="ln599">  const buf_T *buf;</a>
<a name="ln600">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln601">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln602">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln603">    buf = curbuf;</a>
<a name="ln604">  } else {</a>
<a name="ln605">    buf = tv_get_buf_from_arg(&amp;argvars[0]);</a>
<a name="ln606">  }</a>
<a name="ln607">  if (buf != NULL &amp;&amp; buf-&gt;b_fname != NULL) {</a>
<a name="ln608">    rettv-&gt;vval.v_string = (char_u *)xstrdup((char *)buf-&gt;b_fname);</a>
<a name="ln609">  }</a>
<a name="ln610">}</a>
<a name="ln611"> </a>
<a name="ln612">/*</a>
<a name="ln613"> * &quot;bufnr(expr)&quot; function</a>
<a name="ln614"> */</a>
<a name="ln615">static void f_bufnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln616">{</a>
<a name="ln617">  const buf_T *buf;</a>
<a name="ln618">  bool error = false;</a>
<a name="ln619"> </a>
<a name="ln620">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln621"> </a>
<a name="ln622">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln623">    buf = curbuf;</a>
<a name="ln624">  } else {</a>
<a name="ln625">    // Don't use tv_get_buf_from_arg(); we continue if the buffer wasn't found</a>
<a name="ln626">    // and the second argument isn't zero, but we want to return early if the</a>
<a name="ln627">    // first argument isn't a string or number so only one error is shown.</a>
<a name="ln628">    if (!tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln629">      return;</a>
<a name="ln630">    }</a>
<a name="ln631">    emsg_off++;</a>
<a name="ln632">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln633">    emsg_off--;</a>
<a name="ln634">  }</a>
<a name="ln635"> </a>
<a name="ln636">  // If the buffer isn't found and the second argument is not zero create a</a>
<a name="ln637">  // new buffer.</a>
<a name="ln638">  const char *name;</a>
<a name="ln639">  if (buf == NULL</a>
<a name="ln640">      &amp;&amp; argvars[1].v_type != VAR_UNKNOWN</a>
<a name="ln641">      &amp;&amp; tv_get_number_chk(&amp;argvars[1], &amp;error) != 0</a>
<a name="ln642">      &amp;&amp; !error</a>
<a name="ln643">      &amp;&amp; (name = tv_get_string_chk(&amp;argvars[0])) != NULL) {</a>
<a name="ln644">    buf = buflist_new((char_u *)name, NULL, 1, 0);</a>
<a name="ln645">  }</a>
<a name="ln646"> </a>
<a name="ln647">  if (buf != NULL) {</a>
<a name="ln648">    rettv-&gt;vval.v_number = buf-&gt;b_fnum;</a>
<a name="ln649">  }</a>
<a name="ln650">}</a>
<a name="ln651"> </a>
<a name="ln652">static void buf_win_common(typval_T *argvars, typval_T *rettv, bool get_nr)</a>
<a name="ln653">{</a>
<a name="ln654">  const buf_T *const buf = tv_get_buf_from_arg(&amp;argvars[0]);</a>
<a name="ln655">  if (buf == NULL) {  // no need to search if invalid arg or buffer not found</a>
<a name="ln656">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln657">    return;</a>
<a name="ln658">  }</a>
<a name="ln659"> </a>
<a name="ln660">  int winnr = 0;</a>
<a name="ln661">  int winid;</a>
<a name="ln662">  bool found_buf = false;</a>
<a name="ln663">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln664">    winnr++;</a>
<a name="ln665">    if (wp-&gt;w_buffer == buf) {</a>
<a name="ln666">      found_buf = true;</a>
<a name="ln667">      winid = wp-&gt;handle;</a>
<a name="ln668">      break;</a>
<a name="ln669">    }</a>
<a name="ln670">  }</a>
<a name="ln671">  rettv-&gt;vval.v_number = (found_buf ? (get_nr ? winnr : winid) : -1);</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674">/// &quot;bufwinid(nr)&quot; function</a>
<a name="ln675">static void f_bufwinid(typval_T *argvars, typval_T *rettv, FunPtr fptr) {</a>
<a name="ln676">  buf_win_common(argvars, rettv, false);</a>
<a name="ln677">}</a>
<a name="ln678"> </a>
<a name="ln679">/// &quot;bufwinnr(nr)&quot; function</a>
<a name="ln680">static void f_bufwinnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln681">{</a>
<a name="ln682">  buf_win_common(argvars, rettv, true);</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685">/*</a>
<a name="ln686"> * Get buffer by number or pattern.</a>
<a name="ln687"> */</a>
<a name="ln688">buf_T *tv_get_buf(typval_T *tv, int curtab_only)</a>
<a name="ln689">{</a>
<a name="ln690">  char_u      *name = tv-&gt;vval.v_string;</a>
<a name="ln691">  int save_magic;</a>
<a name="ln692">  char_u      *save_cpo;</a>
<a name="ln693">  buf_T       *buf;</a>
<a name="ln694"> </a>
<a name="ln695">  if (tv-&gt;v_type == VAR_NUMBER)</a>
<a name="ln696">    return buflist_findnr((int)tv-&gt;vval.v_number);</a>
<a name="ln697">  if (tv-&gt;v_type != VAR_STRING)</a>
<a name="ln698">    return NULL;</a>
<a name="ln699">  if (name == NULL || *name == NUL)</a>
<a name="ln700">    return curbuf;</a>
<a name="ln701">  if (name[0] == '$' &amp;&amp; name[1] == NUL)</a>
<a name="ln702">    return lastbuf;</a>
<a name="ln703"> </a>
<a name="ln704">  // Ignore 'magic' and 'cpoptions' here to make scripts portable</a>
<a name="ln705">  save_magic = p_magic;</a>
<a name="ln706">  p_magic = TRUE;</a>
<a name="ln707">  save_cpo = p_cpo;</a>
<a name="ln708">  p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln709"> </a>
<a name="ln710">  buf = buflist_findnr(buflist_findpat(name, name + STRLEN(name),</a>
<a name="ln711">                                       true, false, curtab_only));</a>
<a name="ln712"> </a>
<a name="ln713">  p_magic = save_magic;</a>
<a name="ln714">  p_cpo = save_cpo;</a>
<a name="ln715"> </a>
<a name="ln716">  // If not found, try expanding the name, like done for bufexists().</a>
<a name="ln717">  if (buf == NULL) {</a>
<a name="ln718">    buf = find_buffer(tv);</a>
<a name="ln719">  }</a>
<a name="ln720"> </a>
<a name="ln721">  return buf;</a>
<a name="ln722">}</a>
<a name="ln723"> </a>
<a name="ln724">/// Like tv_get_buf() but give an error message if the type is wrong.</a>
<a name="ln725">buf_T *tv_get_buf_from_arg(typval_T *const tv) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln726">{</a>
<a name="ln727">  if (!tv_check_str_or_nr(tv)) {</a>
<a name="ln728">    return NULL;</a>
<a name="ln729">  }</a>
<a name="ln730">  emsg_off++;</a>
<a name="ln731">  buf_T *const buf = tv_get_buf(tv, false);</a>
<a name="ln732">  emsg_off--;</a>
<a name="ln733">  return buf;</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736">/// Get the buffer from &quot;arg&quot; and give an error and return NULL if it is not</a>
<a name="ln737">/// valid.</a>
<a name="ln738">buf_T * get_buf_arg(typval_T *arg)</a>
<a name="ln739">{</a>
<a name="ln740">  buf_T *buf;</a>
<a name="ln741"> </a>
<a name="ln742">  emsg_off++;</a>
<a name="ln743">  buf = tv_get_buf(arg, false);</a>
<a name="ln744">  emsg_off--;</a>
<a name="ln745">  if (buf == NULL) {</a>
<a name="ln746">    EMSG2(_(&quot;E158: Invalid buffer name: %s&quot;), tv_get_string(arg));</a>
<a name="ln747">  }</a>
<a name="ln748">  return buf;</a>
<a name="ln749">}</a>
<a name="ln750"> </a>
<a name="ln751">/*</a>
<a name="ln752"> * &quot;byte2line(byte)&quot; function</a>
<a name="ln753"> */</a>
<a name="ln754">static void f_byte2line(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln755">{</a>
<a name="ln756">  long boff = tv_get_number(&amp;argvars[0]) - 1;</a>
<a name="ln757">  if (boff &lt; 0) {</a>
<a name="ln758">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln759">  } else {</a>
<a name="ln760">    rettv-&gt;vval.v_number = (varnumber_T)ml_find_line_or_offset(curbuf, 0,</a>
<a name="ln761">                                                               &amp;boff, false);</a>
<a name="ln762">  }</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765">static void byteidx(typval_T *argvars, typval_T *rettv, int comp)</a>
<a name="ln766">{</a>
<a name="ln767">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln768">  varnumber_T idx = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln769">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln770">  if (str == NULL || idx &lt; 0) {</a>
<a name="ln771">    return;</a>
<a name="ln772">  }</a>
<a name="ln773"> </a>
<a name="ln774">  const char *t = str;</a>
<a name="ln775">  for (; idx &gt; 0; idx--) {</a>
<a name="ln776">    if (*t == NUL) {  // EOL reached.</a>
<a name="ln777">      return;</a>
<a name="ln778">    }</a>
<a name="ln779">    if (comp) {</a>
<a name="ln780">      t += utf_ptr2len((const char_u *)t);</a>
<a name="ln781">    } else {</a>
<a name="ln782">      t += utfc_ptr2len((const char_u *)t);</a>
<a name="ln783">    }</a>
<a name="ln784">  }</a>
<a name="ln785">  rettv-&gt;vval.v_number = (varnumber_T)(t - str);</a>
<a name="ln786">}</a>
<a name="ln787"> </a>
<a name="ln788">/*</a>
<a name="ln789"> * &quot;byteidx()&quot; function</a>
<a name="ln790"> */</a>
<a name="ln791">static void f_byteidx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln792">{</a>
<a name="ln793">  byteidx(argvars, rettv, FALSE);</a>
<a name="ln794">}</a>
<a name="ln795"> </a>
<a name="ln796">/*</a>
<a name="ln797"> * &quot;byteidxcomp()&quot; function</a>
<a name="ln798"> */</a>
<a name="ln799">static void f_byteidxcomp(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln800">{</a>
<a name="ln801">  byteidx(argvars, rettv, TRUE);</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804">/// &quot;call(func, arglist [, dict])&quot; function</a>
<a name="ln805">static void f_call(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln806">{</a>
<a name="ln807">  if (argvars[1].v_type != VAR_LIST) {</a>
<a name="ln808">    EMSG(_(e_listreq));</a>
<a name="ln809">    return;</a>
<a name="ln810">  }</a>
<a name="ln811">  if (argvars[1].vval.v_list == NULL) {</a>
<a name="ln812">    return;</a>
<a name="ln813">  }</a>
<a name="ln814"> </a>
<a name="ln815">  bool owned = false;</a>
<a name="ln816">  char_u      *func;</a>
<a name="ln817">  partial_T   *partial = NULL;</a>
<a name="ln818">  dict_T      *selfdict = NULL;</a>
<a name="ln819">  if (argvars[0].v_type == VAR_FUNC) {</a>
<a name="ln820">    func = argvars[0].vval.v_string;</a>
<a name="ln821">  } else if (argvars[0].v_type == VAR_PARTIAL) {</a>
<a name="ln822">    partial = argvars[0].vval.v_partial;</a>
<a name="ln823">    func = partial_name(partial);</a>
<a name="ln824">  } else if (nlua_is_table_from_lua(&amp;argvars[0])) {</a>
<a name="ln825">    func = nlua_register_table_as_callable(&amp;argvars[0]);</a>
<a name="ln826">    owned = true;</a>
<a name="ln827">  } else {</a>
<a name="ln828">    func = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln829">  }</a>
<a name="ln830"> </a>
<a name="ln831">  if (*func == NUL) {</a>
<a name="ln832">    return;             // type error or empty name</a>
<a name="ln833">  }</a>
<a name="ln834"> </a>
<a name="ln835">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln836">    if (argvars[2].v_type != VAR_DICT) {</a>
<a name="ln837">      EMSG(_(e_dictreq));</a>
<a name="ln838">      return;</a>
<a name="ln839">    }</a>
<a name="ln840">    selfdict = argvars[2].vval.v_dict;</a>
<a name="ln841">  }</a>
<a name="ln842"> </a>
<a name="ln843">  func_call(func, &amp;argvars[1], partial, selfdict, rettv);</a>
<a name="ln844">  if (owned) {</a>
<a name="ln845">    func_unref(func);</a>
<a name="ln846">  }</a>
<a name="ln847">}</a>
<a name="ln848"> </a>
<a name="ln849">/*</a>
<a name="ln850"> * &quot;changenr()&quot; function</a>
<a name="ln851"> */</a>
<a name="ln852">static void f_changenr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln853">{</a>
<a name="ln854">  rettv-&gt;vval.v_number = curbuf-&gt;b_u_seq_cur;</a>
<a name="ln855">}</a>
<a name="ln856"> </a>
<a name="ln857">// &quot;chanclose(id[, stream])&quot; function</a>
<a name="ln858">static void f_chanclose(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln859">{</a>
<a name="ln860">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln861">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln862"> </a>
<a name="ln863">  if (check_secure()) {</a>
<a name="ln864">    return;</a>
<a name="ln865">  }</a>
<a name="ln866"> </a>
<a name="ln867">  if (argvars[0].v_type != VAR_NUMBER || (argvars[1].v_type != VAR_STRING</a>
<a name="ln868">        &amp;&amp; argvars[1].v_type != VAR_UNKNOWN)) {</a>
<a name="ln869">    EMSG(_(e_invarg));</a>
<a name="ln870">    return;</a>
<a name="ln871">  }</a>
<a name="ln872"> </a>
<a name="ln873">  ChannelPart part = kChannelPartAll;</a>
<a name="ln874">  if (argvars[1].v_type == VAR_STRING) {</a>
<a name="ln875">    char *stream = (char *)argvars[1].vval.v_string;</a>
<a name="ln876">    if (!strcmp(stream, &quot;stdin&quot;)) {</a>
<a name="ln877">      part = kChannelPartStdin;</a>
<a name="ln878">    } else if (!strcmp(stream, &quot;stdout&quot;)) {</a>
<a name="ln879">      part = kChannelPartStdout;</a>
<a name="ln880">    } else if (!strcmp(stream, &quot;stderr&quot;)) {</a>
<a name="ln881">      part = kChannelPartStderr;</a>
<a name="ln882">    } else if (!strcmp(stream, &quot;rpc&quot;)) {</a>
<a name="ln883">      part = kChannelPartRpc;</a>
<a name="ln884">    } else {</a>
<a name="ln885">      EMSG2(_(&quot;Invalid channel stream \&quot;%s\&quot;&quot;), stream);</a>
<a name="ln886">      return;</a>
<a name="ln887">    }</a>
<a name="ln888">  }</a>
<a name="ln889">  const char *error;</a>
<a name="ln890">  rettv-&gt;vval.v_number = channel_close(argvars[0].vval.v_number, part, &amp;error);</a>
<a name="ln891">  if (!rettv-&gt;vval.v_number) {</a>
<a name="ln892">    EMSG(error);</a>
<a name="ln893">  }</a>
<a name="ln894">}</a>
<a name="ln895"> </a>
<a name="ln896">// &quot;chansend(id, data)&quot; function</a>
<a name="ln897">static void f_chansend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln898">{</a>
<a name="ln899">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln900">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln901"> </a>
<a name="ln902">  if (check_secure()) {</a>
<a name="ln903">    return;</a>
<a name="ln904">  }</a>
<a name="ln905"> </a>
<a name="ln906">  if (argvars[0].v_type != VAR_NUMBER || argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln907">    // First argument is the channel id and second is the data to write</a>
<a name="ln908">    EMSG(_(e_invarg));</a>
<a name="ln909">    return;</a>
<a name="ln910">  }</a>
<a name="ln911"> </a>
<a name="ln912">  ptrdiff_t input_len = 0;</a>
<a name="ln913">  char *input = save_tv_as_string(&amp;argvars[1], &amp;input_len, false);</a>
<a name="ln914">  if (!input) {</a>
<a name="ln915">    // Either the error has been handled by save_tv_as_string(),</a>
<a name="ln916">    // or there is no input to send.</a>
<a name="ln917">    return;</a>
<a name="ln918">  }</a>
<a name="ln919">  uint64_t id = argvars[0].vval.v_number;</a>
<a name="ln920">  const char *error = NULL;</a>
<a name="ln921">  rettv-&gt;vval.v_number = channel_send(id, input, input_len, true, &amp;error);</a>
<a name="ln922">  if (error) {</a>
<a name="ln923">    EMSG(error);</a>
<a name="ln924">  }</a>
<a name="ln925">}</a>
<a name="ln926"> </a>
<a name="ln927">/*</a>
<a name="ln928"> * &quot;char2nr(string)&quot; function</a>
<a name="ln929"> */</a>
<a name="ln930">static void f_char2nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln931">{</a>
<a name="ln932">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln933">    if (!tv_check_num(&amp;argvars[1])) {</a>
<a name="ln934">      return;</a>
<a name="ln935">    }</a>
<a name="ln936">  }</a>
<a name="ln937"> </a>
<a name="ln938">  rettv-&gt;vval.v_number = utf_ptr2char(</a>
<a name="ln939">      (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln940">}</a>
<a name="ln941"> </a>
<a name="ln942">// &quot;charidx()&quot; function</a>
<a name="ln943">static void f_charidx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln944">{</a>
<a name="ln945">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln946"> </a>
<a name="ln947">  if (argvars[0].v_type != VAR_STRING</a>
<a name="ln948">      || argvars[1].v_type != VAR_NUMBER</a>
<a name="ln949">      || (argvars[2].v_type != VAR_UNKNOWN</a>
<a name="ln950">          &amp;&amp; argvars[2].v_type != VAR_NUMBER)) {</a>
<a name="ln951">    EMSG(_(e_invarg));</a>
<a name="ln952">    return;</a>
<a name="ln953">  }</a>
<a name="ln954"> </a>
<a name="ln955">  const char *str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln956">  varnumber_T idx = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln957">  if (str == NULL || idx &lt; 0) {</a>
<a name="ln958">    return;</a>
<a name="ln959">  }</a>
<a name="ln960">  int countcc = 0;</a>
<a name="ln961">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln962">    countcc = (int)tv_get_number(&amp;argvars[2]);</a>
<a name="ln963">  }</a>
<a name="ln964">  if (countcc &lt; 0 || countcc &gt; 1) {</a>
<a name="ln965">    EMSG(_(e_invarg));</a>
<a name="ln966">    return;</a>
<a name="ln967">  }</a>
<a name="ln968"> </a>
<a name="ln969">  int (*ptr2len)(const char_u *);</a>
<a name="ln970">  if (countcc) {</a>
<a name="ln971">    ptr2len = utf_ptr2len;</a>
<a name="ln972">  } else {</a>
<a name="ln973">    ptr2len = utfc_ptr2len;</a>
<a name="ln974">  }</a>
<a name="ln975"> </a>
<a name="ln976">  const char *p;</a>
<a name="ln977">  int len;</a>
<a name="ln978">  for (p = str, len = 0; p &lt;= str + idx; len++) {</a>
<a name="ln979">    if (*p == NUL) {</a>
<a name="ln980">      return;</a>
<a name="ln981">    }</a>
<a name="ln982">    p += ptr2len((const char_u *)p);</a>
<a name="ln983">  }</a>
<a name="ln984"> </a>
<a name="ln985">  rettv-&gt;vval.v_number = len &gt; 0 ? len - 1 : 0;</a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988">/*</a>
<a name="ln989"> * &quot;cindent(lnum)&quot; function</a>
<a name="ln990"> */</a>
<a name="ln991">static void f_cindent(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln992">{</a>
<a name="ln993">  pos_T pos;</a>
<a name="ln994">  linenr_T lnum;</a>
<a name="ln995"> </a>
<a name="ln996">  pos = curwin-&gt;w_cursor;</a>
<a name="ln997">  lnum = tv_get_lnum(argvars);</a>
<a name="ln998">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln999">    curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln1000">    rettv-&gt;vval.v_number = get_c_indent();</a>
<a name="ln1001">    curwin-&gt;w_cursor = pos;</a>
<a name="ln1002">  } else</a>
<a name="ln1003">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln1004">}</a>
<a name="ln1005"> </a>
<a name="ln1006">static win_T * get_optional_window(typval_T *argvars, int idx)</a>
<a name="ln1007">{</a>
<a name="ln1008">  win_T *win = curwin;</a>
<a name="ln1009"> </a>
<a name="ln1010">  if (argvars[idx].v_type != VAR_UNKNOWN) {</a>
<a name="ln1011">    win = find_win_by_nr_or_id(&amp;argvars[idx]);</a>
<a name="ln1012">    if (win == NULL) {</a>
<a name="ln1013">      EMSG(_(e_invalwindow));</a>
<a name="ln1014">      return NULL;</a>
<a name="ln1015">    }</a>
<a name="ln1016">  }</a>
<a name="ln1017">  return win;</a>
<a name="ln1018">}</a>
<a name="ln1019"> </a>
<a name="ln1020">/*</a>
<a name="ln1021"> * &quot;clearmatches()&quot; function</a>
<a name="ln1022"> */</a>
<a name="ln1023">static void f_clearmatches(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1024">{</a>
<a name="ln1025">  win_T *win = get_optional_window(argvars, 0);</a>
<a name="ln1026"> </a>
<a name="ln1027">  if (win != NULL) {</a>
<a name="ln1028">    clear_matches(win);</a>
<a name="ln1029">  }</a>
<a name="ln1030">}</a>
<a name="ln1031"> </a>
<a name="ln1032">/*</a>
<a name="ln1033"> * &quot;col(string)&quot; function</a>
<a name="ln1034"> */</a>
<a name="ln1035">static void f_col(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1036">{</a>
<a name="ln1037">  colnr_T col = 0;</a>
<a name="ln1038">  pos_T       *fp;</a>
<a name="ln1039">  int fnum = curbuf-&gt;b_fnum;</a>
<a name="ln1040"> </a>
<a name="ln1041">  fp = var2fpos(&amp;argvars[0], FALSE, &amp;fnum);</a>
<a name="ln1042">  if (fp != NULL &amp;&amp; fnum == curbuf-&gt;b_fnum) {</a>
<a name="ln1043">    if (fp-&gt;col == MAXCOL) {</a>
<a name="ln1044">      // '&gt; can be MAXCOL, get the length of the line then</a>
<a name="ln1045">      if (fp-&gt;lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1046">        col = (colnr_T)STRLEN(ml_get(fp-&gt;lnum)) + 1;</a>
<a name="ln1047">      } else {</a>
<a name="ln1048">        col = MAXCOL;</a>
<a name="ln1049">      }</a>
<a name="ln1050">    } else {</a>
<a name="ln1051">      col = fp-&gt;col + 1;</a>
<a name="ln1052">      // col(&quot;.&quot;) when the cursor is on the NUL at the end of the line</a>
<a name="ln1053">      // because of &quot;coladd&quot; can be seen as an extra column.</a>
<a name="ln1054">      if (virtual_active() &amp;&amp; fp == &amp;curwin-&gt;w_cursor) {</a>
<a name="ln1055">        char_u  *p = get_cursor_pos_ptr();</a>
<a name="ln1056"> </a>
<a name="ln1057">        if (curwin-&gt;w_cursor.coladd &gt;= (colnr_T)chartabsize(p,</a>
<a name="ln1058">                curwin-&gt;w_virtcol - curwin-&gt;w_cursor.coladd)) {</a>
<a name="ln1059">          int l;</a>
<a name="ln1060"> </a>
<a name="ln1061">          if (*p != NUL &amp;&amp; p[(l = (*mb_ptr2len)(p))] == NUL)</a>
<a name="ln1062">            col += l;</a>
<a name="ln1063">        }</a>
<a name="ln1064">      }</a>
<a name="ln1065">    }</a>
<a name="ln1066">  }</a>
<a name="ln1067">  rettv-&gt;vval.v_number = col;</a>
<a name="ln1068">}</a>
<a name="ln1069"> </a>
<a name="ln1070">/*</a>
<a name="ln1071"> * &quot;complete()&quot; function</a>
<a name="ln1072"> */</a>
<a name="ln1073">static void f_complete(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1074">{</a>
<a name="ln1075">  if ((State &amp; INSERT) == 0) {</a>
<a name="ln1076">    EMSG(_(&quot;E785: complete() can only be used in Insert mode&quot;));</a>
<a name="ln1077">    return;</a>
<a name="ln1078">  }</a>
<a name="ln1079"> </a>
<a name="ln1080">  /* Check for undo allowed here, because if something was already inserted</a>
<a name="ln1081">   * the line was already saved for undo and this check isn't done. */</a>
<a name="ln1082">  if (!undo_allowed())</a>
<a name="ln1083">    return;</a>
<a name="ln1084"> </a>
<a name="ln1085">  if (argvars[1].v_type != VAR_LIST) {</a>
<a name="ln1086">    EMSG(_(e_invarg));</a>
<a name="ln1087">    return;</a>
<a name="ln1088">  }</a>
<a name="ln1089"> </a>
<a name="ln1090">  const colnr_T startcol = tv_get_number_chk(&amp;argvars[0], NULL);</a>
<a name="ln1091">  if (startcol &lt;= 0) {</a>
<a name="ln1092">    return;</a>
<a name="ln1093">  }</a>
<a name="ln1094"> </a>
<a name="ln1095">  set_completion(startcol - 1, argvars[1].vval.v_list);</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">/*</a>
<a name="ln1099"> * &quot;complete_add()&quot; function</a>
<a name="ln1100"> */</a>
<a name="ln1101">static void f_complete_add(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1102">{</a>
<a name="ln1103">  rettv-&gt;vval.v_number = ins_compl_add_tv(&amp;argvars[0], 0, false);</a>
<a name="ln1104">}</a>
<a name="ln1105"> </a>
<a name="ln1106">/*</a>
<a name="ln1107"> * &quot;complete_check()&quot; function</a>
<a name="ln1108"> */</a>
<a name="ln1109">static void f_complete_check(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1110">{</a>
<a name="ln1111">  int saved = RedrawingDisabled;</a>
<a name="ln1112"> </a>
<a name="ln1113">  RedrawingDisabled = 0;</a>
<a name="ln1114">  ins_compl_check_keys(0, true);</a>
<a name="ln1115">  rettv-&gt;vval.v_number = compl_interrupted;</a>
<a name="ln1116">  RedrawingDisabled = saved;</a>
<a name="ln1117">}</a>
<a name="ln1118"> </a>
<a name="ln1119">// &quot;complete_info()&quot; function</a>
<a name="ln1120">static void f_complete_info(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1121">{</a>
<a name="ln1122">  tv_dict_alloc_ret(rettv);</a>
<a name="ln1123"> </a>
<a name="ln1124">  list_T *what_list = NULL;</a>
<a name="ln1125"> </a>
<a name="ln1126">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln1127">    if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln1128">      EMSG(_(e_listreq));</a>
<a name="ln1129">      return;</a>
<a name="ln1130">    }</a>
<a name="ln1131">    what_list = argvars[0].vval.v_list;</a>
<a name="ln1132">  }</a>
<a name="ln1133">  get_complete_info(what_list, rettv-&gt;vval.v_dict);</a>
<a name="ln1134">}</a>
<a name="ln1135"> </a>
<a name="ln1136">/*</a>
<a name="ln1137"> * &quot;confirm(message, buttons[, default [, type]])&quot; function</a>
<a name="ln1138"> */</a>
<a name="ln1139">static void f_confirm(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1140">{</a>
<a name="ln1141">  char buf[NUMBUFLEN];</a>
<a name="ln1142">  char buf2[NUMBUFLEN];</a>
<a name="ln1143">  const char *message;</a>
<a name="ln1144">  const char *buttons = NULL;</a>
<a name="ln1145">  int def = 1;</a>
<a name="ln1146">  int type = VIM_GENERIC;</a>
<a name="ln1147">  const char *typestr;</a>
<a name="ln1148">  bool error = false;</a>
<a name="ln1149"> </a>
<a name="ln1150">  message = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln1151">  if (message == NULL) {</a>
<a name="ln1152">    error = true;</a>
<a name="ln1153">  }</a>
<a name="ln1154">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1155">    buttons = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln1156">    if (buttons == NULL) {</a>
<a name="ln1157">      error = true;</a>
<a name="ln1158">    }</a>
<a name="ln1159">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1160">      def = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln1161">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln1162">        typestr = tv_get_string_buf_chk(&amp;argvars[3], buf2);</a>
<a name="ln1163">        if (typestr == NULL) {</a>
<a name="ln1164">          error = true;</a>
<a name="ln1165">        } else {</a>
<a name="ln1166">          switch (TOUPPER_ASC(*typestr)) {</a>
<a name="ln1167">            case 'E': type = VIM_ERROR; break;</a>
<a name="ln1168">            case 'Q': type = VIM_QUESTION; break;</a>
<a name="ln1169">            case 'I': type = VIM_INFO; break;</a>
<a name="ln1170">            case 'W': type = VIM_WARNING; break;</a>
<a name="ln1171">            case 'G': type = VIM_GENERIC; break;</a>
<a name="ln1172">          }</a>
<a name="ln1173">        }</a>
<a name="ln1174">      }</a>
<a name="ln1175">    }</a>
<a name="ln1176">  }</a>
<a name="ln1177"> </a>
<a name="ln1178">  if (buttons == NULL || *buttons == NUL) {</a>
<a name="ln1179">    buttons = _(&quot;&amp;Ok&quot;);</a>
<a name="ln1180">  }</a>
<a name="ln1181"> </a>
<a name="ln1182">  if (!error) {</a>
<a name="ln1183">    rettv-&gt;vval.v_number = do_dialog(</a>
<a name="ln1184">        type, NULL, (char_u *)message, (char_u *)buttons, def, NULL, false);</a>
<a name="ln1185">  }</a>
<a name="ln1186">}</a>
<a name="ln1187"> </a>
<a name="ln1188">/*</a>
<a name="ln1189"> * &quot;copy()&quot; function</a>
<a name="ln1190"> */</a>
<a name="ln1191">static void f_copy(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1192">{</a>
<a name="ln1193">  var_item_copy(NULL, &amp;argvars[0], rettv, false, 0);</a>
<a name="ln1194">}</a>
<a name="ln1195"> </a>
<a name="ln1196">/*</a>
<a name="ln1197"> * &quot;count()&quot; function</a>
<a name="ln1198"> */</a>
<a name="ln1199">static void f_count(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1200">{</a>
<a name="ln1201">  long n = 0;</a>
<a name="ln1202">  int ic = 0;</a>
<a name="ln1203">  bool error = false;</a>
<a name="ln1204"> </a>
<a name="ln1205">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1206">    ic = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln1207">  }</a>
<a name="ln1208"> </a>
<a name="ln1209">  if (argvars[0].v_type == VAR_STRING) {</a>
<a name="ln1210">    const char_u *expr = (char_u *)tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln1211">    const char_u *p = argvars[0].vval.v_string;</a>
<a name="ln1212"> </a>
<a name="ln1213">    if (!error &amp;&amp; expr != NULL &amp;&amp; *expr != NUL &amp;&amp; p != NULL) {</a>
<a name="ln1214">      if (ic) {</a>
<a name="ln1215">        const size_t len = STRLEN(expr);</a>
<a name="ln1216"> </a>
<a name="ln1217">        while (*p != NUL) {</a>
<a name="ln1218">          if (mb_strnicmp(p, expr, len) == 0) {</a>
<a name="ln1219">            n++;</a>
<a name="ln1220">            p += len;</a>
<a name="ln1221">          } else {</a>
<a name="ln1222">            MB_PTR_ADV(p);</a>
<a name="ln1223">          }</a>
<a name="ln1224">        }</a>
<a name="ln1225">      } else {</a>
<a name="ln1226">        char_u *next;</a>
<a name="ln1227">        while ((next = (char_u *)strstr((char *)p, (char *)expr)) != NULL) {</a>
<a name="ln1228">          n++;</a>
<a name="ln1229">          p = next + STRLEN(expr);</a>
<a name="ln1230">        }</a>
<a name="ln1231">      }</a>
<a name="ln1232">    }</a>
<a name="ln1233">  } else if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln1234">    listitem_T      *li;</a>
<a name="ln1235">    list_T          *l;</a>
<a name="ln1236">    long idx;</a>
<a name="ln1237"> </a>
<a name="ln1238">    if ((l = argvars[0].vval.v_list) != NULL) {</a>
<a name="ln1239">      li = tv_list_first(l);</a>
<a name="ln1240">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1241">        if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln1242">          idx = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln1243">          if (!error) {</a>
<a name="ln1244">            li = tv_list_find(l, idx);</a>
<a name="ln1245">            if (li == NULL) {</a>
<a name="ln1246">              EMSGN(_(e_listidx), idx);</a>
<a name="ln1247">            }</a>
<a name="ln1248">          }</a>
<a name="ln1249">        }</a>
<a name="ln1250">        if (error)</a>
<a name="ln1251">          li = NULL;</a>
<a name="ln1252">      }</a>
<a name="ln1253"> </a>
<a name="ln1254">      for (; li != NULL; li = TV_LIST_ITEM_NEXT(l, li)) {</a>
<a name="ln1255">        if (tv_equal(TV_LIST_ITEM_TV(li), &amp;argvars[1], ic, false)) {</a>
<a name="ln1256">          n++;</a>
<a name="ln1257">        }</a>
<a name="ln1258">      }</a>
<a name="ln1259">    }</a>
<a name="ln1260">  } else if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln1261">    int todo;</a>
<a name="ln1262">    dict_T          *d;</a>
<a name="ln1263">    hashitem_T      *hi;</a>
<a name="ln1264"> </a>
<a name="ln1265">    if ((d = argvars[0].vval.v_dict) != NULL) {</a>
<a name="ln1266">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1267">        if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln1268">          EMSG(_(e_invarg));</a>
<a name="ln1269">        }</a>
<a name="ln1270">      }</a>
<a name="ln1271"> </a>
<a name="ln1272">      todo = error ? 0 : (int)d-&gt;dv_hashtab.ht_used;</a>
<a name="ln1273">      for (hi = d-&gt;dv_hashtab.ht_array; todo &gt; 0; ++hi) {</a>
<a name="ln1274">        if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1275">          todo--;</a>
<a name="ln1276">          if (tv_equal(&amp;TV_DICT_HI2DI(hi)-&gt;di_tv, &amp;argvars[1], ic, false)) {</a>
<a name="ln1277">            n++;</a>
<a name="ln1278">          }</a>
<a name="ln1279">        }</a>
<a name="ln1280">      }</a>
<a name="ln1281">    }</a>
<a name="ln1282">  } else {</a>
<a name="ln1283">    EMSG2(_(e_listdictarg), &quot;count()&quot;);</a>
<a name="ln1284">  }</a>
<a name="ln1285">  rettv-&gt;vval.v_number = n;</a>
<a name="ln1286">}</a>
<a name="ln1287"> </a>
<a name="ln1288">/*</a>
<a name="ln1289"> * &quot;cscope_connection([{num} , {dbpath} [, {prepend}]])&quot; function</a>
<a name="ln1290"> *</a>
<a name="ln1291"> * Checks the existence of a cscope connection.</a>
<a name="ln1292"> */</a>
<a name="ln1293">static void f_cscope_connection(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1294">{</a>
<a name="ln1295">  int num = 0;</a>
<a name="ln1296">  const char *dbpath = NULL;</a>
<a name="ln1297">  const char *prepend = NULL;</a>
<a name="ln1298">  char buf[NUMBUFLEN];</a>
<a name="ln1299"> </a>
<a name="ln1300">  if (argvars[0].v_type != VAR_UNKNOWN</a>
<a name="ln1301">      &amp;&amp; argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1302">    num = (int)tv_get_number(&amp;argvars[0]);</a>
<a name="ln1303">    dbpath = tv_get_string(&amp;argvars[1]);</a>
<a name="ln1304">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1305">      prepend = tv_get_string_buf(&amp;argvars[2], buf);</a>
<a name="ln1306">    }</a>
<a name="ln1307">  }</a>
<a name="ln1308"> </a>
<a name="ln1309">  rettv-&gt;vval.v_number = cs_connection(num, (char_u *)dbpath,</a>
<a name="ln1310">                                       (char_u *)prepend);</a>
<a name="ln1311">}</a>
<a name="ln1312"> </a>
<a name="ln1313">/// &quot;ctxget([{index}])&quot; function</a>
<a name="ln1314">static void f_ctxget(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1315">{</a>
<a name="ln1316">  size_t index = 0;</a>
<a name="ln1317">  if (argvars[0].v_type == VAR_NUMBER) {</a>
<a name="ln1318">    index = argvars[0].vval.v_number;</a>
<a name="ln1319">  } else if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln1320">    EMSG2(_(e_invarg2), &quot;expected nothing or a Number as an argument&quot;);</a>
<a name="ln1321">    return;</a>
<a name="ln1322">  }</a>
<a name="ln1323"> </a>
<a name="ln1324">  Context *ctx = ctx_get(index);</a>
<a name="ln1325">  if (ctx == NULL) {</a>
<a name="ln1326">    EMSG3(_(e_invargNval), &quot;index&quot;, &quot;out of bounds&quot;);</a>
<a name="ln1327">    return;</a>
<a name="ln1328">  }</a>
<a name="ln1329"> </a>
<a name="ln1330">  Dictionary ctx_dict = ctx_to_dict(ctx);</a>
<a name="ln1331">  Error err = ERROR_INIT;</a>
<a name="ln1332">  object_to_vim(DICTIONARY_OBJ(ctx_dict), rettv, &amp;err);</a>
<a name="ln1333">  api_free_dictionary(ctx_dict);</a>
<a name="ln1334">  api_clear_error(&amp;err);</a>
<a name="ln1335">}</a>
<a name="ln1336"> </a>
<a name="ln1337">/// &quot;ctxpop()&quot; function</a>
<a name="ln1338">static void f_ctxpop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1339">{</a>
<a name="ln1340">  if (!ctx_restore(NULL, kCtxAll)) {</a>
<a name="ln1341">    EMSG(_(&quot;Context stack is empty&quot;));</a>
<a name="ln1342">  }</a>
<a name="ln1343">}</a>
<a name="ln1344"> </a>
<a name="ln1345">/// &quot;ctxpush([{types}])&quot; function</a>
<a name="ln1346">static void f_ctxpush(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1347">{</a>
<a name="ln1348">  int types = kCtxAll;</a>
<a name="ln1349">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln1350">    types = 0;</a>
<a name="ln1351">    TV_LIST_ITER(argvars[0].vval.v_list, li, {</a>
<a name="ln1352">      typval_T *tv_li = TV_LIST_ITEM_TV(li);</a>
<a name="ln1353">      if (tv_li-&gt;v_type == VAR_STRING) {</a>
<a name="ln1354">        if (strequal((char *)tv_li-&gt;vval.v_string, &quot;regs&quot;)) {</a>
<a name="ln1355">          types |= kCtxRegs;</a>
<a name="ln1356">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;jumps&quot;)) {</a>
<a name="ln1357">          types |= kCtxJumps;</a>
<a name="ln1358">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;bufs&quot;)) {</a>
<a name="ln1359">          types |= kCtxBufs;</a>
<a name="ln1360">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;gvars&quot;)) {</a>
<a name="ln1361">          types |= kCtxGVars;</a>
<a name="ln1362">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;sfuncs&quot;)) {</a>
<a name="ln1363">          types |= kCtxSFuncs;</a>
<a name="ln1364">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;funcs&quot;)) {</a>
<a name="ln1365">          types |= kCtxFuncs;</a>
<a name="ln1366">        }</a>
<a name="ln1367">      }</a>
<a name="ln1368">    });</a>
<a name="ln1369">  } else if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln1370">    EMSG2(_(e_invarg2), &quot;expected nothing or a List as an argument&quot;);</a>
<a name="ln1371">    return;</a>
<a name="ln1372">  }</a>
<a name="ln1373">  ctx_save(NULL, types);</a>
<a name="ln1374">}</a>
<a name="ln1375"> </a>
<a name="ln1376">/// &quot;ctxset({context}[, {index}])&quot; function</a>
<a name="ln1377">static void f_ctxset(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1378">{</a>
<a name="ln1379">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln1380">    EMSG2(_(e_invarg2), &quot;expected dictionary as first argument&quot;);</a>
<a name="ln1381">    return;</a>
<a name="ln1382">  }</a>
<a name="ln1383"> </a>
<a name="ln1384">  size_t index = 0;</a>
<a name="ln1385">  if (argvars[1].v_type == VAR_NUMBER) {</a>
<a name="ln1386">    index = argvars[1].vval.v_number;</a>
<a name="ln1387">  } else if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1388">    EMSG2(_(e_invarg2), &quot;expected nothing or a Number as second argument&quot;);</a>
<a name="ln1389">    return;</a>
<a name="ln1390">  }</a>
<a name="ln1391"> </a>
<a name="ln1392">  Context *ctx = ctx_get(index);</a>
<a name="ln1393">  if (ctx == NULL) {</a>
<a name="ln1394">    EMSG3(_(e_invargNval), &quot;index&quot;, &quot;out of bounds&quot;);</a>
<a name="ln1395">    return;</a>
<a name="ln1396">  }</a>
<a name="ln1397"> </a>
<a name="ln1398">  int save_did_emsg = did_emsg;</a>
<a name="ln1399">  did_emsg = false;</a>
<a name="ln1400"> </a>
<a name="ln1401">  Dictionary dict = vim_to_object(&amp;argvars[0]).data.dictionary;</a>
<a name="ln1402">  Context tmp = CONTEXT_INIT;</a>
<a name="ln1403">  ctx_from_dict(dict, &amp;tmp);</a>
<a name="ln1404"> </a>
<a name="ln1405">  if (did_emsg) {</a>
<a name="ln1406">    ctx_free(&amp;tmp);</a>
<a name="ln1407">  } else {</a>
<a name="ln1408">    ctx_free(ctx);</a>
<a name="ln1409">    *ctx = tmp;</a>
<a name="ln1410">  }</a>
<a name="ln1411"> </a>
<a name="ln1412">  api_free_dictionary(dict);</a>
<a name="ln1413">  did_emsg = save_did_emsg;</a>
<a name="ln1414">}</a>
<a name="ln1415"> </a>
<a name="ln1416">/// &quot;ctxsize()&quot; function</a>
<a name="ln1417">static void f_ctxsize(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1418">{</a>
<a name="ln1419">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln1420">  rettv-&gt;vval.v_number = ctx_size();</a>
<a name="ln1421">}</a>
<a name="ln1422"> </a>
<a name="ln1423">/// &quot;cursor(lnum, col)&quot; function, or</a>
<a name="ln1424">/// &quot;cursor(list)&quot;</a>
<a name="ln1425">///</a>
<a name="ln1426">/// Moves the cursor to the specified line and column.</a>
<a name="ln1427">///</a>
<a name="ln1428">/// @returns 0 when the position could be set, -1 otherwise.</a>
<a name="ln1429">static void f_cursor(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1430">{</a>
<a name="ln1431">  long line, col;</a>
<a name="ln1432">  long coladd = 0;</a>
<a name="ln1433">  bool set_curswant = true;</a>
<a name="ln1434"> </a>
<a name="ln1435">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln1436">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln1437">    pos_T pos;</a>
<a name="ln1438">    colnr_T curswant = -1;</a>
<a name="ln1439"> </a>
<a name="ln1440">    if (list2fpos(argvars, &amp;pos, NULL, &amp;curswant) == FAIL) {</a>
<a name="ln1441">      EMSG(_(e_invarg));</a>
<a name="ln1442">      return;</a>
<a name="ln1443">    }</a>
<a name="ln1444"> </a>
<a name="ln1445">    line = pos.lnum;</a>
<a name="ln1446">    col = pos.col;</a>
<a name="ln1447">    coladd = pos.coladd;</a>
<a name="ln1448">    if (curswant &gt;= 0) {</a>
<a name="ln1449">      curwin-&gt;w_curswant = curswant - 1;</a>
<a name="ln1450">      set_curswant = false;</a>
<a name="ln1451">    }</a>
<a name="ln1452">  } else {</a>
<a name="ln1453">    line = tv_get_lnum(argvars);</a>
<a name="ln1454">    col = (long)tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln1455">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1456">      coladd = (long)tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln1457">    }</a>
<a name="ln1458">  }</a>
<a name="ln1459">  if (line &lt; 0 || col &lt; 0</a>
<a name="ln1460">      || coladd &lt; 0) {</a>
<a name="ln1461">    return;             // type error; errmsg already given</a>
<a name="ln1462">  }</a>
<a name="ln1463">  if (line &gt; 0) {</a>
<a name="ln1464">    curwin-&gt;w_cursor.lnum = line;</a>
<a name="ln1465">  }</a>
<a name="ln1466">  if (col &gt; 0) {</a>
<a name="ln1467">    curwin-&gt;w_cursor.col = col - 1;</a>
<a name="ln1468">  }</a>
<a name="ln1469">  curwin-&gt;w_cursor.coladd = coladd;</a>
<a name="ln1470"> </a>
<a name="ln1471">  // Make sure the cursor is in a valid position.</a>
<a name="ln1472">  check_cursor();</a>
<a name="ln1473">  // Correct cursor for multi-byte character.</a>
<a name="ln1474">  mb_adjust_cursor();</a>
<a name="ln1475"> </a>
<a name="ln1476">  curwin-&gt;w_set_curswant = set_curswant;</a>
<a name="ln1477">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln1478">}</a>
<a name="ln1479"> </a>
<a name="ln1480">// &quot;debugbreak()&quot; function</a>
<a name="ln1481">static void f_debugbreak(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1482">{</a>
<a name="ln1483">  int pid;</a>
<a name="ln1484"> </a>
<a name="ln1485">  rettv-&gt;vval.v_number = FAIL;</a>
<a name="ln1486">  pid = (int)tv_get_number(&amp;argvars[0]);</a>
<a name="ln1487">  if (pid == 0) {</a>
<a name="ln1488">    EMSG(_(e_invarg));</a>
<a name="ln1489">  } else {</a>
<a name="ln1490">#ifdef WIN32</a>
<a name="ln1491">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, pid);</a>
<a name="ln1492"> </a>
<a name="ln1493">    if (hProcess != NULL) {</a>
<a name="ln1494">      DebugBreakProcess(hProcess);</a>
<a name="ln1495">      CloseHandle(hProcess);</a>
<a name="ln1496">      rettv-&gt;vval.v_number = OK;</a>
<a name="ln1497">    }</a>
<a name="ln1498">#else</a>
<a name="ln1499">    uv_kill(pid, SIGINT);</a>
<a name="ln1500">#endif</a>
<a name="ln1501">  }</a>
<a name="ln1502">}</a>
<a name="ln1503"> </a>
<a name="ln1504">// &quot;deepcopy()&quot; function</a>
<a name="ln1505">static void f_deepcopy(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1506">{</a>
<a name="ln1507">  int noref = 0;</a>
<a name="ln1508"> </a>
<a name="ln1509">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1510">    noref = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln1511">  }</a>
<a name="ln1512">  if (noref &lt; 0 || noref &gt; 1) {</a>
<a name="ln1513">    EMSG(_(e_invarg));</a>
<a name="ln1514">  } else {</a>
<a name="ln1515">    var_item_copy(NULL, &amp;argvars[0], rettv, true, (noref == 0</a>
<a name="ln1516">                                                   ? get_copyID()</a>
<a name="ln1517">                                                   : 0));</a>
<a name="ln1518">  }</a>
<a name="ln1519">}</a>
<a name="ln1520"> </a>
<a name="ln1521">// &quot;delete()&quot; function</a>
<a name="ln1522">static void f_delete(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1523">{</a>
<a name="ln1524">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln1525">  if (check_secure()) {</a>
<a name="ln1526">    return;</a>
<a name="ln1527">  }</a>
<a name="ln1528"> </a>
<a name="ln1529">  const char *const name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln1530">  if (*name == NUL) {</a>
<a name="ln1531">    EMSG(_(e_invarg));</a>
<a name="ln1532">    return;</a>
<a name="ln1533">  }</a>
<a name="ln1534"> </a>
<a name="ln1535">  char nbuf[NUMBUFLEN];</a>
<a name="ln1536">  const char *flags;</a>
<a name="ln1537">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1538">    flags = tv_get_string_buf(&amp;argvars[1], nbuf);</a>
<a name="ln1539">  } else {</a>
<a name="ln1540">    flags = &quot;&quot;;</a>
<a name="ln1541">  }</a>
<a name="ln1542"> </a>
<a name="ln1543">  if (*flags == NUL) {</a>
<a name="ln1544">    // delete a file</a>
<a name="ln1545">    rettv-&gt;vval.v_number = os_remove(name) == 0 ? 0 : -1;</a>
<a name="ln1546">  } else if (strcmp(flags, &quot;d&quot;) == 0) {</a>
<a name="ln1547">    // delete an empty directory</a>
<a name="ln1548">    rettv-&gt;vval.v_number = os_rmdir(name) == 0 ? 0 : -1;</a>
<a name="ln1549">  } else if (strcmp(flags, &quot;rf&quot;) == 0) {</a>
<a name="ln1550">    // delete a directory recursively</a>
<a name="ln1551">    rettv-&gt;vval.v_number = delete_recursive(name);</a>
<a name="ln1552">  } else {</a>
<a name="ln1553">    emsgf(_(e_invexpr2), flags);</a>
<a name="ln1554">  }</a>
<a name="ln1555">}</a>
<a name="ln1556"> </a>
<a name="ln1557">// dictwatcheradd(dict, key, funcref) function</a>
<a name="ln1558">static void f_dictwatcheradd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1559">{</a>
<a name="ln1560">  if (check_secure()) {</a>
<a name="ln1561">    return;</a>
<a name="ln1562">  }</a>
<a name="ln1563"> </a>
<a name="ln1564">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln1565">    emsgf(_(e_invarg2), &quot;dict&quot;);</a>
<a name="ln1566">    return;</a>
<a name="ln1567">  } else if (argvars[0].vval.v_dict == NULL) {</a>
<a name="ln1568">    const char *const arg_errmsg = _(&quot;dictwatcheradd() argument&quot;);</a>
<a name="ln1569">    const size_t arg_errmsg_len = strlen(arg_errmsg);</a>
<a name="ln1570">    emsgf(_(e_readonlyvar), (int)arg_errmsg_len, arg_errmsg);</a>
<a name="ln1571">    return;</a>
<a name="ln1572">  }</a>
<a name="ln1573"> </a>
<a name="ln1574">  if (argvars[1].v_type != VAR_STRING &amp;&amp; argvars[1].v_type != VAR_NUMBER) {</a>
<a name="ln1575">    emsgf(_(e_invarg2), &quot;key&quot;);</a>
<a name="ln1576">    return;</a>
<a name="ln1577">  }</a>
<a name="ln1578"> </a>
<a name="ln1579">  const char *const key_pattern = tv_get_string_chk(argvars + 1);</a>
<a name="ln1580">  if (key_pattern == NULL) {</a>
<a name="ln1581">    return;</a>
<a name="ln1582">  }</a>
<a name="ln1583">  const size_t key_pattern_len = strlen(key_pattern);</a>
<a name="ln1584"> </a>
<a name="ln1585">  Callback callback;</a>
<a name="ln1586">  if (!callback_from_typval(&amp;callback, &amp;argvars[2])) {</a>
<a name="ln1587">    emsgf(_(e_invarg2), &quot;funcref&quot;);</a>
<a name="ln1588">    return;</a>
<a name="ln1589">  }</a>
<a name="ln1590"> </a>
<a name="ln1591">  tv_dict_watcher_add(argvars[0].vval.v_dict, key_pattern, key_pattern_len,</a>
<a name="ln1592">                      callback);</a>
<a name="ln1593">}</a>
<a name="ln1594"> </a>
<a name="ln1595">// dictwatcherdel(dict, key, funcref) function</a>
<a name="ln1596">static void f_dictwatcherdel(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1597">{</a>
<a name="ln1598">  if (check_secure()) {</a>
<a name="ln1599">    return;</a>
<a name="ln1600">  }</a>
<a name="ln1601"> </a>
<a name="ln1602">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln1603">    emsgf(_(e_invarg2), &quot;dict&quot;);</a>
<a name="ln1604">    return;</a>
<a name="ln1605">  }</a>
<a name="ln1606"> </a>
<a name="ln1607">  if (argvars[2].v_type != VAR_FUNC &amp;&amp; argvars[2].v_type != VAR_STRING) {</a>
<a name="ln1608">    emsgf(_(e_invarg2), &quot;funcref&quot;);</a>
<a name="ln1609">    return;</a>
<a name="ln1610">  }</a>
<a name="ln1611"> </a>
<a name="ln1612">  const char *const key_pattern = tv_get_string_chk(argvars + 1);</a>
<a name="ln1613">  if (key_pattern == NULL) {</a>
<a name="ln1614">    return;</a>
<a name="ln1615">  }</a>
<a name="ln1616"> </a>
<a name="ln1617">  Callback callback;</a>
<a name="ln1618">  if (!callback_from_typval(&amp;callback, &amp;argvars[2])) {</a>
<a name="ln1619">    return;</a>
<a name="ln1620">  }</a>
<a name="ln1621"> </a>
<a name="ln1622">  if (!tv_dict_watcher_remove(argvars[0].vval.v_dict, key_pattern,</a>
<a name="ln1623">                              strlen(key_pattern), callback)) {</a>
<a name="ln1624">    EMSG(&quot;Couldn't find a watcher matching key and callback&quot;);</a>
<a name="ln1625">  }</a>
<a name="ln1626"> </a>
<a name="ln1627">  callback_free(&amp;callback);</a>
<a name="ln1628">}</a>
<a name="ln1629"> </a>
<a name="ln1630">/// &quot;deletebufline()&quot; function</a>
<a name="ln1631">static void f_deletebufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1632">{</a>
<a name="ln1633">  linenr_T last;</a>
<a name="ln1634">  buf_T *curbuf_save = NULL;</a>
<a name="ln1635">  win_T *curwin_save = NULL;</a>
<a name="ln1636"> </a>
<a name="ln1637">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln1638">  if (buf == NULL) {</a>
<a name="ln1639">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln1640">    return;</a>
<a name="ln1641">  }</a>
<a name="ln1642">  const bool is_curbuf = buf == curbuf;</a>
<a name="ln1643"> </a>
<a name="ln1644">  const linenr_T first = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln1645">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1646">    last = tv_get_lnum_buf(&amp;argvars[2], buf);</a>
<a name="ln1647">  } else {</a>
<a name="ln1648">    last = first;</a>
<a name="ln1649">  }</a>
<a name="ln1650"> </a>
<a name="ln1651">  if (buf-&gt;b_ml.ml_mfp == NULL || first &lt; 1</a>
<a name="ln1652">      || first &gt; buf-&gt;b_ml.ml_line_count || last &lt; first) {</a>
<a name="ln1653">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln1654">    return;</a>
<a name="ln1655">  }</a>
<a name="ln1656"> </a>
<a name="ln1657">  if (!is_curbuf) {</a>
<a name="ln1658">    curbuf_save = curbuf;</a>
<a name="ln1659">    curwin_save = curwin;</a>
<a name="ln1660">    curbuf = buf;</a>
<a name="ln1661">    find_win_for_curbuf();</a>
<a name="ln1662">  }</a>
<a name="ln1663">  if (last &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1664">    last = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1665">  }</a>
<a name="ln1666">  const long count = last - first + 1;</a>
<a name="ln1667"> </a>
<a name="ln1668">  // When coming here from Insert mode, sync undo, so that this can be</a>
<a name="ln1669">  // undone separately from what was previously inserted.</a>
<a name="ln1670">  if (u_sync_once == 2) {</a>
<a name="ln1671">    u_sync_once = 1;  // notify that u_sync() was called</a>
<a name="ln1672">    u_sync(true);</a>
<a name="ln1673">  }</a>
<a name="ln1674"> </a>
<a name="ln1675">  if (u_save(first - 1, last + 1) == FAIL) {</a>
<a name="ln1676">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln1677">  } else {</a>
<a name="ln1678">    for (linenr_T lnum = first; lnum &lt;= last; lnum++) {</a>
<a name="ln1679">      ml_delete(first, true);</a>
<a name="ln1680">    }</a>
<a name="ln1681"> </a>
<a name="ln1682">    FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln1683">      if (wp-&gt;w_buffer == buf) {</a>
<a name="ln1684">        if (wp-&gt;w_cursor.lnum &gt; last) {</a>
<a name="ln1685">          wp-&gt;w_cursor.lnum -= count;</a>
<a name="ln1686">        } else if (wp-&gt;w_cursor.lnum&gt; first) {</a>
<a name="ln1687">          wp-&gt;w_cursor.lnum = first;</a>
<a name="ln1688">        }</a>
<a name="ln1689">        if (wp-&gt;w_cursor.lnum &gt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln1690">          wp-&gt;w_cursor.lnum = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln1691">        }</a>
<a name="ln1692">      }</a>
<a name="ln1693">    }</a>
<a name="ln1694">    check_cursor_col();</a>
<a name="ln1695">    deleted_lines_mark(first, count);</a>
<a name="ln1696">  }</a>
<a name="ln1697"> </a>
<a name="ln1698">  if (!is_curbuf) {</a>
<a name="ln1699">    curbuf = curbuf_save;</a>
<a name="ln1700">    curwin = curwin_save;</a>
<a name="ln1701">  }</a>
<a name="ln1702">}</a>
<a name="ln1703"> </a>
<a name="ln1704">/*</a>
<a name="ln1705"> * &quot;did_filetype()&quot; function</a>
<a name="ln1706"> */</a>
<a name="ln1707">static void f_did_filetype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1708">{</a>
<a name="ln1709">  rettv-&gt;vval.v_number = did_filetype;</a>
<a name="ln1710">}</a>
<a name="ln1711"> </a>
<a name="ln1712">/*</a>
<a name="ln1713"> * &quot;diff_filler()&quot; function</a>
<a name="ln1714"> */</a>
<a name="ln1715">static void f_diff_filler(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1716">{</a>
<a name="ln1717">  rettv-&gt;vval.v_number = diff_check_fill(curwin, tv_get_lnum(argvars));</a>
<a name="ln1718">}</a>
<a name="ln1719"> </a>
<a name="ln1720">/*</a>
<a name="ln1721"> * &quot;diff_hlID()&quot; function</a>
<a name="ln1722"> */</a>
<a name="ln1723">static void f_diff_hlID(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1724">{</a>
<a name="ln1725">  linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln1726">  static linenr_T prev_lnum = 0;</a>
<a name="ln1727">  static int changedtick = 0;</a>
<a name="ln1728">  static int fnum = 0;</a>
<a name="ln1729">  static int change_start = 0;</a>
<a name="ln1730">  static int change_end = 0;</a>
<a name="ln1731">  static hlf_T hlID = (hlf_T)0;</a>
<a name="ln1732">  int filler_lines;</a>
<a name="ln1733">  int col;</a>
<a name="ln1734"> </a>
<a name="ln1735">  if (lnum &lt; 0) {       // ignore type error in {lnum} arg</a>
<a name="ln1736">    lnum = 0;</a>
<a name="ln1737">  }</a>
<a name="ln1738">  if (lnum != prev_lnum</a>
<a name="ln1739">      || changedtick != buf_get_changedtick(curbuf)</a>
<a name="ln1740">      || fnum != curbuf-&gt;b_fnum) {</a>
<a name="ln1741">    // New line, buffer, change: need to get the values.</a>
<a name="ln1742">    filler_lines = diff_check(curwin, lnum);</a>
<a name="ln1743">    if (filler_lines &lt; 0) {</a>
<a name="ln1744">      if (filler_lines == -1) {</a>
<a name="ln1745">        change_start = MAXCOL;</a>
<a name="ln1746">        change_end = -1;</a>
<a name="ln1747">        if (diff_find_change(curwin, lnum, &amp;change_start, &amp;change_end)) {</a>
<a name="ln1748">          hlID = HLF_ADD;               // added line</a>
<a name="ln1749">        } else {</a>
<a name="ln1750">          hlID = HLF_CHD;               // changed line</a>
<a name="ln1751">        }</a>
<a name="ln1752">      } else {</a>
<a name="ln1753">        hlID = HLF_ADD;         // added line</a>
<a name="ln1754">      }</a>
<a name="ln1755">    } else {</a>
<a name="ln1756">      hlID = (hlf_T)0;</a>
<a name="ln1757">    }</a>
<a name="ln1758">    prev_lnum = lnum;</a>
<a name="ln1759">    changedtick = buf_get_changedtick(curbuf);</a>
<a name="ln1760">    fnum = curbuf-&gt;b_fnum;</a>
<a name="ln1761">  }</a>
<a name="ln1762"> </a>
<a name="ln1763">  if (hlID == HLF_CHD || hlID == HLF_TXD) {</a>
<a name="ln1764">    col = tv_get_number(&amp;argvars[1]) - 1;  // Ignore type error in {col}.</a>
<a name="ln1765">    if (col &gt;= change_start &amp;&amp; col &lt;= change_end) {</a>
<a name="ln1766">      hlID = HLF_TXD;  // Changed text.</a>
<a name="ln1767">    } else {</a>
<a name="ln1768">      hlID = HLF_CHD;  // Changed line.</a>
<a name="ln1769">    }</a>
<a name="ln1770">  }</a>
<a name="ln1771">  rettv-&gt;vval.v_number = hlID == (hlf_T)0 ? 0 : (int)(hlID + 1);</a>
<a name="ln1772">}</a>
<a name="ln1773"> </a>
<a name="ln1774">/*</a>
<a name="ln1775"> * &quot;empty({expr})&quot; function</a>
<a name="ln1776"> */</a>
<a name="ln1777">static void f_empty(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1778">{</a>
<a name="ln1779">  bool n = true;</a>
<a name="ln1780"> </a>
<a name="ln1781">  switch (argvars[0].v_type) {</a>
<a name="ln1782">    case VAR_STRING:</a>
<a name="ln1783">    case VAR_FUNC: {</a>
<a name="ln1784">      n = argvars[0].vval.v_string == NULL</a>
<a name="ln1785">          || *argvars[0].vval.v_string == NUL;</a>
<a name="ln1786">      break;</a>
<a name="ln1787">    }</a>
<a name="ln1788">    case VAR_PARTIAL: {</a>
<a name="ln1789">      n = false;</a>
<a name="ln1790">      break;</a>
<a name="ln1791">    }</a>
<a name="ln1792">    case VAR_NUMBER: {</a>
<a name="ln1793">      n = argvars[0].vval.v_number == 0;</a>
<a name="ln1794">      break;</a>
<a name="ln1795">    }</a>
<a name="ln1796">    case VAR_FLOAT: {</a>
<a name="ln1797">      n = argvars[0].vval.v_float == 0.0;</a>
<a name="ln1798">      break;</a>
<a name="ln1799">    }</a>
<a name="ln1800">    case VAR_LIST: {</a>
<a name="ln1801">      n = (tv_list_len(argvars[0].vval.v_list) == 0);</a>
<a name="ln1802">      break;</a>
<a name="ln1803">    }</a>
<a name="ln1804">    case VAR_DICT: {</a>
<a name="ln1805">      n = (tv_dict_len(argvars[0].vval.v_dict) == 0);</a>
<a name="ln1806">      break;</a>
<a name="ln1807">    }</a>
<a name="ln1808">    case VAR_BOOL: {</a>
<a name="ln1809">      switch (argvars[0].vval.v_bool) {</a>
<a name="ln1810">        case kBoolVarTrue: {</a>
<a name="ln1811">          n = false;</a>
<a name="ln1812">          break;</a>
<a name="ln1813">        }</a>
<a name="ln1814">        case kBoolVarFalse: {</a>
<a name="ln1815">          n = true;</a>
<a name="ln1816">          break;</a>
<a name="ln1817">        }</a>
<a name="ln1818">      }</a>
<a name="ln1819">      break;</a>
<a name="ln1820">    }</a>
<a name="ln1821">    case VAR_SPECIAL: {</a>
<a name="ln1822">      n = argvars[0].vval.v_special == kSpecialVarNull;</a>
<a name="ln1823">      break;</a>
<a name="ln1824">    }</a>
<a name="ln1825">    case VAR_UNKNOWN: {</a>
<a name="ln1826">      internal_error(&quot;f_empty(UNKNOWN)&quot;);</a>
<a name="ln1827">      break;</a>
<a name="ln1828">    }</a>
<a name="ln1829">  }</a>
<a name="ln1830"> </a>
<a name="ln1831">  rettv-&gt;vval.v_number = n;</a>
<a name="ln1832">}</a>
<a name="ln1833"> </a>
<a name="ln1834">/// &quot;environ()&quot; function</a>
<a name="ln1835">static void f_environ(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1836">{</a>
<a name="ln1837">  tv_dict_alloc_ret(rettv);</a>
<a name="ln1838"> </a>
<a name="ln1839">  size_t env_size = os_get_fullenv_size();</a>
<a name="ln1840">  char **env = xmalloc(sizeof(*env) * (env_size + 1));</a>
<a name="ln1841">  env[env_size] = NULL;</a>
<a name="ln1842"> </a>
<a name="ln1843">  os_copy_fullenv(env, env_size);</a>
<a name="ln1844"> </a>
<a name="ln1845">  for (ssize_t i = env_size - 1; i &gt;= 0; i--) {</a>
<a name="ln1846">    const char * str = env[i];</a>
<a name="ln1847">    const char * const end = strchr(str + (str[0] == '=' ? 1 : 0),</a>
<a name="ln1848">                                    '=');</a>
<a name="ln1849">    assert(end != NULL);</a>
<a name="ln1850">    ptrdiff_t len = end - str;</a>
<a name="ln1851">    assert(len &gt; 0);</a>
<a name="ln1852">    const char * value = str + len + 1;</a>
<a name="ln1853">    if (tv_dict_find(rettv-&gt;vval.v_dict, str, len) != NULL) {</a>
<a name="ln1854">      // Since we're traversing from the end of the env block to the front, any</a>
<a name="ln1855">      // duplicate names encountered should be ignored.  This preserves the</a>
<a name="ln1856">      // semantics of env vars defined later in the env block taking precedence.</a>
<a name="ln1857">      continue;</a>
<a name="ln1858">    }</a>
<a name="ln1859">    tv_dict_add_str(rettv-&gt;vval.v_dict,</a>
<a name="ln1860">                    str, len,</a>
<a name="ln1861">                    value);</a>
<a name="ln1862">  }</a>
<a name="ln1863">  os_free_fullenv(env);</a>
<a name="ln1864">}</a>
<a name="ln1865"> </a>
<a name="ln1866">/*</a>
<a name="ln1867"> * &quot;escape({string}, {chars})&quot; function</a>
<a name="ln1868"> */</a>
<a name="ln1869">static void f_escape(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1870">{</a>
<a name="ln1871">  char buf[NUMBUFLEN];</a>
<a name="ln1872"> </a>
<a name="ln1873">  rettv-&gt;vval.v_string = vim_strsave_escaped(</a>
<a name="ln1874">      (const char_u *)tv_get_string(&amp;argvars[0]),</a>
<a name="ln1875">      (const char_u *)tv_get_string_buf(&amp;argvars[1], buf));</a>
<a name="ln1876">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln1877">}</a>
<a name="ln1878"> </a>
<a name="ln1879">/// &quot;getenv()&quot; function</a>
<a name="ln1880">static void f_getenv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1881">{</a>
<a name="ln1882">  char_u *p = (char_u *)vim_getenv(tv_get_string(&amp;argvars[0]));</a>
<a name="ln1883"> </a>
<a name="ln1884">  if (p == NULL) {</a>
<a name="ln1885">    rettv-&gt;v_type = VAR_SPECIAL;</a>
<a name="ln1886">    rettv-&gt;vval.v_special = kSpecialVarNull;</a>
<a name="ln1887">    return;</a>
<a name="ln1888">  }</a>
<a name="ln1889">  rettv-&gt;vval.v_string = p;</a>
<a name="ln1890">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln1891">}</a>
<a name="ln1892"> </a>
<a name="ln1893">/*</a>
<a name="ln1894"> * &quot;eval()&quot; function</a>
<a name="ln1895"> */</a>
<a name="ln1896">static void f_eval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1897">{</a>
<a name="ln1898">  const char *s = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln1899">  if (s != NULL) {</a>
<a name="ln1900">    s = (const char *)skipwhite((const char_u *)s);</a>
<a name="ln1901">  }</a>
<a name="ln1902"> </a>
<a name="ln1903">  const char *const expr_start = s;</a>
<a name="ln1904">  if (s == NULL || eval1((char_u **)&amp;s, rettv, true) == FAIL) {</a>
<a name="ln1905">    if (expr_start != NULL &amp;&amp; !aborting()) {</a>
<a name="ln1906">      EMSG2(_(e_invexpr2), expr_start);</a>
<a name="ln1907">    }</a>
<a name="ln1908">    need_clr_eos = FALSE;</a>
<a name="ln1909">    rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln1910">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln1911">  } else if (*s != NUL) {</a>
<a name="ln1912">    EMSG(_(e_trailing));</a>
<a name="ln1913">  }</a>
<a name="ln1914">}</a>
<a name="ln1915"> </a>
<a name="ln1916">/*</a>
<a name="ln1917"> * &quot;eventhandler()&quot; function</a>
<a name="ln1918"> */</a>
<a name="ln1919">static void f_eventhandler(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1920">{</a>
<a name="ln1921">  rettv-&gt;vval.v_number = vgetc_busy;</a>
<a name="ln1922">}</a>
<a name="ln1923"> </a>
<a name="ln1924">/*</a>
<a name="ln1925"> * &quot;executable()&quot; function</a>
<a name="ln1926"> */</a>
<a name="ln1927">static void f_executable(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1928">{</a>
<a name="ln1929">  if (tv_check_for_string(&amp;argvars[0]) == FAIL) {</a>
<a name="ln1930">    return;</a>
<a name="ln1931">  }</a>
<a name="ln1932"> </a>
<a name="ln1933">  // Check in $PATH and also check directly if there is a directory name</a>
<a name="ln1934">  rettv-&gt;vval.v_number = os_can_exe(tv_get_string(&amp;argvars[0]), NULL, true);</a>
<a name="ln1935">}</a>
<a name="ln1936"> </a>
<a name="ln1937">typedef struct {</a>
<a name="ln1938">  const list_T *const l;</a>
<a name="ln1939">  const listitem_T *li;</a>
<a name="ln1940">} GetListLineCookie;</a>
<a name="ln1941"> </a>
<a name="ln1942">static char_u *get_list_line(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln1943">{</a>
<a name="ln1944">  GetListLineCookie *const p = (GetListLineCookie *)cookie;</a>
<a name="ln1945"> </a>
<a name="ln1946">  const listitem_T *const item = p-&gt;li;</a>
<a name="ln1947">  if (item == NULL) {</a>
<a name="ln1948">    return NULL;</a>
<a name="ln1949">  }</a>
<a name="ln1950">  char buf[NUMBUFLEN];</a>
<a name="ln1951">  const char *const s = tv_get_string_buf_chk(TV_LIST_ITEM_TV(item), buf);</a>
<a name="ln1952">  p-&gt;li = TV_LIST_ITEM_NEXT(p-&gt;l, item);</a>
<a name="ln1953">  return (char_u *)(s == NULL ? NULL : xstrdup(s));</a>
<a name="ln1954">}</a>
<a name="ln1955"> </a>
<a name="ln1956">// &quot;execute(command)&quot; function</a>
<a name="ln1957">static void f_execute(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1958">{</a>
<a name="ln1959">  const int save_msg_silent = msg_silent;</a>
<a name="ln1960">  const int save_emsg_silent = emsg_silent;</a>
<a name="ln1961">  const bool save_emsg_noredir = emsg_noredir;</a>
<a name="ln1962">  const bool save_redir_off = redir_off;</a>
<a name="ln1963">  garray_T *const save_capture_ga = capture_ga;</a>
<a name="ln1964">  const int save_msg_col = msg_col;</a>
<a name="ln1965">  bool echo_output = false;</a>
<a name="ln1966"> </a>
<a name="ln1967">  if (check_secure()) {</a>
<a name="ln1968">    return;</a>
<a name="ln1969">  }</a>
<a name="ln1970"> </a>
<a name="ln1971">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1972">    char buf[NUMBUFLEN];</a>
<a name="ln1973">    const char *const s = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln1974"> </a>
<a name="ln1975">    if (s == NULL) {</a>
<a name="ln1976">      return;</a>
<a name="ln1977">    }</a>
<a name="ln1978">    if (*s == NUL) {</a>
<a name="ln1979">      echo_output = true;</a>
<a name="ln1980">    }</a>
<a name="ln1981">    if (strncmp(s, &quot;silent&quot;, 6) == 0) {</a>
<a name="ln1982">      msg_silent++;</a>
<a name="ln1983">    }</a>
<a name="ln1984">    if (strcmp(s, &quot;silent!&quot;) == 0) {</a>
<a name="ln1985">      emsg_silent = true;</a>
<a name="ln1986">      emsg_noredir = true;</a>
<a name="ln1987">    }</a>
<a name="ln1988">  } else {</a>
<a name="ln1989">    msg_silent++;</a>
<a name="ln1990">  }</a>
<a name="ln1991"> </a>
<a name="ln1992">  garray_T capture_local;</a>
<a name="ln1993">  ga_init(&amp;capture_local, (int)sizeof(char), 80);</a>
<a name="ln1994">  capture_ga = &amp;capture_local;</a>
<a name="ln1995">  redir_off = false;</a>
<a name="ln1996">  if (!echo_output) {</a>
<a name="ln1997">    msg_col = 0;  // prevent leading spaces</a>
<a name="ln1998">  }</a>
<a name="ln1999"> </a>
<a name="ln2000">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln2001">    do_cmdline_cmd(tv_get_string(&amp;argvars[0]));</a>
<a name="ln2002">  } else if (argvars[0].vval.v_list != NULL) {</a>
<a name="ln2003">    list_T *const list = argvars[0].vval.v_list;</a>
<a name="ln2004">    tv_list_ref(list);</a>
<a name="ln2005">    GetListLineCookie cookie = {</a>
<a name="ln2006">      .l = list,</a>
<a name="ln2007">      .li = tv_list_first(list),</a>
<a name="ln2008">    };</a>
<a name="ln2009">    do_cmdline(NULL, get_list_line, (void *)&amp;cookie,</a>
<a name="ln2010">               DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT|DOCMD_KEYTYPED);</a>
<a name="ln2011">    tv_list_unref(list);</a>
<a name="ln2012">  }</a>
<a name="ln2013">  msg_silent = save_msg_silent;</a>
<a name="ln2014">  emsg_silent = save_emsg_silent;</a>
<a name="ln2015">  emsg_noredir = save_emsg_noredir;</a>
<a name="ln2016">  redir_off = save_redir_off;</a>
<a name="ln2017">  // &quot;silent reg&quot; or &quot;silent echo x&quot; leaves msg_col somewhere in the line.</a>
<a name="ln2018">  if (echo_output) {</a>
<a name="ln2019">    // When not working silently: put it in column zero.  A following</a>
<a name="ln2020">    // &quot;echon&quot; will overwrite the message, unavoidably.</a>
<a name="ln2021">    msg_col = 0;</a>
<a name="ln2022">  } else {</a>
<a name="ln2023">    // When working silently: Put it back where it was, since nothing</a>
<a name="ln2024">    // should have been written.</a>
<a name="ln2025">    msg_col = save_msg_col;</a>
<a name="ln2026">  }</a>
<a name="ln2027"> </a>
<a name="ln2028">  ga_append(capture_ga, NUL);</a>
<a name="ln2029">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2030">  rettv-&gt;vval.v_string = capture_ga-&gt;ga_data;</a>
<a name="ln2031"> </a>
<a name="ln2032">  capture_ga = save_capture_ga;</a>
<a name="ln2033">}</a>
<a name="ln2034"> </a>
<a name="ln2035">/// &quot;exepath()&quot; function</a>
<a name="ln2036">static void f_exepath(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2037">{</a>
<a name="ln2038">  if (tv_check_for_string(&amp;argvars[0]) == FAIL) {</a>
<a name="ln2039">    return;</a>
<a name="ln2040">  }</a>
<a name="ln2041"> </a>
<a name="ln2042">  char *path = NULL;</a>
<a name="ln2043"> </a>
<a name="ln2044">  (void)os_can_exe(tv_get_string(&amp;argvars[0]), &amp;path, true);</a>
<a name="ln2045"> </a>
<a name="ln2046">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2047">  rettv-&gt;vval.v_string = (char_u *)path;</a>
<a name="ln2048">}</a>
<a name="ln2049"> </a>
<a name="ln2050">/*</a>
<a name="ln2051"> * &quot;exists()&quot; function</a>
<a name="ln2052"> */</a>
<a name="ln2053">static void f_exists(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2054">{</a>
<a name="ln2055">  int n = false;</a>
<a name="ln2056"> </a>
<a name="ln2057">  const char *p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2058">  if (*p == '$') {  // Environment variable.</a>
<a name="ln2059">    // First try &quot;normal&quot; environment variables (fast).</a>
<a name="ln2060">    if (os_env_exists(p + 1)) {</a>
<a name="ln2061">      n = true;</a>
<a name="ln2062">    } else {</a>
<a name="ln2063">      // Try expanding things like $VIM and ${HOME}.</a>
<a name="ln2064">      char_u *const exp = expand_env_save((char_u *)p);</a>
<a name="ln2065">      if (exp != NULL &amp;&amp; *exp != '$') {</a>
<a name="ln2066">        n = true;</a>
<a name="ln2067">      }</a>
<a name="ln2068">      xfree(exp);</a>
<a name="ln2069">    }</a>
<a name="ln2070">  } else if (*p == '&amp;' || *p == '+') {  // Option.</a>
<a name="ln2071">    n = (get_option_tv(&amp;p, NULL, true) == OK);</a>
<a name="ln2072">    if (*skipwhite((const char_u *)p) != NUL) {</a>
<a name="ln2073">      n = false;  // Trailing garbage.</a>
<a name="ln2074">    }</a>
<a name="ln2075">  } else if (*p == '*') {  // Internal or user defined function.</a>
<a name="ln2076">    n = function_exists(p + 1, false);</a>
<a name="ln2077">  } else if (*p == ':') {</a>
<a name="ln2078">    n = cmd_exists(p + 1);</a>
<a name="ln2079">  } else if (*p == '#') {</a>
<a name="ln2080">    if (p[1] == '#') {</a>
<a name="ln2081">      n = autocmd_supported(p + 2);</a>
<a name="ln2082">    } else {</a>
<a name="ln2083">      n = au_exists(p + 1);</a>
<a name="ln2084">    }</a>
<a name="ln2085">  } else {  // Internal variable.</a>
<a name="ln2086">    n = var_exists(p);</a>
<a name="ln2087">  }</a>
<a name="ln2088"> </a>
<a name="ln2089">  rettv-&gt;vval.v_number = n;</a>
<a name="ln2090">}</a>
<a name="ln2091"> </a>
<a name="ln2092">/*</a>
<a name="ln2093"> * &quot;expand()&quot; function</a>
<a name="ln2094"> */</a>
<a name="ln2095">static void f_expand(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2096">{</a>
<a name="ln2097">  size_t len;</a>
<a name="ln2098">  char_u      *errormsg;</a>
<a name="ln2099">  int options = WILD_SILENT|WILD_USE_NL|WILD_LIST_NOTFOUND;</a>
<a name="ln2100">  expand_T xpc;</a>
<a name="ln2101">  bool error = false;</a>
<a name="ln2102">  char_u *result;</a>
<a name="ln2103">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2104">  char_u *p_csl_save = p_csl;</a>
<a name="ln2105"> </a>
<a name="ln2106">  // avoid using 'completeslash' here</a>
<a name="ln2107">  p_csl = empty_option;</a>
<a name="ln2108">#endif</a>
<a name="ln2109"> </a>
<a name="ln2110">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2111">  if (argvars[1].v_type != VAR_UNKNOWN</a>
<a name="ln2112">      &amp;&amp; argvars[2].v_type != VAR_UNKNOWN</a>
<a name="ln2113">      &amp;&amp; tv_get_number_chk(&amp;argvars[2], &amp;error)</a>
<a name="ln2114">      &amp;&amp; !error) {</a>
<a name="ln2115">    tv_list_set_ret(rettv, NULL);</a>
<a name="ln2116">  }</a>
<a name="ln2117"> </a>
<a name="ln2118">  const char *s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2119">  if (*s == '%' || *s == '#' || *s == '&lt;') {</a>
<a name="ln2120">    emsg_off++;</a>
<a name="ln2121">    result = eval_vars((char_u *)s, (char_u *)s, &amp;len, NULL, &amp;errormsg, NULL);</a>
<a name="ln2122">    emsg_off--;</a>
<a name="ln2123">    if (rettv-&gt;v_type == VAR_LIST) {</a>
<a name="ln2124">      tv_list_alloc_ret(rettv, (result != NULL));</a>
<a name="ln2125">      if (result != NULL) {</a>
<a name="ln2126">        tv_list_append_string(rettv-&gt;vval.v_list, (const char *)result, -1);</a>
<a name="ln2127">      }</a>
<a name="ln2128">      XFREE_CLEAR(result);</a>
<a name="ln2129">    } else {</a>
<a name="ln2130">      rettv-&gt;vval.v_string = result;</a>
<a name="ln2131">    }</a>
<a name="ln2132">  } else {</a>
<a name="ln2133">    // When the optional second argument is non-zero, don't remove matches</a>
<a name="ln2134">    // for 'wildignore' and don't put matches for 'suffixes' at the end.</a>
<a name="ln2135">    if (argvars[1].v_type != VAR_UNKNOWN</a>
<a name="ln2136">        &amp;&amp; tv_get_number_chk(&amp;argvars[1], &amp;error)) {</a>
<a name="ln2137">      options |= WILD_KEEP_ALL;</a>
<a name="ln2138">    }</a>
<a name="ln2139">    if (!error) {</a>
<a name="ln2140">      ExpandInit(&amp;xpc);</a>
<a name="ln2141">      xpc.xp_context = EXPAND_FILES;</a>
<a name="ln2142">      if (p_wic) {</a>
<a name="ln2143">        options += WILD_ICASE;</a>
<a name="ln2144">      }</a>
<a name="ln2145">      if (rettv-&gt;v_type == VAR_STRING) {</a>
<a name="ln2146">        rettv-&gt;vval.v_string = ExpandOne(&amp;xpc, (char_u *)s, NULL, options,</a>
<a name="ln2147">                                         WILD_ALL);</a>
<a name="ln2148">      } else {</a>
<a name="ln2149">        ExpandOne(&amp;xpc, (char_u *)s, NULL, options, WILD_ALL_KEEP);</a>
<a name="ln2150">        tv_list_alloc_ret(rettv, xpc.xp_numfiles);</a>
<a name="ln2151">        for (int i = 0; i &lt; xpc.xp_numfiles; i++) {</a>
<a name="ln2152">          tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln2153">                                (const char *)xpc.xp_files[i], -1);</a>
<a name="ln2154">        }</a>
<a name="ln2155">        ExpandCleanup(&amp;xpc);</a>
<a name="ln2156">      }</a>
<a name="ln2157">    } else {</a>
<a name="ln2158">      rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2159">    }</a>
<a name="ln2160">  }</a>
<a name="ln2161">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2162">  p_csl = p_csl_save;</a>
<a name="ln2163">#endif</a>
<a name="ln2164">}</a>
<a name="ln2165"> </a>
<a name="ln2166"> </a>
<a name="ln2167">/// &quot;menu_get(path [, modes])&quot; function</a>
<a name="ln2168">static void f_menu_get(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2169">{</a>
<a name="ln2170">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln2171">  int modes = MENU_ALL_MODES;</a>
<a name="ln2172">  if (argvars[1].v_type == VAR_STRING) {</a>
<a name="ln2173">    const char *const strmodes = tv_get_string(&amp;argvars[1]);</a>
<a name="ln2174">    modes = get_menu_cmd_modes(strmodes, false, NULL, NULL);</a>
<a name="ln2175">  }</a>
<a name="ln2176">  menu_get((char_u *)tv_get_string(&amp;argvars[0]), modes, rettv-&gt;vval.v_list);</a>
<a name="ln2177">}</a>
<a name="ln2178"> </a>
<a name="ln2179">// &quot;expandcmd()&quot; function</a>
<a name="ln2180">// Expand all the special characters in a command string.</a>
<a name="ln2181">static void f_expandcmd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2182">{</a>
<a name="ln2183">  char_u *errormsg = NULL;</a>
<a name="ln2184"> </a>
<a name="ln2185">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2186">  char_u *cmdstr = (char_u *)xstrdup(tv_get_string(&amp;argvars[0]));</a>
<a name="ln2187"> </a>
<a name="ln2188">  exarg_T eap = {</a>
<a name="ln2189">    .cmd = cmdstr,</a>
<a name="ln2190">    .arg = cmdstr,</a>
<a name="ln2191">    .usefilter = false,</a>
<a name="ln2192">    .nextcmd = NULL,</a>
<a name="ln2193">    .cmdidx = CMD_USER,</a>
<a name="ln2194">  };</a>
<a name="ln2195">  eap.argt |= EX_NOSPC;</a>
<a name="ln2196"> </a>
<a name="ln2197">  expand_filename(&amp;eap, &amp;cmdstr, &amp;errormsg);</a>
<a name="ln2198">  if (errormsg != NULL &amp;&amp; *errormsg != NUL) {</a>
<a name="ln2199">    EMSG(errormsg);</a>
<a name="ln2200">  }</a>
<a name="ln2201">  rettv-&gt;vval.v_string = cmdstr;</a>
<a name="ln2202">}</a>
<a name="ln2203"> </a>
<a name="ln2204"> </a>
<a name="ln2205">/// &quot;flatten(list[, {maxdepth}])&quot; function</a>
<a name="ln2206">static void f_flatten(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2207">{</a>
<a name="ln2208">  list_T *list;</a>
<a name="ln2209">  long maxdepth;</a>
<a name="ln2210">  bool error = false;</a>
<a name="ln2211"> </a>
<a name="ln2212">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln2213">    EMSG2(_(e_listarg), &quot;flatten()&quot;);</a>
<a name="ln2214">    return;</a>
<a name="ln2215">  }</a>
<a name="ln2216"> </a>
<a name="ln2217">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln2218">    maxdepth = 999999;</a>
<a name="ln2219">  } else {</a>
<a name="ln2220">    maxdepth = (long)tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln2221">    if (error) {</a>
<a name="ln2222">      return;</a>
<a name="ln2223">    }</a>
<a name="ln2224">    if (maxdepth &lt; 0) {</a>
<a name="ln2225">      EMSG(_(&quot;E900: maxdepth must be non-negative number&quot;));</a>
<a name="ln2226">      return;</a>
<a name="ln2227">    }</a>
<a name="ln2228">  }</a>
<a name="ln2229"> </a>
<a name="ln2230">  list = argvars[0].vval.v_list;</a>
<a name="ln2231">  if (list != NULL</a>
<a name="ln2232">      &amp;&amp; !tv_check_lock(tv_list_locked(list),</a>
<a name="ln2233">                        N_(&quot;flatten() argument&quot;),</a>
<a name="ln2234">                        TV_TRANSLATE)</a>
<a name="ln2235">      &amp;&amp; tv_list_flatten(list, maxdepth) == OK) {</a>
<a name="ln2236">    tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2237">  }</a>
<a name="ln2238">}</a>
<a name="ln2239"> </a>
<a name="ln2240">/*</a>
<a name="ln2241"> * &quot;extend(list, list [, idx])&quot; function</a>
<a name="ln2242"> * &quot;extend(dict, dict [, action])&quot; function</a>
<a name="ln2243"> */</a>
<a name="ln2244">static void f_extend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2245">{</a>
<a name="ln2246">  const char *const arg_errmsg = N_(&quot;extend() argument&quot;);</a>
<a name="ln2247"> </a>
<a name="ln2248">  if (argvars[0].v_type == VAR_LIST &amp;&amp; argvars[1].v_type == VAR_LIST) {</a>
<a name="ln2249">    long before;</a>
<a name="ln2250">    bool error = false;</a>
<a name="ln2251"> </a>
<a name="ln2252">    list_T *const l1 = argvars[0].vval.v_list;</a>
<a name="ln2253">    list_T *const l2 = argvars[1].vval.v_list;</a>
<a name="ln2254">    if (!tv_check_lock(tv_list_locked(l1), arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln2255">      listitem_T *item;</a>
<a name="ln2256">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2257">        before = (long)tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln2258">        if (error) {</a>
<a name="ln2259">          return;  // Type error; errmsg already given.</a>
<a name="ln2260">        }</a>
<a name="ln2261"> </a>
<a name="ln2262">        if (before == tv_list_len(l1)) {</a>
<a name="ln2263">          item = NULL;</a>
<a name="ln2264">        } else {</a>
<a name="ln2265">          item = tv_list_find(l1, before);</a>
<a name="ln2266">          if (item == NULL) {</a>
<a name="ln2267">            EMSGN(_(e_listidx), before);</a>
<a name="ln2268">            return;</a>
<a name="ln2269">          }</a>
<a name="ln2270">        }</a>
<a name="ln2271">      } else {</a>
<a name="ln2272">        item = NULL;</a>
<a name="ln2273">      }</a>
<a name="ln2274">      tv_list_extend(l1, l2, item);</a>
<a name="ln2275"> </a>
<a name="ln2276">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2277">    }</a>
<a name="ln2278">  } else if (argvars[0].v_type == VAR_DICT &amp;&amp; argvars[1].v_type ==</a>
<a name="ln2279">             VAR_DICT) {</a>
<a name="ln2280">    dict_T *const d1 = argvars[0].vval.v_dict;</a>
<a name="ln2281">    dict_T *const d2 = argvars[1].vval.v_dict;</a>
<a name="ln2282">    if (d1 == NULL) {</a>
<a name="ln2283">      const bool locked = tv_check_lock(VAR_FIXED, arg_errmsg, TV_TRANSLATE);</a>
<a name="ln2284">      (void)locked;</a>
<a name="ln2285">      assert(locked == true);</a>
<a name="ln2286">    } else if (d2 == NULL) {</a>
<a name="ln2287">      // Do nothing</a>
<a name="ln2288">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2289">    } else if (!tv_check_lock(d1-&gt;dv_lock, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln2290">      const char *action = &quot;force&quot;;</a>
<a name="ln2291">      // Check the third argument.</a>
<a name="ln2292">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2293">        const char *const av[] = { &quot;keep&quot;, &quot;force&quot;, &quot;error&quot; };</a>
<a name="ln2294"> </a>
<a name="ln2295">        action = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln2296">        if (action == NULL) {</a>
<a name="ln2297">          return;  // Type error; error message already given.</a>
<a name="ln2298">        }</a>
<a name="ln2299">        size_t i;</a>
<a name="ln2300">        for (i = 0; i &lt; ARRAY_SIZE(av); i++) {</a>
<a name="ln2301">          if (strcmp(action, av[i]) == 0) {</a>
<a name="ln2302">            break;</a>
<a name="ln2303">          }</a>
<a name="ln2304">        }</a>
<a name="ln2305">        if (i == 3) {</a>
<a name="ln2306">          EMSG2(_(e_invarg2), action);</a>
<a name="ln2307">          return;</a>
<a name="ln2308">        }</a>
<a name="ln2309">      }</a>
<a name="ln2310"> </a>
<a name="ln2311">      tv_dict_extend(d1, d2, action);</a>
<a name="ln2312"> </a>
<a name="ln2313">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2314">    }</a>
<a name="ln2315">  } else {</a>
<a name="ln2316">    EMSG2(_(e_listdictarg), &quot;extend()&quot;);</a>
<a name="ln2317">  }</a>
<a name="ln2318">}</a>
<a name="ln2319"> </a>
<a name="ln2320">/*</a>
<a name="ln2321"> * &quot;feedkeys()&quot; function</a>
<a name="ln2322"> */</a>
<a name="ln2323">static void f_feedkeys(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2324">{</a>
<a name="ln2325">  // This is not allowed in the sandbox.  If the commands would still be</a>
<a name="ln2326">  // executed in the sandbox it would be OK, but it probably happens later,</a>
<a name="ln2327">  // when &quot;sandbox&quot; is no longer set.</a>
<a name="ln2328">  if (check_secure()) {</a>
<a name="ln2329">    return;</a>
<a name="ln2330">  }</a>
<a name="ln2331"> </a>
<a name="ln2332">  const char *const keys = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2333">  char nbuf[NUMBUFLEN];</a>
<a name="ln2334">  const char *flags = NULL;</a>
<a name="ln2335">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln2336">    flags = tv_get_string_buf(&amp;argvars[1], nbuf);</a>
<a name="ln2337">  }</a>
<a name="ln2338"> </a>
<a name="ln2339">  nvim_feedkeys(cstr_as_string((char *)keys),</a>
<a name="ln2340">                cstr_as_string((char *)flags), true);</a>
<a name="ln2341">}</a>
<a name="ln2342"> </a>
<a name="ln2343">/// &quot;filereadable()&quot; function</a>
<a name="ln2344">static void f_filereadable(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2345">{</a>
<a name="ln2346">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2347">  rettv-&gt;vval.v_number =</a>
<a name="ln2348">    (*p &amp;&amp; !os_isdir((const char_u *)p) &amp;&amp; os_file_is_readable(p));</a>
<a name="ln2349">}</a>
<a name="ln2350"> </a>
<a name="ln2351">/*</a>
<a name="ln2352"> * Return 0 for not writable, 1 for writable file, 2 for a dir which we have</a>
<a name="ln2353"> * rights to write into.</a>
<a name="ln2354"> */</a>
<a name="ln2355">static void f_filewritable(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2356">{</a>
<a name="ln2357">  const char *filename = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2358">  rettv-&gt;vval.v_number = os_file_is_writable(filename);</a>
<a name="ln2359">}</a>
<a name="ln2360"> </a>
<a name="ln2361"> </a>
<a name="ln2362">static void findfilendir(typval_T *argvars, typval_T *rettv, int find_what)</a>
<a name="ln2363">{</a>
<a name="ln2364">  char_u *fresult = NULL;</a>
<a name="ln2365">  char_u *path = *curbuf-&gt;b_p_path == NUL ? p_path : curbuf-&gt;b_p_path;</a>
<a name="ln2366">  int count = 1;</a>
<a name="ln2367">  bool first = true;</a>
<a name="ln2368">  bool error = false;</a>
<a name="ln2369"> </a>
<a name="ln2370">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2371">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2372"> </a>
<a name="ln2373">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2374"> </a>
<a name="ln2375">  char pathbuf[NUMBUFLEN];</a>
<a name="ln2376">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln2377">    const char *p = tv_get_string_buf_chk(&amp;argvars[1], pathbuf);</a>
<a name="ln2378">    if (p == NULL) {</a>
<a name="ln2379">      error = true;</a>
<a name="ln2380">    } else {</a>
<a name="ln2381">      if (*p != NUL) {</a>
<a name="ln2382">        path = (char_u *)p;</a>
<a name="ln2383">      }</a>
<a name="ln2384"> </a>
<a name="ln2385">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2386">        count = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln2387">      }</a>
<a name="ln2388">    }</a>
<a name="ln2389">  }</a>
<a name="ln2390"> </a>
<a name="ln2391">  if (count &lt; 0) {</a>
<a name="ln2392">    tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln2393">  }</a>
<a name="ln2394"> </a>
<a name="ln2395">  if (*fname != NUL &amp;&amp; !error) {</a>
<a name="ln2396">    do {</a>
<a name="ln2397">      if (rettv-&gt;v_type == VAR_STRING || rettv-&gt;v_type == VAR_LIST)</a>
<a name="ln2398">        xfree(fresult);</a>
<a name="ln2399">      fresult = find_file_in_path_option(first ? (char_u *)fname : NULL,</a>
<a name="ln2400">                                         first ? strlen(fname) : 0,</a>
<a name="ln2401">                                         0, first, path,</a>
<a name="ln2402">                                         find_what, curbuf-&gt;b_ffname,</a>
<a name="ln2403">                                         (find_what == FINDFILE_DIR</a>
<a name="ln2404">                                          ? (char_u *)&quot;&quot;</a>
<a name="ln2405">                                          : curbuf-&gt;b_p_sua));</a>
<a name="ln2406">      first = false;</a>
<a name="ln2407"> </a>
<a name="ln2408">      if (fresult != NULL &amp;&amp; rettv-&gt;v_type == VAR_LIST) {</a>
<a name="ln2409">        tv_list_append_string(rettv-&gt;vval.v_list, (const char *)fresult, -1);</a>
<a name="ln2410">      }</a>
<a name="ln2411">    } while ((rettv-&gt;v_type == VAR_LIST || --count &gt; 0) &amp;&amp; fresult != NULL);</a>
<a name="ln2412">  }</a>
<a name="ln2413"> </a>
<a name="ln2414">  if (rettv-&gt;v_type == VAR_STRING)</a>
<a name="ln2415">    rettv-&gt;vval.v_string = fresult;</a>
<a name="ln2416">}</a>
<a name="ln2417"> </a>
<a name="ln2418"> </a>
<a name="ln2419">/*</a>
<a name="ln2420"> * &quot;filter()&quot; function</a>
<a name="ln2421"> */</a>
<a name="ln2422">static void f_filter(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2423">{</a>
<a name="ln2424">  filter_map(argvars, rettv, FALSE);</a>
<a name="ln2425">}</a>
<a name="ln2426"> </a>
<a name="ln2427">/*</a>
<a name="ln2428"> * &quot;finddir({fname}[, {path}[, {count}]])&quot; function</a>
<a name="ln2429"> */</a>
<a name="ln2430">static void f_finddir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2431">{</a>
<a name="ln2432">  findfilendir(argvars, rettv, FINDFILE_DIR);</a>
<a name="ln2433">}</a>
<a name="ln2434"> </a>
<a name="ln2435">/*</a>
<a name="ln2436"> * &quot;findfile({fname}[, {path}[, {count}]])&quot; function</a>
<a name="ln2437"> */</a>
<a name="ln2438">static void f_findfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2439">{</a>
<a name="ln2440">  findfilendir(argvars, rettv, FINDFILE_FILE);</a>
<a name="ln2441">}</a>
<a name="ln2442"> </a>
<a name="ln2443">/*</a>
<a name="ln2444"> * &quot;float2nr({float})&quot; function</a>
<a name="ln2445"> */</a>
<a name="ln2446">static void f_float2nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2447">{</a>
<a name="ln2448">  float_T f;</a>
<a name="ln2449"> </a>
<a name="ln2450">  if (tv_get_float_chk(argvars, &amp;f)) {</a>
<a name="ln2451">    if (f &lt;= (float_T)-VARNUMBER_MAX + DBL_EPSILON) {</a>
<a name="ln2452">      rettv-&gt;vval.v_number = -VARNUMBER_MAX;</a>
<a name="ln2453">    } else if (f &gt;= (float_T)VARNUMBER_MAX - DBL_EPSILON) {</a>
<a name="ln2454">      rettv-&gt;vval.v_number = VARNUMBER_MAX;</a>
<a name="ln2455">    } else {</a>
<a name="ln2456">      rettv-&gt;vval.v_number = (varnumber_T)f;</a>
<a name="ln2457">    }</a>
<a name="ln2458">  }</a>
<a name="ln2459">}</a>
<a name="ln2460"> </a>
<a name="ln2461">/*</a>
<a name="ln2462"> * &quot;fmod()&quot; function</a>
<a name="ln2463"> */</a>
<a name="ln2464">static void f_fmod(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2465">{</a>
<a name="ln2466">  float_T fx;</a>
<a name="ln2467">  float_T fy;</a>
<a name="ln2468"> </a>
<a name="ln2469">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln2470">  if (tv_get_float_chk(argvars, &amp;fx) &amp;&amp; tv_get_float_chk(&amp;argvars[1], &amp;fy)) {</a>
<a name="ln2471">    rettv-&gt;vval.v_float = fmod(fx, fy);</a>
<a name="ln2472">  } else {</a>
<a name="ln2473">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln2474">  }</a>
<a name="ln2475">}</a>
<a name="ln2476"> </a>
<a name="ln2477">/*</a>
<a name="ln2478"> * &quot;fnameescape({string})&quot; function</a>
<a name="ln2479"> */</a>
<a name="ln2480">static void f_fnameescape(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2481">{</a>
<a name="ln2482">  rettv-&gt;vval.v_string = (char_u *)vim_strsave_fnameescape(</a>
<a name="ln2483">      tv_get_string(&amp;argvars[0]), false);</a>
<a name="ln2484">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2485">}</a>
<a name="ln2486"> </a>
<a name="ln2487">/*</a>
<a name="ln2488"> * &quot;fnamemodify({fname}, {mods})&quot; function</a>
<a name="ln2489"> */</a>
<a name="ln2490">static void f_fnamemodify(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2491">{</a>
<a name="ln2492">  char_u *fbuf = NULL;</a>
<a name="ln2493">  size_t len = 0;</a>
<a name="ln2494">  char buf[NUMBUFLEN];</a>
<a name="ln2495">  const char *fname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln2496">  const char *const mods = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln2497">  if (fname == NULL || mods == NULL) {</a>
<a name="ln2498">    fname = NULL;</a>
<a name="ln2499">  } else {</a>
<a name="ln2500">    len = strlen(fname);</a>
<a name="ln2501">    size_t usedlen = 0;</a>
<a name="ln2502">    if (mods != NULL &amp;&amp; *mods != NUL) {</a>
<a name="ln2503">      (void)modify_fname((char_u *)mods, false, &amp;usedlen,</a>
<a name="ln2504">                         (char_u **)&amp;fname, &amp;fbuf, &amp;len);</a>
<a name="ln2505">    }</a>
<a name="ln2506">  }</a>
<a name="ln2507"> </a>
<a name="ln2508">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2509">  if (fname == NULL) {</a>
<a name="ln2510">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2511">  } else {</a>
<a name="ln2512">    rettv-&gt;vval.v_string = (char_u *)xmemdupz(fname, len);</a>
<a name="ln2513">  }</a>
<a name="ln2514">  xfree(fbuf);</a>
<a name="ln2515">}</a>
<a name="ln2516"> </a>
<a name="ln2517"> </a>
<a name="ln2518">/*</a>
<a name="ln2519"> * &quot;foldclosed()&quot; function</a>
<a name="ln2520"> */</a>
<a name="ln2521">static void foldclosed_both(typval_T *argvars, typval_T *rettv, int end)</a>
<a name="ln2522">{</a>
<a name="ln2523">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln2524">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2525">    linenr_T first;</a>
<a name="ln2526">    linenr_T last;</a>
<a name="ln2527">    if (hasFoldingWin(curwin, lnum, &amp;first, &amp;last, false, NULL)) {</a>
<a name="ln2528">      if (end) {</a>
<a name="ln2529">        rettv-&gt;vval.v_number = (varnumber_T)last;</a>
<a name="ln2530">      } else {</a>
<a name="ln2531">        rettv-&gt;vval.v_number = (varnumber_T)first;</a>
<a name="ln2532">      }</a>
<a name="ln2533">      return;</a>
<a name="ln2534">    }</a>
<a name="ln2535">  }</a>
<a name="ln2536">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln2537">}</a>
<a name="ln2538"> </a>
<a name="ln2539">/*</a>
<a name="ln2540"> * &quot;foldclosed()&quot; function</a>
<a name="ln2541"> */</a>
<a name="ln2542">static void f_foldclosed(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2543">{</a>
<a name="ln2544">  foldclosed_both(argvars, rettv, FALSE);</a>
<a name="ln2545">}</a>
<a name="ln2546"> </a>
<a name="ln2547">/*</a>
<a name="ln2548"> * &quot;foldclosedend()&quot; function</a>
<a name="ln2549"> */</a>
<a name="ln2550">static void f_foldclosedend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2551">{</a>
<a name="ln2552">  foldclosed_both(argvars, rettv, TRUE);</a>
<a name="ln2553">}</a>
<a name="ln2554"> </a>
<a name="ln2555">/*</a>
<a name="ln2556"> * &quot;foldlevel()&quot; function</a>
<a name="ln2557"> */</a>
<a name="ln2558">static void f_foldlevel(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2559">{</a>
<a name="ln2560">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln2561">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2562">    rettv-&gt;vval.v_number = foldLevel(lnum);</a>
<a name="ln2563">  }</a>
<a name="ln2564">}</a>
<a name="ln2565"> </a>
<a name="ln2566">/*</a>
<a name="ln2567"> * &quot;foldtext()&quot; function</a>
<a name="ln2568"> */</a>
<a name="ln2569">static void f_foldtext(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2570">{</a>
<a name="ln2571">  linenr_T    foldstart;</a>
<a name="ln2572">  linenr_T    foldend;</a>
<a name="ln2573">  char_u      *dashes;</a>
<a name="ln2574">  linenr_T    lnum;</a>
<a name="ln2575">  char_u      *s;</a>
<a name="ln2576">  char_u      *r;</a>
<a name="ln2577">  int         len;</a>
<a name="ln2578">  char        *txt;</a>
<a name="ln2579"> </a>
<a name="ln2580">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2581">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2582"> </a>
<a name="ln2583">  foldstart = (linenr_T)get_vim_var_nr(VV_FOLDSTART);</a>
<a name="ln2584">  foldend = (linenr_T)get_vim_var_nr(VV_FOLDEND);</a>
<a name="ln2585">  dashes = get_vim_var_str(VV_FOLDDASHES);</a>
<a name="ln2586">  if (foldstart &gt; 0 &amp;&amp; foldend &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2587">    // Find first non-empty line in the fold.</a>
<a name="ln2588">    for (lnum = foldstart; lnum &lt; foldend; lnum++) {</a>
<a name="ln2589">      if (!linewhite(lnum)) {</a>
<a name="ln2590">        break;</a>
<a name="ln2591">      }</a>
<a name="ln2592">    }</a>
<a name="ln2593"> </a>
<a name="ln2594">    // Find interesting text in this line.</a>
<a name="ln2595">    s = skipwhite(ml_get(lnum));</a>
<a name="ln2596">    // skip C comment-start</a>
<a name="ln2597">    if (s[0] == '/' &amp;&amp; (s[1] == '*' || s[1] == '/')) {</a>
<a name="ln2598">      s = skipwhite(s + 2);</a>
<a name="ln2599">      if (*skipwhite(s) == NUL &amp;&amp; lnum + 1 &lt; foldend) {</a>
<a name="ln2600">        s = skipwhite(ml_get(lnum + 1));</a>
<a name="ln2601">        if (*s == '*')</a>
<a name="ln2602">          s = skipwhite(s + 1);</a>
<a name="ln2603">      }</a>
<a name="ln2604">    }</a>
<a name="ln2605">    unsigned long count = (unsigned long)(foldend - foldstart + 1);</a>
<a name="ln2606">    txt = NGETTEXT(&quot;+-%s%3ld line: &quot;, &quot;+-%s%3ld lines: &quot;, count);</a>
<a name="ln2607">    r = xmalloc(STRLEN(txt)</a>
<a name="ln2608">                + STRLEN(dashes)  // for %s</a>
<a name="ln2609">                + 20              // for %3ld</a>
<a name="ln2610">                + STRLEN(s));     // concatenated</a>
<a name="ln2611">    sprintf((char *)r, txt, dashes, count);</a>
<a name="ln2612">    len = (int)STRLEN(r);</a>
<a name="ln2613">    STRCAT(r, s);</a>
<a name="ln2614">    // remove 'foldmarker' and 'commentstring'</a>
<a name="ln2615">    foldtext_cleanup(r + len);</a>
<a name="ln2616">    rettv-&gt;vval.v_string = r;</a>
<a name="ln2617">  }</a>
<a name="ln2618">}</a>
<a name="ln2619"> </a>
<a name="ln2620">/*</a>
<a name="ln2621"> * &quot;foldtextresult(lnum)&quot; function</a>
<a name="ln2622"> */</a>
<a name="ln2623">static void f_foldtextresult(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2624">{</a>
<a name="ln2625">  char_u      *text;</a>
<a name="ln2626">  char_u buf[FOLD_TEXT_LEN];</a>
<a name="ln2627">  static bool entered = false;</a>
<a name="ln2628"> </a>
<a name="ln2629">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2630">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2631">  if (entered) {</a>
<a name="ln2632">    return;  // reject recursive use</a>
<a name="ln2633">  }</a>
<a name="ln2634">  entered = true;</a>
<a name="ln2635">  linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln2636">  // Treat illegal types and illegal string values for {lnum} the same.</a>
<a name="ln2637">  if (lnum &lt; 0) {</a>
<a name="ln2638">    lnum = 0;</a>
<a name="ln2639">  }</a>
<a name="ln2640"> </a>
<a name="ln2641">  foldinfo_T info = fold_info(curwin, lnum);</a>
<a name="ln2642">  if (info.fi_lines &gt; 0) {</a>
<a name="ln2643">    text = get_foldtext(curwin, lnum, lnum + info.fi_lines - 1, info, buf);</a>
<a name="ln2644">    if (text == buf) {</a>
<a name="ln2645">      text = vim_strsave(text);</a>
<a name="ln2646">    }</a>
<a name="ln2647">    rettv-&gt;vval.v_string = text;</a>
<a name="ln2648">  }</a>
<a name="ln2649"> </a>
<a name="ln2650">  entered = false;</a>
<a name="ln2651">}</a>
<a name="ln2652"> </a>
<a name="ln2653">/*</a>
<a name="ln2654"> * &quot;foreground()&quot; function</a>
<a name="ln2655"> */</a>
<a name="ln2656">static void f_foreground(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2657">{</a>
<a name="ln2658">}</a>
<a name="ln2659"> </a>
<a name="ln2660">static void f_funcref(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2661">{</a>
<a name="ln2662">  common_function(argvars, rettv, true, fptr);</a>
<a name="ln2663">}</a>
<a name="ln2664"> </a>
<a name="ln2665">static void f_function(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2666">{</a>
<a name="ln2667">  common_function(argvars, rettv, false, fptr);</a>
<a name="ln2668">}</a>
<a name="ln2669"> </a>
<a name="ln2670">/// &quot;garbagecollect()&quot; function</a>
<a name="ln2671">static void f_garbagecollect(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2672">{</a>
<a name="ln2673">  // This is postponed until we are back at the toplevel, because we may be</a>
<a name="ln2674">  // using Lists and Dicts internally.  E.g.: &quot;:echo [garbagecollect()]&quot;.</a>
<a name="ln2675">  want_garbage_collect = true;</a>
<a name="ln2676"> </a>
<a name="ln2677">  if (argvars[0].v_type != VAR_UNKNOWN &amp;&amp; tv_get_number(&amp;argvars[0]) == 1) {</a>
<a name="ln2678">    garbage_collect_at_exit = true;</a>
<a name="ln2679">  }</a>
<a name="ln2680">}</a>
<a name="ln2681"> </a>
<a name="ln2682">/*</a>
<a name="ln2683"> * &quot;get()&quot; function</a>
<a name="ln2684"> */</a>
<a name="ln2685">static void f_get(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2686">{</a>
<a name="ln2687">  listitem_T  *li;</a>
<a name="ln2688">  list_T      *l;</a>
<a name="ln2689">  dictitem_T  *di;</a>
<a name="ln2690">  dict_T      *d;</a>
<a name="ln2691">  typval_T    *tv = NULL;</a>
<a name="ln2692">  bool what_is_dict = false;</a>
<a name="ln2693"> </a>
<a name="ln2694">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln2695">    if ((l = argvars[0].vval.v_list) != NULL) {</a>
<a name="ln2696">      bool error = false;</a>
<a name="ln2697"> </a>
<a name="ln2698">      li = tv_list_find(l, tv_get_number_chk(&amp;argvars[1], &amp;error));</a>
<a name="ln2699">      if (!error &amp;&amp; li != NULL) {</a>
<a name="ln2700">        tv = TV_LIST_ITEM_TV(li);</a>
<a name="ln2701">      }</a>
<a name="ln2702">    }</a>
<a name="ln2703">  } else if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln2704">    if ((d = argvars[0].vval.v_dict) != NULL) {</a>
<a name="ln2705">      di = tv_dict_find(d, tv_get_string(&amp;argvars[1]), -1);</a>
<a name="ln2706">      if (di != NULL) {</a>
<a name="ln2707">        tv = &amp;di-&gt;di_tv;</a>
<a name="ln2708">      }</a>
<a name="ln2709">    }</a>
<a name="ln2710">  } else if (tv_is_func(argvars[0])) {</a>
<a name="ln2711">    partial_T *pt;</a>
<a name="ln2712">    partial_T fref_pt;</a>
<a name="ln2713"> </a>
<a name="ln2714">    if (argvars[0].v_type == VAR_PARTIAL) {</a>
<a name="ln2715">      pt = argvars[0].vval.v_partial;</a>
<a name="ln2716">    } else {</a>
<a name="ln2717">      memset(&amp;fref_pt, 0, sizeof(fref_pt));</a>
<a name="ln2718">      fref_pt.pt_name = argvars[0].vval.v_string;</a>
<a name="ln2719">      pt = &amp;fref_pt;</a>
<a name="ln2720">    }</a>
<a name="ln2721"> </a>
<a name="ln2722">    if (pt != NULL) {</a>
<a name="ln2723">      const char *const what = tv_get_string(&amp;argvars[1]);</a>
<a name="ln2724"> </a>
<a name="ln2725">      if (strcmp(what, &quot;func&quot;) == 0 || strcmp(what, &quot;name&quot;) == 0) {</a>
<a name="ln2726">        rettv-&gt;v_type = (*what == 'f' ? VAR_FUNC : VAR_STRING);</a>
<a name="ln2727">        const char *const n = (const char *)partial_name(pt);</a>
<a name="ln2728">        assert(n != NULL);</a>
<a name="ln2729">        rettv-&gt;vval.v_string = (char_u *)xstrdup(n);</a>
<a name="ln2730">        if (rettv-&gt;v_type == VAR_FUNC) {</a>
<a name="ln2731">          func_ref(rettv-&gt;vval.v_string);</a>
<a name="ln2732">        }</a>
<a name="ln2733">      } else if (strcmp(what, &quot;dict&quot;) == 0) {</a>
<a name="ln2734">        what_is_dict = true;</a>
<a name="ln2735">        if (pt-&gt;pt_dict != NULL) {</a>
<a name="ln2736">          tv_dict_set_ret(rettv, pt-&gt;pt_dict);</a>
<a name="ln2737">        }</a>
<a name="ln2738">      } else if (strcmp(what, &quot;args&quot;) == 0) {</a>
<a name="ln2739">        rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln2740">        if (tv_list_alloc_ret(rettv, pt-&gt;pt_argc) != NULL) {</a>
<a name="ln2741">          for (int i = 0; i &lt; pt-&gt;pt_argc; i++) {</a>
<a name="ln2742">            tv_list_append_tv(rettv-&gt;vval.v_list, &amp;pt-&gt;pt_argv[i]);</a>
<a name="ln2743">          }</a>
<a name="ln2744">        }</a>
<a name="ln2745">      } else {</a>
<a name="ln2746">        EMSG2(_(e_invarg2), what);</a>
<a name="ln2747">      }</a>
<a name="ln2748"> </a>
<a name="ln2749">      // When {what} == &quot;dict&quot; and pt-&gt;pt_dict == NULL, evaluate the</a>
<a name="ln2750">      // third argument</a>
<a name="ln2751">      if (!what_is_dict) {</a>
<a name="ln2752">        return;</a>
<a name="ln2753">      }</a>
<a name="ln2754">    }</a>
<a name="ln2755">  } else {</a>
<a name="ln2756">    EMSG2(_(e_listdictarg), &quot;get()&quot;);</a>
<a name="ln2757">  }</a>
<a name="ln2758"> </a>
<a name="ln2759">  if (tv == NULL) {</a>
<a name="ln2760">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2761">      tv_copy(&amp;argvars[2], rettv);</a>
<a name="ln2762">    }</a>
<a name="ln2763">  } else {</a>
<a name="ln2764">    tv_copy(tv, rettv);</a>
<a name="ln2765">  }</a>
<a name="ln2766">}</a>
<a name="ln2767"> </a>
<a name="ln2768">/// &quot;getbufinfo()&quot; function</a>
<a name="ln2769">static void f_getbufinfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2770">{</a>
<a name="ln2771">  buf_T *argbuf = NULL;</a>
<a name="ln2772">  bool filtered = false;</a>
<a name="ln2773">  bool sel_buflisted = false;</a>
<a name="ln2774">  bool sel_bufloaded = false;</a>
<a name="ln2775">  bool sel_bufmodified = false;</a>
<a name="ln2776"> </a>
<a name="ln2777">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln2778"> </a>
<a name="ln2779">  // List of all the buffers or selected buffers</a>
<a name="ln2780">  if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln2781">    dict_T *sel_d = argvars[0].vval.v_dict;</a>
<a name="ln2782"> </a>
<a name="ln2783">    if (sel_d != NULL) {</a>
<a name="ln2784">      dictitem_T *di;</a>
<a name="ln2785"> </a>
<a name="ln2786">      filtered = true;</a>
<a name="ln2787"> </a>
<a name="ln2788">      di = tv_dict_find(sel_d, S_LEN(&quot;buflisted&quot;));</a>
<a name="ln2789">      if (di != NULL &amp;&amp; tv_get_number(&amp;di-&gt;di_tv)) {</a>
<a name="ln2790">        sel_buflisted = true;</a>
<a name="ln2791">      }</a>
<a name="ln2792"> </a>
<a name="ln2793">      di = tv_dict_find(sel_d, S_LEN(&quot;bufloaded&quot;));</a>
<a name="ln2794">      if (di != NULL &amp;&amp; tv_get_number(&amp;di-&gt;di_tv)) {</a>
<a name="ln2795">        sel_bufloaded = true;</a>
<a name="ln2796">      }</a>
<a name="ln2797">      di = tv_dict_find(sel_d, S_LEN(&quot;bufmodified&quot;));</a>
<a name="ln2798">      if (di != NULL &amp;&amp; tv_get_number(&amp;di-&gt;di_tv)) {</a>
<a name="ln2799">        sel_bufmodified = true;</a>
<a name="ln2800">      }</a>
<a name="ln2801">    }</a>
<a name="ln2802">  } else if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln2803">    // Information about one buffer.  Argument specifies the buffer</a>
<a name="ln2804">    argbuf = tv_get_buf_from_arg(&amp;argvars[0]);</a>
<a name="ln2805">    if (argbuf == NULL) {</a>
<a name="ln2806">      return;</a>
<a name="ln2807">    }</a>
<a name="ln2808">  }</a>
<a name="ln2809"> </a>
<a name="ln2810">  // Return information about all the buffers or a specified buffer</a>
<a name="ln2811">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2812">    if (argbuf != NULL &amp;&amp; argbuf != buf) {</a>
<a name="ln2813">      continue;</a>
<a name="ln2814">    }</a>
<a name="ln2815">    if (filtered &amp;&amp; ((sel_bufloaded &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL)</a>
<a name="ln2816">                     || (sel_buflisted &amp;&amp; !buf-&gt;b_p_bl)</a>
<a name="ln2817">                     || (sel_bufmodified &amp;&amp; !buf-&gt;b_changed))) {</a>
<a name="ln2818">      continue;</a>
<a name="ln2819">    }</a>
<a name="ln2820"> </a>
<a name="ln2821">    dict_T *const d = get_buffer_info(buf);</a>
<a name="ln2822">    tv_list_append_dict(rettv-&gt;vval.v_list, d);</a>
<a name="ln2823">    if (argbuf != NULL) {</a>
<a name="ln2824">      return;</a>
<a name="ln2825">    }</a>
<a name="ln2826">  }</a>
<a name="ln2827">}</a>
<a name="ln2828"> </a>
<a name="ln2829">/*</a>
<a name="ln2830"> * Get line or list of lines from buffer &quot;buf&quot; into &quot;rettv&quot;.</a>
<a name="ln2831"> * Return a range (from start to end) of lines in rettv from the specified</a>
<a name="ln2832"> * buffer.</a>
<a name="ln2833"> * If 'retlist' is TRUE, then the lines are returned as a Vim List.</a>
<a name="ln2834"> */</a>
<a name="ln2835">static void get_buffer_lines(buf_T *buf,</a>
<a name="ln2836">                             linenr_T start,</a>
<a name="ln2837">                             linenr_T end,</a>
<a name="ln2838">                             int retlist,</a>
<a name="ln2839">                             typval_T *rettv)</a>
<a name="ln2840">{</a>
<a name="ln2841">  rettv-&gt;v_type = (retlist ? VAR_LIST : VAR_STRING);</a>
<a name="ln2842">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2843"> </a>
<a name="ln2844">  if (buf == NULL || buf-&gt;b_ml.ml_mfp == NULL || start &lt; 0 || end &lt; start) {</a>
<a name="ln2845">    if (retlist) {</a>
<a name="ln2846">      tv_list_alloc_ret(rettv, 0);</a>
<a name="ln2847">    }</a>
<a name="ln2848">    return;</a>
<a name="ln2849">  }</a>
<a name="ln2850"> </a>
<a name="ln2851">  if (retlist) {</a>
<a name="ln2852">    if (start &lt; 1) {</a>
<a name="ln2853">      start = 1;</a>
<a name="ln2854">    }</a>
<a name="ln2855">    if (end &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2856">      end = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2857">    }</a>
<a name="ln2858">    tv_list_alloc_ret(rettv, end - start + 1);</a>
<a name="ln2859">    while (start &lt;= end) {</a>
<a name="ln2860">      tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln2861">                            (const char *)ml_get_buf(buf, start++, false), -1);</a>
<a name="ln2862">    }</a>
<a name="ln2863">  } else {</a>
<a name="ln2864">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2865">    rettv-&gt;vval.v_string = ((start &gt;= 1 &amp;&amp; start &lt;= buf-&gt;b_ml.ml_line_count)</a>
<a name="ln2866">                            ? vim_strsave(ml_get_buf(buf, start, false))</a>
<a name="ln2867">                            : NULL);</a>
<a name="ln2868">  }</a>
<a name="ln2869">}</a>
<a name="ln2870"> </a>
<a name="ln2871">/*</a>
<a name="ln2872"> * &quot;getbufline()&quot; function</a>
<a name="ln2873"> */</a>
<a name="ln2874">static void f_getbufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2875">{</a>
<a name="ln2876">  buf_T *const buf = tv_get_buf_from_arg(&amp;argvars[0]);</a>
<a name="ln2877"> </a>
<a name="ln2878">  const linenr_T lnum = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln2879">  const linenr_T end = (argvars[2].v_type == VAR_UNKNOWN</a>
<a name="ln2880">                        ? lnum</a>
<a name="ln2881">                        : tv_get_lnum_buf(&amp;argvars[2], buf));</a>
<a name="ln2882"> </a>
<a name="ln2883">  get_buffer_lines(buf, lnum, end, true, rettv);</a>
<a name="ln2884">}</a>
<a name="ln2885"> </a>
<a name="ln2886">/*</a>
<a name="ln2887"> * &quot;getbufvar()&quot; function</a>
<a name="ln2888"> */</a>
<a name="ln2889">static void f_getbufvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2890">{</a>
<a name="ln2891">  bool done = false;</a>
<a name="ln2892"> </a>
<a name="ln2893">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2894">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2895"> </a>
<a name="ln2896">  if (!tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln2897">    goto f_getbufvar_end;</a>
<a name="ln2898">  }</a>
<a name="ln2899"> </a>
<a name="ln2900">  const char *varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln2901">  emsg_off++;</a>
<a name="ln2902">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln2903"> </a>
<a name="ln2904">  if (buf != NULL &amp;&amp; varname != NULL) {</a>
<a name="ln2905">    if (*varname == '&amp;') {  // buffer-local-option</a>
<a name="ln2906">      buf_T *const save_curbuf = curbuf;</a>
<a name="ln2907"> </a>
<a name="ln2908">      // set curbuf to be our buf, temporarily</a>
<a name="ln2909">      curbuf = buf;</a>
<a name="ln2910"> </a>
<a name="ln2911">      if (varname[1] == NUL) {</a>
<a name="ln2912">        // get all buffer-local options in a dict</a>
<a name="ln2913">        dict_T *opts = get_winbuf_options(true);</a>
<a name="ln2914"> </a>
<a name="ln2915">        if (opts != NULL) {</a>
<a name="ln2916">          tv_dict_set_ret(rettv, opts);</a>
<a name="ln2917">          done = true;</a>
<a name="ln2918">        }</a>
<a name="ln2919">      } else if (get_option_tv(&amp;varname, rettv, true) == OK) {</a>
<a name="ln2920">        // buffer-local-option</a>
<a name="ln2921">        done = true;</a>
<a name="ln2922">      }</a>
<a name="ln2923"> </a>
<a name="ln2924">      // restore previous notion of curbuf</a>
<a name="ln2925">      curbuf = save_curbuf;</a>
<a name="ln2926">    } else {</a>
<a name="ln2927">      // Look up the variable.</a>
<a name="ln2928">      // Let getbufvar({nr}, &quot;&quot;) return the &quot;b:&quot; dictionary.</a>
<a name="ln2929">      dictitem_T *const v = *varname == NUL</a>
<a name="ln2930">        ? (dictitem_T *)&amp;buf-&gt;b_bufvar</a>
<a name="ln2931">        : find_var_in_ht(&amp;buf-&gt;b_vars-&gt;dv_hashtab, 'b',</a>
<a name="ln2932">                         varname, strlen(varname), false);</a>
<a name="ln2933">      if (v != NULL) {</a>
<a name="ln2934">        tv_copy(&amp;v-&gt;di_tv, rettv);</a>
<a name="ln2935">        done = true;</a>
<a name="ln2936">      }</a>
<a name="ln2937">    }</a>
<a name="ln2938">  }</a>
<a name="ln2939">  emsg_off--;</a>
<a name="ln2940"> </a>
<a name="ln2941">f_getbufvar_end:</a>
<a name="ln2942">  if (!done &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2943">    // use the default value</a>
<a name="ln2944">    tv_copy(&amp;argvars[2], rettv);</a>
<a name="ln2945">  }</a>
<a name="ln2946">}</a>
<a name="ln2947"> </a>
<a name="ln2948">// &quot;getchangelist()&quot; function</a>
<a name="ln2949">static void f_getchangelist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2950">{</a>
<a name="ln2951">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln2952">  vim_ignored = tv_get_number(&amp;argvars[0]);  // issue errmsg if type error</a>
<a name="ln2953">  emsg_off++;</a>
<a name="ln2954">  const buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln2955">  emsg_off--;</a>
<a name="ln2956">  if (buf == NULL) {</a>
<a name="ln2957">    return;</a>
<a name="ln2958">  }</a>
<a name="ln2959"> </a>
<a name="ln2960">  list_T *const l = tv_list_alloc(buf-&gt;b_changelistlen);</a>
<a name="ln2961">  tv_list_append_list(rettv-&gt;vval.v_list, l);</a>
<a name="ln2962">  // The current window change list index tracks only the position in the</a>
<a name="ln2963">  // current buffer change list. For other buffers, use the change list</a>
<a name="ln2964">  // length as the current index.</a>
<a name="ln2965">  tv_list_append_number(rettv-&gt;vval.v_list,</a>
<a name="ln2966">                        (buf == curwin-&gt;w_buffer)</a>
<a name="ln2967">                        ? curwin-&gt;w_changelistidx</a>
<a name="ln2968">                        : buf-&gt;b_changelistlen);</a>
<a name="ln2969"> </a>
<a name="ln2970">  for (int i = 0; i &lt; buf-&gt;b_changelistlen; i++) {</a>
<a name="ln2971">    if (buf-&gt;b_changelist[i].mark.lnum == 0) {</a>
<a name="ln2972">      continue;</a>
<a name="ln2973">    }</a>
<a name="ln2974">    dict_T *const d = tv_dict_alloc();</a>
<a name="ln2975">    tv_list_append_dict(l, d);</a>
<a name="ln2976">    tv_dict_add_nr(d, S_LEN(&quot;lnum&quot;), buf-&gt;b_changelist[i].mark.lnum);</a>
<a name="ln2977">    tv_dict_add_nr(d, S_LEN(&quot;col&quot;), buf-&gt;b_changelist[i].mark.col);</a>
<a name="ln2978">    tv_dict_add_nr(d, S_LEN(&quot;coladd&quot;), buf-&gt;b_changelist[i].mark.coladd);</a>
<a name="ln2979">  }</a>
<a name="ln2980">}</a>
<a name="ln2981"> </a>
<a name="ln2982">/*</a>
<a name="ln2983"> * &quot;getchar()&quot; function</a>
<a name="ln2984"> */</a>
<a name="ln2985">static void f_getchar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2986">{</a>
<a name="ln2987">  varnumber_T n;</a>
<a name="ln2988">  bool error = false;</a>
<a name="ln2989"> </a>
<a name="ln2990">  no_mapping++;</a>
<a name="ln2991">  for (;; ) {</a>
<a name="ln2992">    // Position the cursor.  Needed after a message that ends in a space,</a>
<a name="ln2993">    // or if event processing caused a redraw.</a>
<a name="ln2994">    ui_cursor_goto(msg_row, msg_col);</a>
<a name="ln2995"> </a>
<a name="ln2996">    if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln2997">      // getchar(): blocking wait.</a>
<a name="ln2998">      // TODO(bfredl): deduplicate shared logic with state_enter ?</a>
<a name="ln2999">      if (!(char_avail() || using_script() || input_available())) {</a>
<a name="ln3000">        (void)os_inchar(NULL, 0, -1, 0, main_loop.events);</a>
<a name="ln3001">        if (!multiqueue_empty(main_loop.events)) {</a>
<a name="ln3002">          state_handle_k_event();</a>
<a name="ln3003">          continue;</a>
<a name="ln3004">        }</a>
<a name="ln3005">      }</a>
<a name="ln3006">      n = safe_vgetc();</a>
<a name="ln3007">    } else if (tv_get_number_chk(&amp;argvars[0], &amp;error) == 1) {</a>
<a name="ln3008">      // getchar(1): only check if char avail</a>
<a name="ln3009">      n = vpeekc_any();</a>
<a name="ln3010">    } else if (error || vpeekc_any() == NUL) {</a>
<a name="ln3011">      // illegal argument or getchar(0) and no char avail: return zero</a>
<a name="ln3012">      n = 0;</a>
<a name="ln3013">    } else {</a>
<a name="ln3014">      // getchar(0) and char avail() != NUL: get a character.</a>
<a name="ln3015">      // Note that vpeekc_any() returns K_SPECIAL for K_IGNORE.</a>
<a name="ln3016">      n = safe_vgetc();</a>
<a name="ln3017">    }</a>
<a name="ln3018"> </a>
<a name="ln3019">    if (n == K_IGNORE || n == K_VER_SCROLLBAR || n == K_HOR_SCROLLBAR) {</a>
<a name="ln3020">      continue;</a>
<a name="ln3021">    }</a>
<a name="ln3022">    break;</a>
<a name="ln3023">  }</a>
<a name="ln3024">  no_mapping--;</a>
<a name="ln3025"> </a>
<a name="ln3026">  set_vim_var_nr(VV_MOUSE_WIN, 0);</a>
<a name="ln3027">  set_vim_var_nr(VV_MOUSE_WINID, 0);</a>
<a name="ln3028">  set_vim_var_nr(VV_MOUSE_LNUM, 0);</a>
<a name="ln3029">  set_vim_var_nr(VV_MOUSE_COL, 0);</a>
<a name="ln3030"> </a>
<a name="ln3031">  rettv-&gt;vval.v_number = n;</a>
<a name="ln3032">  if (IS_SPECIAL(n) || mod_mask != 0) {</a>
<a name="ln3033">    char_u temp[10];                // modifier: 3, mbyte-char: 6, NUL: 1</a>
<a name="ln3034">    int i = 0;</a>
<a name="ln3035"> </a>
<a name="ln3036">    // Turn a special key into three bytes, plus modifier.</a>
<a name="ln3037">    if (mod_mask != 0) {</a>
<a name="ln3038">      temp[i++] = K_SPECIAL;</a>
<a name="ln3039">      temp[i++] = KS_MODIFIER;</a>
<a name="ln3040">      temp[i++] = mod_mask;</a>
<a name="ln3041">    }</a>
<a name="ln3042">    if (IS_SPECIAL(n)) {</a>
<a name="ln3043">      temp[i++] = K_SPECIAL;</a>
<a name="ln3044">      temp[i++] = K_SECOND(n);</a>
<a name="ln3045">      temp[i++] = K_THIRD(n);</a>
<a name="ln3046">    } else {</a>
<a name="ln3047">      i += utf_char2bytes(n, temp + i);</a>
<a name="ln3048">    }</a>
<a name="ln3049">    temp[i++] = NUL;</a>
<a name="ln3050">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3051">    rettv-&gt;vval.v_string = vim_strsave(temp);</a>
<a name="ln3052"> </a>
<a name="ln3053">    if (is_mouse_key(n)) {</a>
<a name="ln3054">      int row = mouse_row;</a>
<a name="ln3055">      int col = mouse_col;</a>
<a name="ln3056">      int grid = mouse_grid;</a>
<a name="ln3057">      win_T       *win;</a>
<a name="ln3058">      linenr_T lnum;</a>
<a name="ln3059">      win_T       *wp;</a>
<a name="ln3060">      int winnr = 1;</a>
<a name="ln3061"> </a>
<a name="ln3062">      if (row &gt;= 0 &amp;&amp; col &gt;= 0) {</a>
<a name="ln3063">        /* Find the window at the mouse coordinates and compute the</a>
<a name="ln3064">         * text position. */</a>
<a name="ln3065">        win = mouse_find_win(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln3066">        if (win == NULL) {</a>
<a name="ln3067">          return;</a>
<a name="ln3068">        }</a>
<a name="ln3069">        (void)mouse_comp_pos(win, &amp;row, &amp;col, &amp;lnum);</a>
<a name="ln3070">        for (wp = firstwin; wp != win; wp = wp-&gt;w_next)</a>
<a name="ln3071">          ++winnr;</a>
<a name="ln3072">        set_vim_var_nr(VV_MOUSE_WIN, winnr);</a>
<a name="ln3073">        set_vim_var_nr(VV_MOUSE_WINID, wp-&gt;handle);</a>
<a name="ln3074">        set_vim_var_nr(VV_MOUSE_LNUM, lnum);</a>
<a name="ln3075">        set_vim_var_nr(VV_MOUSE_COL, col + 1);</a>
<a name="ln3076">      }</a>
<a name="ln3077">    }</a>
<a name="ln3078">  }</a>
<a name="ln3079">}</a>
<a name="ln3080"> </a>
<a name="ln3081">/*</a>
<a name="ln3082"> * &quot;getcharmod()&quot; function</a>
<a name="ln3083"> */</a>
<a name="ln3084">static void f_getcharmod(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3085">{</a>
<a name="ln3086">  rettv-&gt;vval.v_number = mod_mask;</a>
<a name="ln3087">}</a>
<a name="ln3088"> </a>
<a name="ln3089">/*</a>
<a name="ln3090"> * &quot;getcharsearch()&quot; function</a>
<a name="ln3091"> */</a>
<a name="ln3092">static void f_getcharsearch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3093">{</a>
<a name="ln3094">  tv_dict_alloc_ret(rettv);</a>
<a name="ln3095"> </a>
<a name="ln3096">  dict_T *dict = rettv-&gt;vval.v_dict;</a>
<a name="ln3097"> </a>
<a name="ln3098">  tv_dict_add_str(dict, S_LEN(&quot;char&quot;), last_csearch());</a>
<a name="ln3099">  tv_dict_add_nr(dict, S_LEN(&quot;forward&quot;), last_csearch_forward());</a>
<a name="ln3100">  tv_dict_add_nr(dict, S_LEN(&quot;until&quot;), last_csearch_until());</a>
<a name="ln3101">}</a>
<a name="ln3102"> </a>
<a name="ln3103">/*</a>
<a name="ln3104"> * &quot;getcmdline()&quot; function</a>
<a name="ln3105"> */</a>
<a name="ln3106">static void f_getcmdline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3107">{</a>
<a name="ln3108">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3109">  rettv-&gt;vval.v_string = get_cmdline_str();</a>
<a name="ln3110">}</a>
<a name="ln3111"> </a>
<a name="ln3112">/*</a>
<a name="ln3113"> * &quot;getcmdpos()&quot; function</a>
<a name="ln3114"> */</a>
<a name="ln3115">static void f_getcmdpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3116">{</a>
<a name="ln3117">  rettv-&gt;vval.v_number = get_cmdline_pos() + 1;</a>
<a name="ln3118">}</a>
<a name="ln3119"> </a>
<a name="ln3120">/*</a>
<a name="ln3121"> * &quot;getcmdtype()&quot; function</a>
<a name="ln3122"> */</a>
<a name="ln3123">static void f_getcmdtype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3124">{</a>
<a name="ln3125">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3126">  rettv-&gt;vval.v_string = xmallocz(1);</a>
<a name="ln3127">  rettv-&gt;vval.v_string[0] = get_cmdline_type();</a>
<a name="ln3128">}</a>
<a name="ln3129"> </a>
<a name="ln3130">/*</a>
<a name="ln3131"> * &quot;getcmdwintype()&quot; function</a>
<a name="ln3132"> */</a>
<a name="ln3133">static void f_getcmdwintype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3134">{</a>
<a name="ln3135">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3136">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3137">  rettv-&gt;vval.v_string = xmallocz(1);</a>
<a name="ln3138">  rettv-&gt;vval.v_string[0] = cmdwin_type;</a>
<a name="ln3139">}</a>
<a name="ln3140"> </a>
<a name="ln3141">// &quot;getcompletion()&quot; function</a>
<a name="ln3142">static void f_getcompletion(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3143">{</a>
<a name="ln3144">  char_u        *pat;</a>
<a name="ln3145">  expand_T      xpc;</a>
<a name="ln3146">  bool          filtered = false;</a>
<a name="ln3147">  int           options = WILD_SILENT | WILD_USE_NL | WILD_ADD_SLASH</a>
<a name="ln3148">          | WILD_NO_BEEP;</a>
<a name="ln3149"> </a>
<a name="ln3150">  if (argvars[1].v_type != VAR_STRING) {</a>
<a name="ln3151">    EMSG2(_(e_invarg2), &quot;type must be a string&quot;);</a>
<a name="ln3152">    return;</a>
<a name="ln3153">  }</a>
<a name="ln3154">  const char *const type = tv_get_string(&amp;argvars[1]);</a>
<a name="ln3155"> </a>
<a name="ln3156">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3157">    filtered = (bool)tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln3158">  }</a>
<a name="ln3159"> </a>
<a name="ln3160">  if (p_wic) {</a>
<a name="ln3161">    options |= WILD_ICASE;</a>
<a name="ln3162">  }</a>
<a name="ln3163"> </a>
<a name="ln3164">  // For filtered results, 'wildignore' is used</a>
<a name="ln3165">  if (!filtered) {</a>
<a name="ln3166">    options |= WILD_KEEP_ALL;</a>
<a name="ln3167">  }</a>
<a name="ln3168"> </a>
<a name="ln3169">  if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln3170">    EMSG(_(e_invarg));</a>
<a name="ln3171">    return;</a>
<a name="ln3172">  }</a>
<a name="ln3173"> </a>
<a name="ln3174">  if (strcmp(type, &quot;cmdline&quot;) == 0) {</a>
<a name="ln3175">    set_one_cmd_context(&amp;xpc, tv_get_string(&amp;argvars[0]));</a>
<a name="ln3176">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3177">    goto theend;</a>
<a name="ln3178">  }</a>
<a name="ln3179"> </a>
<a name="ln3180">  ExpandInit(&amp;xpc);</a>
<a name="ln3181">  xpc.xp_pattern = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln3182">  xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3183">  xpc.xp_context = cmdcomplete_str_to_type(type);</a>
<a name="ln3184">  if (xpc.xp_context == EXPAND_NOTHING) {</a>
<a name="ln3185">    EMSG2(_(e_invarg2), type);</a>
<a name="ln3186">    return;</a>
<a name="ln3187">  }</a>
<a name="ln3188"> </a>
<a name="ln3189">  if (xpc.xp_context == EXPAND_MENUS) {</a>
<a name="ln3190">    set_context_in_menu_cmd(&amp;xpc, &quot;menu&quot;, xpc.xp_pattern, false);</a>
<a name="ln3191">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3192">  }</a>
<a name="ln3193"> </a>
<a name="ln3194">  if (xpc.xp_context == EXPAND_CSCOPE) {</a>
<a name="ln3195">    set_context_in_cscope_cmd(&amp;xpc, (const char *)xpc.xp_pattern, CMD_cscope);</a>
<a name="ln3196">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3197">  }</a>
<a name="ln3198"> </a>
<a name="ln3199">  if (xpc.xp_context == EXPAND_SIGN) {</a>
<a name="ln3200">    set_context_in_sign_cmd(&amp;xpc, xpc.xp_pattern);</a>
<a name="ln3201">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3202">  }</a>
<a name="ln3203"> </a>
<a name="ln3204">theend:</a>
<a name="ln3205">  pat = addstar(xpc.xp_pattern, xpc.xp_pattern_len, xpc.xp_context);</a>
<a name="ln3206">  ExpandOne(&amp;xpc, pat, NULL, options, WILD_ALL_KEEP);</a>
<a name="ln3207">  tv_list_alloc_ret(rettv, xpc.xp_numfiles);</a>
<a name="ln3208"> </a>
<a name="ln3209">  for (int i = 0; i &lt; xpc.xp_numfiles; i++) {</a>
<a name="ln3210">    tv_list_append_string(rettv-&gt;vval.v_list, (const char *)xpc.xp_files[i],</a>
<a name="ln3211">                          -1);</a>
<a name="ln3212">  }</a>
<a name="ln3213">  xfree(pat);</a>
<a name="ln3214">  ExpandCleanup(&amp;xpc);</a>
<a name="ln3215">}</a>
<a name="ln3216"> </a>
<a name="ln3217">/// `getcwd([{win}[, {tab}]])` function</a>
<a name="ln3218">///</a>
<a name="ln3219">/// Every scope not specified implies the currently selected scope object.</a>
<a name="ln3220">///</a>
<a name="ln3221">/// @pre  The arguments must be of type number.</a>
<a name="ln3222">/// @pre  There may not be more than two arguments.</a>
<a name="ln3223">/// @pre  An argument may not be -1 if preceding arguments are not all -1.</a>
<a name="ln3224">///</a>
<a name="ln3225">/// @post  The return value will be a string.</a>
<a name="ln3226">static void f_getcwd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3227">{</a>
<a name="ln3228">  // Possible scope of working directory to return.</a>
<a name="ln3229">  CdScope scope = kCdScopeInvalid;</a>
<a name="ln3230"> </a>
<a name="ln3231">  // Numbers of the scope objects (window, tab) we want the working directory</a>
<a name="ln3232">  // of. A `-1` means to skip this scope, a `0` means the current object.</a>
<a name="ln3233">  int scope_number[] = {</a>
<a name="ln3234">    [kCdScopeWindow] = 0,  // Number of window to look at.</a>
<a name="ln3235">    [kCdScopeTab   ] = 0,  // Number of tab to look at.</a>
<a name="ln3236">  };</a>
<a name="ln3237"> </a>
<a name="ln3238">  char_u *cwd  = NULL;  // Current working directory to print</a>
<a name="ln3239">  char_u *from = NULL;  // The original string to copy</a>
<a name="ln3240"> </a>
<a name="ln3241">  tabpage_T *tp  = curtab;  // The tabpage to look at.</a>
<a name="ln3242">  win_T     *win = curwin;  // The window to look at.</a>
<a name="ln3243"> </a>
<a name="ln3244">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3245">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3246"> </a>
<a name="ln3247">  // Pre-conditions and scope extraction together</a>
<a name="ln3248">  for (int i = MIN_CD_SCOPE; i &lt; MAX_CD_SCOPE; i++) {</a>
<a name="ln3249">    // If there is no argument there are no more scopes after it, break out.</a>
<a name="ln3250">    if (argvars[i].v_type == VAR_UNKNOWN) {</a>
<a name="ln3251">      break;</a>
<a name="ln3252">    }</a>
<a name="ln3253">    if (argvars[i].v_type != VAR_NUMBER) {</a>
<a name="ln3254">      EMSG(_(e_invarg));</a>
<a name="ln3255">      return;</a>
<a name="ln3256">    }</a>
<a name="ln3257">    scope_number[i] = argvars[i].vval.v_number;</a>
<a name="ln3258">    // It is an error for the scope number to be less than `-1`.</a>
<a name="ln3259">    if (scope_number[i] &lt; -1) {</a>
<a name="ln3260">      EMSG(_(e_invarg));</a>
<a name="ln3261">      return;</a>
<a name="ln3262">    }</a>
<a name="ln3263">    // Use the narrowest scope the user requested</a>
<a name="ln3264">    if (scope_number[i] &gt;= 0 &amp;&amp; scope == kCdScopeInvalid) {</a>
<a name="ln3265">      // The scope is the current iteration step.</a>
<a name="ln3266">      scope = i;</a>
<a name="ln3267">    } else if (scope_number[i] &lt; 0) {</a>
<a name="ln3268">      scope = i + 1;</a>
<a name="ln3269">    }</a>
<a name="ln3270">  }</a>
<a name="ln3271"> </a>
<a name="ln3272">  // If the user didn't specify anything, default to window scope</a>
<a name="ln3273">  if (scope == kCdScopeInvalid) {</a>
<a name="ln3274">    scope = MIN_CD_SCOPE;</a>
<a name="ln3275">  }</a>
<a name="ln3276"> </a>
<a name="ln3277">  // Find the tabpage by number</a>
<a name="ln3278">  if (scope_number[kCdScopeTab] &gt; 0) {</a>
<a name="ln3279">    tp = find_tabpage(scope_number[kCdScopeTab]);</a>
<a name="ln3280">    if (!tp) {</a>
<a name="ln3281">      EMSG(_(&quot;E5000: Cannot find tab number.&quot;));</a>
<a name="ln3282">      return;</a>
<a name="ln3283">    }</a>
<a name="ln3284">  }</a>
<a name="ln3285"> </a>
<a name="ln3286">  // Find the window in `tp` by number, `NULL` if none.</a>
<a name="ln3287">  if (scope_number[kCdScopeWindow] &gt;= 0) {</a>
<a name="ln3288">    if (scope_number[kCdScopeTab] &lt; 0) {</a>
<a name="ln3289">      EMSG(_(&quot;E5001: Higher scope cannot be -1 if lower scope is &gt;= 0.&quot;));</a>
<a name="ln3290">      return;</a>
<a name="ln3291">    }</a>
<a name="ln3292"> </a>
<a name="ln3293">    if (scope_number[kCdScopeWindow] &gt; 0) {</a>
<a name="ln3294">      win = find_win_by_nr(&amp;argvars[0], tp);</a>
<a name="ln3295">      if (!win) {</a>
<a name="ln3296">        EMSG(_(&quot;E5002: Cannot find window number.&quot;));</a>
<a name="ln3297">        return;</a>
<a name="ln3298">      }</a>
<a name="ln3299">    }</a>
<a name="ln3300">  }</a>
<a name="ln3301"> </a>
<a name="ln3302">  cwd = xmalloc(MAXPATHL);</a>
<a name="ln3303"> </a>
<a name="ln3304">  switch (scope) {</a>
<a name="ln3305">    case kCdScopeWindow:</a>
<a name="ln3306">      assert(win);</a>
<a name="ln3307">      from = win-&gt;w_localdir;</a>
<a name="ln3308">      if (from) {</a>
<a name="ln3309">        break;</a>
<a name="ln3310">      }</a>
<a name="ln3311">      FALLTHROUGH;</a>
<a name="ln3312">    case kCdScopeTab:</a>
<a name="ln3313">      assert(tp);</a>
<a name="ln3314">      from = tp-&gt;tp_localdir;</a>
<a name="ln3315">      if (from) {</a>
<a name="ln3316">        break;</a>
<a name="ln3317">      }</a>
<a name="ln3318">      FALLTHROUGH;</a>
<a name="ln3319">    case kCdScopeGlobal:</a>
<a name="ln3320">      if (globaldir) {        // `globaldir` is not always set.</a>
<a name="ln3321">        from = globaldir;</a>
<a name="ln3322">      } else if (os_dirname(cwd, MAXPATHL) == FAIL) {  // Get the OS CWD.</a>
<a name="ln3323">        from = (char_u *)&quot;&quot;;  // Return empty string on failure.</a>
<a name="ln3324">      }</a>
<a name="ln3325">      break;</a>
<a name="ln3326">    case kCdScopeInvalid:     // We should never get here</a>
<a name="ln3327">      abort();</a>
<a name="ln3328">  }</a>
<a name="ln3329"> </a>
<a name="ln3330">  if (from) {</a>
<a name="ln3331">    xstrlcpy((char *)cwd, (char *)from, MAXPATHL);</a>
<a name="ln3332">  }</a>
<a name="ln3333"> </a>
<a name="ln3334">  rettv-&gt;vval.v_string = vim_strsave(cwd);</a>
<a name="ln3335">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3336">  slash_adjust(rettv-&gt;vval.v_string);</a>
<a name="ln3337">#endif</a>
<a name="ln3338"> </a>
<a name="ln3339">  xfree(cwd);</a>
<a name="ln3340">}</a>
<a name="ln3341"> </a>
<a name="ln3342">/*</a>
<a name="ln3343"> * &quot;getfontname()&quot; function</a>
<a name="ln3344"> */</a>
<a name="ln3345">static void f_getfontname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3346">{</a>
<a name="ln3347">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3348">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3349">}</a>
<a name="ln3350"> </a>
<a name="ln3351">/*</a>
<a name="ln3352"> * &quot;getfperm({fname})&quot; function</a>
<a name="ln3353"> */</a>
<a name="ln3354">static void f_getfperm(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3355">{</a>
<a name="ln3356">  char *perm = NULL;</a>
<a name="ln3357">  char_u flags[] = &quot;rwx&quot;;</a>
<a name="ln3358"> </a>
<a name="ln3359">  const char *filename = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3360">  int32_t file_perm = os_getperm(filename);</a>
<a name="ln3361">  if (file_perm &gt;= 0) {</a>
<a name="ln3362">    perm = xstrdup(&quot;---------&quot;);</a>
<a name="ln3363">    for (int i = 0; i &lt; 9; i++) {</a>
<a name="ln3364">      if (file_perm &amp; (1 &lt;&lt; (8 - i))) {</a>
<a name="ln3365">        perm[i] = flags[i % 3];</a>
<a name="ln3366">      }</a>
<a name="ln3367">    }</a>
<a name="ln3368">  }</a>
<a name="ln3369">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3370">  rettv-&gt;vval.v_string = (char_u *)perm;</a>
<a name="ln3371">}</a>
<a name="ln3372"> </a>
<a name="ln3373">/*</a>
<a name="ln3374"> * &quot;getfsize({fname})&quot; function</a>
<a name="ln3375"> */</a>
<a name="ln3376">static void f_getfsize(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3377">{</a>
<a name="ln3378">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3379"> </a>
<a name="ln3380">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3381"> </a>
<a name="ln3382">  FileInfo file_info;</a>
<a name="ln3383">  if (os_fileinfo(fname, &amp;file_info)) {</a>
<a name="ln3384">    uint64_t filesize = os_fileinfo_size(&amp;file_info);</a>
<a name="ln3385">    if (os_isdir((const char_u *)fname)) {</a>
<a name="ln3386">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln3387">    } else {</a>
<a name="ln3388">      rettv-&gt;vval.v_number = (varnumber_T)filesize;</a>
<a name="ln3389"> </a>
<a name="ln3390">      // non-perfect check for overflow</a>
<a name="ln3391">      if ((uint64_t)rettv-&gt;vval.v_number != filesize) {</a>
<a name="ln3392">        rettv-&gt;vval.v_number = -2;</a>
<a name="ln3393">      }</a>
<a name="ln3394">    }</a>
<a name="ln3395">  } else {</a>
<a name="ln3396">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln3397">  }</a>
<a name="ln3398">}</a>
<a name="ln3399"> </a>
<a name="ln3400">/*</a>
<a name="ln3401"> * &quot;getftime({fname})&quot; function</a>
<a name="ln3402"> */</a>
<a name="ln3403">static void f_getftime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3404">{</a>
<a name="ln3405">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3406"> </a>
<a name="ln3407">  FileInfo file_info;</a>
<a name="ln3408">  if (os_fileinfo(fname, &amp;file_info)) {</a>
<a name="ln3409">    rettv-&gt;vval.v_number = (varnumber_T)file_info.stat.st_mtim.tv_sec;</a>
<a name="ln3410">  } else {</a>
<a name="ln3411">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln3412">  }</a>
<a name="ln3413">}</a>
<a name="ln3414"> </a>
<a name="ln3415">/*</a>
<a name="ln3416"> * &quot;getftype({fname})&quot; function</a>
<a name="ln3417"> */</a>
<a name="ln3418">static void f_getftype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3419">{</a>
<a name="ln3420">  char_u      *type = NULL;</a>
<a name="ln3421">  char        *t;</a>
<a name="ln3422"> </a>
<a name="ln3423">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3424"> </a>
<a name="ln3425">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3426">  FileInfo file_info;</a>
<a name="ln3427">  if (os_fileinfo_link(fname, &amp;file_info)) {</a>
<a name="ln3428">    uint64_t mode = file_info.stat.st_mode;</a>
<a name="ln3429">    if (S_ISREG(mode)) {</a>
<a name="ln3430">      t = &quot;file&quot;;</a>
<a name="ln3431">    } else if (S_ISDIR(mode)) {</a>
<a name="ln3432">      t = &quot;dir&quot;;</a>
<a name="ln3433">    } else if (S_ISLNK(mode)) {</a>
<a name="ln3434">      t = &quot;link&quot;;</a>
<a name="ln3435">    } else if (S_ISBLK(mode)) {</a>
<a name="ln3436">      t = &quot;bdev&quot;;</a>
<a name="ln3437">    } else if (S_ISCHR(mode)) {</a>
<a name="ln3438">      t = &quot;cdev&quot;;</a>
<a name="ln3439">    } else if (S_ISFIFO(mode)) {</a>
<a name="ln3440">      t = &quot;fifo&quot;;</a>
<a name="ln3441">    } else if (S_ISSOCK(mode)) {</a>
<a name="ln3442">      t = &quot;socket&quot;;</a>
<a name="ln3443">    } else {</a>
<a name="ln3444">      t = &quot;other&quot;;</a>
<a name="ln3445">    }</a>
<a name="ln3446">    type = vim_strsave((char_u *)t);</a>
<a name="ln3447">  }</a>
<a name="ln3448">  rettv-&gt;vval.v_string = type;</a>
<a name="ln3449">}</a>
<a name="ln3450"> </a>
<a name="ln3451">// &quot;getjumplist()&quot; function</a>
<a name="ln3452">static void f_getjumplist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3453">{</a>
<a name="ln3454">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3455">  win_T *const wp = find_tabwin(&amp;argvars[0], &amp;argvars[1]);</a>
<a name="ln3456">  if (wp == NULL) {</a>
<a name="ln3457">    return;</a>
<a name="ln3458">  }</a>
<a name="ln3459"> </a>
<a name="ln3460">  cleanup_jumplist(wp, true);</a>
<a name="ln3461"> </a>
<a name="ln3462">  list_T *const l = tv_list_alloc(wp-&gt;w_jumplistlen);</a>
<a name="ln3463">  tv_list_append_list(rettv-&gt;vval.v_list, l);</a>
<a name="ln3464">  tv_list_append_number(rettv-&gt;vval.v_list, wp-&gt;w_jumplistidx);</a>
<a name="ln3465"> </a>
<a name="ln3466">  for (int i = 0; i &lt; wp-&gt;w_jumplistlen; i++) {</a>
<a name="ln3467">    if (wp-&gt;w_jumplist[i].fmark.mark.lnum == 0) {</a>
<a name="ln3468">      continue;</a>
<a name="ln3469">    }</a>
<a name="ln3470">    dict_T *const d = tv_dict_alloc();</a>
<a name="ln3471">    tv_list_append_dict(l, d);</a>
<a name="ln3472">    tv_dict_add_nr(d, S_LEN(&quot;lnum&quot;), wp-&gt;w_jumplist[i].fmark.mark.lnum);</a>
<a name="ln3473">    tv_dict_add_nr(d, S_LEN(&quot;col&quot;), wp-&gt;w_jumplist[i].fmark.mark.col);</a>
<a name="ln3474">    tv_dict_add_nr(d, S_LEN(&quot;coladd&quot;), wp-&gt;w_jumplist[i].fmark.mark.coladd);</a>
<a name="ln3475">    tv_dict_add_nr(d, S_LEN(&quot;bufnr&quot;), wp-&gt;w_jumplist[i].fmark.fnum);</a>
<a name="ln3476">    if (wp-&gt;w_jumplist[i].fname != NULL) {</a>
<a name="ln3477">      tv_dict_add_str(d, S_LEN(&quot;filename&quot;), (char *)wp-&gt;w_jumplist[i].fname);</a>
<a name="ln3478">    }</a>
<a name="ln3479">  }</a>
<a name="ln3480">}</a>
<a name="ln3481"> </a>
<a name="ln3482">/*</a>
<a name="ln3483"> * &quot;getline(lnum, [end])&quot; function</a>
<a name="ln3484"> */</a>
<a name="ln3485">static void f_getline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3486">{</a>
<a name="ln3487">  linenr_T end;</a>
<a name="ln3488">  bool retlist;</a>
<a name="ln3489"> </a>
<a name="ln3490">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln3491">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln3492">    end = lnum;</a>
<a name="ln3493">    retlist = false;</a>
<a name="ln3494">  } else {</a>
<a name="ln3495">    end = tv_get_lnum(&amp;argvars[1]);</a>
<a name="ln3496">    retlist = true;</a>
<a name="ln3497">  }</a>
<a name="ln3498"> </a>
<a name="ln3499">  get_buffer_lines(curbuf, lnum, end, retlist, rettv);</a>
<a name="ln3500">}</a>
<a name="ln3501"> </a>
<a name="ln3502">/// &quot;getloclist()&quot; function</a>
<a name="ln3503">static void f_getloclist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3504">{</a>
<a name="ln3505">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln3506">  get_qf_loc_list(false, wp, &amp;argvars[1], rettv);</a>
<a name="ln3507">}</a>
<a name="ln3508"> </a>
<a name="ln3509"> </a>
<a name="ln3510">/// &quot;getmarklist()&quot; function</a>
<a name="ln3511">static void f_getmarklist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3512">{</a>
<a name="ln3513">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3514"> </a>
<a name="ln3515">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln3516">    get_global_marks(rettv-&gt;vval.v_list);</a>
<a name="ln3517">    return;</a>
<a name="ln3518">  }</a>
<a name="ln3519"> </a>
<a name="ln3520">  buf_T *buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln3521">  if (buf == NULL) {</a>
<a name="ln3522">    return;</a>
<a name="ln3523">  }</a>
<a name="ln3524"> </a>
<a name="ln3525">  get_buf_local_marks(buf, rettv-&gt;vval.v_list);</a>
<a name="ln3526">}</a>
<a name="ln3527"> </a>
<a name="ln3528">/*</a>
<a name="ln3529"> * &quot;getmatches()&quot; function</a>
<a name="ln3530"> */</a>
<a name="ln3531">static void f_getmatches(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3532">{</a>
<a name="ln3533">  matchitem_T *cur;</a>
<a name="ln3534">  int i;</a>
<a name="ln3535">  win_T *win = get_optional_window(argvars, 0);</a>
<a name="ln3536"> </a>
<a name="ln3537">  if (win == NULL) {</a>
<a name="ln3538">    return;</a>
<a name="ln3539">  }</a>
<a name="ln3540"> </a>
<a name="ln3541">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3542">  cur = win-&gt;w_match_head;</a>
<a name="ln3543">  while (cur != NULL) {</a>
<a name="ln3544">    dict_T *dict = tv_dict_alloc();</a>
<a name="ln3545">    if (cur-&gt;match.regprog == NULL) {</a>
<a name="ln3546">      // match added with matchaddpos()</a>
<a name="ln3547">      for (i = 0; i &lt; MAXPOSMATCH; i++) {</a>
<a name="ln3548">        llpos_T   *llpos;</a>
<a name="ln3549">        char buf[30];  // use 30 to avoid compiler warning</a>
<a name="ln3550"> </a>
<a name="ln3551">        llpos = &amp;cur-&gt;pos.pos[i];</a>
<a name="ln3552">        if (llpos-&gt;lnum == 0) {</a>
<a name="ln3553">          break;</a>
<a name="ln3554">        }</a>
<a name="ln3555">        list_T *const l = tv_list_alloc(1 + (llpos-&gt;col &gt; 0 ? 2 : 0));</a>
<a name="ln3556">        tv_list_append_number(l, (varnumber_T)llpos-&gt;lnum);</a>
<a name="ln3557">        if (llpos-&gt;col &gt; 0) {</a>
<a name="ln3558">          tv_list_append_number(l, (varnumber_T)llpos-&gt;col);</a>
<a name="ln3559">          tv_list_append_number(l, (varnumber_T)llpos-&gt;len);</a>
<a name="ln3560">        }</a>
<a name="ln3561">        int len = snprintf(buf, sizeof(buf), &quot;pos%d&quot;, i + 1);</a>
<a name="ln3562">        assert((size_t)len &lt; sizeof(buf));</a>
<a name="ln3563">        tv_dict_add_list(dict, buf, (size_t)len, l);</a>
<a name="ln3564">      }</a>
<a name="ln3565">    } else {</a>
<a name="ln3566">      tv_dict_add_str(dict, S_LEN(&quot;pattern&quot;), (const char *)cur-&gt;pattern);</a>
<a name="ln3567">    }</a>
<a name="ln3568">    tv_dict_add_str(dict, S_LEN(&quot;group&quot;),</a>
<a name="ln3569">                    (const char *)syn_id2name(cur-&gt;hlg_id));</a>
<a name="ln3570">    tv_dict_add_nr(dict, S_LEN(&quot;priority&quot;), (varnumber_T)cur-&gt;priority);</a>
<a name="ln3571">    tv_dict_add_nr(dict, S_LEN(&quot;id&quot;), (varnumber_T)cur-&gt;id);</a>
<a name="ln3572"> </a>
<a name="ln3573">    if (cur-&gt;conceal_char) {</a>
<a name="ln3574">      char buf[MB_MAXBYTES + 1];</a>
<a name="ln3575"> </a>
<a name="ln3576">      buf[utf_char2bytes((int)cur-&gt;conceal_char, (char_u *)buf)] = NUL;</a>
<a name="ln3577">      tv_dict_add_str(dict, S_LEN(&quot;conceal&quot;), buf);</a>
<a name="ln3578">    }</a>
<a name="ln3579"> </a>
<a name="ln3580">    tv_list_append_dict(rettv-&gt;vval.v_list, dict);</a>
<a name="ln3581">    cur = cur-&gt;next;</a>
<a name="ln3582">  }</a>
<a name="ln3583">}</a>
<a name="ln3584"> </a>
<a name="ln3585">/*</a>
<a name="ln3586"> * &quot;getpid()&quot; function</a>
<a name="ln3587"> */</a>
<a name="ln3588">static void f_getpid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3589">{</a>
<a name="ln3590">  rettv-&gt;vval.v_number = os_get_pid();</a>
<a name="ln3591">}</a>
<a name="ln3592"> </a>
<a name="ln3593">static void getpos_both(typval_T *argvars, typval_T *rettv, bool getcurpos)</a>
<a name="ln3594">{</a>
<a name="ln3595">  pos_T *fp;</a>
<a name="ln3596">  int fnum = -1;</a>
<a name="ln3597"> </a>
<a name="ln3598">  if (getcurpos) {</a>
<a name="ln3599">    fp = &amp;curwin-&gt;w_cursor;</a>
<a name="ln3600">  } else {</a>
<a name="ln3601">    fp = var2fpos(&amp;argvars[0], true, &amp;fnum);</a>
<a name="ln3602">  }</a>
<a name="ln3603"> </a>
<a name="ln3604">  list_T *const l = tv_list_alloc_ret(rettv, 4 + (!!getcurpos));</a>
<a name="ln3605">  tv_list_append_number(l, (fnum != -1) ? (varnumber_T)fnum : (varnumber_T)0);</a>
<a name="ln3606">  tv_list_append_number(l, ((fp != NULL)</a>
<a name="ln3607">                            ? (varnumber_T)fp-&gt;lnum</a>
<a name="ln3608">                            : (varnumber_T)0));</a>
<a name="ln3609">  tv_list_append_number(</a>
<a name="ln3610">      l, ((fp != NULL)</a>
<a name="ln3611">          ? (varnumber_T)(fp-&gt;col == MAXCOL ? MAXCOL : fp-&gt;col + 1)</a>
<a name="ln3612">          : (varnumber_T)0));</a>
<a name="ln3613">  tv_list_append_number(</a>
<a name="ln3614">      l, (fp != NULL) ? (varnumber_T)fp-&gt;coladd : (varnumber_T)0);</a>
<a name="ln3615">  if (getcurpos) {</a>
<a name="ln3616">    const int save_set_curswant = curwin-&gt;w_set_curswant;</a>
<a name="ln3617">    const colnr_T save_curswant = curwin-&gt;w_curswant;</a>
<a name="ln3618">    const colnr_T save_virtcol = curwin-&gt;w_virtcol;</a>
<a name="ln3619"> </a>
<a name="ln3620">    update_curswant();</a>
<a name="ln3621">    tv_list_append_number(l, (curwin-&gt;w_curswant == MAXCOL</a>
<a name="ln3622">                              ? (varnumber_T)MAXCOL</a>
<a name="ln3623">                              : (varnumber_T)curwin-&gt;w_curswant + 1));</a>
<a name="ln3624"> </a>
<a name="ln3625">    // Do not change &quot;curswant&quot;, as it is unexpected that a get</a>
<a name="ln3626">    // function has a side effect.</a>
<a name="ln3627">    if (save_set_curswant) {</a>
<a name="ln3628">      curwin-&gt;w_set_curswant = save_set_curswant;</a>
<a name="ln3629">      curwin-&gt;w_curswant = save_curswant;</a>
<a name="ln3630">      curwin-&gt;w_virtcol = save_virtcol;</a>
<a name="ln3631">      curwin-&gt;w_valid &amp;= ~VALID_VIRTCOL;</a>
<a name="ln3632">    }</a>
<a name="ln3633">  }</a>
<a name="ln3634">}</a>
<a name="ln3635"> </a>
<a name="ln3636">/*</a>
<a name="ln3637"> * &quot;getcurpos(string)&quot; function</a>
<a name="ln3638"> */</a>
<a name="ln3639">static void f_getcurpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3640">{</a>
<a name="ln3641">  getpos_both(argvars, rettv, true);</a>
<a name="ln3642">}</a>
<a name="ln3643"> </a>
<a name="ln3644">/*</a>
<a name="ln3645"> * &quot;getpos(string)&quot; function</a>
<a name="ln3646"> */</a>
<a name="ln3647">static void f_getpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3648">{</a>
<a name="ln3649">  getpos_both(argvars, rettv, false);</a>
<a name="ln3650">}</a>
<a name="ln3651"> </a>
<a name="ln3652">/// &quot;getqflist()&quot; functions</a>
<a name="ln3653">static void f_getqflist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3654">{</a>
<a name="ln3655">  get_qf_loc_list(true, NULL, &amp;argvars[0], rettv);</a>
<a name="ln3656">}</a>
<a name="ln3657"> </a>
<a name="ln3658">/// &quot;getreg()&quot; function</a>
<a name="ln3659">static void f_getreg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3660">{</a>
<a name="ln3661">  const char *strregname;</a>
<a name="ln3662">  int arg2 = false;</a>
<a name="ln3663">  bool return_list = false;</a>
<a name="ln3664">  bool error = false;</a>
<a name="ln3665"> </a>
<a name="ln3666">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3667">    strregname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln3668">    error = strregname == NULL;</a>
<a name="ln3669">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln3670">      arg2 = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln3671">      if (!error &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3672">        return_list = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln3673">      }</a>
<a name="ln3674">    }</a>
<a name="ln3675">  } else {</a>
<a name="ln3676">    strregname = _(get_vim_var_str(VV_REG));</a>
<a name="ln3677">  }</a>
<a name="ln3678"> </a>
<a name="ln3679">  if (error) {</a>
<a name="ln3680">    return;</a>
<a name="ln3681">  }</a>
<a name="ln3682"> </a>
<a name="ln3683">  int regname = (uint8_t)(strregname == NULL ? '&quot;' : *strregname);</a>
<a name="ln3684">  if (regname == 0) {</a>
<a name="ln3685">    regname = '&quot;';</a>
<a name="ln3686">  }</a>
<a name="ln3687"> </a>
<a name="ln3688">  if (return_list) {</a>
<a name="ln3689">    rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln3690">    rettv-&gt;vval.v_list =</a>
<a name="ln3691">      get_reg_contents(regname, (arg2 ? kGRegExprSrc : 0) | kGRegList);</a>
<a name="ln3692">    if (rettv-&gt;vval.v_list == NULL) {</a>
<a name="ln3693">      rettv-&gt;vval.v_list = tv_list_alloc(0);</a>
<a name="ln3694">    }</a>
<a name="ln3695">    tv_list_ref(rettv-&gt;vval.v_list);</a>
<a name="ln3696">  } else {</a>
<a name="ln3697">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3698">    rettv-&gt;vval.v_string = get_reg_contents(regname, arg2 ? kGRegExprSrc : 0);</a>
<a name="ln3699">  }</a>
<a name="ln3700">}</a>
<a name="ln3701"> </a>
<a name="ln3702">/*</a>
<a name="ln3703"> * &quot;getregtype()&quot; function</a>
<a name="ln3704"> */</a>
<a name="ln3705">static void f_getregtype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3706">{</a>
<a name="ln3707">  const char *strregname;</a>
<a name="ln3708"> </a>
<a name="ln3709">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3710">    strregname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln3711">    if (strregname == NULL) {  // Type error; errmsg already given.</a>
<a name="ln3712">      rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3713">      rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3714">      return;</a>
<a name="ln3715">    }</a>
<a name="ln3716">  } else {</a>
<a name="ln3717">    // Default to v:register.</a>
<a name="ln3718">    strregname = _(get_vim_var_str(VV_REG));</a>
<a name="ln3719">  }</a>
<a name="ln3720"> </a>
<a name="ln3721">  int regname = (uint8_t)(strregname == NULL ? '&quot;' : *strregname);</a>
<a name="ln3722">  if (regname == 0) {</a>
<a name="ln3723">    regname = '&quot;';</a>
<a name="ln3724">  }</a>
<a name="ln3725"> </a>
<a name="ln3726">  colnr_T reglen = 0;</a>
<a name="ln3727">  char buf[NUMBUFLEN + 2];</a>
<a name="ln3728">  MotionType reg_type = get_reg_type(regname, &amp;reglen);</a>
<a name="ln3729">  format_reg_type(reg_type, reglen, buf, ARRAY_SIZE(buf));</a>
<a name="ln3730"> </a>
<a name="ln3731">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3732">  rettv-&gt;vval.v_string = (char_u *)xstrdup(buf);</a>
<a name="ln3733">}</a>
<a name="ln3734"> </a>
<a name="ln3735">/// &quot;gettabinfo()&quot; function</a>
<a name="ln3736">static void f_gettabinfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3737">{</a>
<a name="ln3738">  tabpage_T *tparg = NULL;</a>
<a name="ln3739"> </a>
<a name="ln3740">  tv_list_alloc_ret(rettv, (argvars[0].v_type == VAR_UNKNOWN</a>
<a name="ln3741">                            ? 1</a>
<a name="ln3742">                            : kListLenMayKnow));</a>
<a name="ln3743"> </a>
<a name="ln3744">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3745">    // Information about one tab page</a>
<a name="ln3746">    tparg = find_tabpage((int)tv_get_number_chk(&amp;argvars[0], NULL));</a>
<a name="ln3747">    if (tparg == NULL) {</a>
<a name="ln3748">      return;</a>
<a name="ln3749">    }</a>
<a name="ln3750">  }</a>
<a name="ln3751"> </a>
<a name="ln3752">  // Get information about a specific tab page or all tab pages</a>
<a name="ln3753">  int tpnr = 0;</a>
<a name="ln3754">  FOR_ALL_TABS(tp) {</a>
<a name="ln3755">    tpnr++;</a>
<a name="ln3756">    if (tparg != NULL &amp;&amp; tp != tparg) {</a>
<a name="ln3757">      continue;</a>
<a name="ln3758">    }</a>
<a name="ln3759">    dict_T *const d = get_tabpage_info(tp, tpnr);</a>
<a name="ln3760">    tv_list_append_dict(rettv-&gt;vval.v_list, d);</a>
<a name="ln3761">    if (tparg != NULL) {</a>
<a name="ln3762">      return;</a>
<a name="ln3763">    }</a>
<a name="ln3764">  }</a>
<a name="ln3765">}</a>
<a name="ln3766"> </a>
<a name="ln3767">/*</a>
<a name="ln3768"> * &quot;gettabvar()&quot; function</a>
<a name="ln3769"> */</a>
<a name="ln3770">static void f_gettabvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3771">{</a>
<a name="ln3772">  win_T *oldcurwin;</a>
<a name="ln3773">  tabpage_T *oldtabpage;</a>
<a name="ln3774">  bool done = false;</a>
<a name="ln3775"> </a>
<a name="ln3776">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3777">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3778"> </a>
<a name="ln3779">  const char *const varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln3780">  tabpage_T *const tp = find_tabpage((int)tv_get_number_chk(&amp;argvars[0], NULL));</a>
<a name="ln3781">  if (tp != NULL &amp;&amp; varname != NULL) {</a>
<a name="ln3782">    // Set tp to be our tabpage, temporarily.  Also set the window to the</a>
<a name="ln3783">    // first window in the tabpage, otherwise the window is not valid.</a>
<a name="ln3784">    win_T *const window = tp == curtab || tp-&gt;tp_firstwin == NULL</a>
<a name="ln3785">        ? firstwin</a>
<a name="ln3786">        : tp-&gt;tp_firstwin;</a>
<a name="ln3787">    if (switch_win(&amp;oldcurwin, &amp;oldtabpage, window, tp, true) == OK) {</a>
<a name="ln3788">      // look up the variable</a>
<a name="ln3789">      // Let gettabvar({nr}, &quot;&quot;) return the &quot;t:&quot; dictionary.</a>
<a name="ln3790">      const dictitem_T *const v = find_var_in_ht(&amp;tp-&gt;tp_vars-&gt;dv_hashtab, 't',</a>
<a name="ln3791">                                                 varname, strlen(varname),</a>
<a name="ln3792">                                                 false);</a>
<a name="ln3793">      if (v != NULL) {</a>
<a name="ln3794">        tv_copy(&amp;v-&gt;di_tv, rettv);</a>
<a name="ln3795">        done = true;</a>
<a name="ln3796">      }</a>
<a name="ln3797">    }</a>
<a name="ln3798"> </a>
<a name="ln3799">    // restore previous notion of curwin</a>
<a name="ln3800">    restore_win(oldcurwin, oldtabpage, true);</a>
<a name="ln3801">  }</a>
<a name="ln3802"> </a>
<a name="ln3803">  if (!done &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3804">    tv_copy(&amp;argvars[2], rettv);</a>
<a name="ln3805">  }</a>
<a name="ln3806">}</a>
<a name="ln3807"> </a>
<a name="ln3808">/*</a>
<a name="ln3809"> * &quot;gettabwinvar()&quot; function</a>
<a name="ln3810"> */</a>
<a name="ln3811">static void f_gettabwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3812">{</a>
<a name="ln3813">  getwinvar(argvars, rettv, 1);</a>
<a name="ln3814">}</a>
<a name="ln3815"> </a>
<a name="ln3816">// &quot;gettagstack()&quot; function</a>
<a name="ln3817">static void f_gettagstack(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3818">{</a>
<a name="ln3819">    win_T        *wp = curwin;                  // default is current window</a>
<a name="ln3820"> </a>
<a name="ln3821">    tv_dict_alloc_ret(rettv);</a>
<a name="ln3822"> </a>
<a name="ln3823">    if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3824">        wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln3825">        if (wp == NULL) {</a>
<a name="ln3826">          return;</a>
<a name="ln3827">        }</a>
<a name="ln3828">    }</a>
<a name="ln3829"> </a>
<a name="ln3830">    get_tagstack(wp, rettv-&gt;vval.v_dict);</a>
<a name="ln3831">}</a>
<a name="ln3832"> </a>
<a name="ln3833">/// &quot;getwininfo()&quot; function</a>
<a name="ln3834">static void f_getwininfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3835">{</a>
<a name="ln3836">  win_T *wparg = NULL;</a>
<a name="ln3837"> </a>
<a name="ln3838">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3839"> </a>
<a name="ln3840">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3841">    wparg = win_id2wp(argvars);</a>
<a name="ln3842">    if (wparg == NULL) {</a>
<a name="ln3843">      return;</a>
<a name="ln3844">    }</a>
<a name="ln3845">  }</a>
<a name="ln3846"> </a>
<a name="ln3847">  // Collect information about either all the windows across all the tab</a>
<a name="ln3848">  // pages or one particular window.</a>
<a name="ln3849">  int16_t tabnr = 0;</a>
<a name="ln3850">  FOR_ALL_TABS(tp) {</a>
<a name="ln3851">    tabnr++;</a>
<a name="ln3852">    int16_t winnr = 0;</a>
<a name="ln3853">    FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln3854">      winnr++;</a>
<a name="ln3855">      if (wparg != NULL &amp;&amp; wp != wparg) {</a>
<a name="ln3856">        continue;</a>
<a name="ln3857">      }</a>
<a name="ln3858">      dict_T *const d = get_win_info(wp, tabnr, winnr);</a>
<a name="ln3859">      tv_list_append_dict(rettv-&gt;vval.v_list, d);</a>
<a name="ln3860">      if (wparg != NULL) {</a>
<a name="ln3861">        // found information about a specific window</a>
<a name="ln3862">        return;</a>
<a name="ln3863">      }</a>
<a name="ln3864">    }</a>
<a name="ln3865">  }</a>
<a name="ln3866">}</a>
<a name="ln3867"> </a>
<a name="ln3868">// Dummy timer callback. Used by f_wait().</a>
<a name="ln3869">static void dummy_timer_due_cb(TimeWatcher *tw, void *data)</a>
<a name="ln3870">{</a>
<a name="ln3871">}</a>
<a name="ln3872"> </a>
<a name="ln3873">// Dummy timer close callback. Used by f_wait().</a>
<a name="ln3874">static void dummy_timer_close_cb(TimeWatcher *tw, void *data)</a>
<a name="ln3875">{</a>
<a name="ln3876">  xfree(tw);</a>
<a name="ln3877">}</a>
<a name="ln3878"> </a>
<a name="ln3879">/// &quot;wait(timeout, condition[, interval])&quot; function</a>
<a name="ln3880">static void f_wait(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3881">{</a>
<a name="ln3882">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3883">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln3884"> </a>
<a name="ln3885">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln3886">    EMSG2(_(e_invargval), &quot;1&quot;);</a>
<a name="ln3887">    return;</a>
<a name="ln3888">  }</a>
<a name="ln3889">  if ((argvars[2].v_type != VAR_NUMBER &amp;&amp; argvars[2].v_type != VAR_UNKNOWN)</a>
<a name="ln3890">      || (argvars[2].v_type == VAR_NUMBER &amp;&amp; argvars[2].vval.v_number &lt;= 0)) {</a>
<a name="ln3891">    EMSG2(_(e_invargval), &quot;3&quot;);</a>
<a name="ln3892">    return;</a>
<a name="ln3893">  }</a>
<a name="ln3894"> </a>
<a name="ln3895">  int timeout = argvars[0].vval.v_number;</a>
<a name="ln3896">  typval_T expr = argvars[1];</a>
<a name="ln3897">  int interval = argvars[2].v_type == VAR_NUMBER</a>
<a name="ln3898">    ? argvars[2].vval.v_number</a>
<a name="ln3899">    : 200;  // Default.</a>
<a name="ln3900">  TimeWatcher *tw = xmalloc(sizeof(TimeWatcher));</a>
<a name="ln3901"> </a>
<a name="ln3902">  // Start dummy timer.</a>
<a name="ln3903">  time_watcher_init(&amp;main_loop, tw, NULL);</a>
<a name="ln3904">  tw-&gt;events = main_loop.events;</a>
<a name="ln3905">  tw-&gt;blockable = true;</a>
<a name="ln3906">  time_watcher_start(tw, dummy_timer_due_cb, interval, interval);</a>
<a name="ln3907"> </a>
<a name="ln3908">  typval_T argv = TV_INITIAL_VALUE;</a>
<a name="ln3909">  typval_T exprval = TV_INITIAL_VALUE;</a>
<a name="ln3910">  bool error = false;</a>
<a name="ln3911">  int save_called_emsg = called_emsg;</a>
<a name="ln3912">  called_emsg = false;</a>
<a name="ln3913"> </a>
<a name="ln3914">  LOOP_PROCESS_EVENTS_UNTIL(&amp;main_loop, main_loop.events, timeout,</a>
<a name="ln3915">                            eval_expr_typval(&amp;expr, &amp;argv, 0, &amp;exprval) != OK</a>
<a name="ln3916">                            || tv_get_number_chk(&amp;exprval, &amp;error)</a>
<a name="ln3917">                            || called_emsg || error || got_int);</a>
<a name="ln3918"> </a>
<a name="ln3919">  if (called_emsg || error) {</a>
<a name="ln3920">    rettv-&gt;vval.v_number = -3;</a>
<a name="ln3921">  } else if (got_int) {</a>
<a name="ln3922">    got_int = false;</a>
<a name="ln3923">    vgetc();</a>
<a name="ln3924">    rettv-&gt;vval.v_number = -2;</a>
<a name="ln3925">  } else if (tv_get_number_chk(&amp;exprval, &amp;error)) {</a>
<a name="ln3926">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln3927">  }</a>
<a name="ln3928"> </a>
<a name="ln3929">  called_emsg = save_called_emsg;</a>
<a name="ln3930"> </a>
<a name="ln3931">  // Stop dummy timer</a>
<a name="ln3932">  time_watcher_stop(tw);</a>
<a name="ln3933">  time_watcher_close(tw, dummy_timer_close_cb);</a>
<a name="ln3934">}</a>
<a name="ln3935"> </a>
<a name="ln3936">// &quot;win_screenpos()&quot; function</a>
<a name="ln3937">static void f_win_screenpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3938">{</a>
<a name="ln3939">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln3940">  const win_T *const wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln3941">  tv_list_append_number(rettv-&gt;vval.v_list, wp == NULL ? 0 : wp-&gt;w_winrow + 1);</a>
<a name="ln3942">  tv_list_append_number(rettv-&gt;vval.v_list, wp == NULL ? 0 : wp-&gt;w_wincol + 1);</a>
<a name="ln3943">}</a>
<a name="ln3944"> </a>
<a name="ln3945">//</a>
<a name="ln3946">// Move the window wp into a new split of targetwin in a given direction</a>
<a name="ln3947">//</a>
<a name="ln3948">static void win_move_into_split(win_T *wp, win_T *targetwin,</a>
<a name="ln3949">                                int size, int flags)</a>
<a name="ln3950">{</a>
<a name="ln3951">  int     dir;</a>
<a name="ln3952">  int     height = wp-&gt;w_height;</a>
<a name="ln3953">  win_T   *oldwin = curwin;</a>
<a name="ln3954"> </a>
<a name="ln3955">  if (wp == targetwin) {</a>
<a name="ln3956">    return;</a>
<a name="ln3957">  }</a>
<a name="ln3958"> </a>
<a name="ln3959">  // Jump to the target window</a>
<a name="ln3960">  if (curwin != targetwin) {</a>
<a name="ln3961">    win_goto(targetwin);</a>
<a name="ln3962">  }</a>
<a name="ln3963"> </a>
<a name="ln3964">  // Remove the old window and frame from the tree of frames</a>
<a name="ln3965">  (void)winframe_remove(wp, &amp;dir, NULL);</a>
<a name="ln3966">  win_remove(wp, NULL);</a>
<a name="ln3967">  last_status(false);     // may need to remove last status line</a>
<a name="ln3968">  (void)win_comp_pos();   // recompute window positions</a>
<a name="ln3969"> </a>
<a name="ln3970">  // Split a window on the desired side and put the old window there</a>
<a name="ln3971">  (void)win_split_ins(size, flags, wp, dir);</a>
<a name="ln3972"> </a>
<a name="ln3973">  // If splitting horizontally, try to preserve height</a>
<a name="ln3974">  if (size == 0 &amp;&amp; !(flags &amp; WSP_VERT)) {</a>
<a name="ln3975">    win_setheight_win(height, wp);</a>
<a name="ln3976">    if (p_ea) {</a>
<a name="ln3977">      win_equal(wp, true, 'v');</a>
<a name="ln3978">    }</a>
<a name="ln3979">  }</a>
<a name="ln3980"> </a>
<a name="ln3981">  if (oldwin != curwin) {</a>
<a name="ln3982">    win_goto(oldwin);</a>
<a name="ln3983">  }</a>
<a name="ln3984">}</a>
<a name="ln3985"> </a>
<a name="ln3986">// &quot;win_splitmove()&quot; function</a>
<a name="ln3987">static void f_win_splitmove(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3988">{</a>
<a name="ln3989">  win_T   *wp;</a>
<a name="ln3990">  win_T   *targetwin;</a>
<a name="ln3991">  int     flags = 0, size = 0;</a>
<a name="ln3992"> </a>
<a name="ln3993">  wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln3994">  targetwin = find_win_by_nr_or_id(&amp;argvars[1]);</a>
<a name="ln3995"> </a>
<a name="ln3996">  if (wp == NULL || targetwin == NULL || wp == targetwin</a>
<a name="ln3997">      || !win_valid(wp) || !win_valid(targetwin)</a>
<a name="ln3998">      || win_valid_floating(wp) || win_valid_floating(targetwin)) {</a>
<a name="ln3999">    EMSG(_(e_invalwindow));</a>
<a name="ln4000">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln4001">    return;</a>
<a name="ln4002">  }</a>
<a name="ln4003"> </a>
<a name="ln4004">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4005">    dict_T      *d;</a>
<a name="ln4006">    dictitem_T  *di;</a>
<a name="ln4007"> </a>
<a name="ln4008">    if (argvars[2].v_type != VAR_DICT || argvars[2].vval.v_dict == NULL) {</a>
<a name="ln4009">      EMSG(_(e_invarg));</a>
<a name="ln4010">      return;</a>
<a name="ln4011">    }</a>
<a name="ln4012"> </a>
<a name="ln4013">    d = argvars[2].vval.v_dict;</a>
<a name="ln4014">    if (tv_dict_get_number(d, &quot;vertical&quot;)) {</a>
<a name="ln4015">      flags |= WSP_VERT;</a>
<a name="ln4016">    }</a>
<a name="ln4017">    if ((di = tv_dict_find(d, &quot;rightbelow&quot;, -1)) != NULL) {</a>
<a name="ln4018">      flags |= tv_get_number(&amp;di-&gt;di_tv) ? WSP_BELOW : WSP_ABOVE;</a>
<a name="ln4019">    }</a>
<a name="ln4020">    size = tv_dict_get_number(d, &quot;size&quot;);</a>
<a name="ln4021">  }</a>
<a name="ln4022"> </a>
<a name="ln4023">  win_move_into_split(wp, targetwin, size, flags);</a>
<a name="ln4024">}</a>
<a name="ln4025"> </a>
<a name="ln4026">// &quot;getwinpos({timeout})&quot; function</a>
<a name="ln4027">static void f_getwinpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4028">{</a>
<a name="ln4029">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln4030">  tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln4031">  tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln4032">}</a>
<a name="ln4033"> </a>
<a name="ln4034">/*</a>
<a name="ln4035"> * &quot;getwinposx()&quot; function</a>
<a name="ln4036"> */</a>
<a name="ln4037">static void f_getwinposx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4038">{</a>
<a name="ln4039">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln4040">}</a>
<a name="ln4041"> </a>
<a name="ln4042">/*</a>
<a name="ln4043"> * &quot;getwinposy()&quot; function</a>
<a name="ln4044"> */</a>
<a name="ln4045">static void f_getwinposy(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4046">{</a>
<a name="ln4047">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln4048">}</a>
<a name="ln4049"> </a>
<a name="ln4050">/// &quot;getwinvar()&quot; function</a>
<a name="ln4051">static void f_getwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4052">{</a>
<a name="ln4053">  getwinvar(argvars, rettv, 0);</a>
<a name="ln4054">}</a>
<a name="ln4055"> </a>
<a name="ln4056">/*</a>
<a name="ln4057"> * &quot;glob()&quot; function</a>
<a name="ln4058"> */</a>
<a name="ln4059">static void f_glob(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4060">{</a>
<a name="ln4061">  int options = WILD_SILENT|WILD_USE_NL;</a>
<a name="ln4062">  expand_T xpc;</a>
<a name="ln4063">  bool error = false;</a>
<a name="ln4064"> </a>
<a name="ln4065">  /* When the optional second argument is non-zero, don't remove matches</a>
<a name="ln4066">  * for 'wildignore' and don't put matches for 'suffixes' at the end. */</a>
<a name="ln4067">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4068">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln4069">    if (tv_get_number_chk(&amp;argvars[1], &amp;error)) {</a>
<a name="ln4070">      options |= WILD_KEEP_ALL;</a>
<a name="ln4071">    }</a>
<a name="ln4072">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4073">      if (tv_get_number_chk(&amp;argvars[2], &amp;error)) {</a>
<a name="ln4074">        tv_list_set_ret(rettv, NULL);</a>
<a name="ln4075">      }</a>
<a name="ln4076">      if (argvars[3].v_type != VAR_UNKNOWN</a>
<a name="ln4077">          &amp;&amp; tv_get_number_chk(&amp;argvars[3], &amp;error)) {</a>
<a name="ln4078">        options |= WILD_ALLLINKS;</a>
<a name="ln4079">      }</a>
<a name="ln4080">    }</a>
<a name="ln4081">  }</a>
<a name="ln4082">  if (!error) {</a>
<a name="ln4083">    ExpandInit(&amp;xpc);</a>
<a name="ln4084">    xpc.xp_context = EXPAND_FILES;</a>
<a name="ln4085">    if (p_wic)</a>
<a name="ln4086">      options += WILD_ICASE;</a>
<a name="ln4087">    if (rettv-&gt;v_type == VAR_STRING) {</a>
<a name="ln4088">      rettv-&gt;vval.v_string = ExpandOne(</a>
<a name="ln4089">          &amp;xpc, (char_u *)tv_get_string(&amp;argvars[0]), NULL, options, WILD_ALL);</a>
<a name="ln4090">    } else {</a>
<a name="ln4091">      ExpandOne(&amp;xpc, (char_u *)tv_get_string(&amp;argvars[0]), NULL, options,</a>
<a name="ln4092">                WILD_ALL_KEEP);</a>
<a name="ln4093">      tv_list_alloc_ret(rettv, xpc.xp_numfiles);</a>
<a name="ln4094">      for (int i = 0; i &lt; xpc.xp_numfiles; i++) {</a>
<a name="ln4095">        tv_list_append_string(rettv-&gt;vval.v_list, (const char *)xpc.xp_files[i],</a>
<a name="ln4096">                              -1);</a>
<a name="ln4097">      }</a>
<a name="ln4098">      ExpandCleanup(&amp;xpc);</a>
<a name="ln4099">    }</a>
<a name="ln4100">  } else</a>
<a name="ln4101">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4102">}</a>
<a name="ln4103"> </a>
<a name="ln4104">/// &quot;globpath()&quot; function</a>
<a name="ln4105">static void f_globpath(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4106">{</a>
<a name="ln4107">  int flags = WILD_IGNORE_COMPLETESLASH;  // Flags for globpath.</a>
<a name="ln4108">  bool error = false;</a>
<a name="ln4109"> </a>
<a name="ln4110">  // Return a string, or a list if the optional third argument is non-zero.</a>
<a name="ln4111">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4112"> </a>
<a name="ln4113">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4114">    // When the optional second argument is non-zero, don't remove matches</a>
<a name="ln4115">    // for 'wildignore' and don't put matches for 'suffixes' at the end.</a>
<a name="ln4116">    if (tv_get_number_chk(&amp;argvars[2], &amp;error)) {</a>
<a name="ln4117">      flags |= WILD_KEEP_ALL;</a>
<a name="ln4118">    }</a>
<a name="ln4119"> </a>
<a name="ln4120">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln4121">      if (tv_get_number_chk(&amp;argvars[3], &amp;error)) {</a>
<a name="ln4122">        tv_list_set_ret(rettv, NULL);</a>
<a name="ln4123">      }</a>
<a name="ln4124">      if (argvars[4].v_type != VAR_UNKNOWN</a>
<a name="ln4125">          &amp;&amp; tv_get_number_chk(&amp;argvars[4], &amp;error)) {</a>
<a name="ln4126">        flags |= WILD_ALLLINKS;</a>
<a name="ln4127">      }</a>
<a name="ln4128">    }</a>
<a name="ln4129">  }</a>
<a name="ln4130"> </a>
<a name="ln4131">  char buf1[NUMBUFLEN];</a>
<a name="ln4132">  const char *const file = tv_get_string_buf_chk(&amp;argvars[1], buf1);</a>
<a name="ln4133">  if (file != NULL &amp;&amp; !error) {</a>
<a name="ln4134">    garray_T ga;</a>
<a name="ln4135">    ga_init(&amp;ga, (int)sizeof(char_u *), 10);</a>
<a name="ln4136">    globpath((char_u *)tv_get_string(&amp;argvars[0]), (char_u *)file, &amp;ga, flags);</a>
<a name="ln4137"> </a>
<a name="ln4138">    if (rettv-&gt;v_type == VAR_STRING) {</a>
<a name="ln4139">      rettv-&gt;vval.v_string = ga_concat_strings_sep(&amp;ga, &quot;\n&quot;);</a>
<a name="ln4140">    } else {</a>
<a name="ln4141">      tv_list_alloc_ret(rettv, ga.ga_len);</a>
<a name="ln4142">      for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln4143">        tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln4144">                              ((const char **)(ga.ga_data))[i], -1);</a>
<a name="ln4145">      }</a>
<a name="ln4146">    }</a>
<a name="ln4147"> </a>
<a name="ln4148">    ga_clear_strings(&amp;ga);</a>
<a name="ln4149">  } else {</a>
<a name="ln4150">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4151">  }</a>
<a name="ln4152">}</a>
<a name="ln4153"> </a>
<a name="ln4154">// &quot;glob2regpat()&quot; function</a>
<a name="ln4155">static void f_glob2regpat(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4156">{</a>
<a name="ln4157">  const char *const pat = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4158"> </a>
<a name="ln4159">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4160">  rettv-&gt;vval.v_string = ((pat == NULL)</a>
<a name="ln4161">                          ? NULL</a>
<a name="ln4162">                          : file_pat_to_reg_pat((char_u *)pat, NULL, NULL,</a>
<a name="ln4163">                                                false));</a>
<a name="ln4164">}</a>
<a name="ln4165"> </a>
<a name="ln4166">/// &quot;has()&quot; function</a>
<a name="ln4167">static void f_has(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4168">{</a>
<a name="ln4169">  static const char *const has_list[] = {</a>
<a name="ln4170">#if defined(BSD) &amp;&amp; !defined(__APPLE__)</a>
<a name="ln4171">    &quot;bsd&quot;,</a>
<a name="ln4172">#endif</a>
<a name="ln4173">#ifdef UNIX</a>
<a name="ln4174">    &quot;unix&quot;,</a>
<a name="ln4175">#endif</a>
<a name="ln4176">#if defined(WIN32)</a>
<a name="ln4177">    &quot;win32&quot;,</a>
<a name="ln4178">#endif</a>
<a name="ln4179">#ifdef _WIN64</a>
<a name="ln4180">    &quot;win64&quot;,</a>
<a name="ln4181">#endif</a>
<a name="ln4182">#ifndef CASE_INSENSITIVE_FILENAME</a>
<a name="ln4183">    &quot;fname_case&quot;,</a>
<a name="ln4184">#endif</a>
<a name="ln4185">#ifdef HAVE_ACL</a>
<a name="ln4186">    &quot;acl&quot;,</a>
<a name="ln4187">#endif</a>
<a name="ln4188">    &quot;autochdir&quot;,</a>
<a name="ln4189">    &quot;arabic&quot;,</a>
<a name="ln4190">    &quot;autocmd&quot;,</a>
<a name="ln4191">    &quot;browsefilter&quot;,</a>
<a name="ln4192">    &quot;byte_offset&quot;,</a>
<a name="ln4193">    &quot;cindent&quot;,</a>
<a name="ln4194">    &quot;cmdline_compl&quot;,</a>
<a name="ln4195">    &quot;cmdline_hist&quot;,</a>
<a name="ln4196">    &quot;comments&quot;,</a>
<a name="ln4197">    &quot;conceal&quot;,</a>
<a name="ln4198">    &quot;cscope&quot;,</a>
<a name="ln4199">    &quot;cursorbind&quot;,</a>
<a name="ln4200">    &quot;cursorshape&quot;,</a>
<a name="ln4201">#ifdef DEBUG</a>
<a name="ln4202">    &quot;debug&quot;,</a>
<a name="ln4203">#endif</a>
<a name="ln4204">    &quot;dialog_con&quot;,</a>
<a name="ln4205">    &quot;diff&quot;,</a>
<a name="ln4206">    &quot;digraphs&quot;,</a>
<a name="ln4207">    &quot;eval&quot;,         // always present, of course!</a>
<a name="ln4208">    &quot;ex_extra&quot;,</a>
<a name="ln4209">    &quot;extra_search&quot;,</a>
<a name="ln4210">    &quot;file_in_path&quot;,</a>
<a name="ln4211">    &quot;filterpipe&quot;,</a>
<a name="ln4212">    &quot;find_in_path&quot;,</a>
<a name="ln4213">    &quot;float&quot;,</a>
<a name="ln4214">    &quot;folding&quot;,</a>
<a name="ln4215">#if defined(UNIX)</a>
<a name="ln4216">    &quot;fork&quot;,</a>
<a name="ln4217">#endif</a>
<a name="ln4218">    &quot;gettext&quot;,</a>
<a name="ln4219">#if defined(HAVE_ICONV)</a>
<a name="ln4220">    &quot;iconv&quot;,</a>
<a name="ln4221">#endif</a>
<a name="ln4222">    &quot;insert_expand&quot;,</a>
<a name="ln4223">    &quot;jumplist&quot;,</a>
<a name="ln4224">    &quot;keymap&quot;,</a>
<a name="ln4225">    &quot;lambda&quot;,</a>
<a name="ln4226">    &quot;langmap&quot;,</a>
<a name="ln4227">    &quot;libcall&quot;,</a>
<a name="ln4228">    &quot;linebreak&quot;,</a>
<a name="ln4229">    &quot;lispindent&quot;,</a>
<a name="ln4230">    &quot;listcmds&quot;,</a>
<a name="ln4231">    &quot;localmap&quot;,</a>
<a name="ln4232">#ifdef __APPLE__</a>
<a name="ln4233">    &quot;mac&quot;,</a>
<a name="ln4234">    &quot;macunix&quot;,</a>
<a name="ln4235">    &quot;osx&quot;,</a>
<a name="ln4236">    &quot;osxdarwin&quot;,</a>
<a name="ln4237">#endif</a>
<a name="ln4238">    &quot;menu&quot;,</a>
<a name="ln4239">    &quot;mksession&quot;,</a>
<a name="ln4240">    &quot;modify_fname&quot;,</a>
<a name="ln4241">    &quot;mouse&quot;,</a>
<a name="ln4242">    &quot;multi_byte&quot;,</a>
<a name="ln4243">    &quot;multi_lang&quot;,</a>
<a name="ln4244">    &quot;num64&quot;,</a>
<a name="ln4245">    &quot;packages&quot;,</a>
<a name="ln4246">    &quot;path_extra&quot;,</a>
<a name="ln4247">    &quot;persistent_undo&quot;,</a>
<a name="ln4248">    &quot;postscript&quot;,</a>
<a name="ln4249">    &quot;printer&quot;,</a>
<a name="ln4250">    &quot;profile&quot;,</a>
<a name="ln4251">    &quot;pythonx&quot;,</a>
<a name="ln4252">    &quot;reltime&quot;,</a>
<a name="ln4253">    &quot;quickfix&quot;,</a>
<a name="ln4254">    &quot;rightleft&quot;,</a>
<a name="ln4255">    &quot;scrollbind&quot;,</a>
<a name="ln4256">    &quot;showcmd&quot;,</a>
<a name="ln4257">    &quot;cmdline_info&quot;,</a>
<a name="ln4258">    &quot;shada&quot;,</a>
<a name="ln4259">    &quot;signs&quot;,</a>
<a name="ln4260">    &quot;smartindent&quot;,</a>
<a name="ln4261">    &quot;startuptime&quot;,</a>
<a name="ln4262">    &quot;statusline&quot;,</a>
<a name="ln4263">    &quot;spell&quot;,</a>
<a name="ln4264">    &quot;syntax&quot;,</a>
<a name="ln4265">#if !defined(UNIX)</a>
<a name="ln4266">    &quot;system&quot;,  // TODO(SplinterOfChaos): This IS defined for UNIX!</a>
<a name="ln4267">#endif</a>
<a name="ln4268">    &quot;tablineat&quot;,</a>
<a name="ln4269">    &quot;tag_binary&quot;,</a>
<a name="ln4270">    &quot;termguicolors&quot;,</a>
<a name="ln4271">    &quot;termresponse&quot;,</a>
<a name="ln4272">    &quot;textobjects&quot;,</a>
<a name="ln4273">    &quot;timers&quot;,</a>
<a name="ln4274">    &quot;title&quot;,</a>
<a name="ln4275">    &quot;user-commands&quot;,        // was accidentally included in 5.4</a>
<a name="ln4276">    &quot;user_commands&quot;,</a>
<a name="ln4277">    &quot;vartabs&quot;,</a>
<a name="ln4278">    &quot;vertsplit&quot;,</a>
<a name="ln4279">    &quot;virtualedit&quot;,</a>
<a name="ln4280">    &quot;visual&quot;,</a>
<a name="ln4281">    &quot;visualextra&quot;,</a>
<a name="ln4282">    &quot;vreplace&quot;,</a>
<a name="ln4283">    &quot;wildignore&quot;,</a>
<a name="ln4284">    &quot;wildmenu&quot;,</a>
<a name="ln4285">    &quot;windows&quot;,</a>
<a name="ln4286">    &quot;winaltkeys&quot;,</a>
<a name="ln4287">    &quot;writebackup&quot;,</a>
<a name="ln4288">#if defined(HAVE_WSL)</a>
<a name="ln4289">    &quot;wsl&quot;,</a>
<a name="ln4290">#endif</a>
<a name="ln4291">    &quot;nvim&quot;,</a>
<a name="ln4292">  };</a>
<a name="ln4293"> </a>
<a name="ln4294">  bool n = false;</a>
<a name="ln4295">  const char *const name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln4296">  for (size_t i = 0; i &lt; ARRAY_SIZE(has_list); i++) {</a>
<a name="ln4297">    if (STRICMP(name, has_list[i]) == 0) {</a>
<a name="ln4298">      n = true;</a>
<a name="ln4299">      break;</a>
<a name="ln4300">    }</a>
<a name="ln4301">  }</a>
<a name="ln4302"> </a>
<a name="ln4303">  if (!n) {</a>
<a name="ln4304">    if (STRNICMP(name, &quot;patch&quot;, 5) == 0) {</a>
<a name="ln4305">      if (name[5] == '-'</a>
<a name="ln4306">          &amp;&amp; strlen(name) &gt;= 11</a>
<a name="ln4307">          &amp;&amp; ascii_isdigit(name[6])</a>
<a name="ln4308">          &amp;&amp; ascii_isdigit(name[8])</a>
<a name="ln4309">          &amp;&amp; ascii_isdigit(name[10])) {</a>
<a name="ln4310">        int major = atoi(name + 6);</a>
<a name="ln4311">        int minor = atoi(name + 8);</a>
<a name="ln4312"> </a>
<a name="ln4313">        // Expect &quot;patch-9.9.01234&quot;.</a>
<a name="ln4314">        n = (major &lt; VIM_VERSION_MAJOR</a>
<a name="ln4315">             || (major == VIM_VERSION_MAJOR</a>
<a name="ln4316">                 &amp;&amp; (minor &lt; VIM_VERSION_MINOR</a>
<a name="ln4317">                     || (minor == VIM_VERSION_MINOR</a>
<a name="ln4318">                         &amp;&amp; has_vim_patch(atoi(name + 10))))));</a>
<a name="ln4319">      } else {</a>
<a name="ln4320">        n = has_vim_patch(atoi(name + 5));</a>
<a name="ln4321">      }</a>
<a name="ln4322">    } else if (STRNICMP(name, &quot;nvim-&quot;, 5) == 0) {</a>
<a name="ln4323">      // Expect &quot;nvim-x.y.z&quot;</a>
<a name="ln4324">      n = has_nvim_version(name + 5);</a>
<a name="ln4325">    } else if (STRICMP(name, &quot;vim_starting&quot;) == 0) {</a>
<a name="ln4326">      n = (starting != 0);</a>
<a name="ln4327">    } else if (STRICMP(name, &quot;ttyin&quot;) == 0) {</a>
<a name="ln4328">      n = stdin_isatty;</a>
<a name="ln4329">    } else if (STRICMP(name, &quot;ttyout&quot;) == 0) {</a>
<a name="ln4330">      n = stdout_isatty;</a>
<a name="ln4331">    } else if (STRICMP(name, &quot;multi_byte_encoding&quot;) == 0) {</a>
<a name="ln4332">      n = true;</a>
<a name="ln4333">    } else if (STRICMP(name, &quot;syntax_items&quot;) == 0) {</a>
<a name="ln4334">      n = syntax_present(curwin);</a>
<a name="ln4335">    } else if (STRICMP(name, &quot;clipboard_working&quot;) == 0) {</a>
<a name="ln4336">      n = eval_has_provider(&quot;clipboard&quot;);</a>
<a name="ln4337">#ifdef UNIX</a>
<a name="ln4338">    } else if (STRICMP(name, &quot;unnamedplus&quot;) == 0) {</a>
<a name="ln4339">      n = eval_has_provider(&quot;clipboard&quot;);</a>
<a name="ln4340">#endif</a>
<a name="ln4341">    }</a>
<a name="ln4342">  }</a>
<a name="ln4343"> </a>
<a name="ln4344">  if (!n &amp;&amp; eval_has_provider(name)) {</a>
<a name="ln4345">    n = true;</a>
<a name="ln4346">  }</a>
<a name="ln4347"> </a>
<a name="ln4348">  rettv-&gt;vval.v_number = n;</a>
<a name="ln4349">}</a>
<a name="ln4350"> </a>
<a name="ln4351">/*</a>
<a name="ln4352"> * &quot;has_key()&quot; function</a>
<a name="ln4353"> */</a>
<a name="ln4354">static void f_has_key(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4355">{</a>
<a name="ln4356">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln4357">    EMSG(_(e_dictreq));</a>
<a name="ln4358">    return;</a>
<a name="ln4359">  }</a>
<a name="ln4360">  if (argvars[0].vval.v_dict == NULL)</a>
<a name="ln4361">    return;</a>
<a name="ln4362"> </a>
<a name="ln4363">  rettv-&gt;vval.v_number = tv_dict_find(argvars[0].vval.v_dict,</a>
<a name="ln4364">                                      tv_get_string(&amp;argvars[1]),</a>
<a name="ln4365">                                      -1) != NULL;</a>
<a name="ln4366">}</a>
<a name="ln4367"> </a>
<a name="ln4368">/// `haslocaldir([{win}[, {tab}]])` function</a>
<a name="ln4369">///</a>
<a name="ln4370">/// Returns `1` if the scope object has a local directory, `0` otherwise. If a</a>
<a name="ln4371">/// scope object is not specified the current one is implied. This function</a>
<a name="ln4372">/// share a lot of code with `f_getcwd`.</a>
<a name="ln4373">///</a>
<a name="ln4374">/// @pre  The arguments must be of type number.</a>
<a name="ln4375">/// @pre  There may not be more than two arguments.</a>
<a name="ln4376">/// @pre  An argument may not be -1 if preceding arguments are not all -1.</a>
<a name="ln4377">///</a>
<a name="ln4378">/// @post  The return value will be either the number `1` or `0`.</a>
<a name="ln4379">static void f_haslocaldir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4380">{</a>
<a name="ln4381">  // Possible scope of working directory to return.</a>
<a name="ln4382">  CdScope scope = kCdScopeInvalid;</a>
<a name="ln4383"> </a>
<a name="ln4384">  // Numbers of the scope objects (window, tab) we want the working directory</a>
<a name="ln4385">  // of. A `-1` means to skip this scope, a `0` means the current object.</a>
<a name="ln4386">  int scope_number[] = {</a>
<a name="ln4387">    [kCdScopeWindow] = 0,  // Number of window to look at.</a>
<a name="ln4388">    [kCdScopeTab   ] = 0,  // Number of tab to look at.</a>
<a name="ln4389">  };</a>
<a name="ln4390"> </a>
<a name="ln4391">  tabpage_T *tp  = curtab;  // The tabpage to look at.</a>
<a name="ln4392">  win_T     *win = curwin;  // The window to look at.</a>
<a name="ln4393"> </a>
<a name="ln4394">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4395">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln4396"> </a>
<a name="ln4397">  // Pre-conditions and scope extraction together</a>
<a name="ln4398">  for (int i = MIN_CD_SCOPE; i &lt; MAX_CD_SCOPE; i++) {</a>
<a name="ln4399">    if (argvars[i].v_type == VAR_UNKNOWN) {</a>
<a name="ln4400">      break;</a>
<a name="ln4401">    }</a>
<a name="ln4402">    if (argvars[i].v_type != VAR_NUMBER) {</a>
<a name="ln4403">      EMSG(_(e_invarg));</a>
<a name="ln4404">      return;</a>
<a name="ln4405">    }</a>
<a name="ln4406">    scope_number[i] = argvars[i].vval.v_number;</a>
<a name="ln4407">    if (scope_number[i] &lt; -1) {</a>
<a name="ln4408">      EMSG(_(e_invarg));</a>
<a name="ln4409">      return;</a>
<a name="ln4410">    }</a>
<a name="ln4411">    // Use the narrowest scope the user requested</a>
<a name="ln4412">    if (scope_number[i] &gt;= 0 &amp;&amp; scope == kCdScopeInvalid) {</a>
<a name="ln4413">      // The scope is the current iteration step.</a>
<a name="ln4414">      scope = i;</a>
<a name="ln4415">    } else if (scope_number[i] &lt; 0) {</a>
<a name="ln4416">      scope = i + 1;</a>
<a name="ln4417">    }</a>
<a name="ln4418">  }</a>
<a name="ln4419"> </a>
<a name="ln4420">  // If the user didn't specify anything, default to window scope</a>
<a name="ln4421">  if (scope == kCdScopeInvalid) {</a>
<a name="ln4422">    scope = MIN_CD_SCOPE;</a>
<a name="ln4423">  }</a>
<a name="ln4424"> </a>
<a name="ln4425">  // Find the tabpage by number</a>
<a name="ln4426">  if (scope_number[kCdScopeTab] &gt; 0) {</a>
<a name="ln4427">    tp = find_tabpage(scope_number[kCdScopeTab]);</a>
<a name="ln4428">    if (!tp) {</a>
<a name="ln4429">      EMSG(_(&quot;E5000: Cannot find tab number.&quot;));</a>
<a name="ln4430">      return;</a>
<a name="ln4431">    }</a>
<a name="ln4432">  }</a>
<a name="ln4433"> </a>
<a name="ln4434">  // Find the window in `tp` by number, `NULL` if none.</a>
<a name="ln4435">  if (scope_number[kCdScopeWindow] &gt;= 0) {</a>
<a name="ln4436">    if (scope_number[kCdScopeTab] &lt; 0) {</a>
<a name="ln4437">      EMSG(_(&quot;E5001: Higher scope cannot be -1 if lower scope is &gt;= 0.&quot;));</a>
<a name="ln4438">      return;</a>
<a name="ln4439">    }</a>
<a name="ln4440"> </a>
<a name="ln4441">    if (scope_number[kCdScopeWindow] &gt; 0) {</a>
<a name="ln4442">      win = find_win_by_nr(&amp;argvars[0], tp);</a>
<a name="ln4443">      if (!win) {</a>
<a name="ln4444">        EMSG(_(&quot;E5002: Cannot find window number.&quot;));</a>
<a name="ln4445">        return;</a>
<a name="ln4446">      }</a>
<a name="ln4447">    }</a>
<a name="ln4448">  }</a>
<a name="ln4449"> </a>
<a name="ln4450">  switch (scope) {</a>
<a name="ln4451">    case kCdScopeWindow:</a>
<a name="ln4452">      assert(win);</a>
<a name="ln4453">      rettv-&gt;vval.v_number = win-&gt;w_localdir ? 1 : 0;</a>
<a name="ln4454">      break;</a>
<a name="ln4455">    case kCdScopeTab:</a>
<a name="ln4456">      assert(tp);</a>
<a name="ln4457">      rettv-&gt;vval.v_number = tp-&gt;tp_localdir ? 1 : 0;</a>
<a name="ln4458">      break;</a>
<a name="ln4459">    case kCdScopeGlobal:</a>
<a name="ln4460">      // The global scope never has a local directory</a>
<a name="ln4461">      break;</a>
<a name="ln4462">    case kCdScopeInvalid:</a>
<a name="ln4463">      // We should never get here</a>
<a name="ln4464">      abort();</a>
<a name="ln4465">  }</a>
<a name="ln4466">}</a>
<a name="ln4467"> </a>
<a name="ln4468">/*</a>
<a name="ln4469"> * &quot;hasmapto()&quot; function</a>
<a name="ln4470"> */</a>
<a name="ln4471">static void f_hasmapto(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4472">{</a>
<a name="ln4473">  const char *mode;</a>
<a name="ln4474">  const char *const name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln4475">  bool abbr = false;</a>
<a name="ln4476">  char buf[NUMBUFLEN];</a>
<a name="ln4477">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln4478">    mode = &quot;nvo&quot;;</a>
<a name="ln4479">  } else {</a>
<a name="ln4480">    mode = tv_get_string_buf(&amp;argvars[1], buf);</a>
<a name="ln4481">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4482">      abbr = tv_get_number(&amp;argvars[2]);</a>
<a name="ln4483">    }</a>
<a name="ln4484">  }</a>
<a name="ln4485"> </a>
<a name="ln4486">  if (map_to_exists(name, mode, abbr)) {</a>
<a name="ln4487">    rettv-&gt;vval.v_number = true;</a>
<a name="ln4488">  } else {</a>
<a name="ln4489">    rettv-&gt;vval.v_number = false;</a>
<a name="ln4490">  }</a>
<a name="ln4491">}</a>
<a name="ln4492"> </a>
<a name="ln4493">/*</a>
<a name="ln4494"> * &quot;histadd()&quot; function</a>
<a name="ln4495"> */</a>
<a name="ln4496">static void f_histadd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4497">{</a>
<a name="ln4498">  HistoryType histype;</a>
<a name="ln4499"> </a>
<a name="ln4500">  rettv-&gt;vval.v_number = false;</a>
<a name="ln4501">  if (check_secure()) {</a>
<a name="ln4502">    return;</a>
<a name="ln4503">  }</a>
<a name="ln4504">  const char *str = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4505">  histype = str != NULL ? get_histtype(str, strlen(str), false) : HIST_INVALID;</a>
<a name="ln4506">  if (histype != HIST_INVALID) {</a>
<a name="ln4507">    char buf[NUMBUFLEN];</a>
<a name="ln4508">    str = tv_get_string_buf(&amp;argvars[1], buf);</a>
<a name="ln4509">    if (*str != NUL) {</a>
<a name="ln4510">      init_history();</a>
<a name="ln4511">      add_to_history(histype, (char_u *)str, false, NUL);</a>
<a name="ln4512">      rettv-&gt;vval.v_number = true;</a>
<a name="ln4513">      return;</a>
<a name="ln4514">    }</a>
<a name="ln4515">  }</a>
<a name="ln4516">}</a>
<a name="ln4517"> </a>
<a name="ln4518">/*</a>
<a name="ln4519"> * &quot;histdel()&quot; function</a>
<a name="ln4520"> */</a>
<a name="ln4521">static void f_histdel(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4522">{</a>
<a name="ln4523">  int n;</a>
<a name="ln4524">  const char *const str = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4525">  if (str == NULL) {</a>
<a name="ln4526">    n = 0;</a>
<a name="ln4527">  } else if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln4528">    // only one argument: clear entire history</a>
<a name="ln4529">    n = clr_history(get_histtype(str, strlen(str), false));</a>
<a name="ln4530">  } else if (argvars[1].v_type == VAR_NUMBER) {</a>
<a name="ln4531">    // index given: remove that entry</a>
<a name="ln4532">    n = del_history_idx(get_histtype(str, strlen(str), false),</a>
<a name="ln4533">                        (int)tv_get_number(&amp;argvars[1]));</a>
<a name="ln4534">  } else {</a>
<a name="ln4535">    // string given: remove all matching entries</a>
<a name="ln4536">    char buf[NUMBUFLEN];</a>
<a name="ln4537">    n = del_history_entry(get_histtype(str, strlen(str), false),</a>
<a name="ln4538">                          (char_u *)tv_get_string_buf(&amp;argvars[1], buf));</a>
<a name="ln4539">  }</a>
<a name="ln4540">  rettv-&gt;vval.v_number = n;</a>
<a name="ln4541">}</a>
<a name="ln4542"> </a>
<a name="ln4543">/*</a>
<a name="ln4544"> * &quot;histget()&quot; function</a>
<a name="ln4545"> */</a>
<a name="ln4546">static void f_histget(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4547">{</a>
<a name="ln4548">  HistoryType type;</a>
<a name="ln4549">  int idx;</a>
<a name="ln4550"> </a>
<a name="ln4551">  const char *const str = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4552">  if (str == NULL) {</a>
<a name="ln4553">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4554">  } else {</a>
<a name="ln4555">    type = get_histtype(str, strlen(str), false);</a>
<a name="ln4556">    if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln4557">      idx = get_history_idx(type);</a>
<a name="ln4558">    } else {</a>
<a name="ln4559">      idx = (int)tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln4560">    }</a>
<a name="ln4561">    // -1 on type error</a>
<a name="ln4562">    rettv-&gt;vval.v_string = vim_strsave(get_history_entry(type, idx));</a>
<a name="ln4563">  }</a>
<a name="ln4564">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4565">}</a>
<a name="ln4566"> </a>
<a name="ln4567">/*</a>
<a name="ln4568"> * &quot;histnr()&quot; function</a>
<a name="ln4569"> */</a>
<a name="ln4570">static void f_histnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4571">{</a>
<a name="ln4572">  const char *const history = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln4573">  HistoryType i = history == NULL</a>
<a name="ln4574">    ? HIST_INVALID</a>
<a name="ln4575">    : get_histtype(history, strlen(history), false);</a>
<a name="ln4576">  if (i != HIST_INVALID) {</a>
<a name="ln4577">    i = get_history_idx(i);</a>
<a name="ln4578">  }</a>
<a name="ln4579">  rettv-&gt;vval.v_number = i;</a>
<a name="ln4580">}</a>
<a name="ln4581"> </a>
<a name="ln4582">/*</a>
<a name="ln4583"> * &quot;highlightID(name)&quot; function</a>
<a name="ln4584"> */</a>
<a name="ln4585">static void f_hlID(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4586">{</a>
<a name="ln4587">  rettv-&gt;vval.v_number = syn_name2id(</a>
<a name="ln4588">      (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln4589">}</a>
<a name="ln4590"> </a>
<a name="ln4591">/*</a>
<a name="ln4592"> * &quot;highlight_exists()&quot; function</a>
<a name="ln4593"> */</a>
<a name="ln4594">static void f_hlexists(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4595">{</a>
<a name="ln4596">  rettv-&gt;vval.v_number = highlight_exists(</a>
<a name="ln4597">      (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln4598">}</a>
<a name="ln4599"> </a>
<a name="ln4600">/*</a>
<a name="ln4601"> * &quot;hostname()&quot; function</a>
<a name="ln4602"> */</a>
<a name="ln4603">static void f_hostname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4604">{</a>
<a name="ln4605">  char hostname[256];</a>
<a name="ln4606"> </a>
<a name="ln4607">  os_get_hostname(hostname, 256);</a>
<a name="ln4608">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4609">  rettv-&gt;vval.v_string = vim_strsave((char_u *)hostname);</a>
<a name="ln4610">}</a>
<a name="ln4611"> </a>
<a name="ln4612">/*</a>
<a name="ln4613"> * iconv() function</a>
<a name="ln4614"> */</a>
<a name="ln4615">static void f_iconv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4616">{</a>
<a name="ln4617">  vimconv_T vimconv;</a>
<a name="ln4618"> </a>
<a name="ln4619">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4620">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4621"> </a>
<a name="ln4622">  const char *const str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln4623">  char buf1[NUMBUFLEN];</a>
<a name="ln4624">  char_u *const from = enc_canonize(enc_skip(</a>
<a name="ln4625">      (char_u *)tv_get_string_buf(&amp;argvars[1], buf1)));</a>
<a name="ln4626">  char buf2[NUMBUFLEN];</a>
<a name="ln4627">  char_u *const to = enc_canonize(enc_skip(</a>
<a name="ln4628">      (char_u *)tv_get_string_buf(&amp;argvars[2], buf2)));</a>
<a name="ln4629">  vimconv.vc_type = CONV_NONE;</a>
<a name="ln4630">  convert_setup(&amp;vimconv, from, to);</a>
<a name="ln4631"> </a>
<a name="ln4632">  // If the encodings are equal, no conversion needed.</a>
<a name="ln4633">  if (vimconv.vc_type == CONV_NONE) {</a>
<a name="ln4634">    rettv-&gt;vval.v_string = (char_u *)xstrdup(str);</a>
<a name="ln4635">  } else {</a>
<a name="ln4636">    rettv-&gt;vval.v_string = string_convert(&amp;vimconv, (char_u *)str, NULL);</a>
<a name="ln4637">  }</a>
<a name="ln4638"> </a>
<a name="ln4639">  convert_setup(&amp;vimconv, NULL, NULL);</a>
<a name="ln4640">  xfree(from);</a>
<a name="ln4641">  xfree(to);</a>
<a name="ln4642">}</a>
<a name="ln4643"> </a>
<a name="ln4644">/*</a>
<a name="ln4645"> * &quot;indent()&quot; function</a>
<a name="ln4646"> */</a>
<a name="ln4647">static void f_indent(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4648">{</a>
<a name="ln4649">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln4650">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln4651">    rettv-&gt;vval.v_number = get_indent_lnum(lnum);</a>
<a name="ln4652">  } else {</a>
<a name="ln4653">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln4654">  }</a>
<a name="ln4655">}</a>
<a name="ln4656"> </a>
<a name="ln4657">/*</a>
<a name="ln4658"> * &quot;index()&quot; function</a>
<a name="ln4659"> */</a>
<a name="ln4660">static void f_index(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4661">{</a>
<a name="ln4662">  long idx = 0;</a>
<a name="ln4663">  bool ic = false;</a>
<a name="ln4664"> </a>
<a name="ln4665">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln4666">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln4667">    EMSG(_(e_listreq));</a>
<a name="ln4668">    return;</a>
<a name="ln4669">  }</a>
<a name="ln4670">  list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln4671">  if (l != NULL) {</a>
<a name="ln4672">    listitem_T *item = tv_list_first(l);</a>
<a name="ln4673">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4674">      bool error = false;</a>
<a name="ln4675"> </a>
<a name="ln4676">      // Start at specified item.</a>
<a name="ln4677">      idx = tv_list_uidx(l, tv_get_number_chk(&amp;argvars[2], &amp;error));</a>
<a name="ln4678">      if (error || idx == -1) {</a>
<a name="ln4679">        item = NULL;</a>
<a name="ln4680">      } else {</a>
<a name="ln4681">        item = tv_list_find(l, idx);</a>
<a name="ln4682">        assert(item != NULL);</a>
<a name="ln4683">      }</a>
<a name="ln4684">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln4685">        ic = !!tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln4686">        if (error) {</a>
<a name="ln4687">          item = NULL;</a>
<a name="ln4688">        }</a>
<a name="ln4689">      }</a>
<a name="ln4690">    }</a>
<a name="ln4691"> </a>
<a name="ln4692">    for (; item != NULL; item = TV_LIST_ITEM_NEXT(l, item), idx++) {</a>
<a name="ln4693">      if (tv_equal(TV_LIST_ITEM_TV(item), &amp;argvars[1], ic, false)) {</a>
<a name="ln4694">        rettv-&gt;vval.v_number = idx;</a>
<a name="ln4695">        break;</a>
<a name="ln4696">      }</a>
<a name="ln4697">    }</a>
<a name="ln4698">  }</a>
<a name="ln4699">}</a>
<a name="ln4700"> </a>
<a name="ln4701">static bool inputsecret_flag = false;</a>
<a name="ln4702"> </a>
<a name="ln4703">/*</a>
<a name="ln4704"> * &quot;input()&quot; function</a>
<a name="ln4705"> *     Also handles inputsecret() when inputsecret is set.</a>
<a name="ln4706"> */</a>
<a name="ln4707">static void f_input(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4708">{</a>
<a name="ln4709">  get_user_input(argvars, rettv, FALSE, inputsecret_flag);</a>
<a name="ln4710">}</a>
<a name="ln4711"> </a>
<a name="ln4712">/*</a>
<a name="ln4713"> * &quot;inputdialog()&quot; function</a>
<a name="ln4714"> */</a>
<a name="ln4715">static void f_inputdialog(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4716">{</a>
<a name="ln4717">  get_user_input(argvars, rettv, TRUE, inputsecret_flag);</a>
<a name="ln4718">}</a>
<a name="ln4719"> </a>
<a name="ln4720">/*</a>
<a name="ln4721"> * &quot;inputlist()&quot; function</a>
<a name="ln4722"> */</a>
<a name="ln4723">static void f_inputlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4724">{</a>
<a name="ln4725">  int selected;</a>
<a name="ln4726">  int mouse_used;</a>
<a name="ln4727"> </a>
<a name="ln4728">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln4729">    EMSG2(_(e_listarg), &quot;inputlist()&quot;);</a>
<a name="ln4730">    return;</a>
<a name="ln4731">  }</a>
<a name="ln4732"> </a>
<a name="ln4733">  msg_start();</a>
<a name="ln4734">  msg_row = Rows - 1;   // for when 'cmdheight' &gt; 1</a>
<a name="ln4735">  lines_left = Rows;    // avoid more prompt</a>
<a name="ln4736">  msg_scroll = true;</a>
<a name="ln4737">  msg_clr_eos();</a>
<a name="ln4738"> </a>
<a name="ln4739">  TV_LIST_ITER_CONST(argvars[0].vval.v_list, li, {</a>
<a name="ln4740">    msg_puts(tv_get_string(TV_LIST_ITEM_TV(li)));</a>
<a name="ln4741">    msg_putchar('\n');</a>
<a name="ln4742">  });</a>
<a name="ln4743"> </a>
<a name="ln4744">  // Ask for choice.</a>
<a name="ln4745">  selected = prompt_for_number(&amp;mouse_used);</a>
<a name="ln4746">  if (mouse_used) {</a>
<a name="ln4747">    selected -= lines_left;</a>
<a name="ln4748">  }</a>
<a name="ln4749"> </a>
<a name="ln4750">  rettv-&gt;vval.v_number = selected;</a>
<a name="ln4751">}</a>
<a name="ln4752"> </a>
<a name="ln4753"> </a>
<a name="ln4754">static garray_T ga_userinput = { 0, 0, sizeof(tasave_T), 4, NULL };</a>
<a name="ln4755"> </a>
<a name="ln4756">/// &quot;inputrestore()&quot; function</a>
<a name="ln4757">static void f_inputrestore(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4758">{</a>
<a name="ln4759">  if (!GA_EMPTY(&amp;ga_userinput)) {</a>
<a name="ln4760">    ga_userinput.ga_len--;</a>
<a name="ln4761">    restore_typeahead((tasave_T *)(ga_userinput.ga_data)</a>
<a name="ln4762">                      + ga_userinput.ga_len);</a>
<a name="ln4763">    // default return is zero == OK</a>
<a name="ln4764">  } else if (p_verbose &gt; 1) {</a>
<a name="ln4765">    verb_msg(_(&quot;called inputrestore() more often than inputsave()&quot;));</a>
<a name="ln4766">    rettv-&gt;vval.v_number = 1;  // Failed</a>
<a name="ln4767">  }</a>
<a name="ln4768">}</a>
<a name="ln4769"> </a>
<a name="ln4770">/// &quot;inputsave()&quot; function</a>
<a name="ln4771">static void f_inputsave(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4772">{</a>
<a name="ln4773">  // Add an entry to the stack of typeahead storage.</a>
<a name="ln4774">  tasave_T *p = GA_APPEND_VIA_PTR(tasave_T, &amp;ga_userinput);</a>
<a name="ln4775">  save_typeahead(p);</a>
<a name="ln4776">}</a>
<a name="ln4777"> </a>
<a name="ln4778">/// &quot;inputsecret()&quot; function</a>
<a name="ln4779">static void f_inputsecret(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4780">{</a>
<a name="ln4781">  cmdline_star++;</a>
<a name="ln4782">  inputsecret_flag = true;</a>
<a name="ln4783">  f_input(argvars, rettv, NULL);</a>
<a name="ln4784">  cmdline_star--;</a>
<a name="ln4785">  inputsecret_flag = false;</a>
<a name="ln4786">}</a>
<a name="ln4787"> </a>
<a name="ln4788">/*</a>
<a name="ln4789"> * &quot;insert()&quot; function</a>
<a name="ln4790"> */</a>
<a name="ln4791">static void f_insert(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4792">{</a>
<a name="ln4793">  list_T *l;</a>
<a name="ln4794">  bool error = false;</a>
<a name="ln4795"> </a>
<a name="ln4796">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln4797">    EMSG2(_(e_listarg), &quot;insert()&quot;);</a>
<a name="ln4798">  } else if (!tv_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),</a>
<a name="ln4799">                            N_(&quot;insert() argument&quot;), TV_TRANSLATE)) {</a>
<a name="ln4800">    long before = 0;</a>
<a name="ln4801">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4802">      before = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln4803">    }</a>
<a name="ln4804">    if (error) {</a>
<a name="ln4805">      // type error; errmsg already given</a>
<a name="ln4806">      return;</a>
<a name="ln4807">    }</a>
<a name="ln4808"> </a>
<a name="ln4809">    listitem_T *item = NULL;</a>
<a name="ln4810">    if (before != tv_list_len(l)) {</a>
<a name="ln4811">      item = tv_list_find(l, before);</a>
<a name="ln4812">      if (item == NULL) {</a>
<a name="ln4813">        EMSGN(_(e_listidx), before);</a>
<a name="ln4814">        l = NULL;</a>
<a name="ln4815">      }</a>
<a name="ln4816">    }</a>
<a name="ln4817">    if (l != NULL) {</a>
<a name="ln4818">      tv_list_insert_tv(l, &amp;argvars[1], item);</a>
<a name="ln4819">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln4820">    }</a>
<a name="ln4821">  }</a>
<a name="ln4822">}</a>
<a name="ln4823"> </a>
<a name="ln4824">// &quot;interrupt()&quot; function</a>
<a name="ln4825">static void f_interrupt(typval_T *argvars FUNC_ATTR_UNUSED,</a>
<a name="ln4826">                        typval_T *rettv FUNC_ATTR_UNUSED,</a>
<a name="ln4827">                        FunPtr fptr FUNC_ATTR_UNUSED)</a>
<a name="ln4828">{</a>
<a name="ln4829">  got_int = true;</a>
<a name="ln4830">}</a>
<a name="ln4831"> </a>
<a name="ln4832">/*</a>
<a name="ln4833"> * &quot;invert(expr)&quot; function</a>
<a name="ln4834"> */</a>
<a name="ln4835">static void f_invert(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4836">{</a>
<a name="ln4837">  rettv-&gt;vval.v_number = ~tv_get_number_chk(&amp;argvars[0], NULL);</a>
<a name="ln4838">}</a>
<a name="ln4839"> </a>
<a name="ln4840">/*</a>
<a name="ln4841"> * &quot;isdirectory()&quot; function</a>
<a name="ln4842"> */</a>
<a name="ln4843">static void f_isdirectory(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4844">{</a>
<a name="ln4845">  rettv-&gt;vval.v_number = os_isdir((const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln4846">}</a>
<a name="ln4847"> </a>
<a name="ln4848">/*</a>
<a name="ln4849"> * &quot;islocked()&quot; function</a>
<a name="ln4850"> */</a>
<a name="ln4851">static void f_islocked(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4852">{</a>
<a name="ln4853">  lval_T lv;</a>
<a name="ln4854">  dictitem_T  *di;</a>
<a name="ln4855"> </a>
<a name="ln4856">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln4857">  const char_u *const end = get_lval((char_u *)tv_get_string(&amp;argvars[0]),</a>
<a name="ln4858">                                     NULL,</a>
<a name="ln4859">                                     &amp;lv, false, false,</a>
<a name="ln4860">                                     GLV_NO_AUTOLOAD|GLV_READ_ONLY,</a>
<a name="ln4861">                                     FNE_CHECK_START);</a>
<a name="ln4862">  if (end != NULL &amp;&amp; lv.ll_name != NULL) {</a>
<a name="ln4863">    if (*end != NUL) {</a>
<a name="ln4864">      EMSG(_(e_trailing));</a>
<a name="ln4865">    } else {</a>
<a name="ln4866">      if (lv.ll_tv == NULL) {</a>
<a name="ln4867">        di = find_var((const char *)lv.ll_name, lv.ll_name_len, NULL, true);</a>
<a name="ln4868">        if (di != NULL) {</a>
<a name="ln4869">          // Consider a variable locked when:</a>
<a name="ln4870">          // 1. the variable itself is locked</a>
<a name="ln4871">          // 2. the value of the variable is locked.</a>
<a name="ln4872">          // 3. the List or Dict value is locked.</a>
<a name="ln4873">          rettv-&gt;vval.v_number = ((di-&gt;di_flags &amp; DI_FLAGS_LOCK)</a>
<a name="ln4874">                                  || tv_islocked(&amp;di-&gt;di_tv));</a>
<a name="ln4875">        }</a>
<a name="ln4876">      } else if (lv.ll_range) {</a>
<a name="ln4877">        EMSG(_(&quot;E786: Range not allowed&quot;));</a>
<a name="ln4878">      } else if (lv.ll_newkey != NULL) {</a>
<a name="ln4879">        EMSG2(_(e_dictkey), lv.ll_newkey);</a>
<a name="ln4880">      } else if (lv.ll_list != NULL) {</a>
<a name="ln4881">        // List item.</a>
<a name="ln4882">        rettv-&gt;vval.v_number = tv_islocked(TV_LIST_ITEM_TV(lv.ll_li));</a>
<a name="ln4883">      } else {</a>
<a name="ln4884">        // Dictionary item.</a>
<a name="ln4885">        rettv-&gt;vval.v_number = tv_islocked(&amp;lv.ll_di-&gt;di_tv);</a>
<a name="ln4886">      }</a>
<a name="ln4887">    }</a>
<a name="ln4888">  }</a>
<a name="ln4889"> </a>
<a name="ln4890">  clear_lval(&amp;lv);</a>
<a name="ln4891">}</a>
<a name="ln4892"> </a>
<a name="ln4893">// &quot;isinf()&quot; function</a>
<a name="ln4894">static void f_isinf(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4895">{</a>
<a name="ln4896">  if (argvars[0].v_type == VAR_FLOAT</a>
<a name="ln4897">      &amp;&amp; xisinf(argvars[0].vval.v_float)) {</a>
<a name="ln4898">    rettv-&gt;vval.v_number = argvars[0].vval.v_float &gt; 0.0 ? 1 : -1;</a>
<a name="ln4899">  }</a>
<a name="ln4900">}</a>
<a name="ln4901"> </a>
<a name="ln4902">// &quot;isnan()&quot; function</a>
<a name="ln4903">static void f_isnan(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4904">{</a>
<a name="ln4905">  rettv-&gt;vval.v_number = argvars[0].v_type == VAR_FLOAT</a>
<a name="ln4906">    &amp;&amp; xisnan(argvars[0].vval.v_float);</a>
<a name="ln4907">}</a>
<a name="ln4908"> </a>
<a name="ln4909">/// &quot;id()&quot; function</a>
<a name="ln4910">static void f_id(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4911">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4912">{</a>
<a name="ln4913">  const int len = vim_vsnprintf_typval(NULL, 0, &quot;%p&quot;, dummy_ap, argvars);</a>
<a name="ln4914">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4915">  rettv-&gt;vval.v_string = xmalloc(len + 1);</a>
<a name="ln4916">  vim_vsnprintf_typval((char *)rettv-&gt;vval.v_string, len + 1, &quot;%p&quot;,</a>
<a name="ln4917">                       dummy_ap, argvars);</a>
<a name="ln4918">}</a>
<a name="ln4919"> </a>
<a name="ln4920">/*</a>
<a name="ln4921"> * &quot;items(dict)&quot; function</a>
<a name="ln4922"> */</a>
<a name="ln4923">static void f_items(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4924">{</a>
<a name="ln4925">  dict_list(argvars, rettv, 2);</a>
<a name="ln4926">}</a>
<a name="ln4927"> </a>
<a name="ln4928">// &quot;jobpid(id)&quot; function</a>
<a name="ln4929">static void f_jobpid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4930">{</a>
<a name="ln4931">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4932">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln4933"> </a>
<a name="ln4934">  if (check_secure()) {</a>
<a name="ln4935">    return;</a>
<a name="ln4936">  }</a>
<a name="ln4937"> </a>
<a name="ln4938">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln4939">    EMSG(_(e_invarg));</a>
<a name="ln4940">    return;</a>
<a name="ln4941">  }</a>
<a name="ln4942"> </a>
<a name="ln4943">  Channel *data = find_job(argvars[0].vval.v_number, true);</a>
<a name="ln4944">  if (!data) {</a>
<a name="ln4945">    return;</a>
<a name="ln4946">  }</a>
<a name="ln4947"> </a>
<a name="ln4948">  Process *proc = (Process *)&amp;data-&gt;stream.proc;</a>
<a name="ln4949">  rettv-&gt;vval.v_number = proc-&gt;pid;</a>
<a name="ln4950">}</a>
<a name="ln4951"> </a>
<a name="ln4952">// &quot;jobresize(job, width, height)&quot; function</a>
<a name="ln4953">static void f_jobresize(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4954">{</a>
<a name="ln4955">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4956">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln4957"> </a>
<a name="ln4958">  if (check_secure()) {</a>
<a name="ln4959">    return;</a>
<a name="ln4960">  }</a>
<a name="ln4961"> </a>
<a name="ln4962">  if (argvars[0].v_type != VAR_NUMBER || argvars[1].v_type != VAR_NUMBER</a>
<a name="ln4963">      || argvars[2].v_type != VAR_NUMBER) {</a>
<a name="ln4964">    // job id, width, height</a>
<a name="ln4965">    EMSG(_(e_invarg));</a>
<a name="ln4966">    return;</a>
<a name="ln4967">  }</a>
<a name="ln4968"> </a>
<a name="ln4969"> </a>
<a name="ln4970">  Channel *data = find_job(argvars[0].vval.v_number, true);</a>
<a name="ln4971">  if (!data) {</a>
<a name="ln4972">    return;</a>
<a name="ln4973">  }</a>
<a name="ln4974"> </a>
<a name="ln4975">  if (data-&gt;stream.proc.type != kProcessTypePty) {</a>
<a name="ln4976">    EMSG(_(e_channotpty));</a>
<a name="ln4977">    return;</a>
<a name="ln4978">  }</a>
<a name="ln4979"> </a>
<a name="ln4980">  pty_process_resize(&amp;data-&gt;stream.pty, argvars[1].vval.v_number,</a>
<a name="ln4981">                     argvars[2].vval.v_number);</a>
<a name="ln4982">  rettv-&gt;vval.v_number = 1;</a>
<a name="ln4983">}</a>
<a name="ln4984"> </a>
<a name="ln4985">static const char *ignored_env_vars[] = {</a>
<a name="ln4986">#ifndef WIN32</a>
<a name="ln4987">  &quot;COLUMNS&quot;,</a>
<a name="ln4988">  &quot;LINES&quot;,</a>
<a name="ln4989">  &quot;TERMCAP&quot;,</a>
<a name="ln4990">  &quot;COLORFGBG&quot;,</a>
<a name="ln4991">#endif</a>
<a name="ln4992">  NULL</a>
<a name="ln4993">};</a>
<a name="ln4994"> </a>
<a name="ln4995">/// According to comments in src/win/process.c of libuv, Windows has a few</a>
<a name="ln4996">/// &quot;essential&quot; environment variables.</a>
<a name="ln4997">static const char *required_env_vars[] = {</a>
<a name="ln4998">#ifdef WIN32</a>
<a name="ln4999">  &quot;HOMEDRIVE&quot;,</a>
<a name="ln5000">  &quot;HOMEPATH&quot;,</a>
<a name="ln5001">  &quot;LOGONSERVER&quot;,</a>
<a name="ln5002">  &quot;PATH&quot;,</a>
<a name="ln5003">  &quot;SYSTEMDRIVE&quot;,</a>
<a name="ln5004">  &quot;SYSTEMROOT&quot;,</a>
<a name="ln5005">  &quot;TEMP&quot;,</a>
<a name="ln5006">  &quot;USERDOMAIN&quot;,</a>
<a name="ln5007">  &quot;USERNAME&quot;,</a>
<a name="ln5008">  &quot;USERPROFILE&quot;,</a>
<a name="ln5009">  &quot;WINDIR&quot;,</a>
<a name="ln5010">#endif</a>
<a name="ln5011">  NULL</a>
<a name="ln5012">};</a>
<a name="ln5013"> </a>
<a name="ln5014">static dict_T *create_environment(const dictitem_T *job_env,</a>
<a name="ln5015">                                  const bool clear_env,</a>
<a name="ln5016">                                  const bool pty,</a>
<a name="ln5017">                                  const char * const pty_term_name)</a>
<a name="ln5018">{</a>
<a name="ln5019">  dict_T * env = tv_dict_alloc();</a>
<a name="ln5020"> </a>
<a name="ln5021">  if (!clear_env) {</a>
<a name="ln5022">    typval_T temp_env = TV_INITIAL_VALUE;</a>
<a name="ln5023">    f_environ(NULL, &amp;temp_env, NULL);</a>
<a name="ln5024">    tv_dict_extend(env, temp_env.vval.v_dict, &quot;force&quot;);</a>
<a name="ln5025">    tv_dict_free(temp_env.vval.v_dict);</a>
<a name="ln5026"> </a>
<a name="ln5027">    if (pty) {</a>
<a name="ln5028">      // These environment variables generally shouldn't be propagated to the</a>
<a name="ln5029">      // child process.  We're removing them here so the user can still decide</a>
<a name="ln5030">      // they want to explicitly set them.</a>
<a name="ln5031">      for (size_t i = 0;</a>
<a name="ln5032">           i &lt; ARRAY_SIZE(ignored_env_vars) &amp;&amp; ignored_env_vars[i];</a>
<a name="ln5033">           i++) {</a>
<a name="ln5034">        dictitem_T *dv = tv_dict_find(env, ignored_env_vars[i], -1);</a>
<a name="ln5035">        if (dv) {</a>
<a name="ln5036">          tv_dict_item_remove(env, dv);</a>
<a name="ln5037">        }</a>
<a name="ln5038">      }</a>
<a name="ln5039">#ifndef WIN32</a>
<a name="ln5040">      // Set COLORTERM to &quot;truecolor&quot; if termguicolors is set and 256</a>
<a name="ln5041">      // otherwise, but only if it was set in the parent terminal at all</a>
<a name="ln5042">      dictitem_T *dv = tv_dict_find(env, S_LEN(&quot;COLORTERM&quot;));</a>
<a name="ln5043">      if (dv) {</a>
<a name="ln5044">        tv_dict_item_remove(env, dv);</a>
<a name="ln5045">        tv_dict_add_str(env, S_LEN(&quot;COLORTERM&quot;), p_tgc ? &quot;truecolor&quot; : &quot;256&quot;);</a>
<a name="ln5046">      }</a>
<a name="ln5047">#endif</a>
<a name="ln5048">    }</a>
<a name="ln5049">  }</a>
<a name="ln5050"> </a>
<a name="ln5051">  // For a pty, we need a sane $TERM set.  We can't rely on nvim's environment,</a>
<a name="ln5052">  // because the child process is going to be communicating with nvim, not the</a>
<a name="ln5053">  // parent terminal.  Set a sane default, but let the user override it in the</a>
<a name="ln5054">  // job's environment if they want.</a>
<a name="ln5055">  if (pty) {</a>
<a name="ln5056">    dictitem_T *dv = tv_dict_find(env, S_LEN(&quot;TERM&quot;));</a>
<a name="ln5057">    if (dv) {</a>
<a name="ln5058">      tv_dict_item_remove(env, dv);</a>
<a name="ln5059">    }</a>
<a name="ln5060">    tv_dict_add_str(env, S_LEN(&quot;TERM&quot;), pty_term_name);</a>
<a name="ln5061">  }</a>
<a name="ln5062"> </a>
<a name="ln5063">  if (job_env) {</a>
<a name="ln5064">    tv_dict_extend(env, job_env-&gt;di_tv.vval.v_dict, &quot;force&quot;);</a>
<a name="ln5065">  }</a>
<a name="ln5066"> </a>
<a name="ln5067">  if (pty) {</a>
<a name="ln5068">    // Now that the custom environment is configured, we need to ensure certain</a>
<a name="ln5069">    // environment variables are present.</a>
<a name="ln5070">    for (size_t i = 0;</a>
<a name="ln5071">         i &lt; ARRAY_SIZE(required_env_vars) &amp;&amp; required_env_vars[i];</a>
<a name="ln5072">         i++) {</a>
<a name="ln5073">      size_t len = strlen(required_env_vars[i]);</a>
<a name="ln5074">      dictitem_T *dv = tv_dict_find(env, required_env_vars[i], len);</a>
<a name="ln5075">      if (!dv) {</a>
<a name="ln5076">        const char *env_var = os_getenv(required_env_vars[i]);</a>
<a name="ln5077">        if (env_var) {</a>
<a name="ln5078">          tv_dict_add_str(env, required_env_vars[i], len, env_var);</a>
<a name="ln5079">        }</a>
<a name="ln5080">      }</a>
<a name="ln5081">    }</a>
<a name="ln5082">  }</a>
<a name="ln5083"> </a>
<a name="ln5084">  return env;</a>
<a name="ln5085">}</a>
<a name="ln5086"> </a>
<a name="ln5087">// &quot;jobstart()&quot; function</a>
<a name="ln5088">static void f_jobstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5089">{</a>
<a name="ln5090">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5091">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln5092"> </a>
<a name="ln5093">  if (check_secure()) {</a>
<a name="ln5094">    return;</a>
<a name="ln5095">  }</a>
<a name="ln5096"> </a>
<a name="ln5097">  bool executable = true;</a>
<a name="ln5098">  char **argv = tv_to_argv(&amp;argvars[0], NULL, &amp;executable);</a>
<a name="ln5099">  dict_T *env = NULL;</a>
<a name="ln5100">  if (!argv) {</a>
<a name="ln5101">    rettv-&gt;vval.v_number = executable ? 0 : -1;</a>
<a name="ln5102">    return;  // Did error message in tv_to_argv.</a>
<a name="ln5103">  }</a>
<a name="ln5104"> </a>
<a name="ln5105">  if (argvars[1].v_type != VAR_DICT &amp;&amp; argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln5106">    // Wrong argument types</a>
<a name="ln5107">    EMSG2(_(e_invarg2), &quot;expected dictionary&quot;);</a>
<a name="ln5108">    shell_free_argv(argv);</a>
<a name="ln5109">    return;</a>
<a name="ln5110">  }</a>
<a name="ln5111"> </a>
<a name="ln5112"> </a>
<a name="ln5113">  dict_T *job_opts = NULL;</a>
<a name="ln5114">  bool detach = false;</a>
<a name="ln5115">  bool rpc = false;</a>
<a name="ln5116">  bool pty = false;</a>
<a name="ln5117">  bool clear_env = false;</a>
<a name="ln5118">  bool overlapped = false;</a>
<a name="ln5119">  CallbackReader on_stdout = CALLBACK_READER_INIT,</a>
<a name="ln5120">                 on_stderr = CALLBACK_READER_INIT;</a>
<a name="ln5121">  Callback on_exit = CALLBACK_NONE;</a>
<a name="ln5122">  char *cwd = NULL;</a>
<a name="ln5123">  dictitem_T *job_env = NULL;</a>
<a name="ln5124">  if (argvars[1].v_type == VAR_DICT) {</a>
<a name="ln5125">    job_opts = argvars[1].vval.v_dict;</a>
<a name="ln5126"> </a>
<a name="ln5127">    detach = tv_dict_get_number(job_opts, &quot;detach&quot;) != 0;</a>
<a name="ln5128">    rpc = tv_dict_get_number(job_opts, &quot;rpc&quot;) != 0;</a>
<a name="ln5129">    pty = tv_dict_get_number(job_opts, &quot;pty&quot;) != 0;</a>
<a name="ln5130">    clear_env = tv_dict_get_number(job_opts, &quot;clear_env&quot;) != 0;</a>
<a name="ln5131">    overlapped = tv_dict_get_number(job_opts, &quot;overlapped&quot;) != 0;</a>
<a name="ln5132"> </a>
<a name="ln5133">    if (pty &amp;&amp; rpc) {</a>
<a name="ln5134">      EMSG2(_(e_invarg2), &quot;job cannot have both 'pty' and 'rpc' options set&quot;);</a>
<a name="ln5135">      shell_free_argv(argv);</a>
<a name="ln5136">      return;</a>
<a name="ln5137">    }</a>
<a name="ln5138"> </a>
<a name="ln5139">#ifdef WIN32</a>
<a name="ln5140">    if (pty &amp;&amp; overlapped) {</a>
<a name="ln5141">      EMSG2(_(e_invarg2),</a>
<a name="ln5142">            &quot;job cannot have both 'pty' and 'overlapped' options set&quot;);</a>
<a name="ln5143">      shell_free_argv(argv);</a>
<a name="ln5144">      return;</a>
<a name="ln5145">    }</a>
<a name="ln5146">#endif</a>
<a name="ln5147"> </a>
<a name="ln5148">    char *new_cwd = tv_dict_get_string(job_opts, &quot;cwd&quot;, false);</a>
<a name="ln5149">    if (new_cwd &amp;&amp; *new_cwd != NUL) {</a>
<a name="ln5150">      cwd = new_cwd;</a>
<a name="ln5151">      // The new cwd must be a directory.</a>
<a name="ln5152">      if (!os_isdir_executable((const char *)cwd)) {</a>
<a name="ln5153">        EMSG2(_(e_invarg2), &quot;expected valid directory&quot;);</a>
<a name="ln5154">        shell_free_argv(argv);</a>
<a name="ln5155">        return;</a>
<a name="ln5156">      }</a>
<a name="ln5157">    }</a>
<a name="ln5158"> </a>
<a name="ln5159">    job_env = tv_dict_find(job_opts, S_LEN(&quot;env&quot;));</a>
<a name="ln5160">    if (job_env &amp;&amp; job_env-&gt;di_tv.v_type != VAR_DICT) {</a>
<a name="ln5161">      EMSG2(_(e_invarg2), &quot;env&quot;);</a>
<a name="ln5162">      shell_free_argv(argv);</a>
<a name="ln5163">      return;</a>
<a name="ln5164">    }</a>
<a name="ln5165"> </a>
<a name="ln5166">    if (!common_job_callbacks(job_opts, &amp;on_stdout, &amp;on_stderr, &amp;on_exit)) {</a>
<a name="ln5167">      shell_free_argv(argv);</a>
<a name="ln5168">      return;</a>
<a name="ln5169">    }</a>
<a name="ln5170">  }</a>
<a name="ln5171"> </a>
<a name="ln5172">  uint16_t width = 0, height = 0;</a>
<a name="ln5173">  char *term_name = NULL;</a>
<a name="ln5174"> </a>
<a name="ln5175">  if (pty) {</a>
<a name="ln5176">    width = (uint16_t)tv_dict_get_number(job_opts, &quot;width&quot;);</a>
<a name="ln5177">    height = (uint16_t)tv_dict_get_number(job_opts, &quot;height&quot;);</a>
<a name="ln5178">    // Legacy method, before env option existed, to specify $TERM.  No longer</a>
<a name="ln5179">    // documented, but still usable to avoid breaking scripts.</a>
<a name="ln5180">    term_name = tv_dict_get_string(job_opts, &quot;TERM&quot;, false);</a>
<a name="ln5181">    if (!term_name) {</a>
<a name="ln5182">      term_name = &quot;ansi&quot;;</a>
<a name="ln5183">    }</a>
<a name="ln5184">  }</a>
<a name="ln5185"> </a>
<a name="ln5186">  env = create_environment(job_env, clear_env, pty, term_name);</a>
<a name="ln5187"> </a>
<a name="ln5188">  Channel *chan = channel_job_start(argv, on_stdout, on_stderr, on_exit, pty,</a>
<a name="ln5189">                                    rpc, overlapped, detach, cwd, width, height,</a>
<a name="ln5190">                                    env, &amp;rettv-&gt;vval.v_number);</a>
<a name="ln5191">  if (chan) {</a>
<a name="ln5192">    channel_create_event(chan, NULL);</a>
<a name="ln5193">  }</a>
<a name="ln5194">}</a>
<a name="ln5195"> </a>
<a name="ln5196">// &quot;jobstop()&quot; function</a>
<a name="ln5197">static void f_jobstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5198">{</a>
<a name="ln5199">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5200">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln5201"> </a>
<a name="ln5202">  if (check_secure()) {</a>
<a name="ln5203">    return;</a>
<a name="ln5204">  }</a>
<a name="ln5205"> </a>
<a name="ln5206">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln5207">    // Only argument is the job id</a>
<a name="ln5208">    EMSG(_(e_invarg));</a>
<a name="ln5209">    return;</a>
<a name="ln5210">  }</a>
<a name="ln5211"> </a>
<a name="ln5212">  Channel *data = find_job(argvars[0].vval.v_number, false);</a>
<a name="ln5213">  if (!data) {</a>
<a name="ln5214">    return;</a>
<a name="ln5215">  }</a>
<a name="ln5216"> </a>
<a name="ln5217">  const char *error = NULL;</a>
<a name="ln5218">  if (data-&gt;is_rpc) {</a>
<a name="ln5219">    // Ignore return code, but show error later.</a>
<a name="ln5220">    (void)channel_close(data-&gt;id, kChannelPartRpc, &amp;error);</a>
<a name="ln5221">  }</a>
<a name="ln5222">  process_stop((Process *)&amp;data-&gt;stream.proc);</a>
<a name="ln5223">  rettv-&gt;vval.v_number = 1;</a>
<a name="ln5224">  if (error) {</a>
<a name="ln5225">    EMSG(error);</a>
<a name="ln5226">  }</a>
<a name="ln5227">}</a>
<a name="ln5228"> </a>
<a name="ln5229">// &quot;jobwait(ids[, timeout])&quot; function</a>
<a name="ln5230">static void f_jobwait(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5231">{</a>
<a name="ln5232">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5233">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln5234"> </a>
<a name="ln5235">  if (check_secure()) {</a>
<a name="ln5236">    return;</a>
<a name="ln5237">  }</a>
<a name="ln5238">  if (argvars[0].v_type != VAR_LIST || (argvars[1].v_type != VAR_NUMBER</a>
<a name="ln5239">        &amp;&amp; argvars[1].v_type != VAR_UNKNOWN)) {</a>
<a name="ln5240">    EMSG(_(e_invarg));</a>
<a name="ln5241">    return;</a>
<a name="ln5242">  }</a>
<a name="ln5243"> </a>
<a name="ln5244">  ui_busy_start();</a>
<a name="ln5245">  list_T *args = argvars[0].vval.v_list;</a>
<a name="ln5246">  Channel **jobs = xcalloc(tv_list_len(args), sizeof(*jobs));</a>
<a name="ln5247">  MultiQueue *waiting_jobs = multiqueue_new_parent(loop_on_put, &amp;main_loop);</a>
<a name="ln5248"> </a>
<a name="ln5249">  // Validate, prepare jobs for waiting.</a>
<a name="ln5250">  int i = 0;</a>
<a name="ln5251">  TV_LIST_ITER_CONST(args, arg, {</a>
<a name="ln5252">    Channel *chan = NULL;</a>
<a name="ln5253">    if (TV_LIST_ITEM_TV(arg)-&gt;v_type != VAR_NUMBER</a>
<a name="ln5254">        || !(chan = find_job(TV_LIST_ITEM_TV(arg)-&gt;vval.v_number, false))) {</a>
<a name="ln5255">      jobs[i] = NULL;  // Invalid job.</a>
<a name="ln5256">    } else {</a>
<a name="ln5257">      jobs[i] = chan;</a>
<a name="ln5258">      channel_incref(chan);</a>
<a name="ln5259">      if (chan-&gt;stream.proc.status &lt; 0) {</a>
<a name="ln5260">        // Process any pending events on the job's queue before temporarily</a>
<a name="ln5261">        // replacing it.</a>
<a name="ln5262">        multiqueue_process_events(chan-&gt;events);</a>
<a name="ln5263">        multiqueue_replace_parent(chan-&gt;events, waiting_jobs);</a>
<a name="ln5264">      }</a>
<a name="ln5265">    }</a>
<a name="ln5266">    i++;</a>
<a name="ln5267">  });</a>
<a name="ln5268"> </a>
<a name="ln5269">  int remaining = -1;</a>
<a name="ln5270">  uint64_t before = 0;</a>
<a name="ln5271">  if (argvars[1].v_type == VAR_NUMBER &amp;&amp; argvars[1].vval.v_number &gt;= 0) {</a>
<a name="ln5272">    remaining = argvars[1].vval.v_number;</a>
<a name="ln5273">    before = os_hrtime();</a>
<a name="ln5274">  }</a>
<a name="ln5275"> </a>
<a name="ln5276">  for (i = 0; i &lt; tv_list_len(args); i++) {</a>
<a name="ln5277">    if (remaining == 0) {</a>
<a name="ln5278">      break;  // Timeout.</a>
<a name="ln5279">    }</a>
<a name="ln5280">    if (jobs[i] == NULL) {</a>
<a name="ln5281">      continue;  // Invalid job, will assign status=-3 below.</a>
<a name="ln5282">    }</a>
<a name="ln5283">    int status = process_wait(&amp;jobs[i]-&gt;stream.proc, remaining,</a>
<a name="ln5284">                              waiting_jobs);</a>
<a name="ln5285">    if (status &lt; 0) {</a>
<a name="ln5286">      break;  // Interrupted (CTRL-C) or timeout, skip remaining jobs.</a>
<a name="ln5287">    }</a>
<a name="ln5288">    if (remaining &gt; 0) {</a>
<a name="ln5289">      uint64_t now = os_hrtime();</a>
<a name="ln5290">      remaining = MIN(0, remaining - (int)((now - before) / 1000000));</a>
<a name="ln5291">      before = now;</a>
<a name="ln5292">    }</a>
<a name="ln5293">  }</a>
<a name="ln5294"> </a>
<a name="ln5295">  list_T *const rv = tv_list_alloc(tv_list_len(args));</a>
<a name="ln5296"> </a>
<a name="ln5297">  // For each job:</a>
<a name="ln5298">  //  * Restore its parent queue if the job is still alive.</a>
<a name="ln5299">  //  * Append its status to the output list, or:</a>
<a name="ln5300">  //       -3 for &quot;invalid job id&quot;</a>
<a name="ln5301">  //       -2 for &quot;interrupted&quot; (user hit CTRL-C)</a>
<a name="ln5302">  //       -1 for jobs that were skipped or timed out</a>
<a name="ln5303">  for (i = 0; i &lt; tv_list_len(args); i++) {</a>
<a name="ln5304">    if (jobs[i] == NULL) {</a>
<a name="ln5305">      tv_list_append_number(rv, -3);</a>
<a name="ln5306">      continue;</a>
<a name="ln5307">    }</a>
<a name="ln5308">    multiqueue_process_events(jobs[i]-&gt;events);</a>
<a name="ln5309">    multiqueue_replace_parent(jobs[i]-&gt;events, main_loop.events);</a>
<a name="ln5310"> </a>
<a name="ln5311">    tv_list_append_number(rv, jobs[i]-&gt;stream.proc.status);</a>
<a name="ln5312">    channel_decref(jobs[i]);</a>
<a name="ln5313">  }</a>
<a name="ln5314"> </a>
<a name="ln5315">  multiqueue_free(waiting_jobs);</a>
<a name="ln5316">  xfree(jobs);</a>
<a name="ln5317">  ui_busy_stop();</a>
<a name="ln5318">  tv_list_ref(rv);</a>
<a name="ln5319">  rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln5320">  rettv-&gt;vval.v_list = rv;</a>
<a name="ln5321">}</a>
<a name="ln5322"> </a>
<a name="ln5323">/*</a>
<a name="ln5324"> * &quot;join()&quot; function</a>
<a name="ln5325"> */</a>
<a name="ln5326">static void f_join(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5327">{</a>
<a name="ln5328">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln5329">    EMSG(_(e_listreq));</a>
<a name="ln5330">    return;</a>
<a name="ln5331">  }</a>
<a name="ln5332">  const char *const sep = (argvars[1].v_type == VAR_UNKNOWN</a>
<a name="ln5333">                           ? &quot; &quot;</a>
<a name="ln5334">                           : tv_get_string_chk(&amp;argvars[1]));</a>
<a name="ln5335"> </a>
<a name="ln5336">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5337"> </a>
<a name="ln5338">  if (sep != NULL) {</a>
<a name="ln5339">    garray_T ga;</a>
<a name="ln5340">    ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln5341">    tv_list_join(&amp;ga, argvars[0].vval.v_list, sep);</a>
<a name="ln5342">    ga_append(&amp;ga, NUL);</a>
<a name="ln5343">    rettv-&gt;vval.v_string = (char_u *)ga.ga_data;</a>
<a name="ln5344">  } else {</a>
<a name="ln5345">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5346">  }</a>
<a name="ln5347">}</a>
<a name="ln5348"> </a>
<a name="ln5349">/// json_decode() function</a>
<a name="ln5350">static void f_json_decode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5351">{</a>
<a name="ln5352">  char numbuf[NUMBUFLEN];</a>
<a name="ln5353">  const char *s = NULL;</a>
<a name="ln5354">  char *tofree = NULL;</a>
<a name="ln5355">  size_t len;</a>
<a name="ln5356">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln5357">    if (!encode_vim_list_to_buf(argvars[0].vval.v_list, &amp;len, &amp;tofree)) {</a>
<a name="ln5358">      EMSG(_(&quot;E474: Failed to convert list to string&quot;));</a>
<a name="ln5359">      return;</a>
<a name="ln5360">    }</a>
<a name="ln5361">    s = tofree;</a>
<a name="ln5362">    if (s == NULL) {</a>
<a name="ln5363">      assert(len == 0);</a>
<a name="ln5364">      s = &quot;&quot;;</a>
<a name="ln5365">    }</a>
<a name="ln5366">  } else {</a>
<a name="ln5367">    s = tv_get_string_buf_chk(&amp;argvars[0], numbuf);</a>
<a name="ln5368">    if (s) {</a>
<a name="ln5369">      len = strlen(s);</a>
<a name="ln5370">    } else {</a>
<a name="ln5371">      return;</a>
<a name="ln5372">    }</a>
<a name="ln5373">  }</a>
<a name="ln5374">  if (json_decode_string(s, len, rettv) == FAIL) {</a>
<a name="ln5375">    emsgf(_(&quot;E474: Failed to parse %.*s&quot;), (int)len, s);</a>
<a name="ln5376">    rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5377">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln5378">  }</a>
<a name="ln5379">  assert(rettv-&gt;v_type != VAR_UNKNOWN);</a>
<a name="ln5380">  xfree(tofree);</a>
<a name="ln5381">}</a>
<a name="ln5382"> </a>
<a name="ln5383">/// json_encode() function</a>
<a name="ln5384">static void f_json_encode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5385">{</a>
<a name="ln5386">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5387">  rettv-&gt;vval.v_string = (char_u *)encode_tv2json(&amp;argvars[0], NULL);</a>
<a name="ln5388">}</a>
<a name="ln5389"> </a>
<a name="ln5390">/*</a>
<a name="ln5391"> * &quot;keys()&quot; function</a>
<a name="ln5392"> */</a>
<a name="ln5393">static void f_keys(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5394">{</a>
<a name="ln5395">  dict_list(argvars, rettv, 0);</a>
<a name="ln5396">}</a>
<a name="ln5397"> </a>
<a name="ln5398">/*</a>
<a name="ln5399"> * &quot;last_buffer_nr()&quot; function.</a>
<a name="ln5400"> */</a>
<a name="ln5401">static void f_last_buffer_nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5402">{</a>
<a name="ln5403">  int n = 0;</a>
<a name="ln5404"> </a>
<a name="ln5405">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln5406">    if (n &lt; buf-&gt;b_fnum) {</a>
<a name="ln5407">      n = buf-&gt;b_fnum;</a>
<a name="ln5408">    }</a>
<a name="ln5409">  }</a>
<a name="ln5410"> </a>
<a name="ln5411">  rettv-&gt;vval.v_number = n;</a>
<a name="ln5412">}</a>
<a name="ln5413"> </a>
<a name="ln5414">/*</a>
<a name="ln5415"> * &quot;len()&quot; function</a>
<a name="ln5416"> */</a>
<a name="ln5417">static void f_len(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5418">{</a>
<a name="ln5419">  switch (argvars[0].v_type) {</a>
<a name="ln5420">    case VAR_STRING:</a>
<a name="ln5421">    case VAR_NUMBER: {</a>
<a name="ln5422">      rettv-&gt;vval.v_number = (varnumber_T)strlen(</a>
<a name="ln5423">          tv_get_string(&amp;argvars[0]));</a>
<a name="ln5424">      break;</a>
<a name="ln5425">    }</a>
<a name="ln5426">    case VAR_LIST: {</a>
<a name="ln5427">      rettv-&gt;vval.v_number = tv_list_len(argvars[0].vval.v_list);</a>
<a name="ln5428">      break;</a>
<a name="ln5429">    }</a>
<a name="ln5430">    case VAR_DICT: {</a>
<a name="ln5431">      rettv-&gt;vval.v_number = tv_dict_len(argvars[0].vval.v_dict);</a>
<a name="ln5432">      break;</a>
<a name="ln5433">    }</a>
<a name="ln5434">    case VAR_UNKNOWN:</a>
<a name="ln5435">    case VAR_BOOL:</a>
<a name="ln5436">    case VAR_SPECIAL:</a>
<a name="ln5437">    case VAR_FLOAT:</a>
<a name="ln5438">    case VAR_PARTIAL:</a>
<a name="ln5439">    case VAR_FUNC: {</a>
<a name="ln5440">      EMSG(_(&quot;E701: Invalid type for len()&quot;));</a>
<a name="ln5441">      break;</a>
<a name="ln5442">    }</a>
<a name="ln5443">  }</a>
<a name="ln5444">}</a>
<a name="ln5445"> </a>
<a name="ln5446">static void libcall_common(typval_T *argvars, typval_T *rettv, int out_type)</a>
<a name="ln5447">{</a>
<a name="ln5448">  rettv-&gt;v_type = out_type;</a>
<a name="ln5449">  if (out_type != VAR_NUMBER) {</a>
<a name="ln5450">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5451">  }</a>
<a name="ln5452"> </a>
<a name="ln5453">  if (check_secure()) {</a>
<a name="ln5454">    return;</a>
<a name="ln5455">  }</a>
<a name="ln5456"> </a>
<a name="ln5457">  // The first two args (libname and funcname) must be strings</a>
<a name="ln5458">  if (argvars[0].v_type != VAR_STRING || argvars[1].v_type != VAR_STRING) {</a>
<a name="ln5459">    return;</a>
<a name="ln5460">  }</a>
<a name="ln5461"> </a>
<a name="ln5462">  const char *libname = (char *)argvars[0].vval.v_string;</a>
<a name="ln5463">  const char *funcname = (char *)argvars[1].vval.v_string;</a>
<a name="ln5464"> </a>
<a name="ln5465">  VarType in_type = argvars[2].v_type;</a>
<a name="ln5466"> </a>
<a name="ln5467">  // input variables</a>
<a name="ln5468">  char *str_in = (in_type == VAR_STRING)</a>
<a name="ln5469">      ? (char *)argvars[2].vval.v_string : NULL;</a>
<a name="ln5470">  int int_in = argvars[2].vval.v_number;</a>
<a name="ln5471"> </a>
<a name="ln5472">  // output variables</a>
<a name="ln5473">  char **str_out = (out_type == VAR_STRING)</a>
<a name="ln5474">      ? (char **)&amp;rettv-&gt;vval.v_string : NULL;</a>
<a name="ln5475">  int int_out = 0;</a>
<a name="ln5476"> </a>
<a name="ln5477">  bool success = os_libcall(libname, funcname,</a>
<a name="ln5478">                            str_in, int_in,</a>
<a name="ln5479">                            str_out, &amp;int_out);</a>
<a name="ln5480"> </a>
<a name="ln5481">  if (!success) {</a>
<a name="ln5482">    EMSG2(_(e_libcall), funcname);</a>
<a name="ln5483">    return;</a>
<a name="ln5484">  }</a>
<a name="ln5485"> </a>
<a name="ln5486">  if (out_type == VAR_NUMBER) {</a>
<a name="ln5487">     rettv-&gt;vval.v_number = (varnumber_T)int_out;</a>
<a name="ln5488">  }</a>
<a name="ln5489">}</a>
<a name="ln5490"> </a>
<a name="ln5491">/*</a>
<a name="ln5492"> * &quot;libcall()&quot; function</a>
<a name="ln5493"> */</a>
<a name="ln5494">static void f_libcall(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5495">{</a>
<a name="ln5496">  libcall_common(argvars, rettv, VAR_STRING);</a>
<a name="ln5497">}</a>
<a name="ln5498"> </a>
<a name="ln5499">/*</a>
<a name="ln5500"> * &quot;libcallnr()&quot; function</a>
<a name="ln5501"> */</a>
<a name="ln5502">static void f_libcallnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5503">{</a>
<a name="ln5504">  libcall_common(argvars, rettv, VAR_NUMBER);</a>
<a name="ln5505">}</a>
<a name="ln5506"> </a>
<a name="ln5507">/*</a>
<a name="ln5508"> * &quot;line(string)&quot; function</a>
<a name="ln5509"> */</a>
<a name="ln5510">static void f_line(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5511">{</a>
<a name="ln5512">  linenr_T lnum = 0;</a>
<a name="ln5513">  pos_T       *fp;</a>
<a name="ln5514">  int fnum;</a>
<a name="ln5515"> </a>
<a name="ln5516">  fp = var2fpos(&amp;argvars[0], TRUE, &amp;fnum);</a>
<a name="ln5517">  if (fp != NULL)</a>
<a name="ln5518">    lnum = fp-&gt;lnum;</a>
<a name="ln5519">  rettv-&gt;vval.v_number = lnum;</a>
<a name="ln5520">}</a>
<a name="ln5521"> </a>
<a name="ln5522">/*</a>
<a name="ln5523"> * &quot;line2byte(lnum)&quot; function</a>
<a name="ln5524"> */</a>
<a name="ln5525">static void f_line2byte(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5526">{</a>
<a name="ln5527">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln5528">  if (lnum &lt; 1 || lnum &gt; curbuf-&gt;b_ml.ml_line_count + 1) {</a>
<a name="ln5529">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln5530">  } else {</a>
<a name="ln5531">    rettv-&gt;vval.v_number = ml_find_line_or_offset(curbuf, lnum, NULL, false);</a>
<a name="ln5532">  }</a>
<a name="ln5533">  if (rettv-&gt;vval.v_number &gt;= 0) {</a>
<a name="ln5534">    rettv-&gt;vval.v_number++;</a>
<a name="ln5535">  }</a>
<a name="ln5536">}</a>
<a name="ln5537"> </a>
<a name="ln5538">/*</a>
<a name="ln5539"> * &quot;lispindent(lnum)&quot; function</a>
<a name="ln5540"> */</a>
<a name="ln5541">static void f_lispindent(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5542">{</a>
<a name="ln5543">  const pos_T pos = curwin-&gt;w_cursor;</a>
<a name="ln5544">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln5545">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5546">    curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln5547">    rettv-&gt;vval.v_number = get_lisp_indent();</a>
<a name="ln5548">    curwin-&gt;w_cursor = pos;</a>
<a name="ln5549">  } else {</a>
<a name="ln5550">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln5551">  }</a>
<a name="ln5552">}</a>
<a name="ln5553"> </a>
<a name="ln5554">// &quot;list2str()&quot; function</a>
<a name="ln5555">static void f_list2str(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5556">{</a>
<a name="ln5557">  garray_T ga;</a>
<a name="ln5558"> </a>
<a name="ln5559">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5560">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5561">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln5562">    EMSG(_(e_invarg));</a>
<a name="ln5563">    return;</a>
<a name="ln5564">  }</a>
<a name="ln5565"> </a>
<a name="ln5566">  list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln5567">  if (l == NULL) {</a>
<a name="ln5568">    return;  // empty list results in empty string</a>
<a name="ln5569">  }</a>
<a name="ln5570"> </a>
<a name="ln5571">  ga_init(&amp;ga, 1, 80);</a>
<a name="ln5572">  char_u buf[MB_MAXBYTES + 1];</a>
<a name="ln5573"> </a>
<a name="ln5574">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln5575">    buf[utf_char2bytes(tv_get_number(TV_LIST_ITEM_TV(li)), buf)] = NUL;</a>
<a name="ln5576">    ga_concat(&amp;ga, buf);</a>
<a name="ln5577">  });</a>
<a name="ln5578">  ga_append(&amp;ga, NUL);</a>
<a name="ln5579"> </a>
<a name="ln5580">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln5581">}</a>
<a name="ln5582"> </a>
<a name="ln5583">/*</a>
<a name="ln5584"> * &quot;localtime()&quot; function</a>
<a name="ln5585"> */</a>
<a name="ln5586">static void f_localtime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5587">{</a>
<a name="ln5588">  rettv-&gt;vval.v_number = (varnumber_T)time(NULL);</a>
<a name="ln5589">}</a>
<a name="ln5590"> </a>
<a name="ln5591"> </a>
<a name="ln5592">static void get_maparg(typval_T *argvars, typval_T *rettv, int exact)</a>
<a name="ln5593">{</a>
<a name="ln5594">  char_u *keys_buf = NULL;</a>
<a name="ln5595">  char_u *rhs;</a>
<a name="ln5596">  int mode;</a>
<a name="ln5597">  int abbr = FALSE;</a>
<a name="ln5598">  int get_dict = FALSE;</a>
<a name="ln5599">  mapblock_T  *mp;</a>
<a name="ln5600">  int buffer_local;</a>
<a name="ln5601"> </a>
<a name="ln5602">  // Return empty string for failure.</a>
<a name="ln5603">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5604">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5605"> </a>
<a name="ln5606">  char_u *keys = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln5607">  if (*keys == NUL) {</a>
<a name="ln5608">    return;</a>
<a name="ln5609">  }</a>
<a name="ln5610"> </a>
<a name="ln5611">  char buf[NUMBUFLEN];</a>
<a name="ln5612">  const char *which;</a>
<a name="ln5613">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln5614">    which = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln5615">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5616">      abbr = tv_get_number(&amp;argvars[2]);</a>
<a name="ln5617">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5618">        get_dict = tv_get_number(&amp;argvars[3]);</a>
<a name="ln5619">      }</a>
<a name="ln5620">    }</a>
<a name="ln5621">  } else {</a>
<a name="ln5622">    which = &quot;&quot;;</a>
<a name="ln5623">  }</a>
<a name="ln5624">  if (which == NULL) {</a>
<a name="ln5625">    return;</a>
<a name="ln5626">  }</a>
<a name="ln5627"> </a>
<a name="ln5628">  mode = get_map_mode((char_u **)&amp;which, 0);</a>
<a name="ln5629"> </a>
<a name="ln5630">  keys = replace_termcodes(keys, STRLEN(keys), &amp;keys_buf, true, true, true,</a>
<a name="ln5631">                           CPO_TO_CPO_FLAGS);</a>
<a name="ln5632">  rhs = check_map(keys, mode, exact, false, abbr, &amp;mp, &amp;buffer_local);</a>
<a name="ln5633">  xfree(keys_buf);</a>
<a name="ln5634"> </a>
<a name="ln5635">  if (!get_dict) {</a>
<a name="ln5636">    // Return a string.</a>
<a name="ln5637">    if (rhs != NULL) {</a>
<a name="ln5638">      if (*rhs == NUL) {</a>
<a name="ln5639">        rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;&lt;Nop&gt;&quot;);</a>
<a name="ln5640">      } else {</a>
<a name="ln5641">        rettv-&gt;vval.v_string = (char_u *)str2special_save(</a>
<a name="ln5642">            (char *)rhs, false, false);</a>
<a name="ln5643">      }</a>
<a name="ln5644">    }</a>
<a name="ln5645"> </a>
<a name="ln5646">  } else {</a>
<a name="ln5647">    tv_dict_alloc_ret(rettv);</a>
<a name="ln5648">    if (rhs != NULL) {</a>
<a name="ln5649">      // Return a dictionary.</a>
<a name="ln5650">      mapblock_fill_dict(rettv-&gt;vval.v_dict, mp, buffer_local, true);</a>
<a name="ln5651">    }</a>
<a name="ln5652">  }</a>
<a name="ln5653">}</a>
<a name="ln5654"> </a>
<a name="ln5655">/// luaeval() function implementation</a>
<a name="ln5656">static void f_luaeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5657">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5658">{</a>
<a name="ln5659">  const char *const str = (const char *)tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln5660">  if (str == NULL) {</a>
<a name="ln5661">    return;</a>
<a name="ln5662">  }</a>
<a name="ln5663"> </a>
<a name="ln5664">  nlua_typval_eval(cstr_as_string((char *)str), &amp;argvars[1], rettv);</a>
<a name="ln5665">}</a>
<a name="ln5666"> </a>
<a name="ln5667">/*</a>
<a name="ln5668"> * &quot;map()&quot; function</a>
<a name="ln5669"> */</a>
<a name="ln5670">static void f_map(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5671">{</a>
<a name="ln5672">  filter_map(argvars, rettv, TRUE);</a>
<a name="ln5673">}</a>
<a name="ln5674"> </a>
<a name="ln5675">/*</a>
<a name="ln5676"> * &quot;maparg()&quot; function</a>
<a name="ln5677"> */</a>
<a name="ln5678">static void f_maparg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5679">{</a>
<a name="ln5680">  get_maparg(argvars, rettv, TRUE);</a>
<a name="ln5681">}</a>
<a name="ln5682"> </a>
<a name="ln5683">/*</a>
<a name="ln5684"> * &quot;mapcheck()&quot; function</a>
<a name="ln5685"> */</a>
<a name="ln5686">static void f_mapcheck(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5687">{</a>
<a name="ln5688">  get_maparg(argvars, rettv, FALSE);</a>
<a name="ln5689">}</a>
<a name="ln5690"> </a>
<a name="ln5691"> </a>
<a name="ln5692">static void find_some_match(typval_T *const argvars, typval_T *const rettv,</a>
<a name="ln5693">                            const SomeMatchType type)</a>
<a name="ln5694">{</a>
<a name="ln5695">  char_u      *str = NULL;</a>
<a name="ln5696">  long        len = 0;</a>
<a name="ln5697">  char_u      *expr = NULL;</a>
<a name="ln5698">  regmatch_T regmatch;</a>
<a name="ln5699">  char_u      *save_cpo;</a>
<a name="ln5700">  long start = 0;</a>
<a name="ln5701">  long nth = 1;</a>
<a name="ln5702">  colnr_T startcol = 0;</a>
<a name="ln5703">  bool match = false;</a>
<a name="ln5704">  list_T      *l = NULL;</a>
<a name="ln5705">  listitem_T  *li = NULL;</a>
<a name="ln5706">  long idx = 0;</a>
<a name="ln5707">  char_u      *tofree = NULL;</a>
<a name="ln5708"> </a>
<a name="ln5709">  // Make 'cpoptions' empty, the 'l' flag should not be used here.</a>
<a name="ln5710">  save_cpo = p_cpo;</a>
<a name="ln5711">  p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln5712"> </a>
<a name="ln5713">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln5714">  switch (type) {</a>
<a name="ln5715">    // matchlist(): return empty list when there are no matches.</a>
<a name="ln5716">    case kSomeMatchList: {</a>
<a name="ln5717">      tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln5718">      break;</a>
<a name="ln5719">    }</a>
<a name="ln5720">    // matchstrpos(): return [&quot;&quot;, -1, -1, -1]</a>
<a name="ln5721">    case kSomeMatchStrPos: {</a>
<a name="ln5722">      tv_list_alloc_ret(rettv, 4);</a>
<a name="ln5723">      tv_list_append_string(rettv-&gt;vval.v_list, &quot;&quot;, 0);</a>
<a name="ln5724">      tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln5725">      tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln5726">      tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln5727">      break;</a>
<a name="ln5728">    }</a>
<a name="ln5729">    case kSomeMatchStr: {</a>
<a name="ln5730">      rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5731">      rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5732">      break;</a>
<a name="ln5733">    }</a>
<a name="ln5734">    case kSomeMatch:</a>
<a name="ln5735">    case kSomeMatchEnd: {</a>
<a name="ln5736">      // Do nothing: zero is default.</a>
<a name="ln5737">      break;</a>
<a name="ln5738">    }</a>
<a name="ln5739">  }</a>
<a name="ln5740"> </a>
<a name="ln5741">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln5742">    if ((l = argvars[0].vval.v_list) == NULL) {</a>
<a name="ln5743">      goto theend;</a>
<a name="ln5744">    }</a>
<a name="ln5745">    li = tv_list_first(l);</a>
<a name="ln5746">  } else {</a>
<a name="ln5747">    expr = str = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln5748">    len = (long)STRLEN(str);</a>
<a name="ln5749">  }</a>
<a name="ln5750"> </a>
<a name="ln5751">  char patbuf[NUMBUFLEN];</a>
<a name="ln5752">  const char *const pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln5753">  if (pat == NULL) {</a>
<a name="ln5754">    goto theend;</a>
<a name="ln5755">  }</a>
<a name="ln5756"> </a>
<a name="ln5757">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5758">    bool error = false;</a>
<a name="ln5759"> </a>
<a name="ln5760">    start = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln5761">    if (error) {</a>
<a name="ln5762">      goto theend;</a>
<a name="ln5763">    }</a>
<a name="ln5764">    if (l != NULL) {</a>
<a name="ln5765">      idx = tv_list_uidx(l, start);</a>
<a name="ln5766">      if (idx == -1) {</a>
<a name="ln5767">        goto theend;</a>
<a name="ln5768">      }</a>
<a name="ln5769">      li = tv_list_find(l, idx);</a>
<a name="ln5770">    } else {</a>
<a name="ln5771">      if (start &lt; 0)</a>
<a name="ln5772">        start = 0;</a>
<a name="ln5773">      if (start &gt; len)</a>
<a name="ln5774">        goto theend;</a>
<a name="ln5775">      // When &quot;count&quot; argument is there ignore matches before &quot;start&quot;,</a>
<a name="ln5776">      // otherwise skip part of the string.  Differs when pattern is &quot;^&quot;</a>
<a name="ln5777">      // or &quot;\&lt;&quot;.</a>
<a name="ln5778">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5779">        startcol = start;</a>
<a name="ln5780">      } else {</a>
<a name="ln5781">        str += start;</a>
<a name="ln5782">        len -= start;</a>
<a name="ln5783">      }</a>
<a name="ln5784">    }</a>
<a name="ln5785"> </a>
<a name="ln5786">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5787">      nth = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln5788">    }</a>
<a name="ln5789">    if (error) {</a>
<a name="ln5790">      goto theend;</a>
<a name="ln5791">    }</a>
<a name="ln5792">  }</a>
<a name="ln5793"> </a>
<a name="ln5794">  regmatch.regprog = vim_regcomp((char_u *)pat, RE_MAGIC + RE_STRING);</a>
<a name="ln5795">  if (regmatch.regprog != NULL) {</a>
<a name="ln5796">    regmatch.rm_ic = p_ic;</a>
<a name="ln5797"> </a>
<a name="ln5798">    for (;; ) {</a>
<a name="ln5799">      if (l != NULL) {</a>
<a name="ln5800">        if (li == NULL) {</a>
<a name="ln5801">          match = false;</a>
<a name="ln5802">          break;</a>
<a name="ln5803">        }</a>
<a name="ln5804">        xfree(tofree);</a>
<a name="ln5805">        tofree = expr = str = (char_u *)encode_tv2echo(TV_LIST_ITEM_TV(li),</a>
<a name="ln5806">                                                       NULL);</a>
<a name="ln5807">        if (str == NULL) {</a>
<a name="ln5808">          break;</a>
<a name="ln5809">        }</a>
<a name="ln5810">      }</a>
<a name="ln5811"> </a>
<a name="ln5812">      match = vim_regexec_nl(&amp;regmatch, str, (colnr_T)startcol);</a>
<a name="ln5813"> </a>
<a name="ln5814">      if (match &amp;&amp; --nth &lt;= 0)</a>
<a name="ln5815">        break;</a>
<a name="ln5816">      if (l == NULL &amp;&amp; !match)</a>
<a name="ln5817">        break;</a>
<a name="ln5818"> </a>
<a name="ln5819">      // Advance to just after the match.</a>
<a name="ln5820">      if (l != NULL) {</a>
<a name="ln5821">        li = TV_LIST_ITEM_NEXT(l, li);</a>
<a name="ln5822">        idx++;</a>
<a name="ln5823">      } else {</a>
<a name="ln5824">        startcol = (colnr_T)(regmatch.startp[0]</a>
<a name="ln5825">                             + (*mb_ptr2len)(regmatch.startp[0]) - str);</a>
<a name="ln5826">        if (startcol &gt; (colnr_T)len || str + startcol &lt;= regmatch.startp[0]) {</a>
<a name="ln5827">            match = false;</a>
<a name="ln5828">            break;</a>
<a name="ln5829">        }</a>
<a name="ln5830">      }</a>
<a name="ln5831">    }</a>
<a name="ln5832"> </a>
<a name="ln5833">    if (match) {</a>
<a name="ln5834">      switch (type) {</a>
<a name="ln5835">        case kSomeMatchStrPos: {</a>
<a name="ln5836">          list_T *const ret_l = rettv-&gt;vval.v_list;</a>
<a name="ln5837">          listitem_T *li1 = tv_list_first(ret_l);</a>
<a name="ln5838">          listitem_T *li2 = TV_LIST_ITEM_NEXT(ret_l, li1);</a>
<a name="ln5839">          listitem_T *li3 = TV_LIST_ITEM_NEXT(ret_l, li2);</a>
<a name="ln5840">          listitem_T *li4 = TV_LIST_ITEM_NEXT(ret_l, li3);</a>
<a name="ln5841">          xfree(TV_LIST_ITEM_TV(li1)-&gt;vval.v_string);</a>
<a name="ln5842"> </a>
<a name="ln5843">          const size_t rd = (size_t)(regmatch.endp[0] - regmatch.startp[0]);</a>
<a name="ln5844">          TV_LIST_ITEM_TV(li1)-&gt;vval.v_string = xmemdupz(</a>
<a name="ln5845">              (const char *)regmatch.startp[0], rd);</a>
<a name="ln5846">          TV_LIST_ITEM_TV(li3)-&gt;vval.v_number = (varnumber_T)(</a>
<a name="ln5847">              regmatch.startp[0] - expr);</a>
<a name="ln5848">          TV_LIST_ITEM_TV(li4)-&gt;vval.v_number = (varnumber_T)(</a>
<a name="ln5849">              regmatch.endp[0] - expr);</a>
<a name="ln5850">          if (l != NULL) {</a>
<a name="ln5851">            TV_LIST_ITEM_TV(li2)-&gt;vval.v_number = (varnumber_T)idx;</a>
<a name="ln5852">          }</a>
<a name="ln5853">          break;</a>
<a name="ln5854">        }</a>
<a name="ln5855">        case kSomeMatchList: {</a>
<a name="ln5856">          // Return list with matched string and submatches.</a>
<a name="ln5857">          for (int i = 0; i &lt; NSUBEXP; i++) {</a>
<a name="ln5858">            if (regmatch.endp[i] == NULL) {</a>
<a name="ln5859">              tv_list_append_string(rettv-&gt;vval.v_list, NULL, 0);</a>
<a name="ln5860">            } else {</a>
<a name="ln5861">              tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln5862">                                    (const char *)regmatch.startp[i],</a>
<a name="ln5863">                                    (regmatch.endp[i] - regmatch.startp[i]));</a>
<a name="ln5864">            }</a>
<a name="ln5865">          }</a>
<a name="ln5866">          break;</a>
<a name="ln5867">        }</a>
<a name="ln5868">        case kSomeMatchStr: {</a>
<a name="ln5869">          // Return matched string.</a>
<a name="ln5870">          if (l != NULL) {</a>
<a name="ln5871">            tv_copy(TV_LIST_ITEM_TV(li), rettv);</a>
<a name="ln5872">          } else {</a>
<a name="ln5873">            rettv-&gt;vval.v_string = (char_u *)xmemdupz(</a>
<a name="ln5874">                (const char *)regmatch.startp[0],</a>
<a name="ln5875">                (size_t)(regmatch.endp[0] - regmatch.startp[0]));</a>
<a name="ln5876">          }</a>
<a name="ln5877">          break;</a>
<a name="ln5878">        }</a>
<a name="ln5879">        case kSomeMatch:</a>
<a name="ln5880">        case kSomeMatchEnd: {</a>
<a name="ln5881">          if (l != NULL) {</a>
<a name="ln5882">            rettv-&gt;vval.v_number = idx;</a>
<a name="ln5883">          } else {</a>
<a name="ln5884">            if (type == kSomeMatch) {</a>
<a name="ln5885">              rettv-&gt;vval.v_number =</a>
<a name="ln5886">                (varnumber_T)(regmatch.startp[0] - str);</a>
<a name="ln5887">            } else {</a>
<a name="ln5888">              rettv-&gt;vval.v_number =</a>
<a name="ln5889">                (varnumber_T)(regmatch.endp[0] - str);</a>
<a name="ln5890">            }</a>
<a name="ln5891">            rettv-&gt;vval.v_number += (varnumber_T)(str - expr);</a>
<a name="ln5892">          }</a>
<a name="ln5893">          break;</a>
<a name="ln5894">        }</a>
<a name="ln5895">      }</a>
<a name="ln5896">    }</a>
<a name="ln5897">    vim_regfree(regmatch.regprog);</a>
<a name="ln5898">  }</a>
<a name="ln5899"> </a>
<a name="ln5900">theend:</a>
<a name="ln5901">  if (type == kSomeMatchStrPos &amp;&amp; l == NULL &amp;&amp; rettv-&gt;vval.v_list != NULL) {</a>
<a name="ln5902">    // matchstrpos() without a list: drop the second item</a>
<a name="ln5903">    list_T *const ret_l = rettv-&gt;vval.v_list;</a>
<a name="ln5904">    tv_list_item_remove(ret_l, TV_LIST_ITEM_NEXT(ret_l, tv_list_first(ret_l)));</a>
<a name="ln5905">  }</a>
<a name="ln5906"> </a>
<a name="ln5907">  xfree(tofree);</a>
<a name="ln5908">  p_cpo = save_cpo;</a>
<a name="ln5909">}</a>
<a name="ln5910"> </a>
<a name="ln5911">/*</a>
<a name="ln5912"> * &quot;match()&quot; function</a>
<a name="ln5913"> */</a>
<a name="ln5914">static void f_match(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5915">{</a>
<a name="ln5916">  find_some_match(argvars, rettv, kSomeMatch);</a>
<a name="ln5917">}</a>
<a name="ln5918"> </a>
<a name="ln5919">/*</a>
<a name="ln5920"> * &quot;matchadd()&quot; function</a>
<a name="ln5921"> */</a>
<a name="ln5922">static void f_matchadd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5923">{</a>
<a name="ln5924">  char grpbuf[NUMBUFLEN];</a>
<a name="ln5925">  char patbuf[NUMBUFLEN];</a>
<a name="ln5926">  // group</a>
<a name="ln5927">  const char *const grp = tv_get_string_buf_chk(&amp;argvars[0], grpbuf);</a>
<a name="ln5928">  // pattern</a>
<a name="ln5929">  const char *const pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln5930">  // default priority</a>
<a name="ln5931">  int prio = 10;</a>
<a name="ln5932">  int id = -1;</a>
<a name="ln5933">  bool error = false;</a>
<a name="ln5934">  const char *conceal_char = NULL;</a>
<a name="ln5935">  win_T *win = curwin;</a>
<a name="ln5936"> </a>
<a name="ln5937">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln5938"> </a>
<a name="ln5939">  if (grp == NULL || pat == NULL) {</a>
<a name="ln5940">    return;</a>
<a name="ln5941">  }</a>
<a name="ln5942">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5943">    prio = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln5944">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5945">      id = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln5946">      if (argvars[4].v_type != VAR_UNKNOWN</a>
<a name="ln5947">          &amp;&amp; matchadd_dict_arg(&amp;argvars[4], &amp;conceal_char, &amp;win) == FAIL) {</a>
<a name="ln5948">        return;</a>
<a name="ln5949">      }</a>
<a name="ln5950">    }</a>
<a name="ln5951">  }</a>
<a name="ln5952">  if (error) {</a>
<a name="ln5953">    return;</a>
<a name="ln5954">  }</a>
<a name="ln5955">  if (id &gt;= 1 &amp;&amp; id &lt;= 3) {</a>
<a name="ln5956">    EMSGN(_(&quot;E798: ID is reserved for \&quot;:match\&quot;: %&quot; PRId64), id);</a>
<a name="ln5957">    return;</a>
<a name="ln5958">  }</a>
<a name="ln5959"> </a>
<a name="ln5960">  rettv-&gt;vval.v_number = match_add(win, grp, pat, prio, id, NULL, conceal_char);</a>
<a name="ln5961">}</a>
<a name="ln5962"> </a>
<a name="ln5963">static void f_matchaddpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5964">{</a>
<a name="ln5965">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln5966"> </a>
<a name="ln5967">  char buf[NUMBUFLEN];</a>
<a name="ln5968">  const char *const group = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln5969">  if (group == NULL) {</a>
<a name="ln5970">    return;</a>
<a name="ln5971">  }</a>
<a name="ln5972"> </a>
<a name="ln5973">  if (argvars[1].v_type != VAR_LIST) {</a>
<a name="ln5974">    EMSG2(_(e_listarg), &quot;matchaddpos()&quot;);</a>
<a name="ln5975">    return;</a>
<a name="ln5976">  }</a>
<a name="ln5977"> </a>
<a name="ln5978">  list_T *l;</a>
<a name="ln5979">  l = argvars[1].vval.v_list;</a>
<a name="ln5980">  if (l == NULL) {</a>
<a name="ln5981">    return;</a>
<a name="ln5982">  }</a>
<a name="ln5983"> </a>
<a name="ln5984">  bool error = false;</a>
<a name="ln5985">  int prio = 10;</a>
<a name="ln5986">  int id = -1;</a>
<a name="ln5987">  const char *conceal_char = NULL;</a>
<a name="ln5988">  win_T *win = curwin;</a>
<a name="ln5989"> </a>
<a name="ln5990">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5991">    prio = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln5992">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5993">      id = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln5994">      if (argvars[4].v_type != VAR_UNKNOWN</a>
<a name="ln5995">          &amp;&amp; matchadd_dict_arg(&amp;argvars[4], &amp;conceal_char, &amp;win) == FAIL) {</a>
<a name="ln5996">        return;</a>
<a name="ln5997">      }</a>
<a name="ln5998">    }</a>
<a name="ln5999">  }</a>
<a name="ln6000">  if (error == true) {</a>
<a name="ln6001">    return;</a>
<a name="ln6002">  }</a>
<a name="ln6003"> </a>
<a name="ln6004">  // id == 3 is ok because matchaddpos() is supposed to substitute :3match</a>
<a name="ln6005">  if (id == 1 || id == 2) {</a>
<a name="ln6006">    EMSGN(_(&quot;E798: ID is reserved for \&quot;match\&quot;: %&quot; PRId64), id);</a>
<a name="ln6007">    return;</a>
<a name="ln6008">  }</a>
<a name="ln6009"> </a>
<a name="ln6010">  rettv-&gt;vval.v_number = match_add(win, group, NULL, prio, id, l, conceal_char);</a>
<a name="ln6011">}</a>
<a name="ln6012"> </a>
<a name="ln6013">/*</a>
<a name="ln6014"> * &quot;matcharg()&quot; function</a>
<a name="ln6015"> */</a>
<a name="ln6016">static void f_matcharg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6017">{</a>
<a name="ln6018">  const int id = tv_get_number(&amp;argvars[0]);</a>
<a name="ln6019"> </a>
<a name="ln6020">  tv_list_alloc_ret(rettv, (id &gt;= 1 &amp;&amp; id &lt;= 3</a>
<a name="ln6021">                            ? 2</a>
<a name="ln6022">                            : 0));</a>
<a name="ln6023"> </a>
<a name="ln6024">  if (id &gt;= 1 &amp;&amp; id &lt;= 3) {</a>
<a name="ln6025">    matchitem_T *const m = (matchitem_T *)get_match(curwin, id);</a>
<a name="ln6026"> </a>
<a name="ln6027">    if (m != NULL) {</a>
<a name="ln6028">      tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln6029">                            (const char *)syn_id2name(m-&gt;hlg_id), -1);</a>
<a name="ln6030">      tv_list_append_string(rettv-&gt;vval.v_list, (const char *)m-&gt;pattern, -1);</a>
<a name="ln6031">    } else {</a>
<a name="ln6032">      tv_list_append_string(rettv-&gt;vval.v_list, NULL, 0);</a>
<a name="ln6033">      tv_list_append_string(rettv-&gt;vval.v_list, NULL, 0);</a>
<a name="ln6034">    }</a>
<a name="ln6035">  }</a>
<a name="ln6036">}</a>
<a name="ln6037"> </a>
<a name="ln6038">/*</a>
<a name="ln6039"> * &quot;matchdelete()&quot; function</a>
<a name="ln6040"> */</a>
<a name="ln6041">static void f_matchdelete(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6042">{</a>
<a name="ln6043">  win_T   *win = get_optional_window(argvars, 1);</a>
<a name="ln6044">  if (win == NULL) {</a>
<a name="ln6045">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln6046">  } else {</a>
<a name="ln6047">    rettv-&gt;vval.v_number = match_delete(win,</a>
<a name="ln6048">                                        (int)tv_get_number(&amp;argvars[0]), true);</a>
<a name="ln6049">  }</a>
<a name="ln6050">}</a>
<a name="ln6051"> </a>
<a name="ln6052">/*</a>
<a name="ln6053"> * &quot;matchend()&quot; function</a>
<a name="ln6054"> */</a>
<a name="ln6055">static void f_matchend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6056">{</a>
<a name="ln6057">  find_some_match(argvars, rettv, kSomeMatchEnd);</a>
<a name="ln6058">}</a>
<a name="ln6059"> </a>
<a name="ln6060">/*</a>
<a name="ln6061"> * &quot;matchlist()&quot; function</a>
<a name="ln6062"> */</a>
<a name="ln6063">static void f_matchlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6064">{</a>
<a name="ln6065">  find_some_match(argvars, rettv, kSomeMatchList);</a>
<a name="ln6066">}</a>
<a name="ln6067"> </a>
<a name="ln6068">/*</a>
<a name="ln6069"> * &quot;matchstr()&quot; function</a>
<a name="ln6070"> */</a>
<a name="ln6071">static void f_matchstr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6072">{</a>
<a name="ln6073">  find_some_match(argvars, rettv, kSomeMatchStr);</a>
<a name="ln6074">}</a>
<a name="ln6075"> </a>
<a name="ln6076">/// &quot;matchstrpos()&quot; function</a>
<a name="ln6077">static void f_matchstrpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6078">{</a>
<a name="ln6079">  find_some_match(argvars, rettv, kSomeMatchStrPos);</a>
<a name="ln6080">}</a>
<a name="ln6081"> </a>
<a name="ln6082">/// Get maximal/minimal number value in a list or dictionary</a>
<a name="ln6083">///</a>
<a name="ln6084">/// @param[in]  tv  List or dictionary to work with. If it contains something</a>
<a name="ln6085">///                 that is not an integer number (or cannot be coerced to</a>
<a name="ln6086">///                 it) error is given.</a>
<a name="ln6087">/// @param[out]  rettv  Location where result will be saved. Only assigns</a>
<a name="ln6088">///                     vval.v_number, type is not touched. Returns zero for</a>
<a name="ln6089">///                     empty lists/dictionaries.</a>
<a name="ln6090">/// @param[in]  domax  Determines whether maximal or minimal value is desired.</a>
<a name="ln6091">static void max_min(const typval_T *const tv, typval_T *const rettv,</a>
<a name="ln6092">                    const bool domax)</a>
<a name="ln6093">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6094">{</a>
<a name="ln6095">  bool error = false;</a>
<a name="ln6096"> </a>
<a name="ln6097">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln6098">  varnumber_T n = (domax ? VARNUMBER_MIN : VARNUMBER_MAX);</a>
<a name="ln6099">  if (tv-&gt;v_type == VAR_LIST) {</a>
<a name="ln6100">    if (tv_list_len(tv-&gt;vval.v_list) == 0) {</a>
<a name="ln6101">      return;</a>
<a name="ln6102">    }</a>
<a name="ln6103">    TV_LIST_ITER_CONST(tv-&gt;vval.v_list, li, {</a>
<a name="ln6104">      const varnumber_T i = tv_get_number_chk(TV_LIST_ITEM_TV(li), &amp;error);</a>
<a name="ln6105">      if (error) {</a>
<a name="ln6106">        return;</a>
<a name="ln6107">      }</a>
<a name="ln6108">      if (domax ? i &gt; n : i &lt; n) {</a>
<a name="ln6109">        n = i;</a>
<a name="ln6110">      }</a>
<a name="ln6111">    });</a>
<a name="ln6112">  } else if (tv-&gt;v_type == VAR_DICT) {</a>
<a name="ln6113">    if (tv_dict_len(tv-&gt;vval.v_dict) == 0) {</a>
<a name="ln6114">      return;</a>
<a name="ln6115">    }</a>
<a name="ln6116">    TV_DICT_ITER(tv-&gt;vval.v_dict, di, {</a>
<a name="ln6117">      const varnumber_T i = tv_get_number_chk(&amp;di-&gt;di_tv, &amp;error);</a>
<a name="ln6118">      if (error) {</a>
<a name="ln6119">        return;</a>
<a name="ln6120">      }</a>
<a name="ln6121">      if (domax ? i &gt; n : i &lt; n) {</a>
<a name="ln6122">        n = i;</a>
<a name="ln6123">      }</a>
<a name="ln6124">    });</a>
<a name="ln6125">  } else {</a>
<a name="ln6126">    EMSG2(_(e_listdictarg), domax ? &quot;max()&quot; : &quot;min()&quot;);</a>
<a name="ln6127">    return;</a>
<a name="ln6128">  }</a>
<a name="ln6129">  rettv-&gt;vval.v_number = n;</a>
<a name="ln6130">}</a>
<a name="ln6131"> </a>
<a name="ln6132">/*</a>
<a name="ln6133"> * &quot;max()&quot; function</a>
<a name="ln6134"> */</a>
<a name="ln6135">static void f_max(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6136">{</a>
<a name="ln6137">  max_min(argvars, rettv, TRUE);</a>
<a name="ln6138">}</a>
<a name="ln6139"> </a>
<a name="ln6140">/*</a>
<a name="ln6141"> * &quot;min()&quot; function</a>
<a name="ln6142"> */</a>
<a name="ln6143">static void f_min(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6144">{</a>
<a name="ln6145">  max_min(argvars, rettv, FALSE);</a>
<a name="ln6146">}</a>
<a name="ln6147"> </a>
<a name="ln6148">/*</a>
<a name="ln6149"> * &quot;mkdir()&quot; function</a>
<a name="ln6150"> */</a>
<a name="ln6151">static void f_mkdir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6152">{</a>
<a name="ln6153">  int prot = 0755;  // -V536</a>
<a name="ln6154"> </a>
<a name="ln6155">  rettv-&gt;vval.v_number = FAIL;</a>
<a name="ln6156">  if (check_secure()) {</a>
<a name="ln6157">    return;</a>
<a name="ln6158">  }</a>
<a name="ln6159"> </a>
<a name="ln6160">  char buf[NUMBUFLEN];</a>
<a name="ln6161">  const char *const dir = tv_get_string_buf(&amp;argvars[0], buf);</a>
<a name="ln6162">  if (*dir == NUL) {</a>
<a name="ln6163">    return;</a>
<a name="ln6164">  }</a>
<a name="ln6165"> </a>
<a name="ln6166">  if (*path_tail((char_u *)dir) == NUL) {</a>
<a name="ln6167">    // Remove trailing slashes.</a>
<a name="ln6168">    *path_tail_with_sep((char_u *)dir) = NUL;</a>
<a name="ln6169">  }</a>
<a name="ln6170"> </a>
<a name="ln6171">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln6172">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6173">      prot = tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln6174">      if (prot == -1) {</a>
<a name="ln6175">        return;</a>
<a name="ln6176">      }</a>
<a name="ln6177">    }</a>
<a name="ln6178">    if (strcmp(tv_get_string(&amp;argvars[1]), &quot;p&quot;) == 0) {</a>
<a name="ln6179">      char *failed_dir;</a>
<a name="ln6180">      int ret = os_mkdir_recurse(dir, prot, &amp;failed_dir);</a>
<a name="ln6181">      if (ret != 0) {</a>
<a name="ln6182">        EMSG3(_(e_mkdir), failed_dir, os_strerror(ret));</a>
<a name="ln6183">        xfree(failed_dir);</a>
<a name="ln6184">        rettv-&gt;vval.v_number = FAIL;</a>
<a name="ln6185">        return;</a>
<a name="ln6186">      } else {</a>
<a name="ln6187">        rettv-&gt;vval.v_number = OK;</a>
<a name="ln6188">        return;</a>
<a name="ln6189">      }</a>
<a name="ln6190">    }</a>
<a name="ln6191">  }</a>
<a name="ln6192">  rettv-&gt;vval.v_number = vim_mkdir_emsg(dir, prot);</a>
<a name="ln6193">}</a>
<a name="ln6194"> </a>
<a name="ln6195">/// &quot;mode()&quot; function</a>
<a name="ln6196">static void f_mode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6197">{</a>
<a name="ln6198">  char *mode = get_mode();</a>
<a name="ln6199"> </a>
<a name="ln6200">  // Clear out the minor mode when the argument is not a non-zero number or</a>
<a name="ln6201">  // non-empty string.</a>
<a name="ln6202">  if (!non_zero_arg(&amp;argvars[0])) {</a>
<a name="ln6203">    mode[1] = NUL;</a>
<a name="ln6204">  }</a>
<a name="ln6205"> </a>
<a name="ln6206">  rettv-&gt;vval.v_string = (char_u *)mode;</a>
<a name="ln6207">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6208">}</a>
<a name="ln6209"> </a>
<a name="ln6210">/// &quot;msgpackdump()&quot; function</a>
<a name="ln6211">static void f_msgpackdump(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6212">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6213">{</a>
<a name="ln6214">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln6215">    EMSG2(_(e_listarg), &quot;msgpackdump()&quot;);</a>
<a name="ln6216">    return;</a>
<a name="ln6217">  }</a>
<a name="ln6218">  list_T *const ret_list = tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln6219">  list_T *const list = argvars[0].vval.v_list;</a>
<a name="ln6220">  msgpack_packer *lpacker = msgpack_packer_new(ret_list, &amp;encode_list_write);</a>
<a name="ln6221">  const char *const msg = _(&quot;msgpackdump() argument, index %i&quot;);</a>
<a name="ln6222">  // Assume that translation will not take more then 4 times more space</a>
<a name="ln6223">  char msgbuf[sizeof(&quot;msgpackdump() argument, index &quot;) * 4 + NUMBUFLEN];</a>
<a name="ln6224">  int idx = 0;</a>
<a name="ln6225">  TV_LIST_ITER(list, li, {</a>
<a name="ln6226">    vim_snprintf(msgbuf, sizeof(msgbuf), (char *)msg, idx);</a>
<a name="ln6227">    idx++;</a>
<a name="ln6228">    if (encode_vim_to_msgpack(lpacker, TV_LIST_ITEM_TV(li), msgbuf) == FAIL) {</a>
<a name="ln6229">      break;</a>
<a name="ln6230">    }</a>
<a name="ln6231">  });</a>
<a name="ln6232">  msgpack_packer_free(lpacker);</a>
<a name="ln6233">}</a>
<a name="ln6234"> </a>
<a name="ln6235">/// &quot;msgpackparse&quot; function</a>
<a name="ln6236">static void f_msgpackparse(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6237">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6238">{</a>
<a name="ln6239">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln6240">    EMSG2(_(e_listarg), &quot;msgpackparse()&quot;);</a>
<a name="ln6241">    return;</a>
<a name="ln6242">  }</a>
<a name="ln6243">  list_T *const ret_list = tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln6244">  const list_T *const list = argvars[0].vval.v_list;</a>
<a name="ln6245">  if (tv_list_len(list) == 0) {</a>
<a name="ln6246">    return;</a>
<a name="ln6247">  }</a>
<a name="ln6248">  if (TV_LIST_ITEM_TV(tv_list_first(list))-&gt;v_type != VAR_STRING) {</a>
<a name="ln6249">    EMSG2(_(e_invarg2), &quot;List item is not a string&quot;);</a>
<a name="ln6250">    return;</a>
<a name="ln6251">  }</a>
<a name="ln6252">  ListReaderState lrstate = encode_init_lrstate(list);</a>
<a name="ln6253">  msgpack_unpacker *const unpacker = msgpack_unpacker_new(IOSIZE);</a>
<a name="ln6254">  if (unpacker == NULL) {</a>
<a name="ln6255">    EMSG(_(e_outofmem));</a>
<a name="ln6256">    return;</a>
<a name="ln6257">  }</a>
<a name="ln6258">  msgpack_unpacked unpacked;</a>
<a name="ln6259">  msgpack_unpacked_init(&amp;unpacked);</a>
<a name="ln6260">  do {</a>
<a name="ln6261">    if (!msgpack_unpacker_reserve_buffer(unpacker, IOSIZE)) {</a>
<a name="ln6262">      EMSG(_(e_outofmem));</a>
<a name="ln6263">      goto f_msgpackparse_exit;</a>
<a name="ln6264">    }</a>
<a name="ln6265">    size_t read_bytes;</a>
<a name="ln6266">    const int rlret = encode_read_from_list(</a>
<a name="ln6267">        &amp;lrstate, msgpack_unpacker_buffer(unpacker), IOSIZE, &amp;read_bytes);</a>
<a name="ln6268">    if (rlret == FAIL) {</a>
<a name="ln6269">      EMSG2(_(e_invarg2), &quot;List item is not a string&quot;);</a>
<a name="ln6270">      goto f_msgpackparse_exit;</a>
<a name="ln6271">    }</a>
<a name="ln6272">    msgpack_unpacker_buffer_consumed(unpacker, read_bytes);</a>
<a name="ln6273">    if (read_bytes == 0) {</a>
<a name="ln6274">      break;</a>
<a name="ln6275">    }</a>
<a name="ln6276">    while (unpacker-&gt;off &lt; unpacker-&gt;used) {</a>
<a name="ln6277">      const msgpack_unpack_return result = msgpack_unpacker_next(unpacker,</a>
<a name="ln6278">                                                                 &amp;unpacked);</a>
<a name="ln6279">      if (result == MSGPACK_UNPACK_PARSE_ERROR) {</a>
<a name="ln6280">        EMSG2(_(e_invarg2), &quot;Failed to parse msgpack string&quot;);</a>
<a name="ln6281">        goto f_msgpackparse_exit;</a>
<a name="ln6282">      }</a>
<a name="ln6283">      if (result == MSGPACK_UNPACK_NOMEM_ERROR) {</a>
<a name="ln6284">        EMSG(_(e_outofmem));</a>
<a name="ln6285">        goto f_msgpackparse_exit;</a>
<a name="ln6286">      }</a>
<a name="ln6287">      if (result == MSGPACK_UNPACK_SUCCESS) {</a>
<a name="ln6288">        typval_T tv = { .v_type = VAR_UNKNOWN };</a>
<a name="ln6289">        if (msgpack_to_vim(unpacked.data, &amp;tv) == FAIL) {</a>
<a name="ln6290">          EMSG2(_(e_invarg2), &quot;Failed to convert msgpack string&quot;);</a>
<a name="ln6291">          goto f_msgpackparse_exit;</a>
<a name="ln6292">        }</a>
<a name="ln6293">        tv_list_append_owned_tv(ret_list, tv);</a>
<a name="ln6294">      }</a>
<a name="ln6295">      if (result == MSGPACK_UNPACK_CONTINUE) {</a>
<a name="ln6296">        if (rlret == OK) {</a>
<a name="ln6297">          EMSG2(_(e_invarg2), &quot;Incomplete msgpack string&quot;);</a>
<a name="ln6298">        }</a>
<a name="ln6299">        break;</a>
<a name="ln6300">      }</a>
<a name="ln6301">    }</a>
<a name="ln6302">    if (rlret == OK) {</a>
<a name="ln6303">      break;</a>
<a name="ln6304">    }</a>
<a name="ln6305">  } while (true);</a>
<a name="ln6306"> </a>
<a name="ln6307">f_msgpackparse_exit:</a>
<a name="ln6308">  msgpack_unpacked_destroy(&amp;unpacked);</a>
<a name="ln6309">  msgpack_unpacker_free(unpacker);</a>
<a name="ln6310">  return;</a>
<a name="ln6311">}</a>
<a name="ln6312"> </a>
<a name="ln6313">/*</a>
<a name="ln6314"> * &quot;nextnonblank()&quot; function</a>
<a name="ln6315"> */</a>
<a name="ln6316">static void f_nextnonblank(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6317">{</a>
<a name="ln6318">  linenr_T lnum;</a>
<a name="ln6319"> </a>
<a name="ln6320">  for (lnum = tv_get_lnum(argvars);; lnum++) {</a>
<a name="ln6321">    if (lnum &lt; 0 || lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6322">      lnum = 0;</a>
<a name="ln6323">      break;</a>
<a name="ln6324">    }</a>
<a name="ln6325">    if (*skipwhite(ml_get(lnum)) != NUL) {</a>
<a name="ln6326">      break;</a>
<a name="ln6327">    }</a>
<a name="ln6328">  }</a>
<a name="ln6329">  rettv-&gt;vval.v_number = lnum;</a>
<a name="ln6330">}</a>
<a name="ln6331"> </a>
<a name="ln6332">/*</a>
<a name="ln6333"> * &quot;nr2char()&quot; function</a>
<a name="ln6334"> */</a>
<a name="ln6335">static void f_nr2char(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6336">{</a>
<a name="ln6337">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln6338">    if (!tv_check_num(&amp;argvars[1])) {</a>
<a name="ln6339">      return;</a>
<a name="ln6340">    }</a>
<a name="ln6341">  }</a>
<a name="ln6342"> </a>
<a name="ln6343">  bool error = false;</a>
<a name="ln6344">  const varnumber_T num = tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln6345">  if (error) {</a>
<a name="ln6346">    return;</a>
<a name="ln6347">  }</a>
<a name="ln6348">  if (num &lt; 0) {</a>
<a name="ln6349">    EMSG(_(&quot;E5070: Character number must not be less than zero&quot;));</a>
<a name="ln6350">    return;</a>
<a name="ln6351">  }</a>
<a name="ln6352">  if (num &gt; INT_MAX) {</a>
<a name="ln6353">    emsgf(_(&quot;E5071: Character number must not be greater than INT_MAX (%i)&quot;),</a>
<a name="ln6354">          INT_MAX);</a>
<a name="ln6355">    return;</a>
<a name="ln6356">  }</a>
<a name="ln6357"> </a>
<a name="ln6358">  char buf[MB_MAXBYTES];</a>
<a name="ln6359">  const int len = utf_char2bytes((int)num, (char_u *)buf);</a>
<a name="ln6360"> </a>
<a name="ln6361">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6362">  rettv-&gt;vval.v_string = xmemdupz(buf, (size_t)len);</a>
<a name="ln6363">}</a>
<a name="ln6364"> </a>
<a name="ln6365">/*</a>
<a name="ln6366"> * &quot;or(expr, expr)&quot; function</a>
<a name="ln6367"> */</a>
<a name="ln6368">static void f_or(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6369">{</a>
<a name="ln6370">  rettv-&gt;vval.v_number = tv_get_number_chk(&amp;argvars[0], NULL)</a>
<a name="ln6371">                         | tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln6372">}</a>
<a name="ln6373"> </a>
<a name="ln6374">/*</a>
<a name="ln6375"> * &quot;pathshorten()&quot; function</a>
<a name="ln6376"> */</a>
<a name="ln6377">static void f_pathshorten(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6378">{</a>
<a name="ln6379">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6380">  const char *const s = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln6381">  if (!s) {</a>
<a name="ln6382">    return;</a>
<a name="ln6383">  }</a>
<a name="ln6384">  rettv-&gt;vval.v_string = shorten_dir((char_u *)xstrdup(s));</a>
<a name="ln6385">}</a>
<a name="ln6386"> </a>
<a name="ln6387">/*</a>
<a name="ln6388"> * &quot;pow()&quot; function</a>
<a name="ln6389"> */</a>
<a name="ln6390">static void f_pow(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6391">{</a>
<a name="ln6392">  float_T fx;</a>
<a name="ln6393">  float_T fy;</a>
<a name="ln6394"> </a>
<a name="ln6395">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln6396">  if (tv_get_float_chk(argvars, &amp;fx) &amp;&amp; tv_get_float_chk(&amp;argvars[1], &amp;fy)) {</a>
<a name="ln6397">    rettv-&gt;vval.v_float = pow(fx, fy);</a>
<a name="ln6398">  } else {</a>
<a name="ln6399">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln6400">  }</a>
<a name="ln6401">}</a>
<a name="ln6402"> </a>
<a name="ln6403">/*</a>
<a name="ln6404"> * &quot;prevnonblank()&quot; function</a>
<a name="ln6405"> */</a>
<a name="ln6406">static void f_prevnonblank(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6407">{</a>
<a name="ln6408">  linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln6409">  if (lnum &lt; 1 || lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6410">    lnum = 0;</a>
<a name="ln6411">  } else {</a>
<a name="ln6412">    while (lnum &gt;= 1 &amp;&amp; *skipwhite(ml_get(lnum)) == NUL) {</a>
<a name="ln6413">      lnum--;</a>
<a name="ln6414">    }</a>
<a name="ln6415">  }</a>
<a name="ln6416">  rettv-&gt;vval.v_number = lnum;</a>
<a name="ln6417">}</a>
<a name="ln6418"> </a>
<a name="ln6419">/*</a>
<a name="ln6420"> * &quot;printf()&quot; function</a>
<a name="ln6421"> */</a>
<a name="ln6422">static void f_printf(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6423">{</a>
<a name="ln6424">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6425">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln6426">  {</a>
<a name="ln6427">    int len;</a>
<a name="ln6428">    int saved_did_emsg = did_emsg;</a>
<a name="ln6429"> </a>
<a name="ln6430">    // Get the required length, allocate the buffer and do it for real.</a>
<a name="ln6431">    did_emsg = false;</a>
<a name="ln6432">    char buf[NUMBUFLEN];</a>
<a name="ln6433">    const char *fmt = tv_get_string_buf(&amp;argvars[0], buf);</a>
<a name="ln6434">    len = vim_vsnprintf_typval(NULL, 0, fmt, dummy_ap, argvars + 1);</a>
<a name="ln6435">    if (!did_emsg) {</a>
<a name="ln6436">      char *s = xmalloc(len + 1);</a>
<a name="ln6437">      rettv-&gt;vval.v_string = (char_u *)s;</a>
<a name="ln6438">      (void)vim_vsnprintf_typval(s, len + 1, fmt, dummy_ap, argvars + 1);</a>
<a name="ln6439">    }</a>
<a name="ln6440">    did_emsg |= saved_did_emsg;</a>
<a name="ln6441">  }</a>
<a name="ln6442">}</a>
<a name="ln6443"> </a>
<a name="ln6444">// &quot;prompt_setcallback({buffer}, {callback})&quot; function</a>
<a name="ln6445">static void f_prompt_setcallback(typval_T *argvars,</a>
<a name="ln6446">                                 typval_T *rettv, FunPtr fptr)</a>
<a name="ln6447">{</a>
<a name="ln6448">    buf_T *buf;</a>
<a name="ln6449">    Callback prompt_callback = { .type = kCallbackNone };</a>
<a name="ln6450"> </a>
<a name="ln6451">    if (check_secure()) {</a>
<a name="ln6452">      return;</a>
<a name="ln6453">    }</a>
<a name="ln6454">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln6455">    if (buf == NULL) {</a>
<a name="ln6456">      return;</a>
<a name="ln6457">    }</a>
<a name="ln6458"> </a>
<a name="ln6459">    if (argvars[1].v_type != VAR_STRING || *argvars[1].vval.v_string != NUL) {</a>
<a name="ln6460">      if (!callback_from_typval(&amp;prompt_callback, &amp;argvars[1])) {</a>
<a name="ln6461">        return;</a>
<a name="ln6462">      }</a>
<a name="ln6463">    }</a>
<a name="ln6464"> </a>
<a name="ln6465">    callback_free(&amp;buf-&gt;b_prompt_callback);</a>
<a name="ln6466">    buf-&gt;b_prompt_callback = prompt_callback;</a>
<a name="ln6467">}</a>
<a name="ln6468"> </a>
<a name="ln6469">// &quot;prompt_setinterrupt({buffer}, {callback})&quot; function</a>
<a name="ln6470">static void f_prompt_setinterrupt(typval_T *argvars,</a>
<a name="ln6471">                                  typval_T *rettv, FunPtr fptr)</a>
<a name="ln6472">{</a>
<a name="ln6473">    buf_T *buf;</a>
<a name="ln6474">    Callback interrupt_callback = { .type = kCallbackNone };</a>
<a name="ln6475"> </a>
<a name="ln6476">    if (check_secure()) {</a>
<a name="ln6477">      return;</a>
<a name="ln6478">    }</a>
<a name="ln6479">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln6480">    if (buf == NULL) {</a>
<a name="ln6481">      return;</a>
<a name="ln6482">    }</a>
<a name="ln6483"> </a>
<a name="ln6484">    if (argvars[1].v_type != VAR_STRING || *argvars[1].vval.v_string != NUL) {</a>
<a name="ln6485">      if (!callback_from_typval(&amp;interrupt_callback, &amp;argvars[1])) {</a>
<a name="ln6486">        return;</a>
<a name="ln6487">      }</a>
<a name="ln6488">    }</a>
<a name="ln6489"> </a>
<a name="ln6490">    callback_free(&amp;buf-&gt;b_prompt_interrupt);</a>
<a name="ln6491">    buf-&gt;b_prompt_interrupt= interrupt_callback;</a>
<a name="ln6492">}</a>
<a name="ln6493"> </a>
<a name="ln6494">/// &quot;prompt_getprompt({buffer})&quot; function</a>
<a name="ln6495">void f_prompt_getprompt(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6496">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6497">{</a>
<a name="ln6498">  // return an empty string by default, e.g. it's not a prompt buffer</a>
<a name="ln6499">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6500">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln6501"> </a>
<a name="ln6502">  buf_T *const buf = tv_get_buf_from_arg(&amp;argvars[0]);</a>
<a name="ln6503">  if (buf == NULL) {</a>
<a name="ln6504">    return;</a>
<a name="ln6505">  }</a>
<a name="ln6506"> </a>
<a name="ln6507">  if (!bt_prompt(buf)) {</a>
<a name="ln6508">    return;</a>
<a name="ln6509">  }</a>
<a name="ln6510"> </a>
<a name="ln6511">  rettv-&gt;vval.v_string = vim_strsave(buf_prompt_text(buf));</a>
<a name="ln6512">}</a>
<a name="ln6513"> </a>
<a name="ln6514">// &quot;prompt_setprompt({buffer}, {text})&quot; function</a>
<a name="ln6515">static void f_prompt_setprompt(typval_T *argvars,</a>
<a name="ln6516">                               typval_T *rettv, FunPtr fptr)</a>
<a name="ln6517">{</a>
<a name="ln6518">    buf_T *buf;</a>
<a name="ln6519">    const char_u *text;</a>
<a name="ln6520"> </a>
<a name="ln6521">    if (check_secure()) {</a>
<a name="ln6522">      return;</a>
<a name="ln6523">    }</a>
<a name="ln6524">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln6525">    if (buf == NULL) {</a>
<a name="ln6526">      return;</a>
<a name="ln6527">    }</a>
<a name="ln6528"> </a>
<a name="ln6529">    text = (const char_u *)tv_get_string(&amp;argvars[1]);</a>
<a name="ln6530">    xfree(buf-&gt;b_prompt_text);</a>
<a name="ln6531">    buf-&gt;b_prompt_text = vim_strsave(text);</a>
<a name="ln6532">}</a>
<a name="ln6533"> </a>
<a name="ln6534">// &quot;pum_getpos()&quot; function</a>
<a name="ln6535">static void f_pum_getpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6536">{</a>
<a name="ln6537">  tv_dict_alloc_ret(rettv);</a>
<a name="ln6538">  pum_set_event_info(rettv-&gt;vval.v_dict);</a>
<a name="ln6539">}</a>
<a name="ln6540"> </a>
<a name="ln6541">/*</a>
<a name="ln6542"> * &quot;pumvisible()&quot; function</a>
<a name="ln6543"> */</a>
<a name="ln6544">static void f_pumvisible(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6545">{</a>
<a name="ln6546">  if (pum_visible())</a>
<a name="ln6547">    rettv-&gt;vval.v_number = 1;</a>
<a name="ln6548">}</a>
<a name="ln6549"> </a>
<a name="ln6550">/*</a>
<a name="ln6551"> * &quot;pyeval()&quot; function</a>
<a name="ln6552"> */</a>
<a name="ln6553">static void f_pyeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6554">{</a>
<a name="ln6555">  script_host_eval(&quot;python&quot;, argvars, rettv);</a>
<a name="ln6556">}</a>
<a name="ln6557"> </a>
<a name="ln6558">/*</a>
<a name="ln6559"> * &quot;py3eval()&quot; function</a>
<a name="ln6560"> */</a>
<a name="ln6561">static void f_py3eval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6562">{</a>
<a name="ln6563">  script_host_eval(&quot;python3&quot;, argvars, rettv);</a>
<a name="ln6564">}</a>
<a name="ln6565"> </a>
<a name="ln6566">// &quot;pyxeval()&quot; function</a>
<a name="ln6567">static void f_pyxeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6568">{</a>
<a name="ln6569">  init_pyxversion();</a>
<a name="ln6570">  if (p_pyx == 2) {</a>
<a name="ln6571">    f_pyeval(argvars, rettv, NULL);</a>
<a name="ln6572">  } else {</a>
<a name="ln6573">    f_py3eval(argvars, rettv, NULL);</a>
<a name="ln6574">  }</a>
<a name="ln6575">}</a>
<a name="ln6576"> </a>
<a name="ln6577">///</a>
<a name="ln6578">/// &quot;perleval()&quot; function</a>
<a name="ln6579">///</a>
<a name="ln6580">static void f_perleval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6581">{</a>
<a name="ln6582">  script_host_eval(&quot;perl&quot;, argvars, rettv);</a>
<a name="ln6583">}</a>
<a name="ln6584"> </a>
<a name="ln6585">// &quot;rubyeval()&quot; function</a>
<a name="ln6586">static void f_rubyeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6587">{</a>
<a name="ln6588">  script_host_eval(&quot;ruby&quot;, argvars, rettv);</a>
<a name="ln6589">}</a>
<a name="ln6590"> </a>
<a name="ln6591">/*</a>
<a name="ln6592"> * &quot;range()&quot; function</a>
<a name="ln6593"> */</a>
<a name="ln6594">static void f_range(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6595">{</a>
<a name="ln6596">  varnumber_T start;</a>
<a name="ln6597">  varnumber_T end;</a>
<a name="ln6598">  varnumber_T stride = 1;</a>
<a name="ln6599">  varnumber_T i;</a>
<a name="ln6600">  bool error = false;</a>
<a name="ln6601"> </a>
<a name="ln6602">  start = tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln6603">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln6604">    end = start - 1;</a>
<a name="ln6605">    start = 0;</a>
<a name="ln6606">  } else {</a>
<a name="ln6607">    end = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln6608">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6609">      stride = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln6610">    }</a>
<a name="ln6611">  }</a>
<a name="ln6612"> </a>
<a name="ln6613">  if (error) {</a>
<a name="ln6614">    return;  // Type error; errmsg already given.</a>
<a name="ln6615">  }</a>
<a name="ln6616">  if (stride == 0) {</a>
<a name="ln6617">    EMSG(_(&quot;E726: Stride is zero&quot;));</a>
<a name="ln6618">  } else if (stride &gt; 0 ? end + 1 &lt; start : end - 1 &gt; start) {</a>
<a name="ln6619">    EMSG(_(&quot;E727: Start past end&quot;));</a>
<a name="ln6620">  } else {</a>
<a name="ln6621">    tv_list_alloc_ret(rettv, (end - start) / stride);</a>
<a name="ln6622">    for (i = start; stride &gt; 0 ? i &lt;= end : i &gt;= end; i += stride) {</a>
<a name="ln6623">      tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)i);</a>
<a name="ln6624">    }</a>
<a name="ln6625">  }</a>
<a name="ln6626">}</a>
<a name="ln6627"> </a>
<a name="ln6628">// Evaluate &quot;expr&quot; for readdir().</a>
<a name="ln6629">static varnumber_T readdir_checkitem(typval_T *expr, const char *name)</a>
<a name="ln6630">{</a>
<a name="ln6631">  typval_T save_val;</a>
<a name="ln6632">  typval_T rettv;</a>
<a name="ln6633">  typval_T argv[2];</a>
<a name="ln6634">  varnumber_T retval = 0;</a>
<a name="ln6635">  bool error = false;</a>
<a name="ln6636"> </a>
<a name="ln6637">  prepare_vimvar(VV_VAL, &amp;save_val);</a>
<a name="ln6638">  set_vim_var_string(VV_VAL, name, -1);</a>
<a name="ln6639">  argv[0].v_type = VAR_STRING;</a>
<a name="ln6640">  argv[0].vval.v_string = (char_u *)name;</a>
<a name="ln6641"> </a>
<a name="ln6642">  if (eval_expr_typval(expr, argv, 1, &amp;rettv) == FAIL) {</a>
<a name="ln6643">    goto theend;</a>
<a name="ln6644">  }</a>
<a name="ln6645"> </a>
<a name="ln6646">  retval = tv_get_number_chk(&amp;rettv, &amp;error);</a>
<a name="ln6647">  if (error) {</a>
<a name="ln6648">    retval = -1;</a>
<a name="ln6649">  }</a>
<a name="ln6650"> </a>
<a name="ln6651">  tv_clear(&amp;rettv);</a>
<a name="ln6652"> </a>
<a name="ln6653">theend:</a>
<a name="ln6654">  set_vim_var_string(VV_VAL, NULL, 0);</a>
<a name="ln6655">  restore_vimvar(VV_VAL, &amp;save_val);</a>
<a name="ln6656">  return retval;</a>
<a name="ln6657">}</a>
<a name="ln6658"> </a>
<a name="ln6659">// &quot;readdir()&quot; function</a>
<a name="ln6660">static void f_readdir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6661">{</a>
<a name="ln6662">  typval_T *expr;</a>
<a name="ln6663">  const char *path;</a>
<a name="ln6664">  garray_T ga;</a>
<a name="ln6665">  Directory dir;</a>
<a name="ln6666"> </a>
<a name="ln6667">  tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln6668">  path = tv_get_string(&amp;argvars[0]);</a>
<a name="ln6669">  expr = &amp;argvars[1];</a>
<a name="ln6670">  ga_init(&amp;ga, (int)sizeof(char *), 20);</a>
<a name="ln6671"> </a>
<a name="ln6672">  if (!os_scandir(&amp;dir, path)) {</a>
<a name="ln6673">    smsg(_(e_notopen), path);</a>
<a name="ln6674">  } else {</a>
<a name="ln6675">    for (;;) {</a>
<a name="ln6676">      bool ignore;</a>
<a name="ln6677"> </a>
<a name="ln6678">      path = os_scandir_next(&amp;dir);</a>
<a name="ln6679">      if (path == NULL) {</a>
<a name="ln6680">        break;</a>
<a name="ln6681">      }</a>
<a name="ln6682"> </a>
<a name="ln6683">      ignore = (path[0] == '.'</a>
<a name="ln6684">                &amp;&amp; (path[1] == NUL || (path[1] == '.' &amp;&amp; path[2] == NUL)));</a>
<a name="ln6685">      if (!ignore &amp;&amp; expr-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln6686">        varnumber_T r = readdir_checkitem(expr, path);</a>
<a name="ln6687"> </a>
<a name="ln6688">        if (r &lt; 0) {</a>
<a name="ln6689">          break;</a>
<a name="ln6690">        }</a>
<a name="ln6691">        if (r == 0) {</a>
<a name="ln6692">          ignore = true;</a>
<a name="ln6693">        }</a>
<a name="ln6694">      }</a>
<a name="ln6695"> </a>
<a name="ln6696">      if (!ignore) {</a>
<a name="ln6697">        ga_grow(&amp;ga, 1);</a>
<a name="ln6698">        ((char **)ga.ga_data)[ga.ga_len++] = xstrdup(path);</a>
<a name="ln6699">      }</a>
<a name="ln6700">    }</a>
<a name="ln6701"> </a>
<a name="ln6702">    os_closedir(&amp;dir);</a>
<a name="ln6703">  }</a>
<a name="ln6704"> </a>
<a name="ln6705">  if (rettv-&gt;vval.v_list != NULL &amp;&amp; ga.ga_len &gt; 0) {</a>
<a name="ln6706">    sort_strings((char_u **)ga.ga_data, ga.ga_len);</a>
<a name="ln6707">    for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln6708">      path = ((const char **)ga.ga_data)[i];</a>
<a name="ln6709">      tv_list_append_string(rettv-&gt;vval.v_list, path, -1);</a>
<a name="ln6710">    }</a>
<a name="ln6711">  }</a>
<a name="ln6712">  ga_clear_strings(&amp;ga);</a>
<a name="ln6713">}</a>
<a name="ln6714"> </a>
<a name="ln6715">/*</a>
<a name="ln6716"> * &quot;readfile()&quot; function</a>
<a name="ln6717"> */</a>
<a name="ln6718">static void f_readfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6719">{</a>
<a name="ln6720">  bool binary = false;</a>
<a name="ln6721">  FILE        *fd;</a>
<a name="ln6722">  char_u buf[(IOSIZE/256) * 256];       // rounded to avoid odd + 1</a>
<a name="ln6723">  int io_size = sizeof(buf);</a>
<a name="ln6724">  int readlen;                          // size of last fread()</a>
<a name="ln6725">  char_u      *prev    = NULL;          // previously read bytes, if any</a>
<a name="ln6726">  long prevlen  = 0;                    // length of data in prev</a>
<a name="ln6727">  long prevsize = 0;                    // size of prev buffer</a>
<a name="ln6728">  long maxline  = MAXLNUM;</a>
<a name="ln6729"> </a>
<a name="ln6730">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln6731">    if (strcmp(tv_get_string(&amp;argvars[1]), &quot;b&quot;) == 0) {</a>
<a name="ln6732">      binary = true;</a>
<a name="ln6733">    }</a>
<a name="ln6734">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6735">      maxline = tv_get_number(&amp;argvars[2]);</a>
<a name="ln6736">    }</a>
<a name="ln6737">  }</a>
<a name="ln6738"> </a>
<a name="ln6739">  list_T *const l = tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln6740"> </a>
<a name="ln6741">  // Always open the file in binary mode, library functions have a mind of</a>
<a name="ln6742">  // their own about CR-LF conversion.</a>
<a name="ln6743">  const char *const fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln6744">  if (*fname == NUL || (fd = os_fopen(fname, READBIN)) == NULL) {</a>
<a name="ln6745">    EMSG2(_(e_notopen), *fname == NUL ? _(&quot;&lt;empty&gt;&quot;) : fname);</a>
<a name="ln6746">    return;</a>
<a name="ln6747">  }</a>
<a name="ln6748"> </a>
<a name="ln6749">  while (maxline &lt; 0 || tv_list_len(l) &lt; maxline) {</a>
<a name="ln6750">    readlen = (int)fread(buf, 1, io_size, fd);</a>
<a name="ln6751"> </a>
<a name="ln6752">    // This for loop processes what was read, but is also entered at end</a>
<a name="ln6753">    // of file so that either:</a>
<a name="ln6754">    // - an incomplete line gets written</a>
<a name="ln6755">    // - a &quot;binary&quot; file gets an empty line at the end if it ends in a</a>
<a name="ln6756">    //   newline.</a>
<a name="ln6757">    char_u *p;  // Position in buf.</a>
<a name="ln6758">    char_u *start;  // Start of current line.</a>
<a name="ln6759">    for (p = buf, start = buf;</a>
<a name="ln6760">         p &lt; buf + readlen || (readlen &lt;= 0 &amp;&amp; (prevlen &gt; 0 || binary));</a>
<a name="ln6761">         p++) {</a>
<a name="ln6762">      if (*p == '\n' || readlen &lt;= 0) {</a>
<a name="ln6763">        char_u      *s  = NULL;</a>
<a name="ln6764">        size_t len = p - start;</a>
<a name="ln6765"> </a>
<a name="ln6766">        // Finished a line.  Remove CRs before NL.</a>
<a name="ln6767">        if (readlen &gt; 0 &amp;&amp; !binary) {</a>
<a name="ln6768">          while (len &gt; 0 &amp;&amp; start[len - 1] == '\r') {</a>
<a name="ln6769">            len--;</a>
<a name="ln6770">          }</a>
<a name="ln6771">          // removal may cross back to the &quot;prev&quot; string</a>
<a name="ln6772">          if (len == 0) {</a>
<a name="ln6773">            while (prevlen &gt; 0 &amp;&amp; prev[prevlen - 1] == '\r') {</a>
<a name="ln6774">              prevlen--;</a>
<a name="ln6775">            }</a>
<a name="ln6776">          }</a>
<a name="ln6777">        }</a>
<a name="ln6778">        if (prevlen == 0) {</a>
<a name="ln6779">          assert(len &lt; INT_MAX);</a>
<a name="ln6780">          s = vim_strnsave(start, len);</a>
<a name="ln6781">        } else {</a>
<a name="ln6782">          /* Change &quot;prev&quot; buffer to be the right size.  This way</a>
<a name="ln6783">           * the bytes are only copied once, and very long lines are</a>
<a name="ln6784">           * allocated only once.  */</a>
<a name="ln6785">          s = xrealloc(prev, prevlen + len + 1);</a>
<a name="ln6786">          memcpy(s + prevlen, start, len);</a>
<a name="ln6787">          s[prevlen + len] = NUL;</a>
<a name="ln6788">          prev = NULL;             // the list will own the string</a>
<a name="ln6789">          prevlen = prevsize = 0;</a>
<a name="ln6790">        }</a>
<a name="ln6791"> </a>
<a name="ln6792">        tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln6793">          .v_type = VAR_STRING,</a>
<a name="ln6794">          .v_lock = VAR_UNLOCKED,</a>
<a name="ln6795">          .vval.v_string = s,</a>
<a name="ln6796">        });</a>
<a name="ln6797"> </a>
<a name="ln6798">        start = p + 1;  // Step over newline.</a>
<a name="ln6799">        if (maxline &lt; 0) {</a>
<a name="ln6800">          if (tv_list_len(l) &gt; -maxline) {</a>
<a name="ln6801">            assert(tv_list_len(l) == 1 + (-maxline));</a>
<a name="ln6802">            tv_list_item_remove(l, tv_list_first(l));</a>
<a name="ln6803">          }</a>
<a name="ln6804">        } else if (tv_list_len(l) &gt;= maxline) {</a>
<a name="ln6805">          assert(tv_list_len(l) == maxline);</a>
<a name="ln6806">          break;</a>
<a name="ln6807">        }</a>
<a name="ln6808">        if (readlen &lt;= 0) {</a>
<a name="ln6809">          break;</a>
<a name="ln6810">        }</a>
<a name="ln6811">      } else if (*p == NUL) {</a>
<a name="ln6812">        *p = '\n';</a>
<a name="ln6813">      // Check for utf8 &quot;bom&quot;; U+FEFF is encoded as EF BB BF.  Do this</a>
<a name="ln6814">      // when finding the BF and check the previous two bytes.</a>
<a name="ln6815">      } else if (*p == 0xbf &amp;&amp; !binary) {</a>
<a name="ln6816">        // Find the two bytes before the 0xbf.  If p is at buf, or buf + 1,</a>
<a name="ln6817">        // these may be in the &quot;prev&quot; string.</a>
<a name="ln6818">        char_u back1 = p &gt;= buf + 1 ? p[-1]</a>
<a name="ln6819">                       : prevlen &gt;= 1 ? prev[prevlen - 1] : NUL;</a>
<a name="ln6820">        char_u back2 = p &gt;= buf + 2 ? p[-2]</a>
<a name="ln6821">                       : p == buf + 1 &amp;&amp; prevlen &gt;= 1 ? prev[prevlen - 1]</a>
<a name="ln6822">                       : prevlen &gt;= 2 ? prev[prevlen - 2] : NUL;</a>
<a name="ln6823"> </a>
<a name="ln6824">        if (back2 == 0xef &amp;&amp; back1 == 0xbb) {</a>
<a name="ln6825">          char_u *dest = p - 2;</a>
<a name="ln6826"> </a>
<a name="ln6827">          // Usually a BOM is at the beginning of a file, and so at</a>
<a name="ln6828">          // the beginning of a line; then we can just step over it.</a>
<a name="ln6829">          if (start == dest) {</a>
<a name="ln6830">            start = p + 1;</a>
<a name="ln6831">          } else {</a>
<a name="ln6832">            // have to shuffle buf to close gap</a>
<a name="ln6833">            int adjust_prevlen = 0;</a>
<a name="ln6834"> </a>
<a name="ln6835">            if (dest &lt; buf) {  // -V782</a>
<a name="ln6836">              adjust_prevlen = (int)(buf - dest);  // -V782</a>
<a name="ln6837">              // adjust_prevlen must be 1 or 2.</a>
<a name="ln6838">              dest = buf;</a>
<a name="ln6839">            }</a>
<a name="ln6840">            if (readlen &gt; p - buf + 1)</a>
<a name="ln6841">              memmove(dest, p + 1, readlen - (p - buf) - 1);</a>
<a name="ln6842">            readlen -= 3 - adjust_prevlen;</a>
<a name="ln6843">            prevlen -= adjust_prevlen;</a>
<a name="ln6844">            p = dest - 1;</a>
<a name="ln6845">          }</a>
<a name="ln6846">        }</a>
<a name="ln6847">      }</a>
<a name="ln6848">    }     // for</a>
<a name="ln6849"> </a>
<a name="ln6850">    if ((maxline &gt;= 0 &amp;&amp; tv_list_len(l) &gt;= maxline) || readlen &lt;= 0) {</a>
<a name="ln6851">      break;</a>
<a name="ln6852">    }</a>
<a name="ln6853">    if (start &lt; p) {</a>
<a name="ln6854">      // There's part of a line in buf, store it in &quot;prev&quot;.</a>
<a name="ln6855">      if (p - start + prevlen &gt;= prevsize) {</a>
<a name="ln6856">        /* A common use case is ordinary text files and &quot;prev&quot; gets a</a>
<a name="ln6857">         * fragment of a line, so the first allocation is made</a>
<a name="ln6858">         * small, to avoid repeatedly 'allocing' large and</a>
<a name="ln6859">         * 'reallocing' small. */</a>
<a name="ln6860">        if (prevsize == 0)</a>
<a name="ln6861">          prevsize = (long)(p - start);</a>
<a name="ln6862">        else {</a>
<a name="ln6863">          long grow50pc = (prevsize * 3) / 2;</a>
<a name="ln6864">          long growmin  = (long)((p - start) * 2 + prevlen);</a>
<a name="ln6865">          prevsize = grow50pc &gt; growmin ? grow50pc : growmin;</a>
<a name="ln6866">        }</a>
<a name="ln6867">        prev = xrealloc(prev, prevsize);</a>
<a name="ln6868">      }</a>
<a name="ln6869">      // Add the line part to end of &quot;prev&quot;.</a>
<a name="ln6870">      memmove(prev + prevlen, start, p - start);</a>
<a name="ln6871">      prevlen += (long)(p - start);</a>
<a name="ln6872">    }</a>
<a name="ln6873">  }   // while</a>
<a name="ln6874"> </a>
<a name="ln6875">  xfree(prev);</a>
<a name="ln6876">  fclose(fd);</a>
<a name="ln6877">}</a>
<a name="ln6878"> </a>
<a name="ln6879">// &quot;reg_executing()&quot; function</a>
<a name="ln6880">static void f_reg_executing(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6881">{</a>
<a name="ln6882">  return_register(reg_executing, rettv);</a>
<a name="ln6883">}</a>
<a name="ln6884"> </a>
<a name="ln6885">// &quot;reg_recording()&quot; function</a>
<a name="ln6886">static void f_reg_recording(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6887">{</a>
<a name="ln6888">  return_register(reg_recording, rettv);</a>
<a name="ln6889">}</a>
<a name="ln6890"> </a>
<a name="ln6891">/// list2proftime - convert a List to proftime_T</a>
<a name="ln6892">///</a>
<a name="ln6893">/// @param arg The input list, must be of type VAR_LIST and have</a>
<a name="ln6894">///            exactly 2 items</a>
<a name="ln6895">/// @param[out] tm The proftime_T representation of `arg`</a>
<a name="ln6896">/// @return OK In case of success, FAIL in case of error</a>
<a name="ln6897">static int list2proftime(typval_T *arg, proftime_T *tm) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6898">{</a>
<a name="ln6899">  if (arg-&gt;v_type != VAR_LIST || tv_list_len(arg-&gt;vval.v_list) != 2) {</a>
<a name="ln6900">    return FAIL;</a>
<a name="ln6901">  }</a>
<a name="ln6902"> </a>
<a name="ln6903">  bool error = false;</a>
<a name="ln6904">  varnumber_T n1 = tv_list_find_nr(arg-&gt;vval.v_list, 0L, &amp;error);</a>
<a name="ln6905">  varnumber_T n2 = tv_list_find_nr(arg-&gt;vval.v_list, 1L, &amp;error);</a>
<a name="ln6906">  if (error) {</a>
<a name="ln6907">    return FAIL;</a>
<a name="ln6908">  }</a>
<a name="ln6909"> </a>
<a name="ln6910">  // in f_reltime() we split up the 64-bit proftime_T into two 32-bit</a>
<a name="ln6911">  // values, now we combine them again.</a>
<a name="ln6912">  union {</a>
<a name="ln6913">    struct { int32_t low, high; } split;</a>
<a name="ln6914">    proftime_T prof;</a>
<a name="ln6915">  } u = { .split.high = n1, .split.low = n2 };</a>
<a name="ln6916"> </a>
<a name="ln6917">  *tm = u.prof;</a>
<a name="ln6918"> </a>
<a name="ln6919">  return OK;</a>
<a name="ln6920">}</a>
<a name="ln6921"> </a>
<a name="ln6922">/// f_reltime - return an item that represents a time value</a>
<a name="ln6923">///</a>
<a name="ln6924">/// @param[out] rettv Without an argument it returns the current time. With</a>
<a name="ln6925">///             one argument it returns the time passed since the argument.</a>
<a name="ln6926">///             With two arguments it returns the time passed between</a>
<a name="ln6927">///             the two arguments.</a>
<a name="ln6928">static void f_reltime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6929">{</a>
<a name="ln6930">  proftime_T res;</a>
<a name="ln6931">  proftime_T start;</a>
<a name="ln6932"> </a>
<a name="ln6933">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln6934">    // no arguments: get current time.</a>
<a name="ln6935">    res = profile_start();</a>
<a name="ln6936">  } else if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln6937">    if (list2proftime(&amp;argvars[0], &amp;res) == FAIL) {</a>
<a name="ln6938">      return;</a>
<a name="ln6939">    }</a>
<a name="ln6940">    res = profile_end(res);</a>
<a name="ln6941">  } else {</a>
<a name="ln6942">    // two arguments: compute the difference.</a>
<a name="ln6943">    if (list2proftime(&amp;argvars[0], &amp;start) == FAIL</a>
<a name="ln6944">        || list2proftime(&amp;argvars[1], &amp;res) == FAIL) {</a>
<a name="ln6945">      return;</a>
<a name="ln6946">    }</a>
<a name="ln6947">    res = profile_sub(res, start);</a>
<a name="ln6948">  }</a>
<a name="ln6949"> </a>
<a name="ln6950">  // we have to store the 64-bit proftime_T inside of a list of int's</a>
<a name="ln6951">  // (varnumber_T is defined as int). For all our supported platforms, int's</a>
<a name="ln6952">  // are at least 32-bits wide. So we'll use two 32-bit values to store it.</a>
<a name="ln6953">  union {</a>
<a name="ln6954">    struct { int32_t low, high; } split;</a>
<a name="ln6955">    proftime_T prof;</a>
<a name="ln6956">  } u = { .prof = res };</a>
<a name="ln6957"> </a>
<a name="ln6958">  // statically assert that the union type conv will provide the correct</a>
<a name="ln6959">  // results, if varnumber_T or proftime_T change, the union cast will need</a>
<a name="ln6960">  // to be revised.</a>
<a name="ln6961">  STATIC_ASSERT(sizeof(u.prof) == sizeof(u) &amp;&amp; sizeof(u.split) == sizeof(u),</a>
<a name="ln6962">      &quot;type punning will produce incorrect results on this platform&quot;);</a>
<a name="ln6963"> </a>
<a name="ln6964">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln6965">  tv_list_append_number(rettv-&gt;vval.v_list, u.split.high);</a>
<a name="ln6966">  tv_list_append_number(rettv-&gt;vval.v_list, u.split.low);</a>
<a name="ln6967">}</a>
<a name="ln6968"> </a>
<a name="ln6969">/// &quot;reltimestr()&quot; function</a>
<a name="ln6970">static void f_reltimestr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6971">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6972">{</a>
<a name="ln6973">  proftime_T tm;</a>
<a name="ln6974"> </a>
<a name="ln6975">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6976">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln6977">  if (list2proftime(&amp;argvars[0], &amp;tm) == OK) {</a>
<a name="ln6978">    rettv-&gt;vval.v_string = (char_u *)xstrdup(profile_msg(tm));</a>
<a name="ln6979">  }</a>
<a name="ln6980">}</a>
<a name="ln6981"> </a>
<a name="ln6982">/*</a>
<a name="ln6983"> * &quot;remove()&quot; function</a>
<a name="ln6984"> */</a>
<a name="ln6985">static void f_remove(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6986">{</a>
<a name="ln6987">  list_T      *l;</a>
<a name="ln6988">  listitem_T  *item, *item2;</a>
<a name="ln6989">  listitem_T  *li;</a>
<a name="ln6990">  long idx;</a>
<a name="ln6991">  long end;</a>
<a name="ln6992">  dict_T      *d;</a>
<a name="ln6993">  dictitem_T  *di;</a>
<a name="ln6994">  const char *const arg_errmsg = N_(&quot;remove() argument&quot;);</a>
<a name="ln6995"> </a>
<a name="ln6996">  if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln6997">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6998">      EMSG2(_(e_toomanyarg), &quot;remove()&quot;);</a>
<a name="ln6999">    } else if ((d = argvars[0].vval.v_dict) != NULL</a>
<a name="ln7000">               &amp;&amp; !tv_check_lock(d-&gt;dv_lock, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln7001">      const char *key = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln7002">      if (key != NULL) {</a>
<a name="ln7003">        di = tv_dict_find(d, key, -1);</a>
<a name="ln7004">        if (di == NULL) {</a>
<a name="ln7005">          EMSG2(_(e_dictkey), key);</a>
<a name="ln7006">        } else if (!var_check_fixed(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE)</a>
<a name="ln7007">                   &amp;&amp; !var_check_ro(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln7008">          *rettv = di-&gt;di_tv;</a>
<a name="ln7009">          di-&gt;di_tv = TV_INITIAL_VALUE;</a>
<a name="ln7010">          tv_dict_item_remove(d, di);</a>
<a name="ln7011">          if (tv_dict_is_watched(d)) {</a>
<a name="ln7012">            tv_dict_watcher_notify(d, key, NULL, rettv);</a>
<a name="ln7013">          }</a>
<a name="ln7014">        }</a>
<a name="ln7015">      }</a>
<a name="ln7016">    }</a>
<a name="ln7017">  } else if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln7018">    EMSG2(_(e_listdictarg), &quot;remove()&quot;);</a>
<a name="ln7019">  } else if (!tv_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),</a>
<a name="ln7020">                            arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln7021">    bool error = false;</a>
<a name="ln7022"> </a>
<a name="ln7023">    idx = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln7024">    if (error) {</a>
<a name="ln7025">      // Type error: do nothing, errmsg already given.</a>
<a name="ln7026">    } else if ((item = tv_list_find(l, idx)) == NULL) {</a>
<a name="ln7027">      EMSGN(_(e_listidx), idx);</a>
<a name="ln7028">    } else {</a>
<a name="ln7029">      if (argvars[2].v_type == VAR_UNKNOWN) {</a>
<a name="ln7030">        // Remove one item, return its value.</a>
<a name="ln7031">        tv_list_drop_items(l, item, item);</a>
<a name="ln7032">        *rettv = *TV_LIST_ITEM_TV(item);</a>
<a name="ln7033">        xfree(item);</a>
<a name="ln7034">      } else {</a>
<a name="ln7035">        // Remove range of items, return list with values.</a>
<a name="ln7036">        end = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln7037">        if (error) {</a>
<a name="ln7038">          // Type error: do nothing.</a>
<a name="ln7039">        } else if ((item2 = tv_list_find(l, end)) == NULL) {</a>
<a name="ln7040">          EMSGN(_(e_listidx), end);</a>
<a name="ln7041">        } else {</a>
<a name="ln7042">          int cnt = 0;</a>
<a name="ln7043"> </a>
<a name="ln7044">          for (li = item; li != NULL; li = TV_LIST_ITEM_NEXT(l, li)) {</a>
<a name="ln7045">            cnt++;</a>
<a name="ln7046">            if (li == item2) {</a>
<a name="ln7047">              break;</a>
<a name="ln7048">            }</a>
<a name="ln7049">          }</a>
<a name="ln7050">          if (li == NULL) {  // Didn't find &quot;item2&quot; after &quot;item&quot;.</a>
<a name="ln7051">            EMSG(_(e_invrange));</a>
<a name="ln7052">          } else {</a>
<a name="ln7053">            tv_list_move_items(l, item, item2, tv_list_alloc_ret(rettv, cnt),</a>
<a name="ln7054">                               cnt);</a>
<a name="ln7055">          }</a>
<a name="ln7056">        }</a>
<a name="ln7057">      }</a>
<a name="ln7058">    }</a>
<a name="ln7059">  }</a>
<a name="ln7060">}</a>
<a name="ln7061"> </a>
<a name="ln7062">/*</a>
<a name="ln7063"> * &quot;rename({from}, {to})&quot; function</a>
<a name="ln7064"> */</a>
<a name="ln7065">static void f_rename(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7066">{</a>
<a name="ln7067">  if (check_secure()) {</a>
<a name="ln7068">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln7069">  } else {</a>
<a name="ln7070">    char buf[NUMBUFLEN];</a>
<a name="ln7071">    rettv-&gt;vval.v_number = vim_rename(</a>
<a name="ln7072">        (const char_u *)tv_get_string(&amp;argvars[0]),</a>
<a name="ln7073">        (const char_u *)tv_get_string_buf(&amp;argvars[1], buf));</a>
<a name="ln7074">  }</a>
<a name="ln7075">}</a>
<a name="ln7076"> </a>
<a name="ln7077">/*</a>
<a name="ln7078"> * &quot;repeat()&quot; function</a>
<a name="ln7079"> */</a>
<a name="ln7080">static void f_repeat(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7081">{</a>
<a name="ln7082">  varnumber_T n = tv_get_number(&amp;argvars[1]);</a>
<a name="ln7083">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln7084">    tv_list_alloc_ret(rettv, (n &gt; 0) * n * tv_list_len(argvars[0].vval.v_list));</a>
<a name="ln7085">    while (n-- &gt; 0) {</a>
<a name="ln7086">      tv_list_extend(rettv-&gt;vval.v_list, argvars[0].vval.v_list, NULL);</a>
<a name="ln7087">    }</a>
<a name="ln7088">  } else {</a>
<a name="ln7089">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln7090">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln7091">    if (n &lt;= 0) {</a>
<a name="ln7092">      return;</a>
<a name="ln7093">    }</a>
<a name="ln7094"> </a>
<a name="ln7095">    const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln7096"> </a>
<a name="ln7097">    const size_t slen = strlen(p);</a>
<a name="ln7098">    if (slen == 0) {</a>
<a name="ln7099">      return;</a>
<a name="ln7100">    }</a>
<a name="ln7101">    const size_t len = slen * n;</a>
<a name="ln7102">    // Detect overflow.</a>
<a name="ln7103">    if (len / n != slen) {</a>
<a name="ln7104">      return;</a>
<a name="ln7105">    }</a>
<a name="ln7106"> </a>
<a name="ln7107">    char *const r = xmallocz(len);</a>
<a name="ln7108">    for (varnumber_T i = 0; i &lt; n; i++) {</a>
<a name="ln7109">      memmove(r + i * slen, p, slen);</a>
<a name="ln7110">    }</a>
<a name="ln7111"> </a>
<a name="ln7112">    rettv-&gt;vval.v_string = (char_u *)r;</a>
<a name="ln7113">  }</a>
<a name="ln7114">}</a>
<a name="ln7115"> </a>
<a name="ln7116">/*</a>
<a name="ln7117"> * &quot;resolve()&quot; function</a>
<a name="ln7118"> */</a>
<a name="ln7119">static void f_resolve(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7120">{</a>
<a name="ln7121">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln7122">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln7123">#ifdef WIN32</a>
<a name="ln7124">  char *v = os_resolve_shortcut(fname);</a>
<a name="ln7125">  if (v == NULL) {</a>
<a name="ln7126">    if (os_is_reparse_point_include(fname)) {</a>
<a name="ln7127">      v = os_realpath(fname, v);</a>
<a name="ln7128">    }</a>
<a name="ln7129">  }</a>
<a name="ln7130">  rettv-&gt;vval.v_string = (char_u *)(v == NULL ? xstrdup(fname) : v);</a>
<a name="ln7131">#else</a>
<a name="ln7132"># ifdef HAVE_READLINK</a>
<a name="ln7133">  {</a>
<a name="ln7134">    bool is_relative_to_current = false;</a>
<a name="ln7135">    bool has_trailing_pathsep = false;</a>
<a name="ln7136">    int limit = 100;</a>
<a name="ln7137"> </a>
<a name="ln7138">    char *p = xstrdup(fname);</a>
<a name="ln7139"> </a>
<a name="ln7140">    if (p[0] == '.' &amp;&amp; (vim_ispathsep(p[1])</a>
<a name="ln7141">                        || (p[1] == '.' &amp;&amp; (vim_ispathsep(p[2]))))) {</a>
<a name="ln7142">      is_relative_to_current = true;</a>
<a name="ln7143">    }</a>
<a name="ln7144"> </a>
<a name="ln7145">    ptrdiff_t len = (ptrdiff_t)strlen(p);</a>
<a name="ln7146">    if (len &gt; 1 &amp;&amp; after_pathsep(p, p + len)) {</a>
<a name="ln7147">      has_trailing_pathsep = true;</a>
<a name="ln7148">      p[len - 1] = NUL;  // The trailing slash breaks readlink().</a>
<a name="ln7149">    }</a>
<a name="ln7150"> </a>
<a name="ln7151">    char *q = (char *)path_next_component(p);</a>
<a name="ln7152">    char *remain = NULL;</a>
<a name="ln7153">    if (*q != NUL) {</a>
<a name="ln7154">      // Separate the first path component in &quot;p&quot;, and keep the</a>
<a name="ln7155">      // remainder (beginning with the path separator).</a>
<a name="ln7156">      remain = xstrdup(q - 1);</a>
<a name="ln7157">      q[-1] = NUL;</a>
<a name="ln7158">    }</a>
<a name="ln7159"> </a>
<a name="ln7160">    char *const buf = xmallocz(MAXPATHL);</a>
<a name="ln7161"> </a>
<a name="ln7162">    char *cpy;</a>
<a name="ln7163">    for (;; ) {</a>
<a name="ln7164">      for (;; ) {</a>
<a name="ln7165">        len = readlink(p, buf, MAXPATHL);</a>
<a name="ln7166">        if (len &lt;= 0) {</a>
<a name="ln7167">          break;</a>
<a name="ln7168">        }</a>
<a name="ln7169">        buf[len] = NUL;</a>
<a name="ln7170"> </a>
<a name="ln7171">        if (limit-- == 0) {</a>
<a name="ln7172">          xfree(p);</a>
<a name="ln7173">          xfree(remain);</a>
<a name="ln7174">          EMSG(_(&quot;E655: Too many symbolic links (cycle?)&quot;));</a>
<a name="ln7175">          rettv-&gt;vval.v_string = NULL;</a>
<a name="ln7176">          xfree(buf);</a>
<a name="ln7177">          return;</a>
<a name="ln7178">        }</a>
<a name="ln7179"> </a>
<a name="ln7180">        // Ensure that the result will have a trailing path separator</a>
<a name="ln7181">        // if the argument has one. */</a>
<a name="ln7182">        if (remain == NULL &amp;&amp; has_trailing_pathsep) {</a>
<a name="ln7183">          add_pathsep(buf);</a>
<a name="ln7184">        }</a>
<a name="ln7185"> </a>
<a name="ln7186">        // Separate the first path component in the link value and</a>
<a name="ln7187">        // concatenate the remainders. */</a>
<a name="ln7188">        q = (char *)path_next_component(vim_ispathsep(*buf) ? buf + 1 : buf);</a>
<a name="ln7189">        if (*q != NUL) {</a>
<a name="ln7190">          cpy = remain;</a>
<a name="ln7191">          remain = (remain</a>
<a name="ln7192">                    ? (char *)concat_str((char_u *)q - 1, (char_u *)remain)</a>
<a name="ln7193">                    : xstrdup(q - 1));</a>
<a name="ln7194">          xfree(cpy);</a>
<a name="ln7195">          q[-1] = NUL;</a>
<a name="ln7196">        }</a>
<a name="ln7197"> </a>
<a name="ln7198">        q = (char *)path_tail((char_u *)p);</a>
<a name="ln7199">        if (q &gt; p &amp;&amp; *q == NUL) {</a>
<a name="ln7200">          // Ignore trailing path separator.</a>
<a name="ln7201">          q[-1] = NUL;</a>
<a name="ln7202">          q = (char *)path_tail((char_u *)p);</a>
<a name="ln7203">        }</a>
<a name="ln7204">        if (q &gt; p &amp;&amp; !path_is_absolute((const char_u *)buf)) {</a>
<a name="ln7205">          // Symlink is relative to directory of argument. Replace the</a>
<a name="ln7206">          // symlink with the resolved name in the same directory.</a>
<a name="ln7207">          const size_t p_len = strlen(p);</a>
<a name="ln7208">          const size_t buf_len = strlen(buf);</a>
<a name="ln7209">          p = xrealloc(p, p_len + buf_len + 1);</a>
<a name="ln7210">          memcpy(path_tail((char_u *)p), buf, buf_len + 1);</a>
<a name="ln7211">        } else {</a>
<a name="ln7212">          xfree(p);</a>
<a name="ln7213">          p = xstrdup(buf);</a>
<a name="ln7214">        }</a>
<a name="ln7215">      }</a>
<a name="ln7216"> </a>
<a name="ln7217">      if (remain == NULL) {</a>
<a name="ln7218">        break;</a>
<a name="ln7219">      }</a>
<a name="ln7220"> </a>
<a name="ln7221">      // Append the first path component of &quot;remain&quot; to &quot;p&quot;.</a>
<a name="ln7222">      q = (char *)path_next_component(remain + 1);</a>
<a name="ln7223">      len = q - remain - (*q != NUL);</a>
<a name="ln7224">      const size_t p_len = strlen(p);</a>
<a name="ln7225">      cpy = xmallocz(p_len + len);</a>
<a name="ln7226">      memcpy(cpy, p, p_len + 1);</a>
<a name="ln7227">      xstrlcat(cpy + p_len, remain, len + 1);</a>
<a name="ln7228">      xfree(p);</a>
<a name="ln7229">      p = cpy;</a>
<a name="ln7230"> </a>
<a name="ln7231">      // Shorten &quot;remain&quot;.</a>
<a name="ln7232">      if (*q != NUL) {</a>
<a name="ln7233">        STRMOVE(remain, q - 1);</a>
<a name="ln7234">      } else {</a>
<a name="ln7235">        XFREE_CLEAR(remain);</a>
<a name="ln7236">      }</a>
<a name="ln7237">    }</a>
<a name="ln7238"> </a>
<a name="ln7239">    // If the result is a relative path name, make it explicitly relative to</a>
<a name="ln7240">    // the current directory if and only if the argument had this form.</a>
<a name="ln7241">    if (!vim_ispathsep(*p)) {</a>
<a name="ln7242">      if (is_relative_to_current</a>
<a name="ln7243">          &amp;&amp; *p != NUL</a>
<a name="ln7244">          &amp;&amp; !(p[0] == '.'</a>
<a name="ln7245">               &amp;&amp; (p[1] == NUL</a>
<a name="ln7246">                   || vim_ispathsep(p[1])</a>
<a name="ln7247">                   || (p[1] == '.'</a>
<a name="ln7248">                       &amp;&amp; (p[2] == NUL</a>
<a name="ln7249">                           || vim_ispathsep(p[2])))))) {</a>
<a name="ln7250">        // Prepend &quot;./&quot;.</a>
<a name="ln7251">        cpy = (char *)concat_str((const char_u *)&quot;./&quot;, (const char_u *)p);</a>
<a name="ln7252">        xfree(p);</a>
<a name="ln7253">        p = cpy;</a>
<a name="ln7254">      } else if (!is_relative_to_current) {</a>
<a name="ln7255">        // Strip leading &quot;./&quot;.</a>
<a name="ln7256">        q = p;</a>
<a name="ln7257">        while (q[0] == '.' &amp;&amp; vim_ispathsep(q[1])) {</a>
<a name="ln7258">          q += 2;</a>
<a name="ln7259">        }</a>
<a name="ln7260">        if (q &gt; p) {</a>
<a name="ln7261">          STRMOVE(p, p + 2);</a>
<a name="ln7262">        }</a>
<a name="ln7263">      }</a>
<a name="ln7264">    }</a>
<a name="ln7265"> </a>
<a name="ln7266">    // Ensure that the result will have no trailing path separator</a>
<a name="ln7267">    // if the argument had none.  But keep &quot;/&quot; or &quot;//&quot;.</a>
<a name="ln7268">    if (!has_trailing_pathsep) {</a>
<a name="ln7269">      q = p + strlen(p);</a>
<a name="ln7270">      if (after_pathsep(p, q)) {</a>
<a name="ln7271">        *path_tail_with_sep((char_u *)p) = NUL;</a>
<a name="ln7272">      }</a>
<a name="ln7273">    }</a>
<a name="ln7274"> </a>
<a name="ln7275">    rettv-&gt;vval.v_string = (char_u *)p;</a>
<a name="ln7276">    xfree(buf);</a>
<a name="ln7277">  }</a>
<a name="ln7278"># else</a>
<a name="ln7279">  char *v = os_realpath(fname, NULL);</a>
<a name="ln7280">  rettv-&gt;vval.v_string = (char_u *)(v == NULL ? xstrdup(fname) : v);</a>
<a name="ln7281"># endif</a>
<a name="ln7282">#endif</a>
<a name="ln7283"> </a>
<a name="ln7284">  simplify_filename(rettv-&gt;vval.v_string);</a>
<a name="ln7285">}</a>
<a name="ln7286"> </a>
<a name="ln7287">/*</a>
<a name="ln7288"> * &quot;reverse({list})&quot; function</a>
<a name="ln7289"> */</a>
<a name="ln7290">static void f_reverse(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7291">{</a>
<a name="ln7292">  list_T *l;</a>
<a name="ln7293">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln7294">    EMSG2(_(e_listarg), &quot;reverse()&quot;);</a>
<a name="ln7295">  } else if (!tv_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),</a>
<a name="ln7296">                            N_(&quot;reverse() argument&quot;), TV_TRANSLATE)) {</a>
<a name="ln7297">    tv_list_reverse(l);</a>
<a name="ln7298">    tv_list_set_ret(rettv, l);</a>
<a name="ln7299">  }</a>
<a name="ln7300">}</a>
<a name="ln7301"> </a>
<a name="ln7302">#define SP_NOMOVE       0x01        ///&lt; don't move cursor</a>
<a name="ln7303">#define SP_REPEAT       0x02        ///&lt; repeat to find outer pair</a>
<a name="ln7304">#define SP_RETCOUNT     0x04        ///&lt; return matchcount</a>
<a name="ln7305">#define SP_SETPCMARK    0x08        ///&lt; set previous context mark</a>
<a name="ln7306">#define SP_START        0x10        ///&lt; accept match at start position</a>
<a name="ln7307">#define SP_SUBPAT       0x20        ///&lt; return nr of matching sub-pattern</a>
<a name="ln7308">#define SP_END          0x40        ///&lt; leave cursor at end of match</a>
<a name="ln7309">#define SP_COLUMN       0x80        ///&lt; start at cursor column</a>
<a name="ln7310"> </a>
<a name="ln7311">/*</a>
<a name="ln7312"> * Get flags for a search function.</a>
<a name="ln7313"> * Possibly sets &quot;p_ws&quot;.</a>
<a name="ln7314"> * Returns BACKWARD, FORWARD or zero (for an error).</a>
<a name="ln7315"> */</a>
<a name="ln7316">static int get_search_arg(typval_T *varp, int *flagsp)</a>
<a name="ln7317">{</a>
<a name="ln7318">  int dir = FORWARD;</a>
<a name="ln7319">  int mask;</a>
<a name="ln7320"> </a>
<a name="ln7321">  if (varp-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln7322">    char nbuf[NUMBUFLEN];</a>
<a name="ln7323">    const char *flags = tv_get_string_buf_chk(varp, nbuf);</a>
<a name="ln7324">    if (flags == NULL) {</a>
<a name="ln7325">      return 0;  // Type error; errmsg already given.</a>
<a name="ln7326">    }</a>
<a name="ln7327">    while (*flags != NUL) {</a>
<a name="ln7328">      switch (*flags) {</a>
<a name="ln7329">        case 'b': dir = BACKWARD; break;</a>
<a name="ln7330">        case 'w': p_ws = true; break;</a>
<a name="ln7331">        case 'W': p_ws = false; break;</a>
<a name="ln7332">        default: {</a>
<a name="ln7333">          mask = 0;</a>
<a name="ln7334">          if (flagsp != NULL) {</a>
<a name="ln7335">            switch (*flags) {</a>
<a name="ln7336">              case 'c': mask = SP_START; break;</a>
<a name="ln7337">              case 'e': mask = SP_END; break;</a>
<a name="ln7338">              case 'm': mask = SP_RETCOUNT; break;</a>
<a name="ln7339">              case 'n': mask = SP_NOMOVE; break;</a>
<a name="ln7340">              case 'p': mask = SP_SUBPAT; break;</a>
<a name="ln7341">              case 'r': mask = SP_REPEAT; break;</a>
<a name="ln7342">              case 's': mask = SP_SETPCMARK; break;</a>
<a name="ln7343">              case 'z': mask = SP_COLUMN; break;</a>
<a name="ln7344">            }</a>
<a name="ln7345">          }</a>
<a name="ln7346">          if (mask == 0) {</a>
<a name="ln7347">            emsgf(_(e_invarg2), flags);</a>
<a name="ln7348">            dir = 0;</a>
<a name="ln7349">          } else {</a>
<a name="ln7350">            *flagsp |= mask;</a>
<a name="ln7351">          }</a>
<a name="ln7352">        }</a>
<a name="ln7353">      }</a>
<a name="ln7354">      if (dir == 0) {</a>
<a name="ln7355">        break;</a>
<a name="ln7356">      }</a>
<a name="ln7357">      flags++;</a>
<a name="ln7358">    }</a>
<a name="ln7359">  }</a>
<a name="ln7360">  return dir;</a>
<a name="ln7361">}</a>
<a name="ln7362"> </a>
<a name="ln7363">// Shared by search() and searchpos() functions.</a>
<a name="ln7364">static int search_cmn(typval_T *argvars, pos_T *match_pos, int *flagsp)</a>
<a name="ln7365">{</a>
<a name="ln7366">  int flags;</a>
<a name="ln7367">  pos_T pos;</a>
<a name="ln7368">  pos_T save_cursor;</a>
<a name="ln7369">  bool save_p_ws = p_ws;</a>
<a name="ln7370">  int dir;</a>
<a name="ln7371">  int retval = 0;               // default: FAIL</a>
<a name="ln7372">  long lnum_stop = 0;</a>
<a name="ln7373">  proftime_T tm;</a>
<a name="ln7374">  long time_limit = 0;</a>
<a name="ln7375">  int options = SEARCH_KEEP;</a>
<a name="ln7376">  int subpatnum;</a>
<a name="ln7377">  searchit_arg_T sia;</a>
<a name="ln7378"> </a>
<a name="ln7379">  const char *const pat = tv_get_string(&amp;argvars[0]);</a>
<a name="ln7380">  dir = get_search_arg(&amp;argvars[1], flagsp);  // May set p_ws.</a>
<a name="ln7381">  if (dir == 0) {</a>
<a name="ln7382">    goto theend;</a>
<a name="ln7383">  }</a>
<a name="ln7384">  flags = *flagsp;</a>
<a name="ln7385">  if (flags &amp; SP_START) {</a>
<a name="ln7386">    options |= SEARCH_START;</a>
<a name="ln7387">  }</a>
<a name="ln7388">  if (flags &amp; SP_END) {</a>
<a name="ln7389">    options |= SEARCH_END;</a>
<a name="ln7390">  }</a>
<a name="ln7391">  if (flags &amp; SP_COLUMN) {</a>
<a name="ln7392">    options |= SEARCH_COL;</a>
<a name="ln7393">  }</a>
<a name="ln7394"> </a>
<a name="ln7395">  // Optional arguments: line number to stop searching and timeout.</a>
<a name="ln7396">  if (argvars[1].v_type != VAR_UNKNOWN &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln7397">    lnum_stop = tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln7398">    if (lnum_stop &lt; 0) {</a>
<a name="ln7399">      goto theend;</a>
<a name="ln7400">    }</a>
<a name="ln7401">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln7402">      time_limit = tv_get_number_chk(&amp;argvars[3], NULL);</a>
<a name="ln7403">      if (time_limit &lt; 0) {</a>
<a name="ln7404">        goto theend;</a>
<a name="ln7405">      }</a>
<a name="ln7406">    }</a>
<a name="ln7407">  }</a>
<a name="ln7408"> </a>
<a name="ln7409">  // Set the time limit, if there is one.</a>
<a name="ln7410">  tm = profile_setlimit(time_limit);</a>
<a name="ln7411"> </a>
<a name="ln7412">  /*</a>
<a name="ln7413">   * This function does not accept SP_REPEAT and SP_RETCOUNT flags.</a>
<a name="ln7414">   * Check to make sure only those flags are set.</a>
<a name="ln7415">   * Also, Only the SP_NOMOVE or the SP_SETPCMARK flag can be set. Both</a>
<a name="ln7416">   * flags cannot be set. Check for that condition also.</a>
<a name="ln7417">   */</a>
<a name="ln7418">  if (((flags &amp; (SP_REPEAT | SP_RETCOUNT)) != 0)</a>
<a name="ln7419">      || ((flags &amp; SP_NOMOVE) &amp;&amp; (flags &amp; SP_SETPCMARK))) {</a>
<a name="ln7420">    EMSG2(_(e_invarg2), tv_get_string(&amp;argvars[1]));</a>
<a name="ln7421">    goto theend;</a>
<a name="ln7422">  }</a>
<a name="ln7423"> </a>
<a name="ln7424">  pos = save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln7425">  memset(&amp;sia, 0, sizeof(sia));</a>
<a name="ln7426">  sia.sa_stop_lnum = (linenr_T)lnum_stop;</a>
<a name="ln7427">  sia.sa_tm = &amp;tm;</a>
<a name="ln7428">  subpatnum = searchit(curwin, curbuf, &amp;pos, NULL, dir, (char_u *)pat, 1,</a>
<a name="ln7429">                       options, RE_SEARCH, &amp;sia);</a>
<a name="ln7430">  if (subpatnum != FAIL) {</a>
<a name="ln7431">    if (flags &amp; SP_SUBPAT)</a>
<a name="ln7432">      retval = subpatnum;</a>
<a name="ln7433">    else</a>
<a name="ln7434">      retval = pos.lnum;</a>
<a name="ln7435">    if (flags &amp; SP_SETPCMARK)</a>
<a name="ln7436">      setpcmark();</a>
<a name="ln7437">    curwin-&gt;w_cursor = pos;</a>
<a name="ln7438">    if (match_pos != NULL) {</a>
<a name="ln7439">      // Store the match cursor position</a>
<a name="ln7440">      match_pos-&gt;lnum = pos.lnum;</a>
<a name="ln7441">      match_pos-&gt;col = pos.col + 1;</a>
<a name="ln7442">    }</a>
<a name="ln7443">    // &quot;/$&quot; will put the cursor after the end of the line, may need to</a>
<a name="ln7444">    // correct that here</a>
<a name="ln7445">    check_cursor();</a>
<a name="ln7446">  }</a>
<a name="ln7447"> </a>
<a name="ln7448">  // If 'n' flag is used: restore cursor position.</a>
<a name="ln7449">  if (flags &amp; SP_NOMOVE) {</a>
<a name="ln7450">    curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln7451">  } else {</a>
<a name="ln7452">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln7453">  }</a>
<a name="ln7454">theend:</a>
<a name="ln7455">  p_ws = save_p_ws;</a>
<a name="ln7456"> </a>
<a name="ln7457">  return retval;</a>
<a name="ln7458">}</a>
<a name="ln7459"> </a>
<a name="ln7460">// &quot;rpcnotify()&quot; function</a>
<a name="ln7461">static void f_rpcnotify(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7462">{</a>
<a name="ln7463">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7464">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7465"> </a>
<a name="ln7466">  if (check_secure()) {</a>
<a name="ln7467">    return;</a>
<a name="ln7468">  }</a>
<a name="ln7469"> </a>
<a name="ln7470">  if (argvars[0].v_type != VAR_NUMBER || argvars[0].vval.v_number &lt; 0) {</a>
<a name="ln7471">    EMSG2(_(e_invarg2), &quot;Channel id must be a positive integer&quot;);</a>
<a name="ln7472">    return;</a>
<a name="ln7473">  }</a>
<a name="ln7474"> </a>
<a name="ln7475">  if (argvars[1].v_type != VAR_STRING) {</a>
<a name="ln7476">    EMSG2(_(e_invarg2), &quot;Event type must be a string&quot;);</a>
<a name="ln7477">    return;</a>
<a name="ln7478">  }</a>
<a name="ln7479"> </a>
<a name="ln7480">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln7481"> </a>
<a name="ln7482">  for (typval_T *tv = argvars + 2; tv-&gt;v_type != VAR_UNKNOWN; tv++) {</a>
<a name="ln7483">    ADD(args, vim_to_object(tv));</a>
<a name="ln7484">  }</a>
<a name="ln7485"> </a>
<a name="ln7486">  if (!rpc_send_event((uint64_t)argvars[0].vval.v_number,</a>
<a name="ln7487">                      tv_get_string(&amp;argvars[1]), args)) {</a>
<a name="ln7488">    EMSG2(_(e_invarg2), &quot;Channel doesn't exist&quot;);</a>
<a name="ln7489">    return;</a>
<a name="ln7490">  }</a>
<a name="ln7491"> </a>
<a name="ln7492">  rettv-&gt;vval.v_number = 1;</a>
<a name="ln7493">}</a>
<a name="ln7494"> </a>
<a name="ln7495">// &quot;rpcrequest()&quot; function</a>
<a name="ln7496">static void f_rpcrequest(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7497">{</a>
<a name="ln7498">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7499">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7500">  const int l_provider_call_nesting = provider_call_nesting;</a>
<a name="ln7501"> </a>
<a name="ln7502">  if (check_secure()) {</a>
<a name="ln7503">    return;</a>
<a name="ln7504">  }</a>
<a name="ln7505"> </a>
<a name="ln7506">  if (argvars[0].v_type != VAR_NUMBER || argvars[0].vval.v_number &lt;= 0) {</a>
<a name="ln7507">    EMSG2(_(e_invarg2), &quot;Channel id must be a positive integer&quot;);</a>
<a name="ln7508">    return;</a>
<a name="ln7509">  }</a>
<a name="ln7510"> </a>
<a name="ln7511">  if (argvars[1].v_type != VAR_STRING) {</a>
<a name="ln7512">    EMSG2(_(e_invarg2), &quot;Method name must be a string&quot;);</a>
<a name="ln7513">    return;</a>
<a name="ln7514">  }</a>
<a name="ln7515"> </a>
<a name="ln7516">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln7517"> </a>
<a name="ln7518">  for (typval_T *tv = argvars + 2; tv-&gt;v_type != VAR_UNKNOWN; tv++) {</a>
<a name="ln7519">    ADD(args, vim_to_object(tv));</a>
<a name="ln7520">  }</a>
<a name="ln7521"> </a>
<a name="ln7522">  sctx_T save_current_sctx;</a>
<a name="ln7523">  uint8_t *save_sourcing_name, *save_autocmd_fname, *save_autocmd_match;</a>
<a name="ln7524">  linenr_T save_sourcing_lnum;</a>
<a name="ln7525">  int save_autocmd_bufnr;</a>
<a name="ln7526">  funccal_entry_T funccal_entry;</a>
<a name="ln7527"> </a>
<a name="ln7528">  if (l_provider_call_nesting) {</a>
<a name="ln7529">    // If this is called from a provider function, restore the scope</a>
<a name="ln7530">    // information of the caller.</a>
<a name="ln7531">    save_current_sctx = current_sctx;</a>
<a name="ln7532">    save_sourcing_name = sourcing_name;</a>
<a name="ln7533">    save_sourcing_lnum = sourcing_lnum;</a>
<a name="ln7534">    save_autocmd_fname = autocmd_fname;</a>
<a name="ln7535">    save_autocmd_match = autocmd_match;</a>
<a name="ln7536">    save_autocmd_bufnr = autocmd_bufnr;</a>
<a name="ln7537">    save_funccal(&amp;funccal_entry);</a>
<a name="ln7538"> </a>
<a name="ln7539">    current_sctx = provider_caller_scope.script_ctx;</a>
<a name="ln7540">    sourcing_name = provider_caller_scope.sourcing_name;</a>
<a name="ln7541">    sourcing_lnum = provider_caller_scope.sourcing_lnum;</a>
<a name="ln7542">    autocmd_fname = provider_caller_scope.autocmd_fname;</a>
<a name="ln7543">    autocmd_match = provider_caller_scope.autocmd_match;</a>
<a name="ln7544">    autocmd_bufnr = provider_caller_scope.autocmd_bufnr;</a>
<a name="ln7545">    set_current_funccal((funccall_T *)(provider_caller_scope.funccalp));</a>
<a name="ln7546">  }</a>
<a name="ln7547"> </a>
<a name="ln7548"> </a>
<a name="ln7549">  Error err = ERROR_INIT;</a>
<a name="ln7550"> </a>
<a name="ln7551">  uint64_t chan_id = (uint64_t)argvars[0].vval.v_number;</a>
<a name="ln7552">  const char *method = tv_get_string(&amp;argvars[1]);</a>
<a name="ln7553"> </a>
<a name="ln7554">  Object result = rpc_send_call(chan_id, method, args, &amp;err);</a>
<a name="ln7555"> </a>
<a name="ln7556">  if (l_provider_call_nesting) {</a>
<a name="ln7557">    current_sctx = save_current_sctx;</a>
<a name="ln7558">    sourcing_name = save_sourcing_name;</a>
<a name="ln7559">    sourcing_lnum = save_sourcing_lnum;</a>
<a name="ln7560">    autocmd_fname = save_autocmd_fname;</a>
<a name="ln7561">    autocmd_match = save_autocmd_match;</a>
<a name="ln7562">    autocmd_bufnr = save_autocmd_bufnr;</a>
<a name="ln7563">    restore_funccal();</a>
<a name="ln7564">  }</a>
<a name="ln7565"> </a>
<a name="ln7566">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7567">    const char *name = NULL;</a>
<a name="ln7568">    Channel *chan = find_channel(chan_id);</a>
<a name="ln7569">    if (chan) {</a>
<a name="ln7570">      name = rpc_client_name(chan);</a>
<a name="ln7571">    }</a>
<a name="ln7572">    msg_ext_set_kind(&quot;rpc_error&quot;);</a>
<a name="ln7573">    if (name) {</a>
<a name="ln7574">      emsgf_multiline(&quot;Error invoking '%s' on channel %&quot;PRIu64&quot; (%s):\n%s&quot;,</a>
<a name="ln7575">                      method, chan_id, name, err.msg);</a>
<a name="ln7576">    } else {</a>
<a name="ln7577">      emsgf_multiline(&quot;Error invoking '%s' on channel %&quot;PRIu64&quot;:\n%s&quot;,</a>
<a name="ln7578">                      method, chan_id, err.msg);</a>
<a name="ln7579">    }</a>
<a name="ln7580"> </a>
<a name="ln7581">    goto end;</a>
<a name="ln7582">  }</a>
<a name="ln7583"> </a>
<a name="ln7584">  if (!object_to_vim(result, rettv, &amp;err)) {</a>
<a name="ln7585">    EMSG2(_(&quot;Error converting the call result: %s&quot;), err.msg);</a>
<a name="ln7586">  }</a>
<a name="ln7587"> </a>
<a name="ln7588">end:</a>
<a name="ln7589">  api_free_object(result);</a>
<a name="ln7590">  api_clear_error(&amp;err);</a>
<a name="ln7591">}</a>
<a name="ln7592"> </a>
<a name="ln7593">// &quot;rpcstart()&quot; function (DEPRECATED)</a>
<a name="ln7594">static void f_rpcstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7595">{</a>
<a name="ln7596">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7597">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7598"> </a>
<a name="ln7599">  if (check_secure()) {</a>
<a name="ln7600">    return;</a>
<a name="ln7601">  }</a>
<a name="ln7602"> </a>
<a name="ln7603">  if (argvars[0].v_type != VAR_STRING</a>
<a name="ln7604">      || (argvars[1].v_type != VAR_LIST &amp;&amp; argvars[1].v_type != VAR_UNKNOWN)) {</a>
<a name="ln7605">    // Wrong argument types</a>
<a name="ln7606">    EMSG(_(e_invarg));</a>
<a name="ln7607">    return;</a>
<a name="ln7608">  }</a>
<a name="ln7609"> </a>
<a name="ln7610">  list_T *args = NULL;</a>
<a name="ln7611">  int argsl = 0;</a>
<a name="ln7612">  if (argvars[1].v_type == VAR_LIST) {</a>
<a name="ln7613">    args = argvars[1].vval.v_list;</a>
<a name="ln7614">    argsl = tv_list_len(args);</a>
<a name="ln7615">    // Assert that all list items are strings</a>
<a name="ln7616">    int i = 0;</a>
<a name="ln7617">    TV_LIST_ITER_CONST(args, arg, {</a>
<a name="ln7618">      if (TV_LIST_ITEM_TV(arg)-&gt;v_type != VAR_STRING) {</a>
<a name="ln7619">        emsgf(_(&quot;E5010: List item %d of the second argument is not a string&quot;),</a>
<a name="ln7620">              i);</a>
<a name="ln7621">        return;</a>
<a name="ln7622">      }</a>
<a name="ln7623">      i++;</a>
<a name="ln7624">    });</a>
<a name="ln7625">  }</a>
<a name="ln7626"> </a>
<a name="ln7627">  if (argvars[0].vval.v_string == NULL || argvars[0].vval.v_string[0] == NUL) {</a>
<a name="ln7628">    EMSG(_(e_api_spawn_failed));</a>
<a name="ln7629">    return;</a>
<a name="ln7630">  }</a>
<a name="ln7631"> </a>
<a name="ln7632">  // Allocate extra memory for the argument vector and the NULL pointer</a>
<a name="ln7633">  int argvl = argsl + 2;</a>
<a name="ln7634">  char **argv = xmalloc(sizeof(char_u *) * argvl);</a>
<a name="ln7635"> </a>
<a name="ln7636">  // Copy program name</a>
<a name="ln7637">  argv[0] = xstrdup((char *)argvars[0].vval.v_string);</a>
<a name="ln7638"> </a>
<a name="ln7639">  int i = 1;</a>
<a name="ln7640">  // Copy arguments to the vector</a>
<a name="ln7641">  if (argsl &gt; 0) {</a>
<a name="ln7642">    TV_LIST_ITER_CONST(args, arg, {</a>
<a name="ln7643">      argv[i++] = xstrdup(tv_get_string(TV_LIST_ITEM_TV(arg)));</a>
<a name="ln7644">    });</a>
<a name="ln7645">  }</a>
<a name="ln7646"> </a>
<a name="ln7647">  // The last item of argv must be NULL</a>
<a name="ln7648">  argv[i] = NULL;</a>
<a name="ln7649"> </a>
<a name="ln7650">  Channel *chan = channel_job_start(argv, CALLBACK_READER_INIT,</a>
<a name="ln7651">                                    CALLBACK_READER_INIT, CALLBACK_NONE,</a>
<a name="ln7652">                                    false, true, false, false, NULL, 0, 0,</a>
<a name="ln7653">                                    NULL, &amp;rettv-&gt;vval.v_number);</a>
<a name="ln7654">  if (chan) {</a>
<a name="ln7655">    channel_create_event(chan, NULL);</a>
<a name="ln7656">  }</a>
<a name="ln7657">}</a>
<a name="ln7658"> </a>
<a name="ln7659">// &quot;rpcstop()&quot; function</a>
<a name="ln7660">static void f_rpcstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7661">{</a>
<a name="ln7662">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7663">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7664"> </a>
<a name="ln7665">  if (check_secure()) {</a>
<a name="ln7666">    return;</a>
<a name="ln7667">  }</a>
<a name="ln7668"> </a>
<a name="ln7669">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln7670">    // Wrong argument types</a>
<a name="ln7671">    EMSG(_(e_invarg));</a>
<a name="ln7672">    return;</a>
<a name="ln7673">  }</a>
<a name="ln7674"> </a>
<a name="ln7675">  // if called with a job, stop it, else closes the channel</a>
<a name="ln7676">  uint64_t id = argvars[0].vval.v_number;</a>
<a name="ln7677">  if (find_job(id, false)) {</a>
<a name="ln7678">    f_jobstop(argvars, rettv, NULL);</a>
<a name="ln7679">  } else {</a>
<a name="ln7680">    const char *error;</a>
<a name="ln7681">    rettv-&gt;vval.v_number = channel_close(argvars[0].vval.v_number,</a>
<a name="ln7682">                                         kChannelPartRpc, &amp;error);</a>
<a name="ln7683">    if (!rettv-&gt;vval.v_number) {</a>
<a name="ln7684">      EMSG(error);</a>
<a name="ln7685">    }</a>
<a name="ln7686">  }</a>
<a name="ln7687">}</a>
<a name="ln7688"> </a>
<a name="ln7689">/*</a>
<a name="ln7690"> * &quot;screenattr()&quot; function</a>
<a name="ln7691"> */</a>
<a name="ln7692">static void f_screenattr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7693">{</a>
<a name="ln7694">  int c;</a>
<a name="ln7695"> </a>
<a name="ln7696">  int row = (int)tv_get_number_chk(&amp;argvars[0], NULL) - 1;</a>
<a name="ln7697">  int col = (int)tv_get_number_chk(&amp;argvars[1], NULL) - 1;</a>
<a name="ln7698">  if (row &lt; 0 || row &gt;= default_grid.Rows</a>
<a name="ln7699">      || col &lt; 0 || col &gt;= default_grid.Columns) {</a>
<a name="ln7700">    c = -1;</a>
<a name="ln7701">  } else {</a>
<a name="ln7702">    ScreenGrid *grid = &amp;default_grid;</a>
<a name="ln7703">    screenchar_adjust_grid(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln7704">    c = grid-&gt;attrs[grid-&gt;line_offset[row] + col];</a>
<a name="ln7705">  }</a>
<a name="ln7706">  rettv-&gt;vval.v_number = c;</a>
<a name="ln7707">}</a>
<a name="ln7708"> </a>
<a name="ln7709">/*</a>
<a name="ln7710"> * &quot;screenchar()&quot; function</a>
<a name="ln7711"> */</a>
<a name="ln7712">static void f_screenchar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7713">{</a>
<a name="ln7714">  int c;</a>
<a name="ln7715"> </a>
<a name="ln7716">  int row = tv_get_number_chk(&amp;argvars[0], NULL) - 1;</a>
<a name="ln7717">  int col = tv_get_number_chk(&amp;argvars[1], NULL) - 1;</a>
<a name="ln7718">  if (row &lt; 0 || row &gt;= default_grid.Rows</a>
<a name="ln7719">      || col &lt; 0 || col &gt;= default_grid.Columns) {</a>
<a name="ln7720">    c = -1;</a>
<a name="ln7721">  } else {</a>
<a name="ln7722">    ScreenGrid *grid = &amp;default_grid;</a>
<a name="ln7723">    screenchar_adjust_grid(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln7724">    c = utf_ptr2char(grid-&gt;chars[grid-&gt;line_offset[row] + col]);</a>
<a name="ln7725">  }</a>
<a name="ln7726">  rettv-&gt;vval.v_number = c;</a>
<a name="ln7727">}</a>
<a name="ln7728"> </a>
<a name="ln7729">/*</a>
<a name="ln7730"> * &quot;screencol()&quot; function</a>
<a name="ln7731"> *</a>
<a name="ln7732"> * First column is 1 to be consistent with virtcol().</a>
<a name="ln7733"> */</a>
<a name="ln7734">static void f_screencol(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7735">{</a>
<a name="ln7736">  rettv-&gt;vval.v_number = ui_current_col() + 1;</a>
<a name="ln7737">}</a>
<a name="ln7738"> </a>
<a name="ln7739">/// &quot;screenpos({winid}, {lnum}, {col})&quot; function</a>
<a name="ln7740">static void f_screenpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7741">{</a>
<a name="ln7742">  pos_T pos;</a>
<a name="ln7743">  int row = 0;</a>
<a name="ln7744">  int scol = 0, ccol = 0, ecol = 0;</a>
<a name="ln7745"> </a>
<a name="ln7746">  tv_dict_alloc_ret(rettv);</a>
<a name="ln7747">  dict_T *dict = rettv-&gt;vval.v_dict;</a>
<a name="ln7748"> </a>
<a name="ln7749">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln7750">  if (wp == NULL) {</a>
<a name="ln7751">    return;</a>
<a name="ln7752">  }</a>
<a name="ln7753"> </a>
<a name="ln7754">  pos.lnum = tv_get_number(&amp;argvars[1]);</a>
<a name="ln7755">  pos.col = tv_get_number(&amp;argvars[2]) - 1;</a>
<a name="ln7756">  pos.coladd = 0;</a>
<a name="ln7757">  textpos2screenpos(wp, &amp;pos, &amp;row, &amp;scol, &amp;ccol, &amp;ecol, false);</a>
<a name="ln7758"> </a>
<a name="ln7759">  tv_dict_add_nr(dict, S_LEN(&quot;row&quot;), row);</a>
<a name="ln7760">  tv_dict_add_nr(dict, S_LEN(&quot;col&quot;), scol);</a>
<a name="ln7761">  tv_dict_add_nr(dict, S_LEN(&quot;curscol&quot;), ccol);</a>
<a name="ln7762">  tv_dict_add_nr(dict, S_LEN(&quot;endcol&quot;), ecol);</a>
<a name="ln7763">}</a>
<a name="ln7764"> </a>
<a name="ln7765">/*</a>
<a name="ln7766"> * &quot;screenrow()&quot; function</a>
<a name="ln7767"> */</a>
<a name="ln7768">static void f_screenrow(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7769">{</a>
<a name="ln7770">  rettv-&gt;vval.v_number = ui_current_row() + 1;</a>
<a name="ln7771">}</a>
<a name="ln7772"> </a>
<a name="ln7773">/*</a>
<a name="ln7774"> * &quot;search()&quot; function</a>
<a name="ln7775"> */</a>
<a name="ln7776">static void f_search(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7777">{</a>
<a name="ln7778">  int flags = 0;</a>
<a name="ln7779"> </a>
<a name="ln7780">  rettv-&gt;vval.v_number = search_cmn(argvars, NULL, &amp;flags);</a>
<a name="ln7781">}</a>
<a name="ln7782"> </a>
<a name="ln7783">/*</a>
<a name="ln7784"> * &quot;searchdecl()&quot; function</a>
<a name="ln7785"> */</a>
<a name="ln7786">static void f_searchdecl(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7787">{</a>
<a name="ln7788">  int locally = 1;</a>
<a name="ln7789">  int thisblock = 0;</a>
<a name="ln7790">  bool error = false;</a>
<a name="ln7791"> </a>
<a name="ln7792">  rettv-&gt;vval.v_number = 1;     // default: FAIL</a>
<a name="ln7793"> </a>
<a name="ln7794">  const char *const name = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln7795">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln7796">    locally = tv_get_number_chk(&amp;argvars[1], &amp;error) == 0;</a>
<a name="ln7797">    if (!error &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln7798">      thisblock = tv_get_number_chk(&amp;argvars[2], &amp;error) != 0;</a>
<a name="ln7799">    }</a>
<a name="ln7800">  }</a>
<a name="ln7801">  if (!error &amp;&amp; name != NULL) {</a>
<a name="ln7802">    rettv-&gt;vval.v_number = find_decl((char_u *)name, strlen(name), locally,</a>
<a name="ln7803">                                     thisblock, SEARCH_KEEP) == FAIL;</a>
<a name="ln7804">  }</a>
<a name="ln7805">}</a>
<a name="ln7806"> </a>
<a name="ln7807">/*</a>
<a name="ln7808"> * Used by searchpair() and searchpairpos()</a>
<a name="ln7809"> */</a>
<a name="ln7810">static int searchpair_cmn(typval_T *argvars, pos_T *match_pos)</a>
<a name="ln7811">{</a>
<a name="ln7812">  bool save_p_ws = p_ws;</a>
<a name="ln7813">  int dir;</a>
<a name="ln7814">  int flags = 0;</a>
<a name="ln7815">  int retval = 0;  // default: FAIL</a>
<a name="ln7816">  long lnum_stop = 0;</a>
<a name="ln7817">  long time_limit = 0;</a>
<a name="ln7818"> </a>
<a name="ln7819">  // Get the three pattern arguments: start, middle, end. Will result in an</a>
<a name="ln7820">  // error if not a valid argument.</a>
<a name="ln7821">  char nbuf1[NUMBUFLEN];</a>
<a name="ln7822">  char nbuf2[NUMBUFLEN];</a>
<a name="ln7823">  const char *spat = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln7824">  const char *mpat = tv_get_string_buf_chk(&amp;argvars[1], nbuf1);</a>
<a name="ln7825">  const char *epat = tv_get_string_buf_chk(&amp;argvars[2], nbuf2);</a>
<a name="ln7826">  if (spat == NULL || mpat == NULL || epat == NULL) {</a>
<a name="ln7827">    goto theend;  // Type error.</a>
<a name="ln7828">  }</a>
<a name="ln7829"> </a>
<a name="ln7830">  // Handle the optional fourth argument: flags.</a>
<a name="ln7831">  dir = get_search_arg(&amp;argvars[3], &amp;flags);   // may set p_ws.</a>
<a name="ln7832">  if (dir == 0) {</a>
<a name="ln7833">    goto theend;</a>
<a name="ln7834">  }</a>
<a name="ln7835"> </a>
<a name="ln7836">  // Don't accept SP_END or SP_SUBPAT.</a>
<a name="ln7837">  // Only one of the SP_NOMOVE or SP_SETPCMARK flags can be set.</a>
<a name="ln7838">  if ((flags &amp; (SP_END | SP_SUBPAT)) != 0</a>
<a name="ln7839">      || ((flags &amp; SP_NOMOVE) &amp;&amp; (flags &amp; SP_SETPCMARK))) {</a>
<a name="ln7840">    EMSG2(_(e_invarg2), tv_get_string(&amp;argvars[3]));</a>
<a name="ln7841">    goto theend;</a>
<a name="ln7842">  }</a>
<a name="ln7843"> </a>
<a name="ln7844">  // Using 'r' implies 'W', otherwise it doesn't work.</a>
<a name="ln7845">  if (flags &amp; SP_REPEAT) {</a>
<a name="ln7846">    p_ws = false;</a>
<a name="ln7847">  }</a>
<a name="ln7848"> </a>
<a name="ln7849">  // Optional fifth argument: skip expression.</a>
<a name="ln7850">  const typval_T *skip;</a>
<a name="ln7851">  if (argvars[3].v_type == VAR_UNKNOWN</a>
<a name="ln7852">      || argvars[4].v_type == VAR_UNKNOWN) {</a>
<a name="ln7853">    skip = NULL;</a>
<a name="ln7854">  } else {</a>
<a name="ln7855">    skip = &amp;argvars[4];</a>
<a name="ln7856">    if (skip-&gt;v_type != VAR_FUNC</a>
<a name="ln7857">        &amp;&amp; skip-&gt;v_type != VAR_PARTIAL</a>
<a name="ln7858">        &amp;&amp; skip-&gt;v_type != VAR_STRING) {</a>
<a name="ln7859">      emsgf(_(e_invarg2), tv_get_string(&amp;argvars[4]));</a>
<a name="ln7860">      goto theend;  // Type error.</a>
<a name="ln7861">    }</a>
<a name="ln7862">    if (argvars[5].v_type != VAR_UNKNOWN) {</a>
<a name="ln7863">      lnum_stop = tv_get_number_chk(&amp;argvars[5], NULL);</a>
<a name="ln7864">      if (lnum_stop &lt; 0) {</a>
<a name="ln7865">        emsgf(_(e_invarg2), tv_get_string(&amp;argvars[5]));</a>
<a name="ln7866">        goto theend;</a>
<a name="ln7867">      }</a>
<a name="ln7868">      if (argvars[6].v_type != VAR_UNKNOWN) {</a>
<a name="ln7869">        time_limit = tv_get_number_chk(&amp;argvars[6], NULL);</a>
<a name="ln7870">        if (time_limit &lt; 0) {</a>
<a name="ln7871">          emsgf(_(e_invarg2), tv_get_string(&amp;argvars[6]));</a>
<a name="ln7872">          goto theend;</a>
<a name="ln7873">        }</a>
<a name="ln7874">      }</a>
<a name="ln7875">    }</a>
<a name="ln7876">  }</a>
<a name="ln7877"> </a>
<a name="ln7878">  retval = do_searchpair(</a>
<a name="ln7879">      spat, mpat, epat, dir, skip,</a>
<a name="ln7880">      flags, match_pos, lnum_stop, time_limit);</a>
<a name="ln7881"> </a>
<a name="ln7882">theend:</a>
<a name="ln7883">  p_ws = save_p_ws;</a>
<a name="ln7884"> </a>
<a name="ln7885">  return retval;</a>
<a name="ln7886">}</a>
<a name="ln7887"> </a>
<a name="ln7888">/*</a>
<a name="ln7889"> * &quot;searchpair()&quot; function</a>
<a name="ln7890"> */</a>
<a name="ln7891">static void f_searchpair(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7892">{</a>
<a name="ln7893">  rettv-&gt;vval.v_number = searchpair_cmn(argvars, NULL);</a>
<a name="ln7894">}</a>
<a name="ln7895"> </a>
<a name="ln7896">/*</a>
<a name="ln7897"> * &quot;searchpairpos()&quot; function</a>
<a name="ln7898"> */</a>
<a name="ln7899">static void f_searchpairpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7900">{</a>
<a name="ln7901">  pos_T match_pos;</a>
<a name="ln7902">  int lnum = 0;</a>
<a name="ln7903">  int col = 0;</a>
<a name="ln7904"> </a>
<a name="ln7905">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln7906"> </a>
<a name="ln7907">  if (searchpair_cmn(argvars, &amp;match_pos) &gt; 0) {</a>
<a name="ln7908">    lnum = match_pos.lnum;</a>
<a name="ln7909">    col = match_pos.col;</a>
<a name="ln7910">  }</a>
<a name="ln7911"> </a>
<a name="ln7912">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)lnum);</a>
<a name="ln7913">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)col);</a>
<a name="ln7914">}</a>
<a name="ln7915"> </a>
<a name="ln7916">/*</a>
<a name="ln7917"> * Search for a start/middle/end thing.</a>
<a name="ln7918"> * Used by searchpair(), see its documentation for the details.</a>
<a name="ln7919"> * Returns 0 or -1 for no match,</a>
<a name="ln7920"> */</a>
<a name="ln7921">long</a>
<a name="ln7922">do_searchpair(</a>
<a name="ln7923">    const char *spat,      // start pattern</a>
<a name="ln7924">    const char *mpat,      // middle pattern</a>
<a name="ln7925">    const char *epat,      // end pattern</a>
<a name="ln7926">    int dir,               // BACKWARD or FORWARD</a>
<a name="ln7927">    const typval_T *skip,  // skip expression</a>
<a name="ln7928">    int flags,             // SP_SETPCMARK and other SP_ values</a>
<a name="ln7929">    pos_T *match_pos,</a>
<a name="ln7930">    linenr_T lnum_stop,    // stop at this line if not zero</a>
<a name="ln7931">    long time_limit        // stop after this many msec</a>
<a name="ln7932">)</a>
<a name="ln7933">  FUNC_ATTR_NONNULL_ARG(1, 2, 3)</a>
<a name="ln7934">{</a>
<a name="ln7935">  char_u      *save_cpo;</a>
<a name="ln7936">  char_u      *pat, *pat2 = NULL, *pat3 = NULL;</a>
<a name="ln7937">  long retval = 0;</a>
<a name="ln7938">  pos_T pos;</a>
<a name="ln7939">  pos_T firstpos;</a>
<a name="ln7940">  pos_T foundpos;</a>
<a name="ln7941">  pos_T save_cursor;</a>
<a name="ln7942">  pos_T save_pos;</a>
<a name="ln7943">  int n;</a>
<a name="ln7944">  int nest = 1;</a>
<a name="ln7945">  bool use_skip = false;</a>
<a name="ln7946">  int options = SEARCH_KEEP;</a>
<a name="ln7947">  proftime_T tm;</a>
<a name="ln7948"> </a>
<a name="ln7949">  // Make 'cpoptions' empty, the 'l' flag should not be used here.</a>
<a name="ln7950">  save_cpo = p_cpo;</a>
<a name="ln7951">  p_cpo = empty_option;</a>
<a name="ln7952"> </a>
<a name="ln7953">  // Set the time limit, if there is one.</a>
<a name="ln7954">  tm = profile_setlimit(time_limit);</a>
<a name="ln7955"> </a>
<a name="ln7956">  // Make two search patterns: start/end (pat2, for in nested pairs) and</a>
<a name="ln7957">  // start/middle/end (pat3, for the top pair).</a>
<a name="ln7958">  const size_t pat2_len = strlen(spat) + strlen(epat) + 17;</a>
<a name="ln7959">  pat2 = xmalloc(pat2_len);</a>
<a name="ln7960">  const size_t pat3_len = strlen(spat) + strlen(mpat) + strlen(epat) + 25;</a>
<a name="ln7961">  pat3 = xmalloc(pat3_len);</a>
<a name="ln7962">  snprintf((char *)pat2, pat2_len, &quot;\\m\\(%s\\m\\)\\|\\(%s\\m\\)&quot;, spat, epat);</a>
<a name="ln7963">  if (*mpat == NUL) {</a>
<a name="ln7964">    STRCPY(pat3, pat2);</a>
<a name="ln7965">  } else {</a>
<a name="ln7966">    snprintf((char *)pat3, pat3_len,</a>
<a name="ln7967">             &quot;\\m\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)&quot;, spat, epat, mpat);</a>
<a name="ln7968">  }</a>
<a name="ln7969">  if (flags &amp; SP_START) {</a>
<a name="ln7970">    options |= SEARCH_START;</a>
<a name="ln7971">  }</a>
<a name="ln7972"> </a>
<a name="ln7973">  if (skip != NULL) {</a>
<a name="ln7974">    // Empty string means to not use the skip expression.</a>
<a name="ln7975">    if (skip-&gt;v_type == VAR_STRING || skip-&gt;v_type == VAR_FUNC) {</a>
<a name="ln7976">      use_skip = skip-&gt;vval.v_string != NULL &amp;&amp; *skip-&gt;vval.v_string != NUL;</a>
<a name="ln7977">    }</a>
<a name="ln7978">  }</a>
<a name="ln7979"> </a>
<a name="ln7980">  save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln7981">  pos = curwin-&gt;w_cursor;</a>
<a name="ln7982">  clearpos(&amp;firstpos);</a>
<a name="ln7983">  clearpos(&amp;foundpos);</a>
<a name="ln7984">  pat = pat3;</a>
<a name="ln7985">  for (;; ) {</a>
<a name="ln7986">    searchit_arg_T sia;</a>
<a name="ln7987">    memset(&amp;sia, 0, sizeof(sia));</a>
<a name="ln7988">    sia.sa_stop_lnum = lnum_stop;</a>
<a name="ln7989">    sia.sa_tm = &amp;tm;</a>
<a name="ln7990"> </a>
<a name="ln7991">    n = searchit(curwin, curbuf, &amp;pos, NULL, dir, pat, 1L,</a>
<a name="ln7992">                 options, RE_SEARCH, &amp;sia);</a>
<a name="ln7993">    if (n == FAIL || (firstpos.lnum != 0 &amp;&amp; equalpos(pos, firstpos))) {</a>
<a name="ln7994">      // didn't find it or found the first match again: FAIL</a>
<a name="ln7995">      break;</a>
<a name="ln7996">    }</a>
<a name="ln7997"> </a>
<a name="ln7998">    if (firstpos.lnum == 0)</a>
<a name="ln7999">      firstpos = pos;</a>
<a name="ln8000">    if (equalpos(pos, foundpos)) {</a>
<a name="ln8001">      // Found the same position again.  Can happen with a pattern that</a>
<a name="ln8002">      // has &quot;\zs&quot; at the end and searching backwards.  Advance one</a>
<a name="ln8003">      // character and try again.</a>
<a name="ln8004">      if (dir == BACKWARD) {</a>
<a name="ln8005">        decl(&amp;pos);</a>
<a name="ln8006">      } else {</a>
<a name="ln8007">        incl(&amp;pos);</a>
<a name="ln8008">      }</a>
<a name="ln8009">    }</a>
<a name="ln8010">    foundpos = pos;</a>
<a name="ln8011"> </a>
<a name="ln8012">    // clear the start flag to avoid getting stuck here</a>
<a name="ln8013">    options &amp;= ~SEARCH_START;</a>
<a name="ln8014"> </a>
<a name="ln8015">    // If the skip pattern matches, ignore this match.</a>
<a name="ln8016">    if (use_skip) {</a>
<a name="ln8017">      save_pos = curwin-&gt;w_cursor;</a>
<a name="ln8018">      curwin-&gt;w_cursor = pos;</a>
<a name="ln8019">      bool err = false;</a>
<a name="ln8020">      const bool r = eval_expr_to_bool(skip, &amp;err);</a>
<a name="ln8021">      curwin-&gt;w_cursor = save_pos;</a>
<a name="ln8022">      if (err) {</a>
<a name="ln8023">        // Evaluating {skip} caused an error, break here.</a>
<a name="ln8024">        curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln8025">        retval = -1;</a>
<a name="ln8026">        break;</a>
<a name="ln8027">      }</a>
<a name="ln8028">      if (r)</a>
<a name="ln8029">        continue;</a>
<a name="ln8030">    }</a>
<a name="ln8031"> </a>
<a name="ln8032">    if ((dir == BACKWARD &amp;&amp; n == 3) || (dir == FORWARD &amp;&amp; n == 2)) {</a>
<a name="ln8033">      // Found end when searching backwards or start when searching</a>
<a name="ln8034">      // forward: nested pair.</a>
<a name="ln8035">      nest++;</a>
<a name="ln8036">      pat = pat2;               // nested, don't search for middle</a>
<a name="ln8037">    } else {</a>
<a name="ln8038">      // Found end when searching forward or start when searching</a>
<a name="ln8039">      // backward: end of (nested) pair; or found middle in outer pair.</a>
<a name="ln8040">      if (--nest == 1) {</a>
<a name="ln8041">        pat = pat3;             // outer level, search for middle</a>
<a name="ln8042">      }</a>
<a name="ln8043">    }</a>
<a name="ln8044"> </a>
<a name="ln8045">    if (nest == 0) {</a>
<a name="ln8046">      // Found the match: return matchcount or line number.</a>
<a name="ln8047">      if (flags &amp; SP_RETCOUNT) {</a>
<a name="ln8048">        retval++;</a>
<a name="ln8049">      } else {</a>
<a name="ln8050">        retval = pos.lnum;</a>
<a name="ln8051">      }</a>
<a name="ln8052">      if (flags &amp; SP_SETPCMARK) {</a>
<a name="ln8053">        setpcmark();</a>
<a name="ln8054">      }</a>
<a name="ln8055">      curwin-&gt;w_cursor = pos;</a>
<a name="ln8056">      if (!(flags &amp; SP_REPEAT))</a>
<a name="ln8057">        break;</a>
<a name="ln8058">      nest = 1;             // search for next unmatched</a>
<a name="ln8059">    }</a>
<a name="ln8060">  }</a>
<a name="ln8061"> </a>
<a name="ln8062">  if (match_pos != NULL) {</a>
<a name="ln8063">    // Store the match cursor position</a>
<a name="ln8064">    match_pos-&gt;lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln8065">    match_pos-&gt;col = curwin-&gt;w_cursor.col + 1;</a>
<a name="ln8066">  }</a>
<a name="ln8067"> </a>
<a name="ln8068">  // If 'n' flag is used or search failed: restore cursor position.</a>
<a name="ln8069">  if ((flags &amp; SP_NOMOVE) || retval == 0) {</a>
<a name="ln8070">    curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln8071">  }</a>
<a name="ln8072"> </a>
<a name="ln8073">  xfree(pat2);</a>
<a name="ln8074">  xfree(pat3);</a>
<a name="ln8075">  if (p_cpo == empty_option) {</a>
<a name="ln8076">    p_cpo = save_cpo;</a>
<a name="ln8077">  } else {</a>
<a name="ln8078">    // Darn, evaluating the {skip} expression changed the value.</a>
<a name="ln8079">    free_string_option(save_cpo);</a>
<a name="ln8080">  }</a>
<a name="ln8081"> </a>
<a name="ln8082">  return retval;</a>
<a name="ln8083">}</a>
<a name="ln8084"> </a>
<a name="ln8085">/*</a>
<a name="ln8086"> * &quot;searchpos()&quot; function</a>
<a name="ln8087"> */</a>
<a name="ln8088">static void f_searchpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8089">{</a>
<a name="ln8090">  pos_T match_pos;</a>
<a name="ln8091">  int flags = 0;</a>
<a name="ln8092"> </a>
<a name="ln8093">  const int n = search_cmn(argvars, &amp;match_pos, &amp;flags);</a>
<a name="ln8094"> </a>
<a name="ln8095">  tv_list_alloc_ret(rettv, 2 + (!!(flags &amp; SP_SUBPAT)));</a>
<a name="ln8096"> </a>
<a name="ln8097">  const int lnum = (n &gt; 0 ? match_pos.lnum : 0);</a>
<a name="ln8098">  const int col = (n &gt; 0 ? match_pos.col : 0);</a>
<a name="ln8099"> </a>
<a name="ln8100">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)lnum);</a>
<a name="ln8101">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)col);</a>
<a name="ln8102">  if (flags &amp; SP_SUBPAT) {</a>
<a name="ln8103">    tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)n);</a>
<a name="ln8104">  }</a>
<a name="ln8105">}</a>
<a name="ln8106"> </a>
<a name="ln8107">/// &quot;serverlist()&quot; function</a>
<a name="ln8108">static void f_serverlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8109">{</a>
<a name="ln8110">  size_t n;</a>
<a name="ln8111">  char **addrs = server_address_list(&amp;n);</a>
<a name="ln8112"> </a>
<a name="ln8113">  // Copy addrs into a linked list.</a>
<a name="ln8114">  list_T *const l = tv_list_alloc_ret(rettv, n);</a>
<a name="ln8115">  for (size_t i = 0; i &lt; n; i++) {</a>
<a name="ln8116">    tv_list_append_allocated_string(l, addrs[i]);</a>
<a name="ln8117">  }</a>
<a name="ln8118">  xfree(addrs);</a>
<a name="ln8119">}</a>
<a name="ln8120"> </a>
<a name="ln8121">/// &quot;serverstart()&quot; function</a>
<a name="ln8122">static void f_serverstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8123">{</a>
<a name="ln8124">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln8125">  rettv-&gt;vval.v_string = NULL;  // Address of the new server</a>
<a name="ln8126"> </a>
<a name="ln8127">  if (check_secure()) {</a>
<a name="ln8128">    return;</a>
<a name="ln8129">  }</a>
<a name="ln8130"> </a>
<a name="ln8131">  char *address;</a>
<a name="ln8132">  // If the user supplied an address, use it, otherwise use a temp.</a>
<a name="ln8133">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln8134">    if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln8135">      EMSG(_(e_invarg));</a>
<a name="ln8136">      return;</a>
<a name="ln8137">    } else {</a>
<a name="ln8138">      address = xstrdup(tv_get_string(argvars));</a>
<a name="ln8139">    }</a>
<a name="ln8140">  } else {</a>
<a name="ln8141">    address = server_address_new();</a>
<a name="ln8142">  }</a>
<a name="ln8143"> </a>
<a name="ln8144">  int result = server_start(address);</a>
<a name="ln8145">  xfree(address);</a>
<a name="ln8146"> </a>
<a name="ln8147">  if (result != 0) {</a>
<a name="ln8148">    EMSG2(&quot;Failed to start server: %s&quot;,</a>
<a name="ln8149">          result &gt; 0 ? &quot;Unknown system error&quot; : uv_strerror(result));</a>
<a name="ln8150">    return;</a>
<a name="ln8151">  }</a>
<a name="ln8152"> </a>
<a name="ln8153">  // Since it's possible server_start adjusted the given {address} (e.g.,</a>
<a name="ln8154">  // &quot;localhost:&quot; will now have a port), return the final value to the user.</a>
<a name="ln8155">  size_t n;</a>
<a name="ln8156">  char **addrs = server_address_list(&amp;n);</a>
<a name="ln8157">  rettv-&gt;vval.v_string = (char_u *)addrs[n - 1];</a>
<a name="ln8158"> </a>
<a name="ln8159">  n--;</a>
<a name="ln8160">  for (size_t i = 0; i &lt; n; i++) {</a>
<a name="ln8161">    xfree(addrs[i]);</a>
<a name="ln8162">  }</a>
<a name="ln8163">  xfree(addrs);</a>
<a name="ln8164">}</a>
<a name="ln8165"> </a>
<a name="ln8166">/// &quot;serverstop()&quot; function</a>
<a name="ln8167">static void f_serverstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8168">{</a>
<a name="ln8169">  if (check_secure()) {</a>
<a name="ln8170">    return;</a>
<a name="ln8171">  }</a>
<a name="ln8172"> </a>
<a name="ln8173">  if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln8174">    EMSG(_(e_invarg));</a>
<a name="ln8175">    return;</a>
<a name="ln8176">  }</a>
<a name="ln8177"> </a>
<a name="ln8178">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln8179">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8180">  if (argvars[0].vval.v_string) {</a>
<a name="ln8181">    bool rv = server_stop((char *)argvars[0].vval.v_string);</a>
<a name="ln8182">    rettv-&gt;vval.v_number = (rv ? 1 : 0);</a>
<a name="ln8183">  }</a>
<a name="ln8184">}</a>
<a name="ln8185"> </a>
<a name="ln8186">/// &quot;setbufline()&quot; function</a>
<a name="ln8187">static void f_setbufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8188">{</a>
<a name="ln8189">    linenr_T lnum;</a>
<a name="ln8190">    buf_T    *buf;</a>
<a name="ln8191"> </a>
<a name="ln8192">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln8193">    if (buf == NULL) {</a>
<a name="ln8194">      rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln8195">    } else {</a>
<a name="ln8196">      lnum = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln8197">      set_buffer_lines(buf, lnum, false, &amp;argvars[2], rettv);</a>
<a name="ln8198">    }</a>
<a name="ln8199">}</a>
<a name="ln8200"> </a>
<a name="ln8201">/*</a>
<a name="ln8202"> * &quot;setbufvar()&quot; function</a>
<a name="ln8203"> */</a>
<a name="ln8204">static void f_setbufvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8205">{</a>
<a name="ln8206">  if (check_secure()</a>
<a name="ln8207">      || !tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln8208">    return;</a>
<a name="ln8209">  }</a>
<a name="ln8210">  const char *varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8211">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln8212">  typval_T *varp = &amp;argvars[2];</a>
<a name="ln8213"> </a>
<a name="ln8214">  if (buf != NULL &amp;&amp; varname != NULL) {</a>
<a name="ln8215">    if (*varname == '&amp;') {</a>
<a name="ln8216">      long numval;</a>
<a name="ln8217">      bool error = false;</a>
<a name="ln8218">      aco_save_T aco;</a>
<a name="ln8219"> </a>
<a name="ln8220">      // set curbuf to be our buf, temporarily</a>
<a name="ln8221">      aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln8222"> </a>
<a name="ln8223">      varname++;</a>
<a name="ln8224">      numval = tv_get_number_chk(varp, &amp;error);</a>
<a name="ln8225">      char nbuf[NUMBUFLEN];</a>
<a name="ln8226">      const char *const strval = tv_get_string_buf_chk(varp, nbuf);</a>
<a name="ln8227">      if (!error &amp;&amp; strval != NULL) {</a>
<a name="ln8228">        set_option_value(varname, numval, strval, OPT_LOCAL);</a>
<a name="ln8229">      }</a>
<a name="ln8230"> </a>
<a name="ln8231">      // reset notion of buffer</a>
<a name="ln8232">      aucmd_restbuf(&amp;aco);</a>
<a name="ln8233">    } else {</a>
<a name="ln8234">      const size_t varname_len = STRLEN(varname);</a>
<a name="ln8235">      char *const bufvarname = xmalloc(varname_len + 3);</a>
<a name="ln8236">      buf_T *const save_curbuf = curbuf;</a>
<a name="ln8237">      curbuf = buf;</a>
<a name="ln8238">      memcpy(bufvarname, &quot;b:&quot;, 2);</a>
<a name="ln8239">      memcpy(bufvarname + 2, varname, varname_len + 1);</a>
<a name="ln8240">      set_var(bufvarname, varname_len + 2, varp, true);</a>
<a name="ln8241">      xfree(bufvarname);</a>
<a name="ln8242">      curbuf = save_curbuf;</a>
<a name="ln8243">    }</a>
<a name="ln8244">  }</a>
<a name="ln8245">}</a>
<a name="ln8246"> </a>
<a name="ln8247">static void f_setcharsearch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8248">{</a>
<a name="ln8249">  dict_T        *d;</a>
<a name="ln8250">  dictitem_T        *di;</a>
<a name="ln8251"> </a>
<a name="ln8252">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln8253">    EMSG(_(e_dictreq));</a>
<a name="ln8254">    return;</a>
<a name="ln8255">  }</a>
<a name="ln8256"> </a>
<a name="ln8257">  if ((d = argvars[0].vval.v_dict) != NULL) {</a>
<a name="ln8258">    char_u *const csearch = (char_u *)tv_dict_get_string(d, &quot;char&quot;, false);</a>
<a name="ln8259">    if (csearch != NULL) {</a>
<a name="ln8260">      int pcc[MAX_MCO];</a>
<a name="ln8261">      const int c = utfc_ptr2char(csearch, pcc);</a>
<a name="ln8262">      set_last_csearch(c, csearch, utfc_ptr2len(csearch));</a>
<a name="ln8263">    }</a>
<a name="ln8264"> </a>
<a name="ln8265">    di = tv_dict_find(d, S_LEN(&quot;forward&quot;));</a>
<a name="ln8266">    if (di != NULL) {</a>
<a name="ln8267">      set_csearch_direction(tv_get_number(&amp;di-&gt;di_tv) ? FORWARD : BACKWARD);</a>
<a name="ln8268">    }</a>
<a name="ln8269"> </a>
<a name="ln8270">    di = tv_dict_find(d, S_LEN(&quot;until&quot;));</a>
<a name="ln8271">    if (di != NULL) {</a>
<a name="ln8272">      set_csearch_until(!!tv_get_number(&amp;di-&gt;di_tv));</a>
<a name="ln8273">    }</a>
<a name="ln8274">  }</a>
<a name="ln8275">}</a>
<a name="ln8276"> </a>
<a name="ln8277">/*</a>
<a name="ln8278"> * &quot;setcmdpos()&quot; function</a>
<a name="ln8279"> */</a>
<a name="ln8280">static void f_setcmdpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8281">{</a>
<a name="ln8282">  const int pos = (int)tv_get_number(&amp;argvars[0]) - 1;</a>
<a name="ln8283"> </a>
<a name="ln8284">  if (pos &gt;= 0) {</a>
<a name="ln8285">    rettv-&gt;vval.v_number = set_cmdline_pos(pos);</a>
<a name="ln8286">  }</a>
<a name="ln8287">}</a>
<a name="ln8288"> </a>
<a name="ln8289">/// &quot;setenv()&quot; function</a>
<a name="ln8290">static void f_setenv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8291">{</a>
<a name="ln8292">  char namebuf[NUMBUFLEN];</a>
<a name="ln8293">  char valbuf[NUMBUFLEN];</a>
<a name="ln8294">  const char *name = tv_get_string_buf(&amp;argvars[0], namebuf);</a>
<a name="ln8295"> </a>
<a name="ln8296">  if (argvars[1].v_type == VAR_SPECIAL</a>
<a name="ln8297">      &amp;&amp; argvars[1].vval.v_special == kSpecialVarNull) {</a>
<a name="ln8298">    os_unsetenv(name);</a>
<a name="ln8299">  } else {</a>
<a name="ln8300">    os_setenv(name, tv_get_string_buf(&amp;argvars[1], valbuf), 1);</a>
<a name="ln8301">  }</a>
<a name="ln8302">}</a>
<a name="ln8303"> </a>
<a name="ln8304">/// &quot;setfperm({fname}, {mode})&quot; function</a>
<a name="ln8305">static void f_setfperm(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8306">{</a>
<a name="ln8307">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8308"> </a>
<a name="ln8309">  const char *const fname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln8310">  if (fname == NULL) {</a>
<a name="ln8311">    return;</a>
<a name="ln8312">  }</a>
<a name="ln8313"> </a>
<a name="ln8314">  char modebuf[NUMBUFLEN];</a>
<a name="ln8315">  const char *const mode_str = tv_get_string_buf_chk(&amp;argvars[1], modebuf);</a>
<a name="ln8316">  if (mode_str == NULL) {</a>
<a name="ln8317">    return;</a>
<a name="ln8318">  }</a>
<a name="ln8319">  if (strlen(mode_str) != 9) {</a>
<a name="ln8320">    EMSG2(_(e_invarg2), mode_str);</a>
<a name="ln8321">    return;</a>
<a name="ln8322">  }</a>
<a name="ln8323"> </a>
<a name="ln8324">  int mask = 1;</a>
<a name="ln8325">  int mode = 0;</a>
<a name="ln8326">  for (int i = 8; i &gt;= 0; i--) {</a>
<a name="ln8327">    if (mode_str[i] != '-') {</a>
<a name="ln8328">      mode |= mask;</a>
<a name="ln8329">    }</a>
<a name="ln8330">    mask = mask &lt;&lt; 1;</a>
<a name="ln8331">  }</a>
<a name="ln8332">  rettv-&gt;vval.v_number = os_setperm(fname, mode) == OK;</a>
<a name="ln8333">}</a>
<a name="ln8334"> </a>
<a name="ln8335">/*</a>
<a name="ln8336"> * &quot;setline()&quot; function</a>
<a name="ln8337"> */</a>
<a name="ln8338">static void f_setline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8339">{</a>
<a name="ln8340">  linenr_T lnum = tv_get_lnum(&amp;argvars[0]);</a>
<a name="ln8341">  set_buffer_lines(curbuf, lnum, false, &amp;argvars[1], rettv);</a>
<a name="ln8342">}</a>
<a name="ln8343"> </a>
<a name="ln8344">/// Create quickfix/location list from VimL values</a>
<a name="ln8345">///</a>
<a name="ln8346">/// Used by `setqflist()` and `setloclist()` functions. Accepts invalid</a>
<a name="ln8347">/// args argument in which case errors out, including VAR_UNKNOWN parameters.</a>
<a name="ln8348">///</a>
<a name="ln8349">/// @param[in,out]  wp  Window to create location list for. May be NULL in</a>
<a name="ln8350">///                     which case quickfix list will be created.</a>
<a name="ln8351">/// @param[in]  args  [list, action, what]</a>
<a name="ln8352">/// @param[in]  args[0]  Quickfix list contents.</a>
<a name="ln8353">/// @param[in]  args[1]  Optional. Action to perform:</a>
<a name="ln8354">///                      append to an existing list, replace its content,</a>
<a name="ln8355">///                      or create a new one.</a>
<a name="ln8356">/// @param[in]  args[2]  Optional. Quickfix list properties or title.</a>
<a name="ln8357">///                      Defaults to caller function name.</a>
<a name="ln8358">/// @param[out]  rettv  Return value: 0 in case of success, -1 otherwise.</a>
<a name="ln8359">static void set_qf_ll_list(win_T *wp, typval_T *args, typval_T *rettv)</a>
<a name="ln8360">  FUNC_ATTR_NONNULL_ARG(2, 3)</a>
<a name="ln8361">{</a>
<a name="ln8362">  static char *e_invact = N_(&quot;E927: Invalid action: '%s'&quot;);</a>
<a name="ln8363">  const char *title = NULL;</a>
<a name="ln8364">  int action = ' ';</a>
<a name="ln8365">  static int recursive = 0;</a>
<a name="ln8366">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8367">  dict_T *what = NULL;</a>
<a name="ln8368"> </a>
<a name="ln8369">  typval_T *list_arg = &amp;args[0];</a>
<a name="ln8370">  if (list_arg-&gt;v_type != VAR_LIST) {</a>
<a name="ln8371">    EMSG(_(e_listreq));</a>
<a name="ln8372">    return;</a>
<a name="ln8373">  } else if (recursive != 0) {</a>
<a name="ln8374">    EMSG(_(e_au_recursive));</a>
<a name="ln8375">    return;</a>
<a name="ln8376">  }</a>
<a name="ln8377"> </a>
<a name="ln8378">  typval_T *action_arg = &amp;args[1];</a>
<a name="ln8379">  if (action_arg-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln8380">    // Option argument was not given.</a>
<a name="ln8381">    goto skip_args;</a>
<a name="ln8382">  } else if (action_arg-&gt;v_type != VAR_STRING) {</a>
<a name="ln8383">    EMSG(_(e_stringreq));</a>
<a name="ln8384">    return;</a>
<a name="ln8385">  }</a>
<a name="ln8386">  const char *const act = tv_get_string_chk(action_arg);</a>
<a name="ln8387">  if ((*act == 'a' || *act == 'r' || *act == ' ' || *act == 'f')</a>
<a name="ln8388">      &amp;&amp; act[1] == NUL) {</a>
<a name="ln8389">    action = *act;</a>
<a name="ln8390">  } else {</a>
<a name="ln8391">    EMSG2(_(e_invact), act);</a>
<a name="ln8392">    return;</a>
<a name="ln8393">  }</a>
<a name="ln8394"> </a>
<a name="ln8395">  typval_T *const what_arg = &amp;args[2];</a>
<a name="ln8396">  if (what_arg-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln8397">    // Option argument was not given.</a>
<a name="ln8398">    goto skip_args;</a>
<a name="ln8399">  } else if (what_arg-&gt;v_type == VAR_STRING) {</a>
<a name="ln8400">    title = tv_get_string_chk(what_arg);</a>
<a name="ln8401">    if (!title) {</a>
<a name="ln8402">      // Type error. Error already printed by tv_get_string_chk().</a>
<a name="ln8403">      return;</a>
<a name="ln8404">    }</a>
<a name="ln8405">  } else if (what_arg-&gt;v_type == VAR_DICT &amp;&amp; what_arg-&gt;vval.v_dict != NULL) {</a>
<a name="ln8406">    what = what_arg-&gt;vval.v_dict;</a>
<a name="ln8407">  } else {</a>
<a name="ln8408">    EMSG(_(e_dictreq));</a>
<a name="ln8409">    return;</a>
<a name="ln8410">  }</a>
<a name="ln8411"> </a>
<a name="ln8412">skip_args:</a>
<a name="ln8413">  if (!title) {</a>
<a name="ln8414">    title = (wp ? &quot;:setloclist()&quot; : &quot;:setqflist()&quot;);</a>
<a name="ln8415">  }</a>
<a name="ln8416"> </a>
<a name="ln8417">  recursive++;</a>
<a name="ln8418">  list_T *const l = list_arg-&gt;vval.v_list;</a>
<a name="ln8419">  if (set_errorlist(wp, l, action, (char_u *)title, what) == OK) {</a>
<a name="ln8420">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln8421">  }</a>
<a name="ln8422">  recursive--;</a>
<a name="ln8423">}</a>
<a name="ln8424"> </a>
<a name="ln8425">/*</a>
<a name="ln8426"> * &quot;setloclist()&quot; function</a>
<a name="ln8427"> */</a>
<a name="ln8428">static void f_setloclist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8429">{</a>
<a name="ln8430">  win_T       *win;</a>
<a name="ln8431"> </a>
<a name="ln8432">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8433"> </a>
<a name="ln8434">  win = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln8435">  if (win != NULL) {</a>
<a name="ln8436">    set_qf_ll_list(win, &amp;argvars[1], rettv);</a>
<a name="ln8437">  }</a>
<a name="ln8438">}</a>
<a name="ln8439"> </a>
<a name="ln8440">/*</a>
<a name="ln8441"> * &quot;setmatches()&quot; function</a>
<a name="ln8442"> */</a>
<a name="ln8443">static void f_setmatches(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8444">{</a>
<a name="ln8445">  dict_T *d;</a>
<a name="ln8446">  list_T *s = NULL;</a>
<a name="ln8447">  win_T *win = get_optional_window(argvars, 1);</a>
<a name="ln8448"> </a>
<a name="ln8449">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8450">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln8451">    EMSG(_(e_listreq));</a>
<a name="ln8452">    return;</a>
<a name="ln8453">  }</a>
<a name="ln8454">  if (win == NULL) {</a>
<a name="ln8455">    return;</a>
<a name="ln8456">  }</a>
<a name="ln8457"> </a>
<a name="ln8458">  list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln8459">  // To some extent make sure that we are dealing with a list from</a>
<a name="ln8460">  // &quot;getmatches()&quot;.</a>
<a name="ln8461">  int li_idx = 0;</a>
<a name="ln8462">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln8463">    if (TV_LIST_ITEM_TV(li)-&gt;v_type != VAR_DICT</a>
<a name="ln8464">        || (d = TV_LIST_ITEM_TV(li)-&gt;vval.v_dict) == NULL) {</a>
<a name="ln8465">      emsgf(_(&quot;E474: List item %d is either not a dictionary &quot;</a>
<a name="ln8466">              &quot;or an empty one&quot;), li_idx);</a>
<a name="ln8467">      return;</a>
<a name="ln8468">    }</a>
<a name="ln8469">    if (!(tv_dict_find(d, S_LEN(&quot;group&quot;)) != NULL</a>
<a name="ln8470">          &amp;&amp; (tv_dict_find(d, S_LEN(&quot;pattern&quot;)) != NULL</a>
<a name="ln8471">              || tv_dict_find(d, S_LEN(&quot;pos1&quot;)) != NULL)</a>
<a name="ln8472">          &amp;&amp; tv_dict_find(d, S_LEN(&quot;priority&quot;)) != NULL</a>
<a name="ln8473">          &amp;&amp; tv_dict_find(d, S_LEN(&quot;id&quot;)) != NULL)) {</a>
<a name="ln8474">      emsgf(_(&quot;E474: List item %d is missing one of the required keys&quot;),</a>
<a name="ln8475">            li_idx);</a>
<a name="ln8476">      return;</a>
<a name="ln8477">    }</a>
<a name="ln8478">    li_idx++;</a>
<a name="ln8479">  });</a>
<a name="ln8480"> </a>
<a name="ln8481">  clear_matches(win);</a>
<a name="ln8482">  bool match_add_failed = false;</a>
<a name="ln8483">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln8484">    int i = 0;</a>
<a name="ln8485"> </a>
<a name="ln8486">    d = TV_LIST_ITEM_TV(li)-&gt;vval.v_dict;</a>
<a name="ln8487">    dictitem_T *const di = tv_dict_find(d, S_LEN(&quot;pattern&quot;));</a>
<a name="ln8488">    if (di == NULL) {</a>
<a name="ln8489">      if (s == NULL) {</a>
<a name="ln8490">        s = tv_list_alloc(9);</a>
<a name="ln8491">      }</a>
<a name="ln8492"> </a>
<a name="ln8493">      // match from matchaddpos()</a>
<a name="ln8494">      for (i = 1; i &lt; 9; i++) {</a>
<a name="ln8495">        char buf[30];  // use 30 to avoid compiler warning</a>
<a name="ln8496">        snprintf(buf, sizeof(buf), &quot;pos%d&quot;, i);</a>
<a name="ln8497">        dictitem_T *const pos_di = tv_dict_find(d, buf, -1);</a>
<a name="ln8498">        if (pos_di != NULL) {</a>
<a name="ln8499">          if (pos_di-&gt;di_tv.v_type != VAR_LIST) {</a>
<a name="ln8500">            return;</a>
<a name="ln8501">          }</a>
<a name="ln8502"> </a>
<a name="ln8503">          tv_list_append_tv(s, &amp;pos_di-&gt;di_tv);</a>
<a name="ln8504">          tv_list_ref(s);</a>
<a name="ln8505">        } else {</a>
<a name="ln8506">          break;</a>
<a name="ln8507">        }</a>
<a name="ln8508">      }</a>
<a name="ln8509">    }</a>
<a name="ln8510"> </a>
<a name="ln8511">    // Note: there are three number buffers involved:</a>
<a name="ln8512">    // - group_buf below.</a>
<a name="ln8513">    // - numbuf in tv_dict_get_string().</a>
<a name="ln8514">    // - mybuf in tv_get_string().</a>
<a name="ln8515">    //</a>
<a name="ln8516">    // If you change this code make sure that buffers will not get</a>
<a name="ln8517">    // accidentally reused.</a>
<a name="ln8518">    char group_buf[NUMBUFLEN];</a>
<a name="ln8519">    const char *const group = tv_dict_get_string_buf(d, &quot;group&quot;, group_buf);</a>
<a name="ln8520">    const int priority = (int)tv_dict_get_number(d, &quot;priority&quot;);</a>
<a name="ln8521">    const int id = (int)tv_dict_get_number(d, &quot;id&quot;);</a>
<a name="ln8522">    dictitem_T *const conceal_di = tv_dict_find(d, S_LEN(&quot;conceal&quot;));</a>
<a name="ln8523">    const char *const conceal = (conceal_di != NULL</a>
<a name="ln8524">                                 ? tv_get_string(&amp;conceal_di-&gt;di_tv)</a>
<a name="ln8525">                                 : NULL);</a>
<a name="ln8526">    if (i == 0) {</a>
<a name="ln8527">      if (match_add(win, group,</a>
<a name="ln8528">                    tv_dict_get_string(d, &quot;pattern&quot;, false),</a>
<a name="ln8529">                    priority, id, NULL, conceal) != id) {</a>
<a name="ln8530">        match_add_failed = true;</a>
<a name="ln8531">      }</a>
<a name="ln8532">    } else {</a>
<a name="ln8533">      if (match_add(win, group, NULL, priority, id, s, conceal) != id) {</a>
<a name="ln8534">        match_add_failed = true;</a>
<a name="ln8535">      }</a>
<a name="ln8536">      tv_list_unref(s);</a>
<a name="ln8537">      s = NULL;</a>
<a name="ln8538">    }</a>
<a name="ln8539">  });</a>
<a name="ln8540">  if (!match_add_failed) {</a>
<a name="ln8541">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln8542">  }</a>
<a name="ln8543">}</a>
<a name="ln8544"> </a>
<a name="ln8545">/*</a>
<a name="ln8546"> * &quot;setpos()&quot; function</a>
<a name="ln8547"> */</a>
<a name="ln8548">static void f_setpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8549">{</a>
<a name="ln8550">  pos_T pos;</a>
<a name="ln8551">  int fnum;</a>
<a name="ln8552">  colnr_T     curswant = -1;</a>
<a name="ln8553"> </a>
<a name="ln8554">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8555">  const char *const name = tv_get_string_chk(argvars);</a>
<a name="ln8556">  if (name != NULL) {</a>
<a name="ln8557">    if (list2fpos(&amp;argvars[1], &amp;pos, &amp;fnum, &amp;curswant) == OK) {</a>
<a name="ln8558">      if (pos.col != MAXCOL &amp;&amp; --pos.col &lt; 0) {</a>
<a name="ln8559">        pos.col = 0;</a>
<a name="ln8560">      }</a>
<a name="ln8561">      if (name[0] == '.' &amp;&amp; name[1] == NUL) {</a>
<a name="ln8562">        // set cursor; &quot;fnum&quot; is ignored</a>
<a name="ln8563">        curwin-&gt;w_cursor = pos;</a>
<a name="ln8564">        if (curswant &gt;= 0) {</a>
<a name="ln8565">          curwin-&gt;w_curswant = curswant - 1;</a>
<a name="ln8566">          curwin-&gt;w_set_curswant = false;</a>
<a name="ln8567">        }</a>
<a name="ln8568">        check_cursor();</a>
<a name="ln8569">        rettv-&gt;vval.v_number = 0;</a>
<a name="ln8570">      } else if (name[0] == '\'' &amp;&amp; name[1] != NUL &amp;&amp; name[2] == NUL)   {</a>
<a name="ln8571">        // set mark</a>
<a name="ln8572">        if (setmark_pos((uint8_t)name[1], &amp;pos, fnum) == OK) {</a>
<a name="ln8573">          rettv-&gt;vval.v_number = 0;</a>
<a name="ln8574">        }</a>
<a name="ln8575">      } else {</a>
<a name="ln8576">        EMSG(_(e_invarg));</a>
<a name="ln8577">      }</a>
<a name="ln8578">    }</a>
<a name="ln8579">  }</a>
<a name="ln8580">}</a>
<a name="ln8581"> </a>
<a name="ln8582">/*</a>
<a name="ln8583"> * &quot;setqflist()&quot; function</a>
<a name="ln8584"> */</a>
<a name="ln8585">static void f_setqflist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8586">{</a>
<a name="ln8587">  set_qf_ll_list(NULL, argvars, rettv);</a>
<a name="ln8588">}</a>
<a name="ln8589"> </a>
<a name="ln8590">/*</a>
<a name="ln8591"> * &quot;setreg()&quot; function</a>
<a name="ln8592"> */</a>
<a name="ln8593">static void f_setreg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8594">{</a>
<a name="ln8595">  int regname;</a>
<a name="ln8596">  bool append = false;</a>
<a name="ln8597">  MotionType yank_type;</a>
<a name="ln8598">  long block_len;</a>
<a name="ln8599"> </a>
<a name="ln8600">  block_len = -1;</a>
<a name="ln8601">  yank_type = kMTUnknown;</a>
<a name="ln8602"> </a>
<a name="ln8603">  rettv-&gt;vval.v_number = 1;  // FAIL is default.</a>
<a name="ln8604"> </a>
<a name="ln8605">  const char *const strregname = tv_get_string_chk(argvars);</a>
<a name="ln8606">  if (strregname == NULL) {</a>
<a name="ln8607">    return;  // Type error; errmsg already given.</a>
<a name="ln8608">  }</a>
<a name="ln8609">  regname = (uint8_t)(*strregname);</a>
<a name="ln8610">  if (regname == 0 || regname == '@') {</a>
<a name="ln8611">    regname = '&quot;';</a>
<a name="ln8612">  }</a>
<a name="ln8613"> </a>
<a name="ln8614">  bool set_unnamed = false;</a>
<a name="ln8615">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln8616">    const char *stropt = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln8617">    if (stropt == NULL) {</a>
<a name="ln8618">      return;  // Type error.</a>
<a name="ln8619">    }</a>
<a name="ln8620">    for (; *stropt != NUL; stropt++) {</a>
<a name="ln8621">      switch (*stropt) {</a>
<a name="ln8622">        case 'a': case 'A': {  // append</a>
<a name="ln8623">          append = true;</a>
<a name="ln8624">          break;</a>
<a name="ln8625">        }</a>
<a name="ln8626">        case 'v': case 'c': {  // character-wise selection</a>
<a name="ln8627">          yank_type = kMTCharWise;</a>
<a name="ln8628">          break;</a>
<a name="ln8629">        }</a>
<a name="ln8630">        case 'V': case 'l': {  // line-wise selection</a>
<a name="ln8631">          yank_type = kMTLineWise;</a>
<a name="ln8632">          break;</a>
<a name="ln8633">        }</a>
<a name="ln8634">        case 'b': case Ctrl_V: {  // block-wise selection</a>
<a name="ln8635">          yank_type = kMTBlockWise;</a>
<a name="ln8636">          if (ascii_isdigit(stropt[1])) {</a>
<a name="ln8637">            stropt++;</a>
<a name="ln8638">            block_len = getdigits_long((char_u **)&amp;stropt, true, 0) - 1;</a>
<a name="ln8639">            stropt--;</a>
<a name="ln8640">          }</a>
<a name="ln8641">          break;</a>
<a name="ln8642">        }</a>
<a name="ln8643">        case 'u': case '&quot;': {  // unnamed register</a>
<a name="ln8644">          set_unnamed = true;</a>
<a name="ln8645">          break;</a>
<a name="ln8646">        }</a>
<a name="ln8647">      }</a>
<a name="ln8648">    }</a>
<a name="ln8649">  }</a>
<a name="ln8650"> </a>
<a name="ln8651">  if (argvars[1].v_type == VAR_LIST) {</a>
<a name="ln8652">    list_T *ll = argvars[1].vval.v_list;</a>
<a name="ln8653">    // If the list is NULL handle like an empty list.</a>
<a name="ln8654">    const int len = tv_list_len(ll);</a>
<a name="ln8655"> </a>
<a name="ln8656">    // First half: use for pointers to result lines; second half: use for</a>
<a name="ln8657">    // pointers to allocated copies.</a>
<a name="ln8658">    char **lstval = xmalloc(sizeof(char *) * ((len + 1) * 2));</a>
<a name="ln8659">    const char **curval = (const char **)lstval;</a>
<a name="ln8660">    char **allocval = lstval + len + 2;</a>
<a name="ln8661">    char **curallocval = allocval;</a>
<a name="ln8662"> </a>
<a name="ln8663">    TV_LIST_ITER_CONST(ll, li, {</a>
<a name="ln8664">      char buf[NUMBUFLEN];</a>
<a name="ln8665">      *curval = tv_get_string_buf_chk(TV_LIST_ITEM_TV(li), buf);</a>
<a name="ln8666">      if (*curval == NULL) {</a>
<a name="ln8667">        goto free_lstval;</a>
<a name="ln8668">      }</a>
<a name="ln8669">      if (*curval == buf) {</a>
<a name="ln8670">        // Need to make a copy,</a>
<a name="ln8671">        // next tv_get_string_buf_chk() will overwrite the string.</a>
<a name="ln8672">        *curallocval = xstrdup(*curval);</a>
<a name="ln8673">        *curval = *curallocval;</a>
<a name="ln8674">        curallocval++;</a>
<a name="ln8675">      }</a>
<a name="ln8676">      curval++;</a>
<a name="ln8677">    });</a>
<a name="ln8678">    *curval++ = NULL;</a>
<a name="ln8679"> </a>
<a name="ln8680">    write_reg_contents_lst(regname, (char_u **)lstval, append, yank_type,</a>
<a name="ln8681">                           block_len);</a>
<a name="ln8682"> </a>
<a name="ln8683">free_lstval:</a>
<a name="ln8684">    while (curallocval &gt; allocval) {</a>
<a name="ln8685">      xfree(*--curallocval);</a>
<a name="ln8686">    }</a>
<a name="ln8687">    xfree(lstval);</a>
<a name="ln8688">  } else {</a>
<a name="ln8689">    const char *strval = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8690">    if (strval == NULL) {</a>
<a name="ln8691">      return;</a>
<a name="ln8692">    }</a>
<a name="ln8693">    write_reg_contents_ex(regname, (const char_u *)strval, STRLEN(strval),</a>
<a name="ln8694">                          append, yank_type, block_len);</a>
<a name="ln8695">  }</a>
<a name="ln8696">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8697"> </a>
<a name="ln8698">  if (set_unnamed) {</a>
<a name="ln8699">    // Discard the result. We already handle the error case.</a>
<a name="ln8700">    if (op_reg_set_previous(regname)) { }</a>
<a name="ln8701">  }</a>
<a name="ln8702">}</a>
<a name="ln8703"> </a>
<a name="ln8704">/*</a>
<a name="ln8705"> * &quot;settabvar()&quot; function</a>
<a name="ln8706"> */</a>
<a name="ln8707">static void f_settabvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8708">{</a>
<a name="ln8709">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8710"> </a>
<a name="ln8711">  if (check_secure()) {</a>
<a name="ln8712">    return;</a>
<a name="ln8713">  }</a>
<a name="ln8714"> </a>
<a name="ln8715">  tabpage_T *const tp = find_tabpage((int)tv_get_number_chk(&amp;argvars[0], NULL));</a>
<a name="ln8716">  const char *const varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8717">  typval_T *const varp = &amp;argvars[2];</a>
<a name="ln8718"> </a>
<a name="ln8719">  if (varname != NULL &amp;&amp; tp != NULL) {</a>
<a name="ln8720">    tabpage_T *const save_curtab = curtab;</a>
<a name="ln8721">    goto_tabpage_tp(tp, false, false);</a>
<a name="ln8722"> </a>
<a name="ln8723">    const size_t varname_len = strlen(varname);</a>
<a name="ln8724">    char *const tabvarname = xmalloc(varname_len + 3);</a>
<a name="ln8725">    memcpy(tabvarname, &quot;t:&quot;, 2);</a>
<a name="ln8726">    memcpy(tabvarname + 2, varname, varname_len + 1);</a>
<a name="ln8727">    set_var(tabvarname, varname_len + 2, varp, true);</a>
<a name="ln8728">    xfree(tabvarname);</a>
<a name="ln8729"> </a>
<a name="ln8730">    // Restore current tabpage.</a>
<a name="ln8731">    if (valid_tabpage(save_curtab)) {</a>
<a name="ln8732">      goto_tabpage_tp(save_curtab, false, false);</a>
<a name="ln8733">    }</a>
<a name="ln8734">  }</a>
<a name="ln8735">}</a>
<a name="ln8736"> </a>
<a name="ln8737">/*</a>
<a name="ln8738"> * &quot;settabwinvar()&quot; function</a>
<a name="ln8739"> */</a>
<a name="ln8740">static void f_settabwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8741">{</a>
<a name="ln8742">  setwinvar(argvars, rettv, 1);</a>
<a name="ln8743">}</a>
<a name="ln8744"> </a>
<a name="ln8745">// &quot;settagstack()&quot; function</a>
<a name="ln8746">static void f_settagstack(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8747">{</a>
<a name="ln8748">    static char *e_invact2 = N_(&quot;E962: Invalid action: '%s'&quot;);</a>
<a name="ln8749">    win_T       *wp;</a>
<a name="ln8750">    dict_T      *d;</a>
<a name="ln8751">    int         action = 'r';</a>
<a name="ln8752"> </a>
<a name="ln8753">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln8754"> </a>
<a name="ln8755">    // first argument: window number or id</a>
<a name="ln8756">    wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln8757">    if (wp == NULL) {</a>
<a name="ln8758">      return;</a>
<a name="ln8759">    }</a>
<a name="ln8760"> </a>
<a name="ln8761">    // second argument: dict with items to set in the tag stack</a>
<a name="ln8762">    if (argvars[1].v_type != VAR_DICT) {</a>
<a name="ln8763">        EMSG(_(e_dictreq));</a>
<a name="ln8764">        return;</a>
<a name="ln8765">    }</a>
<a name="ln8766">    d = argvars[1].vval.v_dict;</a>
<a name="ln8767">    if (d == NULL) {</a>
<a name="ln8768">      return;</a>
<a name="ln8769">    }</a>
<a name="ln8770"> </a>
<a name="ln8771">    // third argument: action - 'a' for append and 'r' for replace.</a>
<a name="ln8772">    // default is to replace the stack.</a>
<a name="ln8773">    if (argvars[2].v_type == VAR_UNKNOWN) {</a>
<a name="ln8774">      action = 'r';</a>
<a name="ln8775">    } else if (argvars[2].v_type == VAR_STRING) {</a>
<a name="ln8776">        const char *actstr;</a>
<a name="ln8777">        actstr = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln8778">        if (actstr == NULL) {</a>
<a name="ln8779">          return;</a>
<a name="ln8780">        }</a>
<a name="ln8781">        if ((*actstr == 'r' || *actstr == 'a' || *actstr == 't')</a>
<a name="ln8782">            &amp;&amp; actstr[1] == NUL) {</a>
<a name="ln8783">          action = *actstr;</a>
<a name="ln8784">        } else {</a>
<a name="ln8785">            EMSG2(_(e_invact2), actstr);</a>
<a name="ln8786">            return;</a>
<a name="ln8787">        }</a>
<a name="ln8788">    } else {</a>
<a name="ln8789">        EMSG(_(e_stringreq));</a>
<a name="ln8790">        return;</a>
<a name="ln8791">    }</a>
<a name="ln8792"> </a>
<a name="ln8793">    if (set_tagstack(wp, d, action) == OK) {</a>
<a name="ln8794">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln8795">    }</a>
<a name="ln8796">}</a>
<a name="ln8797"> </a>
<a name="ln8798">/*</a>
<a name="ln8799"> * &quot;setwinvar()&quot; function</a>
<a name="ln8800"> */</a>
<a name="ln8801">static void f_setwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8802">{</a>
<a name="ln8803">  setwinvar(argvars, rettv, 0);</a>
<a name="ln8804">}</a>
<a name="ln8805"> </a>
<a name="ln8806">/// f_sha256 - sha256({string}) function</a>
<a name="ln8807">static void f_sha256(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8808">{</a>
<a name="ln8809">  const char *p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln8810">  const char *hash = sha256_bytes((const uint8_t *)p, strlen(p) , NULL, 0);</a>
<a name="ln8811"> </a>
<a name="ln8812">  // make a copy of the hash (sha256_bytes returns a static buffer)</a>
<a name="ln8813">  rettv-&gt;vval.v_string = (char_u *)xstrdup(hash);</a>
<a name="ln8814">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln8815">}</a>
<a name="ln8816"> </a>
<a name="ln8817">/*</a>
<a name="ln8818"> * &quot;shellescape({string})&quot; function</a>
<a name="ln8819"> */</a>
<a name="ln8820">static void f_shellescape(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8821">{</a>
<a name="ln8822">  const bool do_special = non_zero_arg(&amp;argvars[1]);</a>
<a name="ln8823"> </a>
<a name="ln8824">  rettv-&gt;vval.v_string = vim_strsave_shellescape(</a>
<a name="ln8825">      (const char_u *)tv_get_string(&amp;argvars[0]), do_special, do_special);</a>
<a name="ln8826">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln8827">}</a>
<a name="ln8828"> </a>
<a name="ln8829">/*</a>
<a name="ln8830"> * shiftwidth() function</a>
<a name="ln8831"> */</a>
<a name="ln8832">static void f_shiftwidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8833">{</a>
<a name="ln8834">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8835"> </a>
<a name="ln8836">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln8837">    long col;</a>
<a name="ln8838"> </a>
<a name="ln8839">    col = (long)tv_get_number_chk(argvars, NULL);</a>
<a name="ln8840">    if (col &lt; 0) {</a>
<a name="ln8841">      return;  // type error; errmsg already given</a>
<a name="ln8842">    }</a>
<a name="ln8843">    rettv-&gt;vval.v_number = get_sw_value_col(curbuf, col);</a>
<a name="ln8844">    return;</a>
<a name="ln8845">  }</a>
<a name="ln8846">  rettv-&gt;vval.v_number = get_sw_value(curbuf);</a>
<a name="ln8847">}</a>
<a name="ln8848"> </a>
<a name="ln8849">/// &quot;sign_define()&quot; function</a>
<a name="ln8850">static void f_sign_define(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8851">{</a>
<a name="ln8852">  const char *name;</a>
<a name="ln8853"> </a>
<a name="ln8854">  if (argvars[0].v_type == VAR_LIST &amp;&amp; argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln8855">    // Define multiple signs</a>
<a name="ln8856">    tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln8857"> </a>
<a name="ln8858">    sign_define_multiple(argvars[0].vval.v_list, rettv-&gt;vval.v_list);</a>
<a name="ln8859">    return;</a>
<a name="ln8860">  }</a>
<a name="ln8861"> </a>
<a name="ln8862">  // Define a single sign</a>
<a name="ln8863">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8864"> </a>
<a name="ln8865">  name = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln8866">  if (name == NULL) {</a>
<a name="ln8867">    return;</a>
<a name="ln8868">  }</a>
<a name="ln8869"> </a>
<a name="ln8870">  if (argvars[1].v_type != VAR_UNKNOWN &amp;&amp; argvars[1].v_type != VAR_DICT) {</a>
<a name="ln8871">    EMSG(_(e_dictreq));</a>
<a name="ln8872">    return;</a>
<a name="ln8873">  }</a>
<a name="ln8874"> </a>
<a name="ln8875">  rettv-&gt;vval.v_number = sign_define_from_dict(</a>
<a name="ln8876">      name, argvars[1].v_type == VAR_DICT ? argvars[1].vval.v_dict : NULL);</a>
<a name="ln8877">}</a>
<a name="ln8878"> </a>
<a name="ln8879">/// &quot;sign_getdefined()&quot; function</a>
<a name="ln8880">static void f_sign_getdefined(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8881">{</a>
<a name="ln8882">  const char *name = NULL;</a>
<a name="ln8883"> </a>
<a name="ln8884">  tv_list_alloc_ret(rettv, 0);</a>
<a name="ln8885"> </a>
<a name="ln8886">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln8887">    name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln8888">  }</a>
<a name="ln8889"> </a>
<a name="ln8890">  sign_getlist((const char_u *)name, rettv-&gt;vval.v_list);</a>
<a name="ln8891">}</a>
<a name="ln8892"> </a>
<a name="ln8893">/// &quot;sign_getplaced()&quot; function</a>
<a name="ln8894">static void f_sign_getplaced(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8895">{</a>
<a name="ln8896">  buf_T *buf = NULL;</a>
<a name="ln8897">  dict_T *dict;</a>
<a name="ln8898">  dictitem_T *di;</a>
<a name="ln8899">  linenr_T lnum = 0;</a>
<a name="ln8900">  int sign_id = 0;</a>
<a name="ln8901">  const char *group = NULL;</a>
<a name="ln8902">  bool notanum = false;</a>
<a name="ln8903"> </a>
<a name="ln8904">  tv_list_alloc_ret(rettv, 0);</a>
<a name="ln8905"> </a>
<a name="ln8906">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln8907">    // get signs placed in the specified buffer</a>
<a name="ln8908">    buf = get_buf_arg(&amp;argvars[0]);</a>
<a name="ln8909">    if (buf == NULL) {</a>
<a name="ln8910">      return;</a>
<a name="ln8911">    }</a>
<a name="ln8912"> </a>
<a name="ln8913">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln8914">      if (argvars[1].v_type != VAR_DICT</a>
<a name="ln8915">          || ((dict = argvars[1].vval.v_dict) == NULL)) {</a>
<a name="ln8916">        EMSG(_(e_dictreq));</a>
<a name="ln8917">        return;</a>
<a name="ln8918">      }</a>
<a name="ln8919">      if ((di = tv_dict_find(dict, &quot;lnum&quot;, -1)) != NULL) {</a>
<a name="ln8920">        // get signs placed at this line</a>
<a name="ln8921">        lnum = (linenr_T)tv_get_number_chk(&amp;di-&gt;di_tv, &amp;notanum);</a>
<a name="ln8922">        if (notanum) {</a>
<a name="ln8923">          return;</a>
<a name="ln8924">        }</a>
<a name="ln8925">        (void)lnum;</a>
<a name="ln8926">        lnum = tv_get_lnum(&amp;di-&gt;di_tv);</a>
<a name="ln8927">      }</a>
<a name="ln8928">      if ((di = tv_dict_find(dict, &quot;id&quot;, -1)) != NULL) {</a>
<a name="ln8929">        // get sign placed with this identifier</a>
<a name="ln8930">        sign_id = (int)tv_get_number_chk(&amp;di-&gt;di_tv, &amp;notanum);</a>
<a name="ln8931">        if (notanum) {</a>
<a name="ln8932">          return;</a>
<a name="ln8933">        }</a>
<a name="ln8934">      }</a>
<a name="ln8935">      if ((di = tv_dict_find(dict, &quot;group&quot;, -1)) != NULL) {</a>
<a name="ln8936">        group = tv_get_string_chk(&amp;di-&gt;di_tv);</a>
<a name="ln8937">        if (group == NULL) {</a>
<a name="ln8938">          return;</a>
<a name="ln8939">        }</a>
<a name="ln8940">        if (*group == '\0') {  // empty string means global group</a>
<a name="ln8941">          group = NULL;</a>
<a name="ln8942">        }</a>
<a name="ln8943">      }</a>
<a name="ln8944">    }</a>
<a name="ln8945">  }</a>
<a name="ln8946"> </a>
<a name="ln8947">  sign_get_placed(buf, lnum, sign_id, (const char_u *)group,</a>
<a name="ln8948">                  rettv-&gt;vval.v_list);</a>
<a name="ln8949">}</a>
<a name="ln8950"> </a>
<a name="ln8951">/// &quot;sign_jump()&quot; function</a>
<a name="ln8952">static void f_sign_jump(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8953">{</a>
<a name="ln8954">  int sign_id;</a>
<a name="ln8955">  char *sign_group = NULL;</a>
<a name="ln8956">  buf_T *buf;</a>
<a name="ln8957">  bool notanum = false;</a>
<a name="ln8958"> </a>
<a name="ln8959">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8960"> </a>
<a name="ln8961">  // Sign identifier</a>
<a name="ln8962">  sign_id = (int)tv_get_number_chk(&amp;argvars[0], &amp;notanum);</a>
<a name="ln8963">  if (notanum) {</a>
<a name="ln8964">    return;</a>
<a name="ln8965">  }</a>
<a name="ln8966">  if (sign_id &lt;= 0) {</a>
<a name="ln8967">    EMSG(_(e_invarg));</a>
<a name="ln8968">    return;</a>
<a name="ln8969">  }</a>
<a name="ln8970"> </a>
<a name="ln8971">  // Sign group</a>
<a name="ln8972">  const char * sign_group_chk = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8973">  if (sign_group_chk == NULL) {</a>
<a name="ln8974">    return;</a>
<a name="ln8975">  }</a>
<a name="ln8976">  if (sign_group_chk[0] == '\0') {</a>
<a name="ln8977">    sign_group = NULL;  // global sign group</a>
<a name="ln8978">  } else {</a>
<a name="ln8979">    sign_group = xstrdup(sign_group_chk);</a>
<a name="ln8980">  }</a>
<a name="ln8981"> </a>
<a name="ln8982">  // Buffer to place the sign</a>
<a name="ln8983">  buf = get_buf_arg(&amp;argvars[2]);</a>
<a name="ln8984">  if (buf == NULL) {</a>
<a name="ln8985">    goto cleanup;</a>
<a name="ln8986">  }</a>
<a name="ln8987"> </a>
<a name="ln8988">  rettv-&gt;vval.v_number = sign_jump(sign_id, (char_u *)sign_group, buf);</a>
<a name="ln8989"> </a>
<a name="ln8990">cleanup:</a>
<a name="ln8991">  xfree(sign_group);</a>
<a name="ln8992">}</a>
<a name="ln8993"> </a>
<a name="ln8994">/// &quot;sign_place()&quot; function</a>
<a name="ln8995">static void f_sign_place(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8996">{</a>
<a name="ln8997">  dict_T *dict = NULL;</a>
<a name="ln8998"> </a>
<a name="ln8999">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9000"> </a>
<a name="ln9001">  if (argvars[4].v_type != VAR_UNKNOWN</a>
<a name="ln9002">      &amp;&amp; (argvars[4].v_type != VAR_DICT</a>
<a name="ln9003">          || ((dict = argvars[4].vval.v_dict) == NULL))) {</a>
<a name="ln9004">    EMSG(_(e_dictreq));</a>
<a name="ln9005">    return;</a>
<a name="ln9006">  }</a>
<a name="ln9007"> </a>
<a name="ln9008">  rettv-&gt;vval.v_number = sign_place_from_dict(</a>
<a name="ln9009">      &amp;argvars[0], &amp;argvars[1], &amp;argvars[2], &amp;argvars[3], dict);</a>
<a name="ln9010">}</a>
<a name="ln9011"> </a>
<a name="ln9012">/// &quot;sign_placelist()&quot; function.  Place multiple signs.</a>
<a name="ln9013">static void f_sign_placelist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9014">{</a>
<a name="ln9015">  int sign_id;</a>
<a name="ln9016"> </a>
<a name="ln9017">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln9018"> </a>
<a name="ln9019">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln9020">    EMSG(_(e_listreq));</a>
<a name="ln9021">    return;</a>
<a name="ln9022">  }</a>
<a name="ln9023"> </a>
<a name="ln9024">  // Process the List of sign attributes</a>
<a name="ln9025">  TV_LIST_ITER_CONST(argvars[0].vval.v_list, li, {</a>
<a name="ln9026">    sign_id = -1;</a>
<a name="ln9027">    if (TV_LIST_ITEM_TV(li)-&gt;v_type == VAR_DICT) {</a>
<a name="ln9028">      sign_id = sign_place_from_dict(</a>
<a name="ln9029">          NULL, NULL, NULL, NULL, TV_LIST_ITEM_TV(li)-&gt;vval.v_dict);</a>
<a name="ln9030">    } else {</a>
<a name="ln9031">      EMSG(_(e_dictreq));</a>
<a name="ln9032">    }</a>
<a name="ln9033">    tv_list_append_number(rettv-&gt;vval.v_list, sign_id);</a>
<a name="ln9034">  });</a>
<a name="ln9035">}</a>
<a name="ln9036"> </a>
<a name="ln9037">/// &quot;sign_undefine()&quot; function</a>
<a name="ln9038">static void f_sign_undefine(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9039">{</a>
<a name="ln9040">  const char *name;</a>
<a name="ln9041"> </a>
<a name="ln9042">  if (argvars[0].v_type == VAR_LIST &amp;&amp; argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln9043">    // Undefine multiple signs</a>
<a name="ln9044">    tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln9045"> </a>
<a name="ln9046">    sign_undefine_multiple(argvars[0].vval.v_list, rettv-&gt;vval.v_list);</a>
<a name="ln9047">    return;</a>
<a name="ln9048">  }</a>
<a name="ln9049"> </a>
<a name="ln9050">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9051"> </a>
<a name="ln9052">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln9053">    // Free all the signs</a>
<a name="ln9054">    free_signs();</a>
<a name="ln9055">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln9056">  } else {</a>
<a name="ln9057">    // Free only the specified sign</a>
<a name="ln9058">    name = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln9059">    if (name == NULL) {</a>
<a name="ln9060">      return;</a>
<a name="ln9061">    }</a>
<a name="ln9062"> </a>
<a name="ln9063">    if (sign_undefine_by_name((const char_u *)name) == OK) {</a>
<a name="ln9064">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln9065">    }</a>
<a name="ln9066">  }</a>
<a name="ln9067">}</a>
<a name="ln9068"> </a>
<a name="ln9069">/// &quot;sign_unplace()&quot; function</a>
<a name="ln9070">static void f_sign_unplace(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9071">{</a>
<a name="ln9072">  dict_T *dict = NULL;</a>
<a name="ln9073"> </a>
<a name="ln9074">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9075"> </a>
<a name="ln9076">  if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln9077">    EMSG(_(e_invarg));</a>
<a name="ln9078">    return;</a>
<a name="ln9079">  }</a>
<a name="ln9080"> </a>
<a name="ln9081">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9082">    if (argvars[1].v_type != VAR_DICT) {</a>
<a name="ln9083">      EMSG(_(e_dictreq));</a>
<a name="ln9084">      return;</a>
<a name="ln9085">    }</a>
<a name="ln9086">    dict = argvars[1].vval.v_dict;</a>
<a name="ln9087">  }</a>
<a name="ln9088"> </a>
<a name="ln9089">  rettv-&gt;vval.v_number = sign_unplace_from_dict(&amp;argvars[0], dict);</a>
<a name="ln9090">}</a>
<a name="ln9091"> </a>
<a name="ln9092">/// &quot;sign_unplacelist()&quot; function</a>
<a name="ln9093">static void f_sign_unplacelist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9094">{</a>
<a name="ln9095">  int retval;</a>
<a name="ln9096"> </a>
<a name="ln9097">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln9098"> </a>
<a name="ln9099">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln9100">    EMSG(_(e_listreq));</a>
<a name="ln9101">    return;</a>
<a name="ln9102">  }</a>
<a name="ln9103"> </a>
<a name="ln9104">  TV_LIST_ITER_CONST(argvars[0].vval.v_list, li, {</a>
<a name="ln9105">    retval = -1;</a>
<a name="ln9106">    if (TV_LIST_ITEM_TV(li)-&gt;v_type == VAR_DICT) {</a>
<a name="ln9107">      retval = sign_unplace_from_dict(NULL, TV_LIST_ITEM_TV(li)-&gt;vval.v_dict);</a>
<a name="ln9108">    } else {</a>
<a name="ln9109">      EMSG(_(e_dictreq));</a>
<a name="ln9110">    }</a>
<a name="ln9111">    tv_list_append_number(rettv-&gt;vval.v_list, retval);</a>
<a name="ln9112">  });</a>
<a name="ln9113">}</a>
<a name="ln9114"> </a>
<a name="ln9115">/*</a>
<a name="ln9116"> * &quot;simplify()&quot; function</a>
<a name="ln9117"> */</a>
<a name="ln9118">static void f_simplify(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9119">{</a>
<a name="ln9120">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9121">  rettv-&gt;vval.v_string = (char_u *)xstrdup(p);</a>
<a name="ln9122">  simplify_filename(rettv-&gt;vval.v_string);  // Simplify in place.</a>
<a name="ln9123">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9124">}</a>
<a name="ln9125"> </a>
<a name="ln9126">/// &quot;sockconnect()&quot; function</a>
<a name="ln9127">static void f_sockconnect(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9128">{</a>
<a name="ln9129">  if (argvars[0].v_type != VAR_STRING || argvars[1].v_type != VAR_STRING) {</a>
<a name="ln9130">    EMSG(_(e_invarg));</a>
<a name="ln9131">    return;</a>
<a name="ln9132">  }</a>
<a name="ln9133">  if (argvars[2].v_type != VAR_DICT &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9134">    // Wrong argument types</a>
<a name="ln9135">    EMSG2(_(e_invarg2), &quot;expected dictionary&quot;);</a>
<a name="ln9136">    return;</a>
<a name="ln9137">  }</a>
<a name="ln9138"> </a>
<a name="ln9139">  const char *mode = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9140">  const char *address = tv_get_string(&amp;argvars[1]);</a>
<a name="ln9141"> </a>
<a name="ln9142">  bool tcp;</a>
<a name="ln9143">  if (strcmp(mode, &quot;tcp&quot;) == 0) {</a>
<a name="ln9144">    tcp = true;</a>
<a name="ln9145">  } else if (strcmp(mode, &quot;pipe&quot;) == 0) {</a>
<a name="ln9146">    tcp = false;</a>
<a name="ln9147">  } else {</a>
<a name="ln9148">    EMSG2(_(e_invarg2), &quot;invalid mode&quot;);</a>
<a name="ln9149">    return;</a>
<a name="ln9150">  }</a>
<a name="ln9151"> </a>
<a name="ln9152">  bool rpc = false;</a>
<a name="ln9153">  CallbackReader on_data = CALLBACK_READER_INIT;</a>
<a name="ln9154">  if (argvars[2].v_type == VAR_DICT) {</a>
<a name="ln9155">    dict_T *opts = argvars[2].vval.v_dict;</a>
<a name="ln9156">    rpc = tv_dict_get_number(opts, &quot;rpc&quot;) != 0;</a>
<a name="ln9157"> </a>
<a name="ln9158">    if (!tv_dict_get_callback(opts, S_LEN(&quot;on_data&quot;), &amp;on_data.cb)) {</a>
<a name="ln9159">      return;</a>
<a name="ln9160">    }</a>
<a name="ln9161">    on_data.buffered = tv_dict_get_number(opts, &quot;data_buffered&quot;);</a>
<a name="ln9162">    if (on_data.buffered &amp;&amp; on_data.cb.type == kCallbackNone) {</a>
<a name="ln9163">      on_data.self = opts;</a>
<a name="ln9164">    }</a>
<a name="ln9165">  }</a>
<a name="ln9166"> </a>
<a name="ln9167">  const char *error = NULL;</a>
<a name="ln9168">  uint64_t id = channel_connect(tcp, address, rpc, on_data, 50, &amp;error);</a>
<a name="ln9169"> </a>
<a name="ln9170">  if (error) {</a>
<a name="ln9171">    EMSG2(_(&quot;connection failed: %s&quot;), error);</a>
<a name="ln9172">  }</a>
<a name="ln9173"> </a>
<a name="ln9174">  rettv-&gt;vval.v_number = (varnumber_T)id;</a>
<a name="ln9175">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln9176">}</a>
<a name="ln9177"> </a>
<a name="ln9178">/// struct storing information about current sort</a>
<a name="ln9179">typedef struct {</a>
<a name="ln9180">  int item_compare_ic;</a>
<a name="ln9181">  bool item_compare_numeric;</a>
<a name="ln9182">  bool item_compare_numbers;</a>
<a name="ln9183">  bool item_compare_float;</a>
<a name="ln9184">  const char *item_compare_func;</a>
<a name="ln9185">  partial_T *item_compare_partial;</a>
<a name="ln9186">  dict_T *item_compare_selfdict;</a>
<a name="ln9187">  bool item_compare_func_err;</a>
<a name="ln9188">} sortinfo_T;</a>
<a name="ln9189">static sortinfo_T *sortinfo = NULL;</a>
<a name="ln9190"> </a>
<a name="ln9191">#define ITEM_COMPARE_FAIL 999</a>
<a name="ln9192"> </a>
<a name="ln9193">/*</a>
<a name="ln9194"> * Compare functions for f_sort() and f_uniq() below.</a>
<a name="ln9195"> */</a>
<a name="ln9196">static int item_compare(const void *s1, const void *s2, bool keep_zero)</a>
<a name="ln9197">{</a>
<a name="ln9198">  ListSortItem *const si1 = (ListSortItem *)s1;</a>
<a name="ln9199">  ListSortItem *const si2 = (ListSortItem *)s2;</a>
<a name="ln9200"> </a>
<a name="ln9201">  typval_T *const tv1 = TV_LIST_ITEM_TV(si1-&gt;item);</a>
<a name="ln9202">  typval_T *const tv2 = TV_LIST_ITEM_TV(si2-&gt;item);</a>
<a name="ln9203"> </a>
<a name="ln9204">  int res;</a>
<a name="ln9205"> </a>
<a name="ln9206">  if (sortinfo-&gt;item_compare_numbers) {</a>
<a name="ln9207">    const varnumber_T v1 = tv_get_number(tv1);</a>
<a name="ln9208">    const varnumber_T v2 = tv_get_number(tv2);</a>
<a name="ln9209"> </a>
<a name="ln9210">    res = v1 == v2 ? 0 : v1 &gt; v2 ? 1 : -1;</a>
<a name="ln9211">    goto item_compare_end;</a>
<a name="ln9212">  }</a>
<a name="ln9213"> </a>
<a name="ln9214">  if (sortinfo-&gt;item_compare_float) {</a>
<a name="ln9215">    const float_T v1 = tv_get_float(tv1);</a>
<a name="ln9216">    const float_T v2 = tv_get_float(tv2);</a>
<a name="ln9217"> </a>
<a name="ln9218">    res = v1 == v2 ? 0 : v1 &gt; v2 ? 1 : -1;</a>
<a name="ln9219">    goto item_compare_end;</a>
<a name="ln9220">  }</a>
<a name="ln9221"> </a>
<a name="ln9222">  char *tofree1 = NULL;</a>
<a name="ln9223">  char *tofree2 = NULL;</a>
<a name="ln9224">  char *p1;</a>
<a name="ln9225">  char *p2;</a>
<a name="ln9226"> </a>
<a name="ln9227">  // encode_tv2string() puts quotes around a string and allocates memory.  Don't</a>
<a name="ln9228">  // do that for string variables. Use a single quote when comparing with</a>
<a name="ln9229">  // a non-string to do what the docs promise.</a>
<a name="ln9230">  if (tv1-&gt;v_type == VAR_STRING) {</a>
<a name="ln9231">    if (tv2-&gt;v_type != VAR_STRING || sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln9232">      p1 = &quot;'&quot;;</a>
<a name="ln9233">    } else {</a>
<a name="ln9234">      p1 = (char *)tv1-&gt;vval.v_string;</a>
<a name="ln9235">    }</a>
<a name="ln9236">  } else {</a>
<a name="ln9237">    tofree1 = p1 = encode_tv2string(tv1, NULL);</a>
<a name="ln9238">  }</a>
<a name="ln9239">  if (tv2-&gt;v_type == VAR_STRING) {</a>
<a name="ln9240">    if (tv1-&gt;v_type != VAR_STRING || sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln9241">      p2 = &quot;'&quot;;</a>
<a name="ln9242">    } else {</a>
<a name="ln9243">      p2 = (char *)tv2-&gt;vval.v_string;</a>
<a name="ln9244">    }</a>
<a name="ln9245">  } else {</a>
<a name="ln9246">    tofree2 = p2 = encode_tv2string(tv2, NULL);</a>
<a name="ln9247">  }</a>
<a name="ln9248">  if (p1 == NULL) {</a>
<a name="ln9249">    p1 = &quot;&quot;;</a>
<a name="ln9250">  }</a>
<a name="ln9251">  if (p2 == NULL) {</a>
<a name="ln9252">    p2 = &quot;&quot;;</a>
<a name="ln9253">  }</a>
<a name="ln9254">  if (!sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln9255">    if (sortinfo-&gt;item_compare_ic) {</a>
<a name="ln9256">      res = STRICMP(p1, p2);</a>
<a name="ln9257">    } else {</a>
<a name="ln9258">      res = STRCMP(p1, p2);</a>
<a name="ln9259">    }</a>
<a name="ln9260">  } else {</a>
<a name="ln9261">    double n1, n2;</a>
<a name="ln9262">    n1 = strtod(p1, &amp;p1);</a>
<a name="ln9263">    n2 = strtod(p2, &amp;p2);</a>
<a name="ln9264">    res = n1 == n2 ? 0 : n1 &gt; n2 ? 1 : -1;</a>
<a name="ln9265">  }</a>
<a name="ln9266"> </a>
<a name="ln9267">  xfree(tofree1);</a>
<a name="ln9268">  xfree(tofree2);</a>
<a name="ln9269"> </a>
<a name="ln9270">item_compare_end:</a>
<a name="ln9271">  // When the result would be zero, compare the item indexes.  Makes the</a>
<a name="ln9272">  // sort stable.</a>
<a name="ln9273">  if (res == 0 &amp;&amp; !keep_zero) {</a>
<a name="ln9274">    // WARNING: When using uniq si1 and si2 are actually listitem_T **, no</a>
<a name="ln9275">    // indexes are there.</a>
<a name="ln9276">    res = si1-&gt;idx &gt; si2-&gt;idx ? 1 : -1;</a>
<a name="ln9277">  }</a>
<a name="ln9278">  return res;</a>
<a name="ln9279">}</a>
<a name="ln9280"> </a>
<a name="ln9281">static int item_compare_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9282">{</a>
<a name="ln9283">  return item_compare(s1, s2, true);</a>
<a name="ln9284">}</a>
<a name="ln9285"> </a>
<a name="ln9286">static int item_compare_not_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9287">{</a>
<a name="ln9288">  return item_compare(s1, s2, false);</a>
<a name="ln9289">}</a>
<a name="ln9290"> </a>
<a name="ln9291">static int item_compare2(const void *s1, const void *s2, bool keep_zero)</a>
<a name="ln9292">{</a>
<a name="ln9293">  ListSortItem *si1, *si2;</a>
<a name="ln9294">  int res;</a>
<a name="ln9295">  typval_T rettv;</a>
<a name="ln9296">  typval_T argv[3];</a>
<a name="ln9297">  int dummy;</a>
<a name="ln9298">  const char *func_name;</a>
<a name="ln9299">  partial_T *partial = sortinfo-&gt;item_compare_partial;</a>
<a name="ln9300"> </a>
<a name="ln9301">  // shortcut after failure in previous call; compare all items equal</a>
<a name="ln9302">  if (sortinfo-&gt;item_compare_func_err) {</a>
<a name="ln9303">    return 0;</a>
<a name="ln9304">  }</a>
<a name="ln9305"> </a>
<a name="ln9306">  si1 = (ListSortItem *)s1;</a>
<a name="ln9307">  si2 = (ListSortItem *)s2;</a>
<a name="ln9308"> </a>
<a name="ln9309">  if (partial == NULL) {</a>
<a name="ln9310">    func_name = sortinfo-&gt;item_compare_func;</a>
<a name="ln9311">  } else {</a>
<a name="ln9312">    func_name = (const char *)partial_name(partial);</a>
<a name="ln9313">  }</a>
<a name="ln9314"> </a>
<a name="ln9315">  // Copy the values.  This is needed to be able to set v_lock to VAR_FIXED</a>
<a name="ln9316">  // in the copy without changing the original list items.</a>
<a name="ln9317">  tv_copy(TV_LIST_ITEM_TV(si1-&gt;item), &amp;argv[0]);</a>
<a name="ln9318">  tv_copy(TV_LIST_ITEM_TV(si2-&gt;item), &amp;argv[1]);</a>
<a name="ln9319"> </a>
<a name="ln9320">  rettv.v_type = VAR_UNKNOWN;  // tv_clear() uses this</a>
<a name="ln9321">  res = call_func((const char_u *)func_name,</a>
<a name="ln9322">                  -1,</a>
<a name="ln9323">                  &amp;rettv, 2, argv, NULL, 0L, 0L, &amp;dummy, true,</a>
<a name="ln9324">                  partial, sortinfo-&gt;item_compare_selfdict);</a>
<a name="ln9325">  tv_clear(&amp;argv[0]);</a>
<a name="ln9326">  tv_clear(&amp;argv[1]);</a>
<a name="ln9327"> </a>
<a name="ln9328">  if (res == FAIL) {</a>
<a name="ln9329">    res = ITEM_COMPARE_FAIL;</a>
<a name="ln9330">  } else {</a>
<a name="ln9331">    res = tv_get_number_chk(&amp;rettv, &amp;sortinfo-&gt;item_compare_func_err);</a>
<a name="ln9332">  }</a>
<a name="ln9333">  if (sortinfo-&gt;item_compare_func_err) {</a>
<a name="ln9334">    res = ITEM_COMPARE_FAIL;  // return value has wrong type</a>
<a name="ln9335">  }</a>
<a name="ln9336">  tv_clear(&amp;rettv);</a>
<a name="ln9337"> </a>
<a name="ln9338">  // When the result would be zero, compare the pointers themselves.  Makes</a>
<a name="ln9339">  // the sort stable.</a>
<a name="ln9340">  if (res == 0 &amp;&amp; !keep_zero) {</a>
<a name="ln9341">    // WARNING: When using uniq si1 and si2 are actually listitem_T **, no</a>
<a name="ln9342">    // indexes are there.</a>
<a name="ln9343">    res = si1-&gt;idx &gt; si2-&gt;idx ? 1 : -1;</a>
<a name="ln9344">  }</a>
<a name="ln9345"> </a>
<a name="ln9346">  return res;</a>
<a name="ln9347">}</a>
<a name="ln9348"> </a>
<a name="ln9349">static int item_compare2_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9350">{</a>
<a name="ln9351">  return item_compare2(s1, s2, true);</a>
<a name="ln9352">}</a>
<a name="ln9353"> </a>
<a name="ln9354">static int item_compare2_not_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9355">{</a>
<a name="ln9356">  return item_compare2(s1, s2, false);</a>
<a name="ln9357">}</a>
<a name="ln9358"> </a>
<a name="ln9359">/*</a>
<a name="ln9360"> * &quot;sort({list})&quot; function</a>
<a name="ln9361"> */</a>
<a name="ln9362">static void do_sort_uniq(typval_T *argvars, typval_T *rettv, bool sort)</a>
<a name="ln9363">{</a>
<a name="ln9364">  ListSortItem  *ptrs;</a>
<a name="ln9365">  long len;</a>
<a name="ln9366">  long i;</a>
<a name="ln9367"> </a>
<a name="ln9368">  // Pointer to current info struct used in compare function. Save and restore</a>
<a name="ln9369">  // the current one for nested calls.</a>
<a name="ln9370">  sortinfo_T info;</a>
<a name="ln9371">  sortinfo_T *old_sortinfo = sortinfo;</a>
<a name="ln9372">  sortinfo = &amp;info;</a>
<a name="ln9373"> </a>
<a name="ln9374">  const char *const arg_errmsg = (sort</a>
<a name="ln9375">                                  ? N_(&quot;sort() argument&quot;)</a>
<a name="ln9376">                                  : N_(&quot;uniq() argument&quot;));</a>
<a name="ln9377"> </a>
<a name="ln9378">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln9379">    EMSG2(_(e_listarg), sort ? &quot;sort()&quot; : &quot;uniq()&quot;);</a>
<a name="ln9380">  } else {</a>
<a name="ln9381">    list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln9382">    if (tv_check_lock(tv_list_locked(l), arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln9383">      goto theend;</a>
<a name="ln9384">    }</a>
<a name="ln9385">    tv_list_set_ret(rettv, l);</a>
<a name="ln9386"> </a>
<a name="ln9387">    len = tv_list_len(l);</a>
<a name="ln9388">    if (len &lt;= 1) {</a>
<a name="ln9389">      goto theend;  // short list sorts pretty quickly</a>
<a name="ln9390">    }</a>
<a name="ln9391"> </a>
<a name="ln9392">    info.item_compare_ic = false;</a>
<a name="ln9393">    info.item_compare_numeric = false;</a>
<a name="ln9394">    info.item_compare_numbers = false;</a>
<a name="ln9395">    info.item_compare_float = false;</a>
<a name="ln9396">    info.item_compare_func = NULL;</a>
<a name="ln9397">    info.item_compare_partial = NULL;</a>
<a name="ln9398">    info.item_compare_selfdict = NULL;</a>
<a name="ln9399"> </a>
<a name="ln9400">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9401">      // optional second argument: {func}</a>
<a name="ln9402">      if (argvars[1].v_type == VAR_FUNC) {</a>
<a name="ln9403">        info.item_compare_func = (const char *)argvars[1].vval.v_string;</a>
<a name="ln9404">      } else if (argvars[1].v_type == VAR_PARTIAL) {</a>
<a name="ln9405">        info.item_compare_partial = argvars[1].vval.v_partial;</a>
<a name="ln9406">      } else {</a>
<a name="ln9407">        bool error = false;</a>
<a name="ln9408"> </a>
<a name="ln9409">        i = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln9410">        if (error) {</a>
<a name="ln9411">          goto theend;  // type error; errmsg already given</a>
<a name="ln9412">        }</a>
<a name="ln9413">        if (i == 1) {</a>
<a name="ln9414">          info.item_compare_ic = true;</a>
<a name="ln9415">        } else if (argvars[1].v_type != VAR_NUMBER) {</a>
<a name="ln9416">          info.item_compare_func = tv_get_string(&amp;argvars[1]);</a>
<a name="ln9417">        } else if (i != 0) {</a>
<a name="ln9418">          EMSG(_(e_invarg));</a>
<a name="ln9419">          goto theend;</a>
<a name="ln9420">        }</a>
<a name="ln9421">        if (info.item_compare_func != NULL) {</a>
<a name="ln9422">          if (*info.item_compare_func == NUL) {</a>
<a name="ln9423">            // empty string means default sort</a>
<a name="ln9424">            info.item_compare_func = NULL;</a>
<a name="ln9425">          } else if (strcmp(info.item_compare_func, &quot;n&quot;) == 0) {</a>
<a name="ln9426">            info.item_compare_func = NULL;</a>
<a name="ln9427">            info.item_compare_numeric = true;</a>
<a name="ln9428">          } else if (strcmp(info.item_compare_func, &quot;N&quot;) == 0) {</a>
<a name="ln9429">            info.item_compare_func = NULL;</a>
<a name="ln9430">            info.item_compare_numbers = true;</a>
<a name="ln9431">          } else if (strcmp(info.item_compare_func, &quot;f&quot;) == 0) {</a>
<a name="ln9432">            info.item_compare_func = NULL;</a>
<a name="ln9433">            info.item_compare_float = true;</a>
<a name="ln9434">          } else if (strcmp(info.item_compare_func, &quot;i&quot;) == 0) {</a>
<a name="ln9435">            info.item_compare_func = NULL;</a>
<a name="ln9436">            info.item_compare_ic = true;</a>
<a name="ln9437">          }</a>
<a name="ln9438">        }</a>
<a name="ln9439">      }</a>
<a name="ln9440"> </a>
<a name="ln9441">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9442">        // optional third argument: {dict}</a>
<a name="ln9443">        if (argvars[2].v_type != VAR_DICT) {</a>
<a name="ln9444">          EMSG(_(e_dictreq));</a>
<a name="ln9445">          goto theend;</a>
<a name="ln9446">        }</a>
<a name="ln9447">        info.item_compare_selfdict = argvars[2].vval.v_dict;</a>
<a name="ln9448">      }</a>
<a name="ln9449">    }</a>
<a name="ln9450"> </a>
<a name="ln9451">    // Make an array with each entry pointing to an item in the List.</a>
<a name="ln9452">    ptrs = xmalloc((size_t)(len * sizeof(ListSortItem)));</a>
<a name="ln9453"> </a>
<a name="ln9454">    if (sort) {</a>
<a name="ln9455">      info.item_compare_func_err = false;</a>
<a name="ln9456">      tv_list_item_sort(l, ptrs,</a>
<a name="ln9457">                        ((info.item_compare_func == NULL</a>
<a name="ln9458">                          &amp;&amp; info.item_compare_partial == NULL)</a>
<a name="ln9459">                         ? item_compare_not_keeping_zero</a>
<a name="ln9460">                         : item_compare2_not_keeping_zero),</a>
<a name="ln9461">                        &amp;info.item_compare_func_err);</a>
<a name="ln9462">      if (info.item_compare_func_err) {</a>
<a name="ln9463">        EMSG(_(&quot;E702: Sort compare function failed&quot;));</a>
<a name="ln9464">      }</a>
<a name="ln9465">    } else {</a>
<a name="ln9466">      ListSorter item_compare_func_ptr;</a>
<a name="ln9467"> </a>
<a name="ln9468">      // f_uniq(): ptrs will be a stack of items to remove.</a>
<a name="ln9469">      info.item_compare_func_err = false;</a>
<a name="ln9470">      if (info.item_compare_func != NULL</a>
<a name="ln9471">          || info.item_compare_partial != NULL) {</a>
<a name="ln9472">        item_compare_func_ptr = item_compare2_keeping_zero;</a>
<a name="ln9473">      } else {</a>
<a name="ln9474">        item_compare_func_ptr = item_compare_keeping_zero;</a>
<a name="ln9475">      }</a>
<a name="ln9476"> </a>
<a name="ln9477">      int idx = 0;</a>
<a name="ln9478">      for (listitem_T *li = TV_LIST_ITEM_NEXT(l, tv_list_first(l))</a>
<a name="ln9479">           ; li != NULL;) {</a>
<a name="ln9480">        listitem_T *const prev_li = TV_LIST_ITEM_PREV(l, li);</a>
<a name="ln9481">        if (item_compare_func_ptr(&amp;prev_li, &amp;li) == 0) {</a>
<a name="ln9482">          if (info.item_compare_func_err) {  // -V547</a>
<a name="ln9483">            EMSG(_(&quot;E882: Uniq compare function failed&quot;));</a>
<a name="ln9484">            break;</a>
<a name="ln9485">          }</a>
<a name="ln9486">          li = tv_list_item_remove(l, li);</a>
<a name="ln9487">        } else {</a>
<a name="ln9488">          idx++;</a>
<a name="ln9489">          li = TV_LIST_ITEM_NEXT(l, li);</a>
<a name="ln9490">        }</a>
<a name="ln9491">      }</a>
<a name="ln9492">    }</a>
<a name="ln9493"> </a>
<a name="ln9494">    xfree(ptrs);</a>
<a name="ln9495">  }</a>
<a name="ln9496"> </a>
<a name="ln9497">theend:</a>
<a name="ln9498">  sortinfo = old_sortinfo;</a>
<a name="ln9499">}</a>
<a name="ln9500"> </a>
<a name="ln9501">/// &quot;sort&quot;({list})&quot; function</a>
<a name="ln9502">static void f_sort(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9503">{</a>
<a name="ln9504">  do_sort_uniq(argvars, rettv, true);</a>
<a name="ln9505">}</a>
<a name="ln9506"> </a>
<a name="ln9507">/// &quot;stdioopen()&quot; function</a>
<a name="ln9508">static void f_stdioopen(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9509">{</a>
<a name="ln9510">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln9511">    EMSG(_(e_invarg));</a>
<a name="ln9512">    return;</a>
<a name="ln9513">  }</a>
<a name="ln9514"> </a>
<a name="ln9515"> </a>
<a name="ln9516">  bool rpc = false;</a>
<a name="ln9517">  CallbackReader on_stdin = CALLBACK_READER_INIT;</a>
<a name="ln9518">  dict_T *opts = argvars[0].vval.v_dict;</a>
<a name="ln9519">  rpc = tv_dict_get_number(opts, &quot;rpc&quot;) != 0;</a>
<a name="ln9520"> </a>
<a name="ln9521">  if (!tv_dict_get_callback(opts, S_LEN(&quot;on_stdin&quot;), &amp;on_stdin.cb)) {</a>
<a name="ln9522">    return;</a>
<a name="ln9523">  }</a>
<a name="ln9524">  on_stdin.buffered = tv_dict_get_number(opts, &quot;stdin_buffered&quot;);</a>
<a name="ln9525">  if (on_stdin.buffered &amp;&amp; on_stdin.cb.type == kCallbackNone) {</a>
<a name="ln9526">    on_stdin.self = opts;</a>
<a name="ln9527">  }</a>
<a name="ln9528"> </a>
<a name="ln9529">  const char *error;</a>
<a name="ln9530">  uint64_t id = channel_from_stdio(rpc, on_stdin, &amp;error);</a>
<a name="ln9531">  if (!id) {</a>
<a name="ln9532">    EMSG2(e_stdiochan2, error);</a>
<a name="ln9533">  }</a>
<a name="ln9534"> </a>
<a name="ln9535"> </a>
<a name="ln9536">  rettv-&gt;vval.v_number = (varnumber_T)id;</a>
<a name="ln9537">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln9538">}</a>
<a name="ln9539"> </a>
<a name="ln9540">/// &quot;uniq({list})&quot; function</a>
<a name="ln9541">static void f_uniq(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9542">{</a>
<a name="ln9543">  do_sort_uniq(argvars, rettv, false);</a>
<a name="ln9544">}</a>
<a name="ln9545"> </a>
<a name="ln9546">// &quot;reltimefloat()&quot; function</a>
<a name="ln9547">static void f_reltimefloat(typval_T *argvars , typval_T *rettv, FunPtr fptr)</a>
<a name="ln9548">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln9549">{</a>
<a name="ln9550">  proftime_T tm;</a>
<a name="ln9551"> </a>
<a name="ln9552">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln9553">  rettv-&gt;vval.v_float = 0;</a>
<a name="ln9554">  if (list2proftime(&amp;argvars[0], &amp;tm) == OK) {</a>
<a name="ln9555">    rettv-&gt;vval.v_float = (float_T)profile_signed(tm) / 1000000000.0;</a>
<a name="ln9556">  }</a>
<a name="ln9557">}</a>
<a name="ln9558"> </a>
<a name="ln9559">/*</a>
<a name="ln9560"> * &quot;soundfold({word})&quot; function</a>
<a name="ln9561"> */</a>
<a name="ln9562">static void f_soundfold(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9563">{</a>
<a name="ln9564">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9565">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9566">  rettv-&gt;vval.v_string = (char_u *)eval_soundfold(s);</a>
<a name="ln9567">}</a>
<a name="ln9568"> </a>
<a name="ln9569">/*</a>
<a name="ln9570"> * &quot;spellbadword()&quot; function</a>
<a name="ln9571"> */</a>
<a name="ln9572">static void f_spellbadword(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9573">{</a>
<a name="ln9574">  const char *word = &quot;&quot;;</a>
<a name="ln9575">  hlf_T attr = HLF_COUNT;</a>
<a name="ln9576">  size_t len = 0;</a>
<a name="ln9577"> </a>
<a name="ln9578">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln9579">    // Find the start and length of the badly spelled word.</a>
<a name="ln9580">    len = spell_move_to(curwin, FORWARD, true, true, &amp;attr);</a>
<a name="ln9581">    if (len != 0) {</a>
<a name="ln9582">      word = (char *)get_cursor_pos_ptr();</a>
<a name="ln9583">      curwin-&gt;w_set_curswant = true;</a>
<a name="ln9584">    }</a>
<a name="ln9585">  } else if (curwin-&gt;w_p_spell &amp;&amp; *curbuf-&gt;b_s.b_p_spl != NUL) {</a>
<a name="ln9586">    const char *str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln9587">    int capcol = -1;</a>
<a name="ln9588"> </a>
<a name="ln9589">    if (str != NULL) {</a>
<a name="ln9590">      // Check the argument for spelling.</a>
<a name="ln9591">      while (*str != NUL) {</a>
<a name="ln9592">        len = spell_check(curwin, (char_u *)str, &amp;attr, &amp;capcol, false);</a>
<a name="ln9593">        if (attr != HLF_COUNT) {</a>
<a name="ln9594">          word = str;</a>
<a name="ln9595">          break;</a>
<a name="ln9596">        }</a>
<a name="ln9597">        str += len;</a>
<a name="ln9598">        capcol -= len;</a>
<a name="ln9599">        len = 0;</a>
<a name="ln9600">      }</a>
<a name="ln9601">    }</a>
<a name="ln9602">  }</a>
<a name="ln9603"> </a>
<a name="ln9604">  assert(len &lt;= INT_MAX);</a>
<a name="ln9605">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln9606">  tv_list_append_string(rettv-&gt;vval.v_list, word, len);</a>
<a name="ln9607">  tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln9608">                        (attr == HLF_SPB ? &quot;bad&quot;</a>
<a name="ln9609">                         : attr == HLF_SPR ? &quot;rare&quot;</a>
<a name="ln9610">                         : attr == HLF_SPL ? &quot;local&quot;</a>
<a name="ln9611">                         : attr == HLF_SPC ? &quot;caps&quot;</a>
<a name="ln9612">                         : NULL), -1);</a>
<a name="ln9613">}</a>
<a name="ln9614"> </a>
<a name="ln9615">/*</a>
<a name="ln9616"> * &quot;spellsuggest()&quot; function</a>
<a name="ln9617"> */</a>
<a name="ln9618">static void f_spellsuggest(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9619">{</a>
<a name="ln9620">  bool typeerr = false;</a>
<a name="ln9621">  int maxcount;</a>
<a name="ln9622">  garray_T ga = GA_EMPTY_INIT_VALUE;</a>
<a name="ln9623">  bool need_capital = false;</a>
<a name="ln9624"> </a>
<a name="ln9625">  if (curwin-&gt;w_p_spell &amp;&amp; *curwin-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln9626">    const char *const str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9627">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9628">      maxcount = tv_get_number_chk(&amp;argvars[1], &amp;typeerr);</a>
<a name="ln9629">      if (maxcount &lt;= 0) {</a>
<a name="ln9630">        goto f_spellsuggest_return;</a>
<a name="ln9631">      }</a>
<a name="ln9632">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9633">        need_capital = tv_get_number_chk(&amp;argvars[2], &amp;typeerr);</a>
<a name="ln9634">        if (typeerr) {</a>
<a name="ln9635">          goto f_spellsuggest_return;</a>
<a name="ln9636">        }</a>
<a name="ln9637">      }</a>
<a name="ln9638">    } else {</a>
<a name="ln9639">      maxcount = 25;</a>
<a name="ln9640">    }</a>
<a name="ln9641"> </a>
<a name="ln9642">    spell_suggest_list(&amp;ga, (char_u *)str, maxcount, need_capital, false);</a>
<a name="ln9643">  }</a>
<a name="ln9644"> </a>
<a name="ln9645">f_spellsuggest_return:</a>
<a name="ln9646">  tv_list_alloc_ret(rettv, (ptrdiff_t)ga.ga_len);</a>
<a name="ln9647">  for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln9648">    char *const p = ((char **)ga.ga_data)[i];</a>
<a name="ln9649">    tv_list_append_allocated_string(rettv-&gt;vval.v_list, p);</a>
<a name="ln9650">  }</a>
<a name="ln9651">  ga_clear(&amp;ga);</a>
<a name="ln9652">}</a>
<a name="ln9653"> </a>
<a name="ln9654">static void f_split(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9655">{</a>
<a name="ln9656">  char_u      *save_cpo;</a>
<a name="ln9657">  int match;</a>
<a name="ln9658">  colnr_T col = 0;</a>
<a name="ln9659">  bool keepempty = false;</a>
<a name="ln9660">  bool typeerr = false;</a>
<a name="ln9661"> </a>
<a name="ln9662">  // Make 'cpoptions' empty, the 'l' flag should not be used here.</a>
<a name="ln9663">  save_cpo = p_cpo;</a>
<a name="ln9664">  p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln9665"> </a>
<a name="ln9666">  const char *str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9667">  const char *pat = NULL;</a>
<a name="ln9668">  char patbuf[NUMBUFLEN];</a>
<a name="ln9669">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9670">    pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln9671">    if (pat == NULL) {</a>
<a name="ln9672">      typeerr = true;</a>
<a name="ln9673">    }</a>
<a name="ln9674">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9675">      keepempty = (bool)tv_get_number_chk(&amp;argvars[2], &amp;typeerr);</a>
<a name="ln9676">    }</a>
<a name="ln9677">  }</a>
<a name="ln9678">  if (pat == NULL || *pat == NUL) {</a>
<a name="ln9679">    pat = &quot;[\\x01- ]\\+&quot;;</a>
<a name="ln9680">  }</a>
<a name="ln9681"> </a>
<a name="ln9682">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln9683"> </a>
<a name="ln9684">  if (typeerr) {</a>
<a name="ln9685">    goto theend;</a>
<a name="ln9686">  }</a>
<a name="ln9687"> </a>
<a name="ln9688">  regmatch_T regmatch = {</a>
<a name="ln9689">    .regprog = vim_regcomp((char_u *)pat, RE_MAGIC + RE_STRING),</a>
<a name="ln9690">    .startp = { NULL },</a>
<a name="ln9691">    .endp = { NULL },</a>
<a name="ln9692">    .rm_ic = false,</a>
<a name="ln9693">  };</a>
<a name="ln9694">  if (regmatch.regprog != NULL) {</a>
<a name="ln9695">    while (*str != NUL || keepempty) {</a>
<a name="ln9696">      if (*str == NUL) {</a>
<a name="ln9697">        match = false;  // Empty item at the end.</a>
<a name="ln9698">      } else {</a>
<a name="ln9699">        match = vim_regexec_nl(&amp;regmatch, (char_u *)str, col);</a>
<a name="ln9700">      }</a>
<a name="ln9701">      const char *end;</a>
<a name="ln9702">      if (match) {</a>
<a name="ln9703">        end = (const char *)regmatch.startp[0];</a>
<a name="ln9704">      } else {</a>
<a name="ln9705">        end = str + strlen(str);</a>
<a name="ln9706">      }</a>
<a name="ln9707">      if (keepempty || end &gt; str || (tv_list_len(rettv-&gt;vval.v_list) &gt; 0</a>
<a name="ln9708">                                     &amp;&amp; *str != NUL</a>
<a name="ln9709">                                     &amp;&amp; match</a>
<a name="ln9710">                                     &amp;&amp; end &lt; (const char *)regmatch.endp[0])) {</a>
<a name="ln9711">        tv_list_append_string(rettv-&gt;vval.v_list, str, end - str);</a>
<a name="ln9712">      }</a>
<a name="ln9713">      if (!match) {</a>
<a name="ln9714">        break;</a>
<a name="ln9715">      }</a>
<a name="ln9716">      // Advance to just after the match.</a>
<a name="ln9717">      if (regmatch.endp[0] &gt; (char_u *)str) {</a>
<a name="ln9718">        col = 0;</a>
<a name="ln9719">      } else {</a>
<a name="ln9720">        // Don't get stuck at the same match.</a>
<a name="ln9721">        col = (*mb_ptr2len)(regmatch.endp[0]);</a>
<a name="ln9722">      }</a>
<a name="ln9723">      str = (const char *)regmatch.endp[0];</a>
<a name="ln9724">    }</a>
<a name="ln9725"> </a>
<a name="ln9726">    vim_regfree(regmatch.regprog);</a>
<a name="ln9727">  }</a>
<a name="ln9728"> </a>
<a name="ln9729">theend:</a>
<a name="ln9730">  p_cpo = save_cpo;</a>
<a name="ln9731">}</a>
<a name="ln9732"> </a>
<a name="ln9733">/// &quot;stdpath(type)&quot; function</a>
<a name="ln9734">static void f_stdpath(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9735">{</a>
<a name="ln9736">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9737">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln9738"> </a>
<a name="ln9739">  const char *const p = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln9740">  if (p == NULL) {</a>
<a name="ln9741">    return;  // Type error; errmsg already given.</a>
<a name="ln9742">  }</a>
<a name="ln9743"> </a>
<a name="ln9744">  if (strequal(p, &quot;config&quot;)) {</a>
<a name="ln9745">    rettv-&gt;vval.v_string = (char_u *)get_xdg_home(kXDGConfigHome);</a>
<a name="ln9746">  } else if (strequal(p, &quot;data&quot;)) {</a>
<a name="ln9747">    rettv-&gt;vval.v_string = (char_u *)get_xdg_home(kXDGDataHome);</a>
<a name="ln9748">  } else if (strequal(p, &quot;cache&quot;)) {</a>
<a name="ln9749">    rettv-&gt;vval.v_string = (char_u *)get_xdg_home(kXDGCacheHome);</a>
<a name="ln9750">  } else if (strequal(p, &quot;config_dirs&quot;)) {</a>
<a name="ln9751">    get_xdg_var_list(kXDGConfigDirs, rettv);</a>
<a name="ln9752">  } else if (strequal(p, &quot;data_dirs&quot;)) {</a>
<a name="ln9753">    get_xdg_var_list(kXDGDataDirs, rettv);</a>
<a name="ln9754">  } else {</a>
<a name="ln9755">    EMSG2(_(&quot;E6100: \&quot;%s\&quot; is not a valid stdpath&quot;), p);</a>
<a name="ln9756">  }</a>
<a name="ln9757">}</a>
<a name="ln9758"> </a>
<a name="ln9759">/*</a>
<a name="ln9760"> * &quot;str2float()&quot; function</a>
<a name="ln9761"> */</a>
<a name="ln9762">static void f_str2float(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9763">{</a>
<a name="ln9764">  char_u *p = skipwhite((const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln9765">  bool isneg = (*p == '-');</a>
<a name="ln9766"> </a>
<a name="ln9767">  if (*p == '+' || *p == '-') {</a>
<a name="ln9768">    p = skipwhite(p + 1);</a>
<a name="ln9769">  }</a>
<a name="ln9770">  (void)string2float((char *)p, &amp;rettv-&gt;vval.v_float);</a>
<a name="ln9771">  if (isneg) {</a>
<a name="ln9772">    rettv-&gt;vval.v_float *= -1;</a>
<a name="ln9773">  }</a>
<a name="ln9774">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln9775">}</a>
<a name="ln9776"> </a>
<a name="ln9777">// &quot;str2list()&quot; function</a>
<a name="ln9778">static void f_str2list(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9779">{</a>
<a name="ln9780">  tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln9781">  const char_u *p = (const char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln9782"> </a>
<a name="ln9783">  for (; *p != NUL; p += utf_ptr2len(p)) {</a>
<a name="ln9784">    tv_list_append_number(rettv-&gt;vval.v_list, utf_ptr2char(p));</a>
<a name="ln9785">  }</a>
<a name="ln9786">}</a>
<a name="ln9787"> </a>
<a name="ln9788">// &quot;str2nr()&quot; function</a>
<a name="ln9789">static void f_str2nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9790">{</a>
<a name="ln9791">  int base = 10;</a>
<a name="ln9792">  varnumber_T n;</a>
<a name="ln9793">  int what;</a>
<a name="ln9794"> </a>
<a name="ln9795">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9796">    base = tv_get_number(&amp;argvars[1]);</a>
<a name="ln9797">    if (base != 2 &amp;&amp; base != 8 &amp;&amp; base != 10 &amp;&amp; base != 16) {</a>
<a name="ln9798">      EMSG(_(e_invarg));</a>
<a name="ln9799">      return;</a>
<a name="ln9800">    }</a>
<a name="ln9801">  }</a>
<a name="ln9802"> </a>
<a name="ln9803">  char_u *p = skipwhite((const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln9804">  bool isneg = (*p == '-');</a>
<a name="ln9805">  if (*p == '+' || *p == '-') {</a>
<a name="ln9806">    p = skipwhite(p + 1);</a>
<a name="ln9807">  }</a>
<a name="ln9808">  switch (base) {</a>
<a name="ln9809">    case 2: {</a>
<a name="ln9810">      what = STR2NR_BIN | STR2NR_FORCE;</a>
<a name="ln9811">      break;</a>
<a name="ln9812">    }</a>
<a name="ln9813">    case 8: {</a>
<a name="ln9814">      what = STR2NR_OCT | STR2NR_FORCE;</a>
<a name="ln9815">      break;</a>
<a name="ln9816">    }</a>
<a name="ln9817">    case 16: {</a>
<a name="ln9818">      what = STR2NR_HEX | STR2NR_FORCE;</a>
<a name="ln9819">      break;</a>
<a name="ln9820">    }</a>
<a name="ln9821">    default: {</a>
<a name="ln9822">      what = 0;</a>
<a name="ln9823">    }</a>
<a name="ln9824">  }</a>
<a name="ln9825">  vim_str2nr(p, NULL, NULL, what, &amp;n, NULL, 0);</a>
<a name="ln9826">  if (isneg) {</a>
<a name="ln9827">    rettv-&gt;vval.v_number = -n;</a>
<a name="ln9828">  } else {</a>
<a name="ln9829">    rettv-&gt;vval.v_number = n;</a>
<a name="ln9830">  }</a>
<a name="ln9831">}</a>
<a name="ln9832"> </a>
<a name="ln9833">/*</a>
<a name="ln9834"> * &quot;strftime({format}[, {time}])&quot; function</a>
<a name="ln9835"> */</a>
<a name="ln9836">static void f_strftime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9837">{</a>
<a name="ln9838">  time_t seconds;</a>
<a name="ln9839"> </a>
<a name="ln9840">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9841"> </a>
<a name="ln9842">  char *p = (char *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln9843">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln9844">    seconds = time(NULL);</a>
<a name="ln9845">  } else {</a>
<a name="ln9846">    seconds = (time_t)tv_get_number(&amp;argvars[1]);</a>
<a name="ln9847">  }</a>
<a name="ln9848"> </a>
<a name="ln9849">  struct tm curtime;</a>
<a name="ln9850">  struct tm *curtime_ptr = os_localtime_r(&amp;seconds, &amp;curtime);</a>
<a name="ln9851">  // MSVC returns NULL for an invalid value of seconds.</a>
<a name="ln9852">  if (curtime_ptr == NULL) {</a>
<a name="ln9853">    rettv-&gt;vval.v_string = vim_strsave((char_u *)_(&quot;(Invalid)&quot;));</a>
<a name="ln9854">  } else {</a>
<a name="ln9855">    vimconv_T conv;</a>
<a name="ln9856">    char_u      *enc;</a>
<a name="ln9857"> </a>
<a name="ln9858">    conv.vc_type = CONV_NONE;</a>
<a name="ln9859">    enc = enc_locale();</a>
<a name="ln9860">    convert_setup(&amp;conv, p_enc, enc);</a>
<a name="ln9861">    if (conv.vc_type != CONV_NONE) {</a>
<a name="ln9862">      p = (char *)string_convert(&amp;conv, (char_u *)p, NULL);</a>
<a name="ln9863">    }</a>
<a name="ln9864">    char result_buf[256];</a>
<a name="ln9865">    if (p != NULL) {</a>
<a name="ln9866">      (void)strftime(result_buf, sizeof(result_buf), p, curtime_ptr);</a>
<a name="ln9867">    } else {</a>
<a name="ln9868">      result_buf[0] = NUL;</a>
<a name="ln9869">    }</a>
<a name="ln9870"> </a>
<a name="ln9871">    if (conv.vc_type != CONV_NONE) {</a>
<a name="ln9872">      xfree(p);</a>
<a name="ln9873">    }</a>
<a name="ln9874">    convert_setup(&amp;conv, enc, p_enc);</a>
<a name="ln9875">    if (conv.vc_type != CONV_NONE) {</a>
<a name="ln9876">      rettv-&gt;vval.v_string = string_convert(&amp;conv, (char_u *)result_buf, NULL);</a>
<a name="ln9877">    } else {</a>
<a name="ln9878">      rettv-&gt;vval.v_string = (char_u *)xstrdup(result_buf);</a>
<a name="ln9879">    }</a>
<a name="ln9880"> </a>
<a name="ln9881">    // Release conversion descriptors.</a>
<a name="ln9882">    convert_setup(&amp;conv, NULL, NULL);</a>
<a name="ln9883">    xfree(enc);</a>
<a name="ln9884">  }</a>
<a name="ln9885">}</a>
<a name="ln9886"> </a>
<a name="ln9887">// &quot;strgetchar()&quot; function</a>
<a name="ln9888">static void f_strgetchar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9889">{</a>
<a name="ln9890">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9891"> </a>
<a name="ln9892">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln9893">  if (str == NULL) {</a>
<a name="ln9894">    return;</a>
<a name="ln9895">  }</a>
<a name="ln9896">  bool error = false;</a>
<a name="ln9897">  varnumber_T charidx = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln9898">  if (error) {</a>
<a name="ln9899">    return;</a>
<a name="ln9900">  }</a>
<a name="ln9901"> </a>
<a name="ln9902">  const size_t len = STRLEN(str);</a>
<a name="ln9903">  size_t byteidx = 0;</a>
<a name="ln9904"> </a>
<a name="ln9905">  while (charidx &gt;= 0 &amp;&amp; byteidx &lt; len) {</a>
<a name="ln9906">    if (charidx == 0) {</a>
<a name="ln9907">      rettv-&gt;vval.v_number = utf_ptr2char((const char_u *)str + byteidx);</a>
<a name="ln9908">      break;</a>
<a name="ln9909">    }</a>
<a name="ln9910">    charidx--;</a>
<a name="ln9911">    byteidx += MB_CPTR2LEN((const char_u *)str + byteidx);</a>
<a name="ln9912">  }</a>
<a name="ln9913">}</a>
<a name="ln9914"> </a>
<a name="ln9915">/*</a>
<a name="ln9916"> * &quot;stridx()&quot; function</a>
<a name="ln9917"> */</a>
<a name="ln9918">static void f_stridx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9919">{</a>
<a name="ln9920">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9921"> </a>
<a name="ln9922">  char buf[NUMBUFLEN];</a>
<a name="ln9923">  const char *const needle = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln9924">  const char *haystack = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln9925">  const char *const haystack_start = haystack;</a>
<a name="ln9926">  if (needle == NULL || haystack == NULL) {</a>
<a name="ln9927">    return;  // Type error; errmsg already given.</a>
<a name="ln9928">  }</a>
<a name="ln9929"> </a>
<a name="ln9930">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9931">    bool error = false;</a>
<a name="ln9932"> </a>
<a name="ln9933">    const ptrdiff_t start_idx = (ptrdiff_t)tv_get_number_chk(&amp;argvars[2],</a>
<a name="ln9934">                                                             &amp;error);</a>
<a name="ln9935">    if (error || start_idx &gt;= (ptrdiff_t)strlen(haystack)) {</a>
<a name="ln9936">      return;</a>
<a name="ln9937">    }</a>
<a name="ln9938">    if (start_idx &gt;= 0) {</a>
<a name="ln9939">      haystack += start_idx;</a>
<a name="ln9940">    }</a>
<a name="ln9941">  }</a>
<a name="ln9942"> </a>
<a name="ln9943">  const char *pos = strstr(haystack, needle);</a>
<a name="ln9944">  if (pos != NULL) {</a>
<a name="ln9945">    rettv-&gt;vval.v_number = (varnumber_T)(pos - haystack_start);</a>
<a name="ln9946">  }</a>
<a name="ln9947">}</a>
<a name="ln9948"> </a>
<a name="ln9949">/*</a>
<a name="ln9950"> * &quot;string()&quot; function</a>
<a name="ln9951"> */</a>
<a name="ln9952">void f_string(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9953">{</a>
<a name="ln9954">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9955">  rettv-&gt;vval.v_string = (char_u *)encode_tv2string(&amp;argvars[0], NULL);</a>
<a name="ln9956">}</a>
<a name="ln9957"> </a>
<a name="ln9958">/*</a>
<a name="ln9959"> * &quot;strlen()&quot; function</a>
<a name="ln9960"> */</a>
<a name="ln9961">static void f_strlen(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9962">{</a>
<a name="ln9963">  rettv-&gt;vval.v_number = (varnumber_T)strlen(tv_get_string(&amp;argvars[0]));</a>
<a name="ln9964">}</a>
<a name="ln9965"> </a>
<a name="ln9966">/*</a>
<a name="ln9967"> * &quot;strchars()&quot; function</a>
<a name="ln9968"> */</a>
<a name="ln9969">static void f_strchars(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9970">{</a>
<a name="ln9971">  const char *s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9972">  int skipcc = 0;</a>
<a name="ln9973">  varnumber_T len = 0;</a>
<a name="ln9974">  int (*func_mb_ptr2char_adv)(const char_u **pp);</a>
<a name="ln9975"> </a>
<a name="ln9976">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9977">    skipcc = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln9978">  }</a>
<a name="ln9979">  if (skipcc &lt; 0 || skipcc &gt; 1) {</a>
<a name="ln9980">    EMSG(_(e_invarg));</a>
<a name="ln9981">  } else {</a>
<a name="ln9982">    func_mb_ptr2char_adv = skipcc ? mb_ptr2char_adv : mb_cptr2char_adv;</a>
<a name="ln9983">    while (*s != NUL) {</a>
<a name="ln9984">      func_mb_ptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln9985">      len++;</a>
<a name="ln9986">    }</a>
<a name="ln9987">    rettv-&gt;vval.v_number = len;</a>
<a name="ln9988">  }</a>
<a name="ln9989">}</a>
<a name="ln9990"> </a>
<a name="ln9991">/*</a>
<a name="ln9992"> * &quot;strdisplaywidth()&quot; function</a>
<a name="ln9993"> */</a>
<a name="ln9994">static void f_strdisplaywidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9995">{</a>
<a name="ln9996">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9997">  int col = 0;</a>
<a name="ln9998"> </a>
<a name="ln9999">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10000">    col = tv_get_number(&amp;argvars[1]);</a>
<a name="ln10001">  }</a>
<a name="ln10002"> </a>
<a name="ln10003">  rettv-&gt;vval.v_number = (varnumber_T)(linetabsize_col(col, (char_u *)s) - col);</a>
<a name="ln10004">}</a>
<a name="ln10005"> </a>
<a name="ln10006">/*</a>
<a name="ln10007"> * &quot;strwidth()&quot; function</a>
<a name="ln10008"> */</a>
<a name="ln10009">static void f_strwidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10010">{</a>
<a name="ln10011">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10012"> </a>
<a name="ln10013">  rettv-&gt;vval.v_number = (varnumber_T)mb_string2cells((const char_u *)s);</a>
<a name="ln10014">}</a>
<a name="ln10015"> </a>
<a name="ln10016">// &quot;strcharpart()&quot; function</a>
<a name="ln10017">static void f_strcharpart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10018">{</a>
<a name="ln10019">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10020">  const size_t slen = STRLEN(p);</a>
<a name="ln10021"> </a>
<a name="ln10022">  int nbyte = 0;</a>
<a name="ln10023">  bool error = false;</a>
<a name="ln10024">  varnumber_T nchar = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln10025">  if (!error) {</a>
<a name="ln10026">    if (nchar &gt; 0) {</a>
<a name="ln10027">      while (nchar &gt; 0 &amp;&amp; (size_t)nbyte &lt; slen) {</a>
<a name="ln10028">        nbyte += MB_CPTR2LEN((const char_u *)p + nbyte);</a>
<a name="ln10029">        nchar--;</a>
<a name="ln10030">      }</a>
<a name="ln10031">    } else {</a>
<a name="ln10032">      nbyte = nchar;</a>
<a name="ln10033">    }</a>
<a name="ln10034">  }</a>
<a name="ln10035">  int len = 0;</a>
<a name="ln10036">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10037">    int charlen = tv_get_number(&amp;argvars[2]);</a>
<a name="ln10038">    while (charlen &gt; 0 &amp;&amp; nbyte + len &lt; (int)slen) {</a>
<a name="ln10039">      int off = nbyte + len;</a>
<a name="ln10040"> </a>
<a name="ln10041">      if (off &lt; 0) {</a>
<a name="ln10042">        len += 1;</a>
<a name="ln10043">      } else {</a>
<a name="ln10044">        len += (size_t)MB_CPTR2LEN((const char_u *)p + off);</a>
<a name="ln10045">      }</a>
<a name="ln10046">      charlen--;</a>
<a name="ln10047">    }</a>
<a name="ln10048">  } else {</a>
<a name="ln10049">    len = slen - nbyte;    // default: all bytes that are available.</a>
<a name="ln10050">  }</a>
<a name="ln10051"> </a>
<a name="ln10052">  // Only return the overlap between the specified part and the actual</a>
<a name="ln10053">  // string.</a>
<a name="ln10054">  if (nbyte &lt; 0) {</a>
<a name="ln10055">    len += nbyte;</a>
<a name="ln10056">    nbyte = 0;</a>
<a name="ln10057">  } else if ((size_t)nbyte &gt; slen) {</a>
<a name="ln10058">    nbyte = slen;</a>
<a name="ln10059">  }</a>
<a name="ln10060">  if (len &lt; 0) {</a>
<a name="ln10061">    len = 0;</a>
<a name="ln10062">  } else if (nbyte + len &gt; (int)slen) {</a>
<a name="ln10063">    len = slen - nbyte;</a>
<a name="ln10064">  }</a>
<a name="ln10065"> </a>
<a name="ln10066">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10067">  rettv-&gt;vval.v_string = (char_u *)xstrndup(p + nbyte, (size_t)len);</a>
<a name="ln10068">}</a>
<a name="ln10069"> </a>
<a name="ln10070">/*</a>
<a name="ln10071"> * &quot;strpart()&quot; function</a>
<a name="ln10072"> */</a>
<a name="ln10073">static void f_strpart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10074">{</a>
<a name="ln10075">  bool error = false;</a>
<a name="ln10076"> </a>
<a name="ln10077">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10078">  const size_t slen = strlen(p);</a>
<a name="ln10079"> </a>
<a name="ln10080">  varnumber_T n = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln10081">  varnumber_T len;</a>
<a name="ln10082">  if (error) {</a>
<a name="ln10083">    len = 0;</a>
<a name="ln10084">  } else if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10085">    len = tv_get_number(&amp;argvars[2]);</a>
<a name="ln10086">  } else {</a>
<a name="ln10087">    len = slen - n;  // Default len: all bytes that are available.</a>
<a name="ln10088">  }</a>
<a name="ln10089"> </a>
<a name="ln10090">  // Only return the overlap between the specified part and the actual</a>
<a name="ln10091">  // string.</a>
<a name="ln10092">  if (n &lt; 0) {</a>
<a name="ln10093">    len += n;</a>
<a name="ln10094">    n = 0;</a>
<a name="ln10095">  } else if (n &gt; (varnumber_T)slen) {</a>
<a name="ln10096">    n = slen;</a>
<a name="ln10097">  }</a>
<a name="ln10098">  if (len &lt; 0) {</a>
<a name="ln10099">    len = 0;</a>
<a name="ln10100">  } else if (n + len &gt; (varnumber_T)slen) {</a>
<a name="ln10101">    len = slen - n;</a>
<a name="ln10102">  }</a>
<a name="ln10103"> </a>
<a name="ln10104">  if (argvars[2].v_type != VAR_UNKNOWN &amp;&amp; argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln10105">    int off;</a>
<a name="ln10106"> </a>
<a name="ln10107">    // length in characters</a>
<a name="ln10108">    for (off = n; off &lt; (int)slen &amp;&amp; len &gt; 0; len--) {</a>
<a name="ln10109">      off += utfc_ptr2len((char_u *)p + off);</a>
<a name="ln10110">    }</a>
<a name="ln10111">    len = off - n;</a>
<a name="ln10112">  }</a>
<a name="ln10113"> </a>
<a name="ln10114">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10115">  rettv-&gt;vval.v_string = (char_u *)xmemdupz(p + n, (size_t)len);</a>
<a name="ln10116">}</a>
<a name="ln10117"> </a>
<a name="ln10118">// &quot;strptime({format}, {timestring})&quot; function</a>
<a name="ln10119">static void f_strptime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10120">{</a>
<a name="ln10121">  char fmt_buf[NUMBUFLEN];</a>
<a name="ln10122">  char str_buf[NUMBUFLEN];</a>
<a name="ln10123"> </a>
<a name="ln10124">  struct tm tmval = {</a>
<a name="ln10125">    .tm_isdst = -1,</a>
<a name="ln10126">  };</a>
<a name="ln10127">  char *fmt = (char *)tv_get_string_buf(&amp;argvars[0], fmt_buf);</a>
<a name="ln10128">  char *str = (char *)tv_get_string_buf(&amp;argvars[1], str_buf);</a>
<a name="ln10129"> </a>
<a name="ln10130">  vimconv_T conv = {</a>
<a name="ln10131">    .vc_type = CONV_NONE,</a>
<a name="ln10132">  };</a>
<a name="ln10133">  char_u *enc = enc_locale();</a>
<a name="ln10134">  convert_setup(&amp;conv, p_enc, enc);</a>
<a name="ln10135">  if (conv.vc_type != CONV_NONE) {</a>
<a name="ln10136">    fmt = (char *)string_convert(&amp;conv, (char_u *)fmt, NULL);</a>
<a name="ln10137">  }</a>
<a name="ln10138">  if (fmt == NULL</a>
<a name="ln10139">      || os_strptime(str, fmt, &amp;tmval) == NULL</a>
<a name="ln10140">      || (rettv-&gt;vval.v_number = mktime(&amp;tmval)) == -1) {</a>
<a name="ln10141">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln10142">  }</a>
<a name="ln10143">  if (conv.vc_type != CONV_NONE) {</a>
<a name="ln10144">    xfree(fmt);</a>
<a name="ln10145">  }</a>
<a name="ln10146">  convert_setup(&amp;conv, NULL, NULL);</a>
<a name="ln10147">  xfree(enc);</a>
<a name="ln10148">}</a>
<a name="ln10149"> </a>
<a name="ln10150">/*</a>
<a name="ln10151"> * &quot;strridx()&quot; function</a>
<a name="ln10152"> */</a>
<a name="ln10153">static void f_strridx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10154">{</a>
<a name="ln10155">  char buf[NUMBUFLEN];</a>
<a name="ln10156">  const char *const needle = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln10157">  const char *const haystack = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln10158"> </a>
<a name="ln10159">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln10160">  if (needle == NULL || haystack == NULL) {</a>
<a name="ln10161">    return;  // Type error; errmsg already given.</a>
<a name="ln10162">  }</a>
<a name="ln10163"> </a>
<a name="ln10164">  const size_t haystack_len = STRLEN(haystack);</a>
<a name="ln10165">  ptrdiff_t end_idx;</a>
<a name="ln10166">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10167">    // Third argument: upper limit for index.</a>
<a name="ln10168">    end_idx = (ptrdiff_t)tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln10169">    if (end_idx &lt; 0) {</a>
<a name="ln10170">      return;  // Can never find a match.</a>
<a name="ln10171">    }</a>
<a name="ln10172">  } else {</a>
<a name="ln10173">    end_idx = (ptrdiff_t)haystack_len;</a>
<a name="ln10174">  }</a>
<a name="ln10175"> </a>
<a name="ln10176">  const char *lastmatch = NULL;</a>
<a name="ln10177">  if (*needle == NUL) {</a>
<a name="ln10178">    // Empty string matches past the end.</a>
<a name="ln10179">    lastmatch = haystack + end_idx;</a>
<a name="ln10180">  } else {</a>
<a name="ln10181">    for (const char *rest = haystack; *rest != NUL; rest++) {</a>
<a name="ln10182">      rest = strstr(rest, needle);</a>
<a name="ln10183">      if (rest == NULL || rest &gt; haystack + end_idx) {</a>
<a name="ln10184">        break;</a>
<a name="ln10185">      }</a>
<a name="ln10186">      lastmatch = rest;</a>
<a name="ln10187">    }</a>
<a name="ln10188">  }</a>
<a name="ln10189"> </a>
<a name="ln10190">  if (lastmatch != NULL) {</a>
<a name="ln10191">    rettv-&gt;vval.v_number = (varnumber_T)(lastmatch - haystack);</a>
<a name="ln10192">  }</a>
<a name="ln10193">}</a>
<a name="ln10194"> </a>
<a name="ln10195">/*</a>
<a name="ln10196"> * &quot;strtrans()&quot; function</a>
<a name="ln10197"> */</a>
<a name="ln10198">static void f_strtrans(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10199">{</a>
<a name="ln10200">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10201">  rettv-&gt;vval.v_string = (char_u *)transstr(tv_get_string(&amp;argvars[0]));</a>
<a name="ln10202">}</a>
<a name="ln10203"> </a>
<a name="ln10204">/*</a>
<a name="ln10205"> * &quot;submatch()&quot; function</a>
<a name="ln10206"> */</a>
<a name="ln10207">static void f_submatch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10208">{</a>
<a name="ln10209">  bool error = false;</a>
<a name="ln10210">  int no = (int)tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln10211">  if (error) {</a>
<a name="ln10212">    return;</a>
<a name="ln10213">  }</a>
<a name="ln10214"> </a>
<a name="ln10215">  if (no &lt; 0 || no &gt;= NSUBEXP) {</a>
<a name="ln10216">    emsgf(_(&quot;E935: invalid submatch number: %d&quot;), no);</a>
<a name="ln10217">    return;</a>
<a name="ln10218">  }</a>
<a name="ln10219">  int retList = 0;</a>
<a name="ln10220"> </a>
<a name="ln10221">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10222">    retList = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln10223">    if (error) {</a>
<a name="ln10224">      return;</a>
<a name="ln10225">    }</a>
<a name="ln10226">  }</a>
<a name="ln10227"> </a>
<a name="ln10228">  if (retList == 0) {</a>
<a name="ln10229">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10230">    rettv-&gt;vval.v_string = reg_submatch(no);</a>
<a name="ln10231">  } else {</a>
<a name="ln10232">    rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln10233">    rettv-&gt;vval.v_list = reg_submatch_list(no);</a>
<a name="ln10234">  }</a>
<a name="ln10235">}</a>
<a name="ln10236"> </a>
<a name="ln10237">/*</a>
<a name="ln10238"> * &quot;substitute()&quot; function</a>
<a name="ln10239"> */</a>
<a name="ln10240">static void f_substitute(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10241">{</a>
<a name="ln10242">  char patbuf[NUMBUFLEN];</a>
<a name="ln10243">  char subbuf[NUMBUFLEN];</a>
<a name="ln10244">  char flagsbuf[NUMBUFLEN];</a>
<a name="ln10245"> </a>
<a name="ln10246">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln10247">  const char *const pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln10248">  const char *sub = NULL;</a>
<a name="ln10249">  const char *const flg = tv_get_string_buf_chk(&amp;argvars[3], flagsbuf);</a>
<a name="ln10250"> </a>
<a name="ln10251">  typval_T *expr = NULL;</a>
<a name="ln10252">  if (tv_is_func(argvars[2])) {</a>
<a name="ln10253">    expr = &amp;argvars[2];</a>
<a name="ln10254">  } else {</a>
<a name="ln10255">    sub = tv_get_string_buf_chk(&amp;argvars[2], subbuf);</a>
<a name="ln10256">  }</a>
<a name="ln10257"> </a>
<a name="ln10258">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10259">  if (str == NULL || pat == NULL || (sub == NULL &amp;&amp; expr == NULL)</a>
<a name="ln10260">      || flg == NULL) {</a>
<a name="ln10261">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln10262">  } else {</a>
<a name="ln10263">    rettv-&gt;vval.v_string = do_string_sub((char_u *)str, (char_u *)pat,</a>
<a name="ln10264">                                         (char_u *)sub, expr, (char_u *)flg);</a>
<a name="ln10265">  }</a>
<a name="ln10266">}</a>
<a name="ln10267"> </a>
<a name="ln10268">/// &quot;swapinfo(swap_filename)&quot; function</a>
<a name="ln10269">static void f_swapinfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10270">{</a>
<a name="ln10271">  tv_dict_alloc_ret(rettv);</a>
<a name="ln10272">  get_b0_dict(tv_get_string(argvars), rettv-&gt;vval.v_dict);</a>
<a name="ln10273">}</a>
<a name="ln10274"> </a>
<a name="ln10275">/// &quot;swapname(expr)&quot; function</a>
<a name="ln10276">static void f_swapname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10277">{</a>
<a name="ln10278">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10279">  buf_T *buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln10280">  if (buf == NULL</a>
<a name="ln10281">      || buf-&gt;b_ml.ml_mfp == NULL</a>
<a name="ln10282">      || buf-&gt;b_ml.ml_mfp-&gt;mf_fname == NULL) {</a>
<a name="ln10283">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln10284">  } else {</a>
<a name="ln10285">    rettv-&gt;vval.v_string = vim_strsave(buf-&gt;b_ml.ml_mfp-&gt;mf_fname);</a>
<a name="ln10286">  }</a>
<a name="ln10287">}</a>
<a name="ln10288"> </a>
<a name="ln10289">/// &quot;synID(lnum, col, trans)&quot; function</a>
<a name="ln10290">static void f_synID(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10291">{</a>
<a name="ln10292">  // -1 on type error (both)</a>
<a name="ln10293">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln10294">  const colnr_T col = (colnr_T)tv_get_number(&amp;argvars[1]) - 1;</a>
<a name="ln10295"> </a>
<a name="ln10296">  bool transerr = false;</a>
<a name="ln10297">  const int trans = tv_get_number_chk(&amp;argvars[2], &amp;transerr);</a>
<a name="ln10298"> </a>
<a name="ln10299">  int id = 0;</a>
<a name="ln10300">  if (!transerr &amp;&amp; lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln10301">      &amp;&amp; col &gt;= 0 &amp;&amp; (size_t)col &lt; STRLEN(ml_get(lnum))) {</a>
<a name="ln10302">    id = syn_get_id(curwin, lnum, col, trans, NULL, false);</a>
<a name="ln10303">  }</a>
<a name="ln10304"> </a>
<a name="ln10305">  rettv-&gt;vval.v_number = id;</a>
<a name="ln10306">}</a>
<a name="ln10307"> </a>
<a name="ln10308">/*</a>
<a name="ln10309"> * &quot;synIDattr(id, what [, mode])&quot; function</a>
<a name="ln10310"> */</a>
<a name="ln10311">static void f_synIDattr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10312">{</a>
<a name="ln10313">  const int id = (int)tv_get_number(&amp;argvars[0]);</a>
<a name="ln10314">  const char *const what = tv_get_string(&amp;argvars[1]);</a>
<a name="ln10315">  int modec;</a>
<a name="ln10316">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10317">    char modebuf[NUMBUFLEN];</a>
<a name="ln10318">    const char *const mode = tv_get_string_buf(&amp;argvars[2], modebuf);</a>
<a name="ln10319">    modec = TOLOWER_ASC(mode[0]);</a>
<a name="ln10320">    if (modec != 'c' &amp;&amp; modec != 'g') {</a>
<a name="ln10321">      modec = 0;  // Replace invalid with current.</a>
<a name="ln10322">    }</a>
<a name="ln10323">  } else if (ui_rgb_attached()) {</a>
<a name="ln10324">    modec = 'g';</a>
<a name="ln10325">  } else {</a>
<a name="ln10326">    modec = 'c';</a>
<a name="ln10327">  }</a>
<a name="ln10328"> </a>
<a name="ln10329"> </a>
<a name="ln10330">  const char *p = NULL;</a>
<a name="ln10331">  switch (TOLOWER_ASC(what[0])) {</a>
<a name="ln10332">    case 'b': {</a>
<a name="ln10333">      if (TOLOWER_ASC(what[1]) == 'g') {  // bg[#]</a>
<a name="ln10334">        p = highlight_color(id, what, modec);</a>
<a name="ln10335">      } else {  // bold</a>
<a name="ln10336">        p = highlight_has_attr(id, HL_BOLD, modec);</a>
<a name="ln10337">      }</a>
<a name="ln10338">      break;</a>
<a name="ln10339">    }</a>
<a name="ln10340">    case 'f': {  // fg[#] or font</a>
<a name="ln10341">      p = highlight_color(id, what, modec);</a>
<a name="ln10342">      break;</a>
<a name="ln10343">    }</a>
<a name="ln10344">    case 'i': {</a>
<a name="ln10345">      if (TOLOWER_ASC(what[1]) == 'n') {  // inverse</a>
<a name="ln10346">        p = highlight_has_attr(id, HL_INVERSE, modec);</a>
<a name="ln10347">      } else {  // italic</a>
<a name="ln10348">        p = highlight_has_attr(id, HL_ITALIC, modec);</a>
<a name="ln10349">      }</a>
<a name="ln10350">      break;</a>
<a name="ln10351">    }</a>
<a name="ln10352">    case 'n': {  // name</a>
<a name="ln10353">      p = get_highlight_name_ext(NULL, id - 1, false);</a>
<a name="ln10354">      break;</a>
<a name="ln10355">    }</a>
<a name="ln10356">    case 'r': {  // reverse</a>
<a name="ln10357">      p = highlight_has_attr(id, HL_INVERSE, modec);</a>
<a name="ln10358">      break;</a>
<a name="ln10359">    }</a>
<a name="ln10360">    case 's': {</a>
<a name="ln10361">      if (TOLOWER_ASC(what[1]) == 'p') {  // sp[#]</a>
<a name="ln10362">        p = highlight_color(id, what, modec);</a>
<a name="ln10363">      } else if (TOLOWER_ASC(what[1]) == 't'</a>
<a name="ln10364">                 &amp;&amp; TOLOWER_ASC(what[2]) == 'r') {  // strikethrough</a>
<a name="ln10365">        p = highlight_has_attr(id, HL_STRIKETHROUGH, modec);</a>
<a name="ln10366">      } else {  // standout</a>
<a name="ln10367">        p = highlight_has_attr(id, HL_STANDOUT, modec);</a>
<a name="ln10368">      }</a>
<a name="ln10369">      break;</a>
<a name="ln10370">    }</a>
<a name="ln10371">    case 'u': {</a>
<a name="ln10372">      if (STRLEN(what) &lt;= 5 || TOLOWER_ASC(what[5]) != 'c') {  // underline</a>
<a name="ln10373">        p = highlight_has_attr(id, HL_UNDERLINE, modec);</a>
<a name="ln10374">      } else {  // undercurl</a>
<a name="ln10375">        p = highlight_has_attr(id, HL_UNDERCURL, modec);</a>
<a name="ln10376">      }</a>
<a name="ln10377">      break;</a>
<a name="ln10378">    }</a>
<a name="ln10379">  }</a>
<a name="ln10380"> </a>
<a name="ln10381">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10382">  rettv-&gt;vval.v_string = (char_u *)(p == NULL ? p : xstrdup(p));</a>
<a name="ln10383">}</a>
<a name="ln10384"> </a>
<a name="ln10385">/*</a>
<a name="ln10386"> * &quot;synIDtrans(id)&quot; function</a>
<a name="ln10387"> */</a>
<a name="ln10388">static void f_synIDtrans(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10389">{</a>
<a name="ln10390">  int id = tv_get_number(&amp;argvars[0]);</a>
<a name="ln10391"> </a>
<a name="ln10392">  if (id &gt; 0) {</a>
<a name="ln10393">    id = syn_get_final_id(id);</a>
<a name="ln10394">  } else {</a>
<a name="ln10395">    id = 0;</a>
<a name="ln10396">  }</a>
<a name="ln10397"> </a>
<a name="ln10398">  rettv-&gt;vval.v_number = id;</a>
<a name="ln10399">}</a>
<a name="ln10400"> </a>
<a name="ln10401">/*</a>
<a name="ln10402"> * &quot;synconcealed(lnum, col)&quot; function</a>
<a name="ln10403"> */</a>
<a name="ln10404">static void f_synconcealed(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10405">{</a>
<a name="ln10406">  int syntax_flags = 0;</a>
<a name="ln10407">  int cchar;</a>
<a name="ln10408">  int matchid = 0;</a>
<a name="ln10409">  char_u str[NUMBUFLEN];</a>
<a name="ln10410"> </a>
<a name="ln10411">  tv_list_set_ret(rettv, NULL);</a>
<a name="ln10412"> </a>
<a name="ln10413">  // -1 on type error (both)</a>
<a name="ln10414">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln10415">  const colnr_T col = (colnr_T)tv_get_number(&amp;argvars[1]) - 1;</a>
<a name="ln10416"> </a>
<a name="ln10417">  memset(str, NUL, sizeof(str));</a>
<a name="ln10418"> </a>
<a name="ln10419">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count &amp;&amp; col &gt;= 0</a>
<a name="ln10420">      &amp;&amp; (size_t)col &lt;= STRLEN(ml_get(lnum)) &amp;&amp; curwin-&gt;w_p_cole &gt; 0) {</a>
<a name="ln10421">    (void)syn_get_id(curwin, lnum, col, false, NULL, false);</a>
<a name="ln10422">    syntax_flags = get_syntax_info(&amp;matchid);</a>
<a name="ln10423"> </a>
<a name="ln10424">    // get the conceal character</a>
<a name="ln10425">    if ((syntax_flags &amp; HL_CONCEAL) &amp;&amp; curwin-&gt;w_p_cole &lt; 3) {</a>
<a name="ln10426">      cchar = syn_get_sub_char();</a>
<a name="ln10427">      if (cchar == NUL &amp;&amp; curwin-&gt;w_p_cole == 1) {</a>
<a name="ln10428">        cchar = (curwin-&gt;w_p_lcs_chars.conceal == NUL)</a>
<a name="ln10429">          ? ' '</a>
<a name="ln10430">          : curwin-&gt;w_p_lcs_chars.conceal;</a>
<a name="ln10431">      }</a>
<a name="ln10432">      if (cchar != NUL) {</a>
<a name="ln10433">        utf_char2bytes(cchar, str);</a>
<a name="ln10434">      }</a>
<a name="ln10435">    }</a>
<a name="ln10436">  }</a>
<a name="ln10437"> </a>
<a name="ln10438">  tv_list_alloc_ret(rettv, 3);</a>
<a name="ln10439">  tv_list_append_number(rettv-&gt;vval.v_list, (syntax_flags &amp; HL_CONCEAL) != 0);</a>
<a name="ln10440">  // -1 to auto-determine strlen</a>
<a name="ln10441">  tv_list_append_string(rettv-&gt;vval.v_list, (const char *)str, -1);</a>
<a name="ln10442">  tv_list_append_number(rettv-&gt;vval.v_list, matchid);</a>
<a name="ln10443">}</a>
<a name="ln10444"> </a>
<a name="ln10445">/*</a>
<a name="ln10446"> * &quot;synstack(lnum, col)&quot; function</a>
<a name="ln10447"> */</a>
<a name="ln10448">static void f_synstack(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10449">{</a>
<a name="ln10450">  tv_list_set_ret(rettv, NULL);</a>
<a name="ln10451"> </a>
<a name="ln10452">  // -1 on type error (both)</a>
<a name="ln10453">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln10454">  const colnr_T col = (colnr_T)tv_get_number(&amp;argvars[1]) - 1;</a>
<a name="ln10455"> </a>
<a name="ln10456">  if (lnum &gt;= 1</a>
<a name="ln10457">      &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln10458">      &amp;&amp; col &gt;= 0</a>
<a name="ln10459">      &amp;&amp; (size_t)col &lt;= STRLEN(ml_get(lnum))) {</a>
<a name="ln10460">    tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln10461">    (void)syn_get_id(curwin, lnum, col, false, NULL, true);</a>
<a name="ln10462"> </a>
<a name="ln10463">    int id;</a>
<a name="ln10464">    int i = 0;</a>
<a name="ln10465">    while ((id = syn_get_stack_item(i++)) &gt;= 0) {</a>
<a name="ln10466">      tv_list_append_number(rettv-&gt;vval.v_list, id);</a>
<a name="ln10467">    }</a>
<a name="ln10468">  }</a>
<a name="ln10469">}</a>
<a name="ln10470"> </a>
<a name="ln10471">/// f_system - the VimL system() function</a>
<a name="ln10472">static void f_system(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10473">{</a>
<a name="ln10474">  get_system_output_as_rettv(argvars, rettv, false);</a>
<a name="ln10475">}</a>
<a name="ln10476"> </a>
<a name="ln10477">static void f_systemlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10478">{</a>
<a name="ln10479">  get_system_output_as_rettv(argvars, rettv, true);</a>
<a name="ln10480">}</a>
<a name="ln10481"> </a>
<a name="ln10482"> </a>
<a name="ln10483">/*</a>
<a name="ln10484"> * &quot;tabpagebuflist()&quot; function</a>
<a name="ln10485"> */</a>
<a name="ln10486">static void f_tabpagebuflist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10487">{</a>
<a name="ln10488">  win_T       *wp = NULL;</a>
<a name="ln10489"> </a>
<a name="ln10490">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln10491">    wp = firstwin;</a>
<a name="ln10492">  } else {</a>
<a name="ln10493">    tabpage_T *const tp = find_tabpage((int)tv_get_number(&amp;argvars[0]));</a>
<a name="ln10494">    if (tp != NULL) {</a>
<a name="ln10495">      wp = (tp == curtab) ? firstwin : tp-&gt;tp_firstwin;</a>
<a name="ln10496">    }</a>
<a name="ln10497">  }</a>
<a name="ln10498">  if (wp != NULL) {</a>
<a name="ln10499">    tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln10500">    while (wp != NULL) {</a>
<a name="ln10501">      tv_list_append_number(rettv-&gt;vval.v_list, wp-&gt;w_buffer-&gt;b_fnum);</a>
<a name="ln10502">      wp = wp-&gt;w_next;</a>
<a name="ln10503">    }</a>
<a name="ln10504">  }</a>
<a name="ln10505">}</a>
<a name="ln10506"> </a>
<a name="ln10507">/*</a>
<a name="ln10508"> * &quot;tabpagenr()&quot; function</a>
<a name="ln10509"> */</a>
<a name="ln10510">static void f_tabpagenr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10511">{</a>
<a name="ln10512">  int nr = 1;</a>
<a name="ln10513"> </a>
<a name="ln10514">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln10515">    const char *const arg = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln10516">    nr = 0;</a>
<a name="ln10517">    if (arg != NULL) {</a>
<a name="ln10518">      if (strcmp(arg, &quot;$&quot;) == 0) {</a>
<a name="ln10519">        nr = tabpage_index(NULL) - 1;</a>
<a name="ln10520">      } else if (strcmp(arg, &quot;#&quot;) == 0) {</a>
<a name="ln10521">        nr = valid_tabpage(lastused_tabpage)</a>
<a name="ln10522">             ? tabpage_index(lastused_tabpage)</a>
<a name="ln10523">             : nr;</a>
<a name="ln10524">      } else {</a>
<a name="ln10525">        EMSG2(_(e_invexpr2), arg);</a>
<a name="ln10526">      }</a>
<a name="ln10527">    }</a>
<a name="ln10528">  } else {</a>
<a name="ln10529">    nr = tabpage_index(curtab);</a>
<a name="ln10530">  }</a>
<a name="ln10531">  rettv-&gt;vval.v_number = nr;</a>
<a name="ln10532">}</a>
<a name="ln10533"> </a>
<a name="ln10534"> </a>
<a name="ln10535"> </a>
<a name="ln10536">/*</a>
<a name="ln10537"> * Common code for tabpagewinnr() and winnr().</a>
<a name="ln10538"> */</a>
<a name="ln10539">static int get_winnr(tabpage_T *tp, typval_T *argvar)</a>
<a name="ln10540">{</a>
<a name="ln10541">  win_T       *twin;</a>
<a name="ln10542">  int nr = 1;</a>
<a name="ln10543">  win_T       *wp;</a>
<a name="ln10544"> </a>
<a name="ln10545">  twin = (tp == curtab) ? curwin : tp-&gt;tp_curwin;</a>
<a name="ln10546">  if (argvar-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln10547">    bool invalid_arg = false;</a>
<a name="ln10548">    const char *const arg = tv_get_string_chk(argvar);</a>
<a name="ln10549">    if (arg == NULL) {</a>
<a name="ln10550">      nr = 0;  // Type error; errmsg already given.</a>
<a name="ln10551">    } else if (strcmp(arg, &quot;$&quot;) == 0) {</a>
<a name="ln10552">      twin = (tp == curtab) ? lastwin : tp-&gt;tp_lastwin;</a>
<a name="ln10553">    } else if (strcmp(arg, &quot;#&quot;) == 0) {</a>
<a name="ln10554">      twin = (tp == curtab) ? prevwin : tp-&gt;tp_prevwin;</a>
<a name="ln10555">      if (twin == NULL) {</a>
<a name="ln10556">        nr = 0;</a>
<a name="ln10557">      }</a>
<a name="ln10558">    } else {</a>
<a name="ln10559">      // Extract the window count (if specified). e.g. winnr('3j')</a>
<a name="ln10560">      char_u *endp;</a>
<a name="ln10561">      long count = strtol((char *)arg, (char **)&amp;endp, 10);</a>
<a name="ln10562">      if (count &lt;= 0) {</a>
<a name="ln10563">        // if count is not specified, default to 1</a>
<a name="ln10564">        count = 1;</a>
<a name="ln10565">      }</a>
<a name="ln10566">      if (endp != NULL &amp;&amp; *endp != '\0') {</a>
<a name="ln10567">        if (strequal((char *)endp, &quot;j&quot;)) {</a>
<a name="ln10568">          twin = win_vert_neighbor(tp, twin, false, count);</a>
<a name="ln10569">        } else if (strequal((char *)endp, &quot;k&quot;)) {</a>
<a name="ln10570">          twin = win_vert_neighbor(tp, twin, true, count);</a>
<a name="ln10571">        } else if (strequal((char *)endp, &quot;h&quot;)) {</a>
<a name="ln10572">          twin = win_horz_neighbor(tp, twin, true, count);</a>
<a name="ln10573">        } else if (strequal((char *)endp, &quot;l&quot;)) {</a>
<a name="ln10574">          twin = win_horz_neighbor(tp, twin, false, count);</a>
<a name="ln10575">        } else {</a>
<a name="ln10576">          invalid_arg = true;</a>
<a name="ln10577">        }</a>
<a name="ln10578">      } else {</a>
<a name="ln10579">        invalid_arg = true;</a>
<a name="ln10580">      }</a>
<a name="ln10581">    }</a>
<a name="ln10582"> </a>
<a name="ln10583">    if (invalid_arg) {</a>
<a name="ln10584">      EMSG2(_(e_invexpr2), arg);</a>
<a name="ln10585">      nr = 0;</a>
<a name="ln10586">    }</a>
<a name="ln10587">  }</a>
<a name="ln10588"> </a>
<a name="ln10589">  if (nr &gt; 0)</a>
<a name="ln10590">    for (wp = (tp == curtab) ? firstwin : tp-&gt;tp_firstwin;</a>
<a name="ln10591">         wp != twin; wp = wp-&gt;w_next) {</a>
<a name="ln10592">      if (wp == NULL) {</a>
<a name="ln10593">        // didn't find it in this tabpage</a>
<a name="ln10594">        nr = 0;</a>
<a name="ln10595">        break;</a>
<a name="ln10596">      }</a>
<a name="ln10597">      ++nr;</a>
<a name="ln10598">    }</a>
<a name="ln10599">  return nr;</a>
<a name="ln10600">}</a>
<a name="ln10601"> </a>
<a name="ln10602">/*</a>
<a name="ln10603"> * &quot;tabpagewinnr()&quot; function</a>
<a name="ln10604"> */</a>
<a name="ln10605">static void f_tabpagewinnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10606">{</a>
<a name="ln10607">  int nr = 1;</a>
<a name="ln10608">  tabpage_T *const tp = find_tabpage((int)tv_get_number(&amp;argvars[0]));</a>
<a name="ln10609">  if (tp == NULL) {</a>
<a name="ln10610">    nr = 0;</a>
<a name="ln10611">  } else {</a>
<a name="ln10612">    nr = get_winnr(tp, &amp;argvars[1]);</a>
<a name="ln10613">  }</a>
<a name="ln10614">  rettv-&gt;vval.v_number = nr;</a>
<a name="ln10615">}</a>
<a name="ln10616"> </a>
<a name="ln10617">/*</a>
<a name="ln10618"> * &quot;tagfiles()&quot; function</a>
<a name="ln10619"> */</a>
<a name="ln10620">static void f_tagfiles(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10621">{</a>
<a name="ln10622">  char *fname;</a>
<a name="ln10623">  tagname_T tn;</a>
<a name="ln10624"> </a>
<a name="ln10625">  tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln10626">  fname = xmalloc(MAXPATHL);</a>
<a name="ln10627"> </a>
<a name="ln10628">  bool first = true;</a>
<a name="ln10629">  while (get_tagfname(&amp;tn, first, (char_u *)fname) == OK) {</a>
<a name="ln10630">    tv_list_append_string(rettv-&gt;vval.v_list, fname, -1);</a>
<a name="ln10631">    first = false;</a>
<a name="ln10632">  }</a>
<a name="ln10633"> </a>
<a name="ln10634">  tagname_free(&amp;tn);</a>
<a name="ln10635">  xfree(fname);</a>
<a name="ln10636">}</a>
<a name="ln10637"> </a>
<a name="ln10638">/*</a>
<a name="ln10639"> * &quot;taglist()&quot; function</a>
<a name="ln10640"> */</a>
<a name="ln10641">static void f_taglist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10642">{</a>
<a name="ln10643">  const char *const tag_pattern = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10644"> </a>
<a name="ln10645">  rettv-&gt;vval.v_number = false;</a>
<a name="ln10646">  if (*tag_pattern == NUL) {</a>
<a name="ln10647">    return;</a>
<a name="ln10648">  }</a>
<a name="ln10649"> </a>
<a name="ln10650">  const char *fname = NULL;</a>
<a name="ln10651">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10652">    fname = tv_get_string(&amp;argvars[1]);</a>
<a name="ln10653">  }</a>
<a name="ln10654">  (void)get_tags(tv_list_alloc_ret(rettv, kListLenUnknown),</a>
<a name="ln10655">                 (char_u *)tag_pattern, (char_u *)fname);</a>
<a name="ln10656">}</a>
<a name="ln10657"> </a>
<a name="ln10658">/*</a>
<a name="ln10659"> * &quot;tempname()&quot; function</a>
<a name="ln10660"> */</a>
<a name="ln10661">static void f_tempname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10662">{</a>
<a name="ln10663">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10664">  rettv-&gt;vval.v_string = vim_tempname();</a>
<a name="ln10665">}</a>
<a name="ln10666"> </a>
<a name="ln10667">// &quot;termopen(cmd[, cwd])&quot; function</a>
<a name="ln10668">static void f_termopen(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10669">{</a>
<a name="ln10670">  if (check_secure()) {</a>
<a name="ln10671">    return;</a>
<a name="ln10672">  }</a>
<a name="ln10673"> </a>
<a name="ln10674">  if (curbuf-&gt;b_changed) {</a>
<a name="ln10675">    EMSG(_(&quot;Can only call this function in an unmodified buffer&quot;));</a>
<a name="ln10676">    return;</a>
<a name="ln10677">  }</a>
<a name="ln10678"> </a>
<a name="ln10679">  const char *cmd;</a>
<a name="ln10680">  bool executable = true;</a>
<a name="ln10681">  char **argv = tv_to_argv(&amp;argvars[0], &amp;cmd, &amp;executable);</a>
<a name="ln10682">  if (!argv) {</a>
<a name="ln10683">    rettv-&gt;vval.v_number = executable ? 0 : -1;</a>
<a name="ln10684">    return;  // Did error message in tv_to_argv.</a>
<a name="ln10685">  }</a>
<a name="ln10686"> </a>
<a name="ln10687">  if (argvars[1].v_type != VAR_DICT &amp;&amp; argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10688">    // Wrong argument type</a>
<a name="ln10689">    EMSG2(_(e_invarg2), &quot;expected dictionary&quot;);</a>
<a name="ln10690">    shell_free_argv(argv);</a>
<a name="ln10691">    return;</a>
<a name="ln10692">  }</a>
<a name="ln10693"> </a>
<a name="ln10694">  CallbackReader on_stdout = CALLBACK_READER_INIT,</a>
<a name="ln10695">                 on_stderr = CALLBACK_READER_INIT;</a>
<a name="ln10696">  Callback on_exit = CALLBACK_NONE;</a>
<a name="ln10697">  dict_T *job_opts = NULL;</a>
<a name="ln10698">  const char *cwd = &quot;.&quot;;</a>
<a name="ln10699">  dict_T *env = NULL;</a>
<a name="ln10700">  const bool pty = true;</a>
<a name="ln10701">  bool clear_env = false;</a>
<a name="ln10702">  dictitem_T *job_env = NULL;</a>
<a name="ln10703"> </a>
<a name="ln10704">  if (argvars[1].v_type == VAR_DICT) {</a>
<a name="ln10705">    job_opts = argvars[1].vval.v_dict;</a>
<a name="ln10706"> </a>
<a name="ln10707">    const char *const new_cwd = tv_dict_get_string(job_opts, &quot;cwd&quot;, false);</a>
<a name="ln10708">    if (new_cwd &amp;&amp; *new_cwd != NUL) {</a>
<a name="ln10709">      cwd = new_cwd;</a>
<a name="ln10710">      // The new cwd must be a directory.</a>
<a name="ln10711">      if (!os_isdir_executable((const char *)cwd)) {</a>
<a name="ln10712">        EMSG2(_(e_invarg2), &quot;expected valid directory&quot;);</a>
<a name="ln10713">        shell_free_argv(argv);</a>
<a name="ln10714">        return;</a>
<a name="ln10715">      }</a>
<a name="ln10716">    }</a>
<a name="ln10717"> </a>
<a name="ln10718">    job_env = tv_dict_find(job_opts, S_LEN(&quot;env&quot;));</a>
<a name="ln10719">    if (job_env &amp;&amp; job_env-&gt;di_tv.v_type != VAR_DICT) {</a>
<a name="ln10720">      EMSG2(_(e_invarg2), &quot;env&quot;);</a>
<a name="ln10721">      shell_free_argv(argv);</a>
<a name="ln10722">      return;</a>
<a name="ln10723">    }</a>
<a name="ln10724"> </a>
<a name="ln10725">    clear_env = tv_dict_get_number(job_opts, &quot;clear_env&quot;) != 0;</a>
<a name="ln10726"> </a>
<a name="ln10727">    if (!common_job_callbacks(job_opts, &amp;on_stdout, &amp;on_stderr, &amp;on_exit)) {</a>
<a name="ln10728">      shell_free_argv(argv);</a>
<a name="ln10729">      return;</a>
<a name="ln10730">    }</a>
<a name="ln10731">  }</a>
<a name="ln10732"> </a>
<a name="ln10733">  env = create_environment(job_env, clear_env, pty, &quot;xterm-256color&quot;);</a>
<a name="ln10734"> </a>
<a name="ln10735">  const bool rpc = false;</a>
<a name="ln10736">  const bool overlapped = false;</a>
<a name="ln10737">  const bool detach = false;</a>
<a name="ln10738">  uint16_t term_width = MAX(0, curwin-&gt;w_width_inner - win_col_off(curwin));</a>
<a name="ln10739">  Channel *chan = channel_job_start(argv, on_stdout, on_stderr, on_exit,</a>
<a name="ln10740">                                    pty, rpc, overlapped, detach, cwd,</a>
<a name="ln10741">                                    term_width, curwin-&gt;w_height_inner,</a>
<a name="ln10742">                                    env, &amp;rettv-&gt;vval.v_number);</a>
<a name="ln10743">  if (rettv-&gt;vval.v_number &lt;= 0) {</a>
<a name="ln10744">    return;</a>
<a name="ln10745">  }</a>
<a name="ln10746"> </a>
<a name="ln10747">  int pid = chan-&gt;stream.pty.process.pid;</a>
<a name="ln10748"> </a>
<a name="ln10749">  // &quot;./…&quot; =&gt; &quot;/home/foo/…&quot;</a>
<a name="ln10750">  vim_FullName(cwd, (char *)NameBuff, sizeof(NameBuff), false);</a>
<a name="ln10751">  // &quot;/home/foo/…&quot; =&gt; &quot;~/…&quot;</a>
<a name="ln10752">  size_t len = home_replace(NULL, NameBuff, IObuff, sizeof(IObuff), true);</a>
<a name="ln10753">  // Trim slash.</a>
<a name="ln10754">  if (IObuff[len - 1] == '\\' || IObuff[len - 1] == '/') {</a>
<a name="ln10755">    IObuff[len - 1] = '\0';</a>
<a name="ln10756">  }</a>
<a name="ln10757"> </a>
<a name="ln10758">  // Terminal URI: &quot;term://$CWD//$PID:$CMD&quot;</a>
<a name="ln10759">  snprintf((char *)NameBuff, sizeof(NameBuff), &quot;term://%s//%d:%s&quot;,</a>
<a name="ln10760">           (char *)IObuff, pid, cmd);</a>
<a name="ln10761">  // at this point the buffer has no terminal instance associated yet, so unset</a>
<a name="ln10762">  // the 'swapfile' option to ensure no swap file will be created</a>
<a name="ln10763">  curbuf-&gt;b_p_swf = false;</a>
<a name="ln10764">  (void)setfname(curbuf, NameBuff, NULL, true);</a>
<a name="ln10765">  // Save the job id and pid in b:terminal_job_{id,pid}</a>
<a name="ln10766">  Error err = ERROR_INIT;</a>
<a name="ln10767">  // deprecated: use 'channel' buffer option</a>
<a name="ln10768">  dict_set_var(curbuf-&gt;b_vars, cstr_as_string(&quot;terminal_job_id&quot;),</a>
<a name="ln10769">               INTEGER_OBJ(chan-&gt;id), false, false, &amp;err);</a>
<a name="ln10770">  api_clear_error(&amp;err);</a>
<a name="ln10771">  dict_set_var(curbuf-&gt;b_vars, cstr_as_string(&quot;terminal_job_pid&quot;),</a>
<a name="ln10772">               INTEGER_OBJ(pid), false, false, &amp;err);</a>
<a name="ln10773">  api_clear_error(&amp;err);</a>
<a name="ln10774"> </a>
<a name="ln10775">  channel_terminal_open(curbuf, chan);</a>
<a name="ln10776">  channel_create_event(chan, NULL);</a>
<a name="ln10777">}</a>
<a name="ln10778"> </a>
<a name="ln10779">// &quot;test_garbagecollect_now()&quot; function</a>
<a name="ln10780">static void f_test_garbagecollect_now(typval_T *argvars,</a>
<a name="ln10781">                                      typval_T *rettv, FunPtr fptr)</a>
<a name="ln10782">{</a>
<a name="ln10783">  // This is dangerous, any Lists and Dicts used internally may be freed</a>
<a name="ln10784">  // while still in use.</a>
<a name="ln10785">  garbage_collect(true);</a>
<a name="ln10786">}</a>
<a name="ln10787"> </a>
<a name="ln10788">// &quot;test_write_list_log()&quot; function</a>
<a name="ln10789">static void f_test_write_list_log(typval_T *const argvars,</a>
<a name="ln10790">                                  typval_T *const rettv,</a>
<a name="ln10791">                                  FunPtr fptr)</a>
<a name="ln10792">{</a>
<a name="ln10793">  const char *const fname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln10794">  if (fname == NULL) {</a>
<a name="ln10795">    return;</a>
<a name="ln10796">  }</a>
<a name="ln10797">  list_write_log(fname);</a>
<a name="ln10798">}</a>
<a name="ln10799"> </a>
<a name="ln10800">/// &quot;timer_info([timer])&quot; function</a>
<a name="ln10801">static void f_timer_info(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10802">{</a>
<a name="ln10803">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln10804">    if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln10805">      EMSG(_(e_number_exp));</a>
<a name="ln10806">      return;</a>
<a name="ln10807">    }</a>
<a name="ln10808">    tv_list_alloc_ret(rettv, 1);</a>
<a name="ln10809">    timer_T *timer = find_timer_by_nr(tv_get_number(&amp;argvars[0]));</a>
<a name="ln10810">    if (timer != NULL &amp;&amp; !timer-&gt;stopped) {</a>
<a name="ln10811">      add_timer_info(rettv, timer);</a>
<a name="ln10812">    }</a>
<a name="ln10813">  } else {</a>
<a name="ln10814">    add_timer_info_all(rettv);</a>
<a name="ln10815">  }</a>
<a name="ln10816">}</a>
<a name="ln10817"> </a>
<a name="ln10818">/// &quot;timer_pause(timer, paused)&quot; function</a>
<a name="ln10819">static void f_timer_pause(typval_T *argvars, typval_T *unused, FunPtr fptr)</a>
<a name="ln10820">{</a>
<a name="ln10821">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln10822">    EMSG(_(e_number_exp));</a>
<a name="ln10823">    return;</a>
<a name="ln10824">  }</a>
<a name="ln10825">  int paused = (bool)tv_get_number(&amp;argvars[1]);</a>
<a name="ln10826">  timer_T *timer = find_timer_by_nr(tv_get_number(&amp;argvars[0]));</a>
<a name="ln10827">  if (timer != NULL) {</a>
<a name="ln10828">    if (!timer-&gt;paused &amp;&amp; paused) {</a>
<a name="ln10829">      time_watcher_stop(&amp;timer-&gt;tw);</a>
<a name="ln10830">    } else if (timer-&gt;paused &amp;&amp; !paused) {</a>
<a name="ln10831">      time_watcher_start(&amp;timer-&gt;tw, timer_due_cb, timer-&gt;timeout,</a>
<a name="ln10832">                         timer-&gt;timeout);</a>
<a name="ln10833">    }</a>
<a name="ln10834">    timer-&gt;paused = paused;</a>
<a name="ln10835">  }</a>
<a name="ln10836">}</a>
<a name="ln10837"> </a>
<a name="ln10838">/// &quot;timer_start(timeout, callback, opts)&quot; function</a>
<a name="ln10839">static void f_timer_start(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10840">{</a>
<a name="ln10841">  int repeat = 1;</a>
<a name="ln10842">  dict_T *dict;</a>
<a name="ln10843"> </a>
<a name="ln10844">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln10845"> </a>
<a name="ln10846">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10847">    if (argvars[2].v_type != VAR_DICT</a>
<a name="ln10848">        || (dict = argvars[2].vval.v_dict) == NULL) {</a>
<a name="ln10849">      EMSG2(_(e_invarg2), tv_get_string(&amp;argvars[2]));</a>
<a name="ln10850">      return;</a>
<a name="ln10851">    }</a>
<a name="ln10852">    dictitem_T *const di = tv_dict_find(dict, S_LEN(&quot;repeat&quot;));</a>
<a name="ln10853">    if (di != NULL) {</a>
<a name="ln10854">      repeat = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln10855">      if (repeat == 0) {</a>
<a name="ln10856">        repeat = 1;</a>
<a name="ln10857">      }</a>
<a name="ln10858">    }</a>
<a name="ln10859">  }</a>
<a name="ln10860"> </a>
<a name="ln10861">  Callback callback;</a>
<a name="ln10862">  if (!callback_from_typval(&amp;callback, &amp;argvars[1])) {</a>
<a name="ln10863">    return;</a>
<a name="ln10864">  }</a>
<a name="ln10865">  rettv-&gt;vval.v_number =</a>
<a name="ln10866">      timer_start(tv_get_number(&amp;argvars[0]), repeat, &amp;callback);</a>
<a name="ln10867">}</a>
<a name="ln10868"> </a>
<a name="ln10869"> </a>
<a name="ln10870">// &quot;timer_stop(timerid)&quot; function</a>
<a name="ln10871">static void f_timer_stop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10872">{</a>
<a name="ln10873">    if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln10874">        EMSG(_(e_number_exp));</a>
<a name="ln10875">        return;</a>
<a name="ln10876">    }</a>
<a name="ln10877"> </a>
<a name="ln10878">    timer_T *timer = find_timer_by_nr(tv_get_number(&amp;argvars[0]));</a>
<a name="ln10879">    if (timer == NULL) {</a>
<a name="ln10880">      return;</a>
<a name="ln10881">    }</a>
<a name="ln10882"> </a>
<a name="ln10883">    timer_stop(timer);</a>
<a name="ln10884">}</a>
<a name="ln10885"> </a>
<a name="ln10886">static void f_timer_stopall(typval_T *argvars, typval_T *unused, FunPtr fptr)</a>
<a name="ln10887">{</a>
<a name="ln10888">  timer_stop_all();</a>
<a name="ln10889">}</a>
<a name="ln10890"> </a>
<a name="ln10891">/*</a>
<a name="ln10892"> * &quot;tolower(string)&quot; function</a>
<a name="ln10893"> */</a>
<a name="ln10894">static void f_tolower(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10895">{</a>
<a name="ln10896">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10897">  rettv-&gt;vval.v_string = (char_u *)strcase_save(tv_get_string(&amp;argvars[0]),</a>
<a name="ln10898">                                                false);</a>
<a name="ln10899">}</a>
<a name="ln10900"> </a>
<a name="ln10901">/*</a>
<a name="ln10902"> * &quot;toupper(string)&quot; function</a>
<a name="ln10903"> */</a>
<a name="ln10904">static void f_toupper(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10905">{</a>
<a name="ln10906">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10907">  rettv-&gt;vval.v_string = (char_u *)strcase_save(tv_get_string(&amp;argvars[0]),</a>
<a name="ln10908">                                                true);</a>
<a name="ln10909">}</a>
<a name="ln10910"> </a>
<a name="ln10911">/*</a>
<a name="ln10912"> * &quot;tr(string, fromstr, tostr)&quot; function</a>
<a name="ln10913"> */</a>
<a name="ln10914">static void f_tr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10915">{</a>
<a name="ln10916">  char buf[NUMBUFLEN];</a>
<a name="ln10917">  char buf2[NUMBUFLEN];</a>
<a name="ln10918"> </a>
<a name="ln10919">  const char *in_str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10920">  const char *fromstr = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln10921">  const char *tostr = tv_get_string_buf_chk(&amp;argvars[2], buf2);</a>
<a name="ln10922"> </a>
<a name="ln10923">  // Default return value: empty string.</a>
<a name="ln10924">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10925">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln10926">  if (fromstr == NULL || tostr == NULL) {</a>
<a name="ln10927">    return;  // Type error; errmsg already given.</a>
<a name="ln10928">  }</a>
<a name="ln10929">  garray_T ga;</a>
<a name="ln10930">  ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln10931"> </a>
<a name="ln10932">  // fromstr and tostr have to contain the same number of chars.</a>
<a name="ln10933">  bool first = true;</a>
<a name="ln10934">  while (*in_str != NUL) {</a>
<a name="ln10935">    const char *cpstr = in_str;</a>
<a name="ln10936">    const int inlen = utfc_ptr2len((const char_u *)in_str);</a>
<a name="ln10937">    int cplen = inlen;</a>
<a name="ln10938">    int idx = 0;</a>
<a name="ln10939">    int fromlen;</a>
<a name="ln10940">    for (const char *p = fromstr; *p != NUL; p += fromlen) {</a>
<a name="ln10941">      fromlen = utfc_ptr2len((const char_u *)p);</a>
<a name="ln10942">      if (fromlen == inlen &amp;&amp; STRNCMP(in_str, p, inlen) == 0) {</a>
<a name="ln10943">        int tolen;</a>
<a name="ln10944">        for (p = tostr; *p != NUL; p += tolen) {</a>
<a name="ln10945">          tolen = utfc_ptr2len((const char_u *)p);</a>
<a name="ln10946">          if (idx-- == 0) {</a>
<a name="ln10947">            cplen = tolen;</a>
<a name="ln10948">            cpstr = (char *)p;</a>
<a name="ln10949">            break;</a>
<a name="ln10950">          }</a>
<a name="ln10951">        }</a>
<a name="ln10952">        if (*p == NUL) {  // tostr is shorter than fromstr.</a>
<a name="ln10953">          goto error;</a>
<a name="ln10954">        }</a>
<a name="ln10955">        break;</a>
<a name="ln10956">      }</a>
<a name="ln10957">      idx++;</a>
<a name="ln10958">    }</a>
<a name="ln10959"> </a>
<a name="ln10960">    if (first &amp;&amp; cpstr == in_str) {</a>
<a name="ln10961">      // Check that fromstr and tostr have the same number of</a>
<a name="ln10962">      // (multi-byte) characters.  Done only once when a character</a>
<a name="ln10963">      // of in_str doesn't appear in fromstr.</a>
<a name="ln10964">      first = false;</a>
<a name="ln10965">      int tolen;</a>
<a name="ln10966">      for (const char *p = tostr; *p != NUL; p += tolen) {</a>
<a name="ln10967">        tolen = utfc_ptr2len((const char_u *)p);</a>
<a name="ln10968">        idx--;</a>
<a name="ln10969">      }</a>
<a name="ln10970">      if (idx != 0) {</a>
<a name="ln10971">        goto error;</a>
<a name="ln10972">      }</a>
<a name="ln10973">    }</a>
<a name="ln10974"> </a>
<a name="ln10975">    ga_grow(&amp;ga, cplen);</a>
<a name="ln10976">    memmove((char *)ga.ga_data + ga.ga_len, cpstr, (size_t)cplen);</a>
<a name="ln10977">    ga.ga_len += cplen;</a>
<a name="ln10978"> </a>
<a name="ln10979">    in_str += inlen;</a>
<a name="ln10980">  }</a>
<a name="ln10981"> </a>
<a name="ln10982">  // add a terminating NUL</a>
<a name="ln10983">  ga_append(&amp;ga, NUL);</a>
<a name="ln10984"> </a>
<a name="ln10985">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln10986">  return;</a>
<a name="ln10987">error:</a>
<a name="ln10988">  EMSG2(_(e_invarg2), fromstr);</a>
<a name="ln10989">  ga_clear(&amp;ga);</a>
<a name="ln10990">  return;</a>
<a name="ln10991">}</a>
<a name="ln10992"> </a>
<a name="ln10993">// &quot;trim({expr})&quot; function</a>
<a name="ln10994">static void f_trim(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10995">{</a>
<a name="ln10996">  char buf1[NUMBUFLEN];</a>
<a name="ln10997">  char buf2[NUMBUFLEN];</a>
<a name="ln10998">  const char_u *head = (const char_u *)tv_get_string_buf_chk(&amp;argvars[0], buf1);</a>
<a name="ln10999">  const char_u *mask = NULL;</a>
<a name="ln11000">  const char_u *tail;</a>
<a name="ln11001">  const char_u *prev;</a>
<a name="ln11002">  const char_u *p;</a>
<a name="ln11003">  int c1;</a>
<a name="ln11004">  int dir = 0;</a>
<a name="ln11005"> </a>
<a name="ln11006">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11007">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln11008">  if (head == NULL) {</a>
<a name="ln11009">    return;</a>
<a name="ln11010">  }</a>
<a name="ln11011"> </a>
<a name="ln11012">  if (argvars[1].v_type == VAR_STRING) {</a>
<a name="ln11013">    mask = (const char_u *)tv_get_string_buf_chk(&amp;argvars[1], buf2);</a>
<a name="ln11014">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln11015">      bool error = false;</a>
<a name="ln11016">      // leading or trailing characters to trim</a>
<a name="ln11017">      dir = (int)tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln11018">      if (error) {</a>
<a name="ln11019">        return;</a>
<a name="ln11020">      }</a>
<a name="ln11021">      if (dir &lt; 0 || dir &gt; 2) {</a>
<a name="ln11022">        emsgf(_(e_invarg2), tv_get_string(&amp;argvars[2]));</a>
<a name="ln11023">        return;</a>
<a name="ln11024">      }</a>
<a name="ln11025">    }</a>
<a name="ln11026">  }</a>
<a name="ln11027"> </a>
<a name="ln11028">  if (dir == 0 || dir == 1) {</a>
<a name="ln11029">    // Trim leading characters</a>
<a name="ln11030">    while (*head != NUL) {</a>
<a name="ln11031">      c1 = PTR2CHAR(head);</a>
<a name="ln11032">      if (mask == NULL) {</a>
<a name="ln11033">        if (c1 &gt; ' ' &amp;&amp; c1 != 0xa0) {</a>
<a name="ln11034">          break;</a>
<a name="ln11035">        }</a>
<a name="ln11036">      } else {</a>
<a name="ln11037">        for (p = mask; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln11038">          if (c1 == PTR2CHAR(p)) {</a>
<a name="ln11039">            break;</a>
<a name="ln11040">          }</a>
<a name="ln11041">        }</a>
<a name="ln11042">        if (*p == NUL) {</a>
<a name="ln11043">          break;</a>
<a name="ln11044">        }</a>
<a name="ln11045">      }</a>
<a name="ln11046">      MB_PTR_ADV(head);</a>
<a name="ln11047">    }</a>
<a name="ln11048">  }</a>
<a name="ln11049"> </a>
<a name="ln11050">  tail = head + STRLEN(head);</a>
<a name="ln11051">  if (dir == 0 || dir == 2) {</a>
<a name="ln11052">    // Trim trailing characters</a>
<a name="ln11053">    for (; tail &gt; head; tail = prev) {</a>
<a name="ln11054">      prev = tail;</a>
<a name="ln11055">      MB_PTR_BACK(head, prev);</a>
<a name="ln11056">      c1 = PTR2CHAR(prev);</a>
<a name="ln11057">      if (mask == NULL) {</a>
<a name="ln11058">        if (c1 &gt; ' ' &amp;&amp; c1 != 0xa0) {</a>
<a name="ln11059">          break;</a>
<a name="ln11060">        }</a>
<a name="ln11061">      } else {</a>
<a name="ln11062">        for (p = mask; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln11063">          if (c1 == PTR2CHAR(p)) {</a>
<a name="ln11064">            break;</a>
<a name="ln11065">          }</a>
<a name="ln11066">        }</a>
<a name="ln11067">        if (*p == NUL) {</a>
<a name="ln11068">          break;</a>
<a name="ln11069">        }</a>
<a name="ln11070">      }</a>
<a name="ln11071">    }</a>
<a name="ln11072">  }</a>
<a name="ln11073">  rettv-&gt;vval.v_string = vim_strnsave(head, tail - head);</a>
<a name="ln11074">}</a>
<a name="ln11075"> </a>
<a name="ln11076">/*</a>
<a name="ln11077"> * &quot;type(expr)&quot; function</a>
<a name="ln11078"> */</a>
<a name="ln11079">static void f_type(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11080">{</a>
<a name="ln11081">  int n = -1;</a>
<a name="ln11082"> </a>
<a name="ln11083">  switch (argvars[0].v_type) {</a>
<a name="ln11084">    case VAR_NUMBER: n = VAR_TYPE_NUMBER; break;</a>
<a name="ln11085">    case VAR_STRING: n = VAR_TYPE_STRING; break;</a>
<a name="ln11086">    case VAR_PARTIAL:</a>
<a name="ln11087">    case VAR_FUNC:   n = VAR_TYPE_FUNC; break;</a>
<a name="ln11088">    case VAR_LIST:   n = VAR_TYPE_LIST; break;</a>
<a name="ln11089">    case VAR_DICT:   n = VAR_TYPE_DICT; break;</a>
<a name="ln11090">    case VAR_FLOAT:  n = VAR_TYPE_FLOAT; break;</a>
<a name="ln11091">    case VAR_BOOL:   n = VAR_TYPE_BOOL; break;</a>
<a name="ln11092">    case VAR_SPECIAL:n = VAR_TYPE_SPECIAL; break;</a>
<a name="ln11093">    case VAR_UNKNOWN: {</a>
<a name="ln11094">      internal_error(&quot;f_type(UNKNOWN)&quot;);</a>
<a name="ln11095">      break;</a>
<a name="ln11096">    }</a>
<a name="ln11097">  }</a>
<a name="ln11098">  rettv-&gt;vval.v_number = n;</a>
<a name="ln11099">}</a>
<a name="ln11100"> </a>
<a name="ln11101">/*</a>
<a name="ln11102"> * &quot;undofile(name)&quot; function</a>
<a name="ln11103"> */</a>
<a name="ln11104">static void f_undofile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11105">{</a>
<a name="ln11106">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11107">  const char *const fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln11108"> </a>
<a name="ln11109">  if (*fname == NUL) {</a>
<a name="ln11110">    // If there is no file name there will be no undo file.</a>
<a name="ln11111">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln11112">  } else {</a>
<a name="ln11113">    char *ffname = FullName_save(fname, true);</a>
<a name="ln11114"> </a>
<a name="ln11115">    if (ffname != NULL) {</a>
<a name="ln11116">      rettv-&gt;vval.v_string = (char_u *)u_get_undo_file_name(ffname, false);</a>
<a name="ln11117">    }</a>
<a name="ln11118">    xfree(ffname);</a>
<a name="ln11119">  }</a>
<a name="ln11120">}</a>
<a name="ln11121"> </a>
<a name="ln11122">/*</a>
<a name="ln11123"> * &quot;undotree()&quot; function</a>
<a name="ln11124"> */</a>
<a name="ln11125">static void f_undotree(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11126">{</a>
<a name="ln11127">  tv_dict_alloc_ret(rettv);</a>
<a name="ln11128"> </a>
<a name="ln11129">  dict_T *dict = rettv-&gt;vval.v_dict;</a>
<a name="ln11130"> </a>
<a name="ln11131">  tv_dict_add_nr(dict, S_LEN(&quot;synced&quot;), (varnumber_T)curbuf-&gt;b_u_synced);</a>
<a name="ln11132">  tv_dict_add_nr(dict, S_LEN(&quot;seq_last&quot;), (varnumber_T)curbuf-&gt;b_u_seq_last);</a>
<a name="ln11133">  tv_dict_add_nr(dict, S_LEN(&quot;save_last&quot;),</a>
<a name="ln11134">                 (varnumber_T)curbuf-&gt;b_u_save_nr_last);</a>
<a name="ln11135">  tv_dict_add_nr(dict, S_LEN(&quot;seq_cur&quot;), (varnumber_T)curbuf-&gt;b_u_seq_cur);</a>
<a name="ln11136">  tv_dict_add_nr(dict, S_LEN(&quot;time_cur&quot;), (varnumber_T)curbuf-&gt;b_u_time_cur);</a>
<a name="ln11137">  tv_dict_add_nr(dict, S_LEN(&quot;save_cur&quot;), (varnumber_T)curbuf-&gt;b_u_save_nr_cur);</a>
<a name="ln11138"> </a>
<a name="ln11139">  tv_dict_add_list(dict, S_LEN(&quot;entries&quot;), u_eval_tree(curbuf-&gt;b_u_oldhead));</a>
<a name="ln11140">}</a>
<a name="ln11141"> </a>
<a name="ln11142">/*</a>
<a name="ln11143"> * &quot;values(dict)&quot; function</a>
<a name="ln11144"> */</a>
<a name="ln11145">static void f_values(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11146">{</a>
<a name="ln11147">  dict_list(argvars, rettv, 1);</a>
<a name="ln11148">}</a>
<a name="ln11149"> </a>
<a name="ln11150">/*</a>
<a name="ln11151"> * &quot;virtcol(string)&quot; function</a>
<a name="ln11152"> */</a>
<a name="ln11153">static void f_virtcol(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11154">{</a>
<a name="ln11155">  colnr_T vcol = 0;</a>
<a name="ln11156">  pos_T       *fp;</a>
<a name="ln11157">  int fnum = curbuf-&gt;b_fnum;</a>
<a name="ln11158"> </a>
<a name="ln11159">  fp = var2fpos(&amp;argvars[0], FALSE, &amp;fnum);</a>
<a name="ln11160">  if (fp != NULL &amp;&amp; fp-&gt;lnum &lt;= curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln11161">      &amp;&amp; fnum == curbuf-&gt;b_fnum) {</a>
<a name="ln11162">    // Limit the column to a valid value, getvvcol() doesn't check.</a>
<a name="ln11163">    if (fp-&gt;col &lt; 0) {</a>
<a name="ln11164">      fp-&gt;col = 0;</a>
<a name="ln11165">    } else {</a>
<a name="ln11166">      const size_t len = STRLEN(ml_get(fp-&gt;lnum));</a>
<a name="ln11167">      if (fp-&gt;col &gt; (colnr_T)len) {</a>
<a name="ln11168">        fp-&gt;col = (colnr_T)len;</a>
<a name="ln11169">      }</a>
<a name="ln11170">    }</a>
<a name="ln11171">    getvvcol(curwin, fp, NULL, NULL, &amp;vcol);</a>
<a name="ln11172">    ++vcol;</a>
<a name="ln11173">  }</a>
<a name="ln11174"> </a>
<a name="ln11175">  rettv-&gt;vval.v_number = vcol;</a>
<a name="ln11176">}</a>
<a name="ln11177"> </a>
<a name="ln11178">/*</a>
<a name="ln11179"> * &quot;visualmode()&quot; function</a>
<a name="ln11180"> */</a>
<a name="ln11181">static void f_visualmode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11182">{</a>
<a name="ln11183">  char_u str[2];</a>
<a name="ln11184"> </a>
<a name="ln11185">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11186">  str[0] = curbuf-&gt;b_visual_mode_eval;</a>
<a name="ln11187">  str[1] = NUL;</a>
<a name="ln11188">  rettv-&gt;vval.v_string = vim_strsave(str);</a>
<a name="ln11189"> </a>
<a name="ln11190">  // A non-zero number or non-empty string argument: reset mode.</a>
<a name="ln11191">  if (non_zero_arg(&amp;argvars[0])) {</a>
<a name="ln11192">    curbuf-&gt;b_visual_mode_eval = NUL;</a>
<a name="ln11193">  }</a>
<a name="ln11194">}</a>
<a name="ln11195"> </a>
<a name="ln11196">/*</a>
<a name="ln11197"> * &quot;wildmenumode()&quot; function</a>
<a name="ln11198"> */</a>
<a name="ln11199">static void f_wildmenumode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11200">{</a>
<a name="ln11201">  if (wild_menu_showing || ((State &amp; CMDLINE) &amp;&amp; pum_visible())) {</a>
<a name="ln11202">    rettv-&gt;vval.v_number = 1;</a>
<a name="ln11203">  }</a>
<a name="ln11204">}</a>
<a name="ln11205"> </a>
<a name="ln11206">/// &quot;win_findbuf()&quot; function</a>
<a name="ln11207">static void f_win_findbuf(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11208">{</a>
<a name="ln11209">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln11210">  win_findbuf(argvars, rettv-&gt;vval.v_list);</a>
<a name="ln11211">}</a>
<a name="ln11212"> </a>
<a name="ln11213">/// &quot;win_getid()&quot; function</a>
<a name="ln11214">static void f_win_getid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11215">{</a>
<a name="ln11216">  rettv-&gt;vval.v_number = win_getid(argvars);</a>
<a name="ln11217">}</a>
<a name="ln11218"> </a>
<a name="ln11219">/// &quot;win_gettype(nr)&quot; function</a>
<a name="ln11220">static void f_win_gettype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11221">{</a>
<a name="ln11222">  win_T *wp = curwin;</a>
<a name="ln11223"> </a>
<a name="ln11224">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11225">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln11226">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln11227">    wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11228">    if (wp == NULL) {</a>
<a name="ln11229">      rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;unknown&quot;);</a>
<a name="ln11230">      return;</a>
<a name="ln11231">    }</a>
<a name="ln11232">  }</a>
<a name="ln11233">  if (wp == aucmd_win) {</a>
<a name="ln11234">    rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;autocmd&quot;);</a>
<a name="ln11235">  } else if (wp-&gt;w_p_pvw) {</a>
<a name="ln11236">    rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;preview&quot;);</a>
<a name="ln11237">  } else if (wp-&gt;w_floating) {</a>
<a name="ln11238">    rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;popup&quot;);</a>
<a name="ln11239">  } else if (wp == curwin &amp;&amp; cmdwin_type != 0) {</a>
<a name="ln11240">    rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;command&quot;);</a>
<a name="ln11241">  }</a>
<a name="ln11242">}</a>
<a name="ln11243"> </a>
<a name="ln11244">/// &quot;win_gotoid()&quot; function</a>
<a name="ln11245">static void f_win_gotoid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11246">{</a>
<a name="ln11247">  rettv-&gt;vval.v_number = win_gotoid(argvars);</a>
<a name="ln11248">}</a>
<a name="ln11249"> </a>
<a name="ln11250">/// &quot;win_id2tabwin()&quot; function</a>
<a name="ln11251">static void f_win_id2tabwin(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11252">{</a>
<a name="ln11253">  win_id2tabwin(argvars, rettv);</a>
<a name="ln11254">}</a>
<a name="ln11255"> </a>
<a name="ln11256">/// &quot;win_id2win()&quot; function</a>
<a name="ln11257">static void f_win_id2win(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11258">{</a>
<a name="ln11259">  rettv-&gt;vval.v_number = win_id2win(argvars);</a>
<a name="ln11260">}</a>
<a name="ln11261"> </a>
<a name="ln11262">/// &quot;winbufnr(nr)&quot; function</a>
<a name="ln11263">static void f_winbufnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11264">{</a>
<a name="ln11265">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11266">  if (wp == NULL) {</a>
<a name="ln11267">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln11268">  } else {</a>
<a name="ln11269">    rettv-&gt;vval.v_number = wp-&gt;w_buffer-&gt;b_fnum;</a>
<a name="ln11270">  }</a>
<a name="ln11271">}</a>
<a name="ln11272"> </a>
<a name="ln11273">/*</a>
<a name="ln11274"> * &quot;wincol()&quot; function</a>
<a name="ln11275"> */</a>
<a name="ln11276">static void f_wincol(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11277">{</a>
<a name="ln11278">  validate_cursor();</a>
<a name="ln11279">  rettv-&gt;vval.v_number = curwin-&gt;w_wcol + 1;</a>
<a name="ln11280">}</a>
<a name="ln11281"> </a>
<a name="ln11282">/// &quot;winheight(nr)&quot; function</a>
<a name="ln11283">static void f_winheight(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11284">{</a>
<a name="ln11285">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11286">  if (wp == NULL) {</a>
<a name="ln11287">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln11288">  } else {</a>
<a name="ln11289">    rettv-&gt;vval.v_number = wp-&gt;w_height;</a>
<a name="ln11290">  }</a>
<a name="ln11291">}</a>
<a name="ln11292"> </a>
<a name="ln11293">// &quot;winlayout()&quot; function</a>
<a name="ln11294">static void f_winlayout(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11295">{</a>
<a name="ln11296">  tabpage_T *tp;</a>
<a name="ln11297"> </a>
<a name="ln11298">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln11299"> </a>
<a name="ln11300">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln11301">    tp = curtab;</a>
<a name="ln11302">  } else {</a>
<a name="ln11303">    tp = find_tabpage((int)tv_get_number(&amp;argvars[0]));</a>
<a name="ln11304">    if (tp == NULL) {</a>
<a name="ln11305">      return;</a>
<a name="ln11306">    }</a>
<a name="ln11307">  }</a>
<a name="ln11308"> </a>
<a name="ln11309">  get_framelayout(tp-&gt;tp_topframe, rettv-&gt;vval.v_list, true);</a>
<a name="ln11310">}</a>
<a name="ln11311"> </a>
<a name="ln11312">/*</a>
<a name="ln11313"> * &quot;winline()&quot; function</a>
<a name="ln11314"> */</a>
<a name="ln11315">static void f_winline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11316">{</a>
<a name="ln11317">  validate_cursor();</a>
<a name="ln11318">  rettv-&gt;vval.v_number = curwin-&gt;w_wrow + 1;</a>
<a name="ln11319">}</a>
<a name="ln11320"> </a>
<a name="ln11321">/*</a>
<a name="ln11322"> * &quot;winnr()&quot; function</a>
<a name="ln11323"> */</a>
<a name="ln11324">static void f_winnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11325">{</a>
<a name="ln11326">  int nr = 1;</a>
<a name="ln11327"> </a>
<a name="ln11328">  nr = get_winnr(curtab, &amp;argvars[0]);</a>
<a name="ln11329">  rettv-&gt;vval.v_number = nr;</a>
<a name="ln11330">}</a>
<a name="ln11331"> </a>
<a name="ln11332">/*</a>
<a name="ln11333"> * &quot;winrestcmd()&quot; function</a>
<a name="ln11334"> */</a>
<a name="ln11335">static void f_winrestcmd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11336">{</a>
<a name="ln11337">  garray_T ga;</a>
<a name="ln11338">  char_u buf[50];</a>
<a name="ln11339"> </a>
<a name="ln11340">  ga_init(&amp;ga, (int)sizeof(char), 70);</a>
<a name="ln11341"> </a>
<a name="ln11342">  // Do this twice to handle some window layouts properly.</a>
<a name="ln11343">  for (int i = 0; i &lt; 2; i++) {</a>
<a name="ln11344">    int winnr = 1;</a>
<a name="ln11345">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln11346">      snprintf((char *)buf, sizeof(buf), &quot;%dresize %d|&quot;, winnr,</a>
<a name="ln11347">               wp-&gt;w_height);</a>
<a name="ln11348">      ga_concat(&amp;ga, buf);</a>
<a name="ln11349">      snprintf((char *)buf, sizeof(buf), &quot;vert %dresize %d|&quot;, winnr,</a>
<a name="ln11350">               wp-&gt;w_width);</a>
<a name="ln11351">      ga_concat(&amp;ga, buf);</a>
<a name="ln11352">      winnr++;</a>
<a name="ln11353">    }</a>
<a name="ln11354">  }</a>
<a name="ln11355">  ga_append(&amp;ga, NUL);</a>
<a name="ln11356"> </a>
<a name="ln11357">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln11358">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11359">}</a>
<a name="ln11360"> </a>
<a name="ln11361">/*</a>
<a name="ln11362"> * &quot;winrestview()&quot; function</a>
<a name="ln11363"> */</a>
<a name="ln11364">static void f_winrestview(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11365">{</a>
<a name="ln11366">  dict_T *dict;</a>
<a name="ln11367"> </a>
<a name="ln11368">  if (argvars[0].v_type != VAR_DICT</a>
<a name="ln11369">      || (dict = argvars[0].vval.v_dict) == NULL) {</a>
<a name="ln11370">    EMSG(_(e_invarg));</a>
<a name="ln11371">  } else {</a>
<a name="ln11372">    dictitem_T *di;</a>
<a name="ln11373">    if ((di = tv_dict_find(dict, S_LEN(&quot;lnum&quot;))) != NULL) {</a>
<a name="ln11374">      curwin-&gt;w_cursor.lnum = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11375">    }</a>
<a name="ln11376">    if ((di = tv_dict_find(dict, S_LEN(&quot;col&quot;))) != NULL) {</a>
<a name="ln11377">      curwin-&gt;w_cursor.col = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11378">    }</a>
<a name="ln11379">    if ((di = tv_dict_find(dict, S_LEN(&quot;coladd&quot;))) != NULL) {</a>
<a name="ln11380">      curwin-&gt;w_cursor.coladd = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11381">    }</a>
<a name="ln11382">    if ((di = tv_dict_find(dict, S_LEN(&quot;curswant&quot;))) != NULL) {</a>
<a name="ln11383">      curwin-&gt;w_curswant = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11384">      curwin-&gt;w_set_curswant = false;</a>
<a name="ln11385">    }</a>
<a name="ln11386">    if ((di = tv_dict_find(dict, S_LEN(&quot;topline&quot;))) != NULL) {</a>
<a name="ln11387">      set_topline(curwin, tv_get_number(&amp;di-&gt;di_tv));</a>
<a name="ln11388">    }</a>
<a name="ln11389">    if ((di = tv_dict_find(dict, S_LEN(&quot;topfill&quot;))) != NULL) {</a>
<a name="ln11390">      curwin-&gt;w_topfill = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11391">    }</a>
<a name="ln11392">    if ((di = tv_dict_find(dict, S_LEN(&quot;leftcol&quot;))) != NULL) {</a>
<a name="ln11393">      curwin-&gt;w_leftcol = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11394">    }</a>
<a name="ln11395">    if ((di = tv_dict_find(dict, S_LEN(&quot;skipcol&quot;))) != NULL) {</a>
<a name="ln11396">      curwin-&gt;w_skipcol = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11397">    }</a>
<a name="ln11398"> </a>
<a name="ln11399">    check_cursor();</a>
<a name="ln11400">    win_new_height(curwin, curwin-&gt;w_height);</a>
<a name="ln11401">    win_new_width(curwin, curwin-&gt;w_width);</a>
<a name="ln11402">    changed_window_setting();</a>
<a name="ln11403"> </a>
<a name="ln11404">    if (curwin-&gt;w_topline &lt;= 0)</a>
<a name="ln11405">      curwin-&gt;w_topline = 1;</a>
<a name="ln11406">    if (curwin-&gt;w_topline &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln11407">      curwin-&gt;w_topline = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln11408">    check_topfill(curwin, true);</a>
<a name="ln11409">  }</a>
<a name="ln11410">}</a>
<a name="ln11411"> </a>
<a name="ln11412">/*</a>
<a name="ln11413"> * &quot;winsaveview()&quot; function</a>
<a name="ln11414"> */</a>
<a name="ln11415">static void f_winsaveview(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11416">{</a>
<a name="ln11417">  dict_T      *dict;</a>
<a name="ln11418"> </a>
<a name="ln11419">  tv_dict_alloc_ret(rettv);</a>
<a name="ln11420">  dict = rettv-&gt;vval.v_dict;</a>
<a name="ln11421"> </a>
<a name="ln11422">  tv_dict_add_nr(dict, S_LEN(&quot;lnum&quot;), (varnumber_T)curwin-&gt;w_cursor.lnum);</a>
<a name="ln11423">  tv_dict_add_nr(dict, S_LEN(&quot;col&quot;), (varnumber_T)curwin-&gt;w_cursor.col);</a>
<a name="ln11424">  tv_dict_add_nr(dict, S_LEN(&quot;coladd&quot;), (varnumber_T)curwin-&gt;w_cursor.coladd);</a>
<a name="ln11425">  update_curswant();</a>
<a name="ln11426">  tv_dict_add_nr(dict, S_LEN(&quot;curswant&quot;), (varnumber_T)curwin-&gt;w_curswant);</a>
<a name="ln11427"> </a>
<a name="ln11428">  tv_dict_add_nr(dict, S_LEN(&quot;topline&quot;), (varnumber_T)curwin-&gt;w_topline);</a>
<a name="ln11429">  tv_dict_add_nr(dict, S_LEN(&quot;topfill&quot;), (varnumber_T)curwin-&gt;w_topfill);</a>
<a name="ln11430">  tv_dict_add_nr(dict, S_LEN(&quot;leftcol&quot;), (varnumber_T)curwin-&gt;w_leftcol);</a>
<a name="ln11431">  tv_dict_add_nr(dict, S_LEN(&quot;skipcol&quot;), (varnumber_T)curwin-&gt;w_skipcol);</a>
<a name="ln11432">}</a>
<a name="ln11433"> </a>
<a name="ln11434">/// &quot;winwidth(nr)&quot; function</a>
<a name="ln11435">static void f_winwidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11436">{</a>
<a name="ln11437">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11438">  if (wp == NULL) {</a>
<a name="ln11439">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln11440">  } else {</a>
<a name="ln11441">    rettv-&gt;vval.v_number = wp-&gt;w_width;</a>
<a name="ln11442">  }</a>
<a name="ln11443">}</a>
<a name="ln11444"> </a>
<a name="ln11445">// &quot;windowsversion()&quot; function</a>
<a name="ln11446">static void f_windowsversion(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11447">{</a>
<a name="ln11448">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11449">  rettv-&gt;vval.v_string = (char_u *)xstrdup(windowsVersion);</a>
<a name="ln11450">}</a>
<a name="ln11451"> </a>
<a name="ln11452">/// &quot;wordcount()&quot; function</a>
<a name="ln11453">static void f_wordcount(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11454">{</a>
<a name="ln11455">  tv_dict_alloc_ret(rettv);</a>
<a name="ln11456">  cursor_pos_info(rettv-&gt;vval.v_dict);</a>
<a name="ln11457">}</a>
<a name="ln11458"> </a>
<a name="ln11459">/// &quot;writefile()&quot; function</a>
<a name="ln11460">static void f_writefile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11461">{</a>
<a name="ln11462">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln11463"> </a>
<a name="ln11464">  if (check_secure()) {</a>
<a name="ln11465">    return;</a>
<a name="ln11466">  }</a>
<a name="ln11467"> </a>
<a name="ln11468">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln11469">    EMSG2(_(e_listarg), &quot;writefile()&quot;);</a>
<a name="ln11470">    return;</a>
<a name="ln11471">  }</a>
<a name="ln11472">  const list_T *const list = argvars[0].vval.v_list;</a>
<a name="ln11473">  TV_LIST_ITER_CONST(list, li, {</a>
<a name="ln11474">    if (!tv_check_str_or_nr(TV_LIST_ITEM_TV(li))) {</a>
<a name="ln11475">      return;</a>
<a name="ln11476">    }</a>
<a name="ln11477">  });</a>
<a name="ln11478"> </a>
<a name="ln11479">  bool binary = false;</a>
<a name="ln11480">  bool append = false;</a>
<a name="ln11481">  bool do_fsync = !!p_fs;</a>
<a name="ln11482">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln11483">    const char *const flags = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln11484">    if (flags == NULL) {</a>
<a name="ln11485">      return;</a>
<a name="ln11486">    }</a>
<a name="ln11487">    for (const char *p = flags; *p; p++) {</a>
<a name="ln11488">      switch (*p) {</a>
<a name="ln11489">        case 'b': { binary = true; break; }</a>
<a name="ln11490">        case 'a': { append = true; break; }</a>
<a name="ln11491">        case 's': { do_fsync = true; break; }</a>
<a name="ln11492">        case 'S': { do_fsync = false; break; }</a>
<a name="ln11493">        default: {</a>
<a name="ln11494">          // Using %s, p and not %c, *p to preserve multibyte characters</a>
<a name="ln11495">          emsgf(_(&quot;E5060: Unknown flag: %s&quot;), p);</a>
<a name="ln11496">          return;</a>
<a name="ln11497">        }</a>
<a name="ln11498">      }</a>
<a name="ln11499">    }</a>
<a name="ln11500">  }</a>
<a name="ln11501"> </a>
<a name="ln11502">  char buf[NUMBUFLEN];</a>
<a name="ln11503">  const char *const fname = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln11504">  if (fname == NULL) {</a>
<a name="ln11505">    return;</a>
<a name="ln11506">  }</a>
<a name="ln11507">  FileDescriptor fp;</a>
<a name="ln11508">  int error;</a>
<a name="ln11509">  if (*fname == NUL) {</a>
<a name="ln11510">    EMSG(_(&quot;E482: Can't open file with an empty name&quot;));</a>
<a name="ln11511">  } else if ((error = file_open(&amp;fp, fname,</a>
<a name="ln11512">                                ((append ? kFileAppend : kFileTruncate)</a>
<a name="ln11513">                                 | kFileCreate), 0666)) != 0) {</a>
<a name="ln11514">    emsgf(_(&quot;E482: Can't open file %s for writing: %s&quot;),</a>
<a name="ln11515">          fname, os_strerror(error));</a>
<a name="ln11516">  } else {</a>
<a name="ln11517">    if (write_list(&amp;fp, list, binary)) {</a>
<a name="ln11518">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln11519">    }</a>
<a name="ln11520">    if ((error = file_close(&amp;fp, do_fsync)) != 0) {</a>
<a name="ln11521">      emsgf(_(&quot;E80: Error when closing file %s: %s&quot;),</a>
<a name="ln11522">            fname, os_strerror(error));</a>
<a name="ln11523">    }</a>
<a name="ln11524">  }</a>
<a name="ln11525">}</a>
<a name="ln11526">/*</a>
<a name="ln11527"> * &quot;xor(expr, expr)&quot; function</a>
<a name="ln11528"> */</a>
<a name="ln11529">static void f_xor(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11530">{</a>
<a name="ln11531">  rettv-&gt;vval.v_number = tv_get_number_chk(&amp;argvars[0], NULL)</a>
<a name="ln11532">                         ^ tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln11533">}</a>

</code></pre>
<div class="balloon" rel="1822"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression is always true.</p></div>
<div class="balloon" rel="2502"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: mods != NULL.</p></div>
<div class="balloon" rel="3729"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="8297"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
