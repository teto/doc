
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>marktree.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// Tree data structure for storing marks at (row, col) positions and updating</a>
<a name="ln5">// them to arbitrary text changes. Derivative work of kbtree in klib, whose</a>
<a name="ln6">// copyright notice is reproduced below. Also inspired by the design of the</a>
<a name="ln7">// marker tree data structure of the Atom editor, regarding efficient updates</a>
<a name="ln8">// to text changes.</a>
<a name="ln9">//</a>
<a name="ln10">// Marks are inserted using marktree_put. Text changes are processed using</a>
<a name="ln11">// marktree_splice. All read and delete operations use the iterator.</a>
<a name="ln12">// use marktree_itr_get to put an iterator at a given position or</a>
<a name="ln13">// marktree_lookup to lookup a mark by its id (iterator optional in this case).</a>
<a name="ln14">// Use marktree_itr_current and marktree_itr_next/prev to read marks in a loop.</a>
<a name="ln15">// marktree_del_itr deletes the current mark of the iterator and implicitly</a>
<a name="ln16">// moves the iterator to the next mark.</a>
<a name="ln17">//</a>
<a name="ln18">// Work is ongoing to fully support ranges (mark pairs).</a>
<a name="ln19"> </a>
<a name="ln20">// Copyright notice for kbtree (included in heavily modified form):</a>
<a name="ln21">//</a>
<a name="ln22">// Copyright 1997-1999, 2001, John-Mark Gurney.</a>
<a name="ln23">//           2008-2009, Attractive Chaos &lt;attractor@live.co.uk&gt;</a>
<a name="ln24">//</a>
<a name="ln25">// Redistribution and use in source and binary forms, with or without</a>
<a name="ln26">// modification, are permitted provided that the following conditions</a>
<a name="ln27">// are met:</a>
<a name="ln28">//</a>
<a name="ln29">// 1. Redistributions of source code must retain the above copyright</a>
<a name="ln30">//    notice, this list of conditions and the following disclaimer.</a>
<a name="ln31">// 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln32">//    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln33">//    documentation and/or other materials provided with the distribution.</a>
<a name="ln34">//</a>
<a name="ln35">// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln36">// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln37">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln38">// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</a>
<a name="ln39">// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln40">// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln41">// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln42">// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln43">// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln44">// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln45">// SUCH DAMAGE.</a>
<a name="ln46">//</a>
<a name="ln47">// Changes done by by the neovim project follow the Apache v2 license available</a>
<a name="ln48">// at the repo root.</a>
<a name="ln49"> </a>
<a name="ln50">#include &lt;assert.h&gt;</a>
<a name="ln51"> </a>
<a name="ln52">#include &quot;nvim/marktree.h&quot;</a>
<a name="ln53">#include &quot;nvim/lib/kvec.h&quot;</a>
<a name="ln54">#include &quot;nvim/garray.h&quot;</a>
<a name="ln55"> </a>
<a name="ln56">#define T MT_BRANCH_FACTOR</a>
<a name="ln57">#define ILEN (sizeof(mtnode_t)+(2 * T) * sizeof(void *))</a>
<a name="ln58"> </a>
<a name="ln59">#define RIGHT_GRAVITY (((uint64_t)1) &lt;&lt; 63)</a>
<a name="ln60">#define ANTIGRAVITY(id) ((id)&amp;(RIGHT_GRAVITY-1))</a>
<a name="ln61">#define IS_RIGHT(id) ((id)&amp;RIGHT_GRAVITY)</a>
<a name="ln62"> </a>
<a name="ln63">#define PAIRED MARKTREE_PAIRED_FLAG</a>
<a name="ln64">#define END_FLAG MARKTREE_END_FLAG</a>
<a name="ln65">#define ID_INCR (((uint64_t)1) &lt;&lt; 2)</a>
<a name="ln66"> </a>
<a name="ln67">#define rawkey(itr) (itr-&gt;node-&gt;key[itr-&gt;i])</a>
<a name="ln68"> </a>
<a name="ln69">static bool pos_leq(mtpos_t a, mtpos_t b)</a>
<a name="ln70">{</a>
<a name="ln71">  return a.row &lt; b.row || (a.row == b.row &amp;&amp; a.col &lt;= b.col);</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">static void relative(mtpos_t base, mtpos_t *val)</a>
<a name="ln75">{</a>
<a name="ln76">  assert(pos_leq(base, *val));</a>
<a name="ln77">  if (val-&gt;row == base.row) {</a>
<a name="ln78">    val-&gt;row = 0;</a>
<a name="ln79">    val-&gt;col -= base.col;</a>
<a name="ln80">  } else {</a>
<a name="ln81">    val-&gt;row -= base.row;</a>
<a name="ln82">  }</a>
<a name="ln83">}</a>
<a name="ln84"> </a>
<a name="ln85">static void unrelative(mtpos_t base, mtpos_t *val)</a>
<a name="ln86">{</a>
<a name="ln87">  if (val-&gt;row == 0) {</a>
<a name="ln88">    val-&gt;row = base.row;</a>
<a name="ln89">    val-&gt;col += base.col;</a>
<a name="ln90">  } else {</a>
<a name="ln91">    val-&gt;row += base.row;</a>
<a name="ln92">  }</a>
<a name="ln93">}</a>
<a name="ln94"> </a>
<a name="ln95">static void compose(mtpos_t *base, mtpos_t val)</a>
<a name="ln96">{</a>
<a name="ln97">  if (val.row == 0) {</a>
<a name="ln98">    base-&gt;col += val.col;</a>
<a name="ln99">  } else {</a>
<a name="ln100">    base-&gt;row += val.row;</a>
<a name="ln101">    base-&gt;col = val.col;</a>
<a name="ln102">  }</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln106"># include &quot;marktree.c.generated.h&quot;</a>
<a name="ln107">#endif</a>
<a name="ln108"> </a>
<a name="ln109">#define mt_generic_cmp(a, b) (((b) &lt; (a)) - ((a) &lt; (b)))</a>
<a name="ln110">static int key_cmp(mtkey_t a, mtkey_t b)</a>
<a name="ln111">{</a>
<a name="ln112">  int cmp = mt_generic_cmp(a.pos.row, b.pos.row);</a>
<a name="ln113">  if (cmp != 0) {</a>
<a name="ln114">    return cmp;</a>
<a name="ln115">  }</a>
<a name="ln116">  cmp = mt_generic_cmp(a.pos.col, b.pos.col);</a>
<a name="ln117">  if (cmp != 0) {</a>
<a name="ln118">    return cmp;</a>
<a name="ln119">  }</a>
<a name="ln120">  // NB: keeping the events at the same pos sorted by id is actually not</a>
<a name="ln121">  // necessary only make sure that START is before END etc.</a>
<a name="ln122">  return mt_generic_cmp(a.id, b.id);</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">static inline int marktree_getp_aux(const mtnode_t *x, mtkey_t k, int *r)</a>
<a name="ln126">{</a>
<a name="ln127">  int tr, *rr, begin = 0, end = x-&gt;n;</a>
<a name="ln128">  if (x-&gt;n == 0) {</a>
<a name="ln129">    return -1;</a>
<a name="ln130">  }</a>
<a name="ln131">  rr = r? r : &amp;tr;</a>
<a name="ln132">  while (begin &lt; end) {</a>
<a name="ln133">    int mid = (begin + end) &gt;&gt; 1;</a>
<a name="ln134">    if (key_cmp(x-&gt;key[mid], k) &lt; 0) {</a>
<a name="ln135">      begin = mid + 1;</a>
<a name="ln136">    } else {</a>
<a name="ln137">      end = mid;</a>
<a name="ln138">    }</a>
<a name="ln139">  }</a>
<a name="ln140">  if (begin == x-&gt;n) { *rr = 1; return x-&gt;n - 1; }</a>
<a name="ln141">  if ((*rr = key_cmp(k, x-&gt;key[begin])) &lt; 0) {</a>
<a name="ln142">    begin--;</a>
<a name="ln143">  }</a>
<a name="ln144">  return begin;</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">static inline void refkey(MarkTree *b, mtnode_t *x, int i)</a>
<a name="ln148">{</a>
<a name="ln149">  pmap_put(uint64_t)(b-&gt;id2node, ANTIGRAVITY(x-&gt;key[i].id), x);</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">// put functions</a>
<a name="ln153"> </a>
<a name="ln154">// x must be an internal node, which is not full</a>
<a name="ln155">// x-&gt;ptr[i] should be a full node, i e x-&gt;ptr[i]-&gt;n == 2*T-1</a>
<a name="ln156">static inline void split_node(MarkTree *b, mtnode_t *x, const int i)</a>
<a name="ln157">{</a>
<a name="ln158">  mtnode_t *y = x-&gt;ptr[i];</a>
<a name="ln159">  mtnode_t *z;</a>
<a name="ln160">  z = (mtnode_t *)xcalloc(1, y-&gt;level ? ILEN : sizeof(mtnode_t));</a>
<a name="ln161">  b-&gt;n_nodes++;</a>
<a name="ln162">  z-&gt;level = y-&gt;level;</a>
<a name="ln163">  z-&gt;n = T - 1;</a>
<a name="ln164">  memcpy(z-&gt;key, &amp;y-&gt;key[T], sizeof(mtkey_t) * (T - 1));</a>
<a name="ln165">  for (int j = 0; j &lt; T-1; j++) {</a>
<a name="ln166">    refkey(b, z, j);</a>
<a name="ln167">  }</a>
<a name="ln168">  if (y-&gt;level) {</a>
<a name="ln169">    memcpy(z-&gt;ptr, &amp;y-&gt;ptr[T], sizeof(mtnode_t *) * T);</a>
<a name="ln170">    for (int j = 0; j &lt; T; j++) {</a>
<a name="ln171">      z-&gt;ptr[j]-&gt;parent = z;</a>
<a name="ln172">    }</a>
<a name="ln173">  }</a>
<a name="ln174">  y-&gt;n = T - 1;</a>
<a name="ln175">  memmove(&amp;x-&gt;ptr[i + 2], &amp;x-&gt;ptr[i + 1],</a>
<a name="ln176">          sizeof(mtnode_t *) * (size_t)(x-&gt;n - i));</a>
<a name="ln177">  x-&gt;ptr[i + 1] = z;</a>
<a name="ln178">  z-&gt;parent = x;  // == y-&gt;parent</a>
<a name="ln179">  memmove(&amp;x-&gt;key[i + 1], &amp;x-&gt;key[i], sizeof(mtkey_t) * (size_t)(x-&gt;n - i));</a>
<a name="ln180"> </a>
<a name="ln181">  // move key to internal layer:</a>
<a name="ln182">  x-&gt;key[i] = y-&gt;key[T - 1];</a>
<a name="ln183">  refkey(b, x, i);</a>
<a name="ln184">  x-&gt;n++;</a>
<a name="ln185"> </a>
<a name="ln186">  for (int j = 0; j &lt; T-1; j++) {</a>
<a name="ln187">    relative(x-&gt;key[i].pos, &amp;z-&gt;key[j].pos);</a>
<a name="ln188">  }</a>
<a name="ln189">  if (i &gt; 0) {</a>
<a name="ln190">    unrelative(x-&gt;key[i-1].pos, &amp;x-&gt;key[i].pos);</a>
<a name="ln191">  }</a>
<a name="ln192">}</a>
<a name="ln193"> </a>
<a name="ln194">// x must not be a full node (even if there might be internal space)</a>
<a name="ln195">static inline void marktree_putp_aux(MarkTree *b, mtnode_t *x, mtkey_t k)</a>
<a name="ln196">{</a>
<a name="ln197">  int i;</a>
<a name="ln198">  if (x-&gt;level == 0) {</a>
<a name="ln199">    i = marktree_getp_aux(x, k, 0);</a>
<a name="ln200">    if (i != x-&gt;n - 1) {</a>
<a name="ln201">      memmove(&amp;x-&gt;key[i + 2], &amp;x-&gt;key[i + 1],</a>
<a name="ln202">              (size_t)(x-&gt;n - i - 1) * sizeof(mtkey_t));</a>
<a name="ln203">    }</a>
<a name="ln204">    x-&gt;key[i + 1] = k;</a>
<a name="ln205">    refkey(b, x, i+1);</a>
<a name="ln206">    x-&gt;n++;</a>
<a name="ln207">  } else {</a>
<a name="ln208">    i = marktree_getp_aux(x, k, 0) + 1;</a>
<a name="ln209">    if (x-&gt;ptr[i]-&gt;n == 2 * T - 1) {</a>
<a name="ln210">      split_node(b, x, i);</a>
<a name="ln211">      if (key_cmp(k, x-&gt;key[i]) &gt; 0) {</a>
<a name="ln212">        i++;</a>
<a name="ln213">      }</a>
<a name="ln214">    }</a>
<a name="ln215">    if (i &gt; 0) {</a>
<a name="ln216">      relative(x-&gt;key[i-1].pos, &amp;k.pos);</a>
<a name="ln217">    }</a>
<a name="ln218">    marktree_putp_aux(b, x-&gt;ptr[i], k);</a>
<a name="ln219">  }</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222">uint64_t marktree_put(MarkTree *b, int row, int col, bool right_gravity)</a>
<a name="ln223">{</a>
<a name="ln224">  uint64_t id = (b-&gt;next_id+=ID_INCR);</a>
<a name="ln225">  uint64_t keyid = id;</a>
<a name="ln226">  if (right_gravity) {</a>
<a name="ln227">    // order all right gravity keys after the left ones, for effortless</a>
<a name="ln228">    // insertion (but not deletion!)</a>
<a name="ln229">    keyid |= RIGHT_GRAVITY;</a>
<a name="ln230">  }</a>
<a name="ln231">  marktree_put_key(b, row, col, keyid);</a>
<a name="ln232">  return id;</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">uint64_t marktree_put_pair(MarkTree *b,</a>
<a name="ln236">                           int start_row, int start_col, bool start_right,</a>
<a name="ln237">                           int end_row, int end_col, bool end_right)</a>
<a name="ln238">{</a>
<a name="ln239">  uint64_t id = (b-&gt;next_id+=ID_INCR)|PAIRED;</a>
<a name="ln240">  uint64_t start_id = id|(start_right?RIGHT_GRAVITY:0);</a>
<a name="ln241">  uint64_t end_id = id|END_FLAG|(end_right?RIGHT_GRAVITY:0);</a>
<a name="ln242">  marktree_put_key(b, start_row, start_col, start_id);</a>
<a name="ln243">  marktree_put_key(b, end_row, end_col, end_id);</a>
<a name="ln244">  return id;</a>
<a name="ln245">}</a>
<a name="ln246"> </a>
<a name="ln247">void marktree_put_key(MarkTree *b, int row, int col, uint64_t id)</a>
<a name="ln248">{</a>
<a name="ln249">  mtkey_t k = { .pos = { .row = row, .col = col }, .id = id };</a>
<a name="ln250"> </a>
<a name="ln251">  if (!b-&gt;root) {</a>
<a name="ln252">    b-&gt;root = (mtnode_t *)xcalloc(1, ILEN);</a>
<a name="ln253">    b-&gt;id2node = pmap_new(uint64_t)();</a>
<a name="ln254">    b-&gt;n_nodes++;</a>
<a name="ln255">  }</a>
<a name="ln256">  mtnode_t *r, *s;</a>
<a name="ln257">  b-&gt;n_keys++;</a>
<a name="ln258">  r = b-&gt;root;</a>
<a name="ln259">  if (r-&gt;n == 2 * T - 1) {</a>
<a name="ln260">    b-&gt;n_nodes++;</a>
<a name="ln261">    s = (mtnode_t *)xcalloc(1, ILEN);</a>
<a name="ln262">    b-&gt;root = s; s-&gt;level = r-&gt;level+1; s-&gt;n = 0;</a>
<a name="ln263">    s-&gt;ptr[0] = r;</a>
<a name="ln264">    r-&gt;parent = s;</a>
<a name="ln265">    split_node(b, s, 0);</a>
<a name="ln266">    r = s;</a>
<a name="ln267">  }</a>
<a name="ln268">  marktree_putp_aux(b, r, k);</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">/// INITIATING DELETION PROTOCOL:</a>
<a name="ln272">///</a>
<a name="ln273">/// 1. Construct a valid iterator to the node to delete (argument)</a>
<a name="ln274">/// 2. If an &quot;internal&quot; key. Iterate one step to the left or right,</a>
<a name="ln275">///     which gives an internal key &quot;auxiliary key&quot;.</a>
<a name="ln276">/// 3. Now delete this internal key (intended or auxiliary).</a>
<a name="ln277">///    The leaf node X might become undersized.</a>
<a name="ln278">/// 4. If step two was done: now replace the key that _should_ be</a>
<a name="ln279">///    deleted with the auxiliary key. Adjust relative</a>
<a name="ln280">/// 5. Now &quot;repair&quot; the tree as needed. We always start at a leaf node X.</a>
<a name="ln281">///     - if the node is big enough, terminate</a>
<a name="ln282">///     - if we can steal from the left, steal</a>
<a name="ln283">///     - if we can steal from the right, steal</a>
<a name="ln284">///     - otherwise merge this node with a neighbour. This might make our</a>
<a name="ln285">///       parent undersized. So repeat 5 for the parent.</a>
<a name="ln286">/// 6. If 4 went all the way to the root node. The root node</a>
<a name="ln287">///    might have ended up with size 0. Delete it then.</a>
<a name="ln288">///</a>
<a name="ln289">/// NB: ideally keeps the iterator valid. Like point to the key after this</a>
<a name="ln290">/// if present.</a>
<a name="ln291">///</a>
<a name="ln292">/// @param rev should be true if we plan to iterate _backwards_ and delete</a>
<a name="ln293">///            stuff before this key. Most of the time this is false (the</a>
<a name="ln294">///            recommended strategy is to always iterate forward)</a>
<a name="ln295">void marktree_del_itr(MarkTree *b, MarkTreeIter *itr, bool rev)</a>
<a name="ln296">{</a>
<a name="ln297">  int adjustment = 0;</a>
<a name="ln298"> </a>
<a name="ln299">  mtnode_t *cur = itr-&gt;node;</a>
<a name="ln300">  int curi = itr-&gt;i;</a>
<a name="ln301">  uint64_t id = cur-&gt;key[curi].id;</a>
<a name="ln302">  // fprintf(stderr, &quot;\nDELET %lu\n&quot;, id);</a>
<a name="ln303"> </a>
<a name="ln304">  if (itr-&gt;node-&gt;level) {</a>
<a name="ln305">    if (rev) {</a>
<a name="ln306">      abort();</a>
<a name="ln307">    } else {</a>
<a name="ln308">      // fprintf(stderr, &quot;INTERNAL %d\n&quot;, cur-&gt;level);</a>
<a name="ln309">      // steal previous node</a>
<a name="ln310">      marktree_itr_prev(b, itr);</a>
<a name="ln311">      adjustment = -1;</a>
<a name="ln312">    }</a>
<a name="ln313">  }</a>
<a name="ln314"> </a>
<a name="ln315">  // 3.</a>
<a name="ln316">  mtnode_t *x = itr-&gt;node;</a>
<a name="ln317">  assert(x-&gt;level == 0);</a>
<a name="ln318">  mtkey_t intkey = x-&gt;key[itr-&gt;i];</a>
<a name="ln319">  if (x-&gt;n &gt; itr-&gt;i+1) {</a>
<a name="ln320">    memmove(&amp;x-&gt;key[itr-&gt;i], &amp;x-&gt;key[itr-&gt;i+1],</a>
<a name="ln321">            sizeof(mtkey_t) * (size_t)(x-&gt;n - itr-&gt;i-1));</a>
<a name="ln322">  }</a>
<a name="ln323">  x-&gt;n--;</a>
<a name="ln324"> </a>
<a name="ln325">  // 4.</a>
<a name="ln326">  // if (adjustment == 1) {</a>
<a name="ln327">  //   abort();</a>
<a name="ln328">  // }</a>
<a name="ln329">  if (adjustment == -1) {</a>
<a name="ln330">    int ilvl = itr-&gt;lvl-1;</a>
<a name="ln331">    const mtnode_t *lnode = x;</a>
<a name="ln332">    do {</a>
<a name="ln333">      const mtnode_t *const p = lnode-&gt;parent;</a>
<a name="ln334">      if (ilvl &lt; 0) {</a>
<a name="ln335">        abort();</a>
<a name="ln336">      }</a>
<a name="ln337">      const int i = itr-&gt;s[ilvl].i;</a>
<a name="ln338">      assert(p-&gt;ptr[i] == lnode);</a>
<a name="ln339">      if (i &gt; 0) {</a>
<a name="ln340">        unrelative(p-&gt;key[i-1].pos, &amp;intkey.pos);</a>
<a name="ln341">      }</a>
<a name="ln342">      lnode = p;</a>
<a name="ln343">      ilvl--;</a>
<a name="ln344">    } while (lnode != cur);</a>
<a name="ln345"> </a>
<a name="ln346">    mtkey_t deleted = cur-&gt;key[curi];</a>
<a name="ln347">    cur-&gt;key[curi] = intkey;</a>
<a name="ln348">    refkey(b, cur, curi);</a>
<a name="ln349">    relative(intkey.pos, &amp;deleted.pos);</a>
<a name="ln350">    mtnode_t *y = cur-&gt;ptr[curi+1];</a>
<a name="ln351">    if (deleted.pos.row || deleted.pos.col) {</a>
<a name="ln352">      while (y) {</a>
<a name="ln353">        for (int k = 0; k &lt; y-&gt;n; k++) {</a>
<a name="ln354">          unrelative(deleted.pos, &amp;y-&gt;key[k].pos);</a>
<a name="ln355">        }</a>
<a name="ln356">        y = y-&gt;level ? y-&gt;ptr[0] : NULL;</a>
<a name="ln357">      }</a>
<a name="ln358">    }</a>
<a name="ln359">  }</a>
<a name="ln360"> </a>
<a name="ln361">  b-&gt;n_keys--;</a>
<a name="ln362">  pmap_del(uint64_t)(b-&gt;id2node, ANTIGRAVITY(id));</a>
<a name="ln363"> </a>
<a name="ln364">  // 5.</a>
<a name="ln365">  bool itr_dirty = false;</a>
<a name="ln366">  int rlvl = itr-&gt;lvl-1;</a>
<a name="ln367">  int *lasti = &amp;itr-&gt;i;</a>
<a name="ln368">  while (x != b-&gt;root) {</a>
<a name="ln369">    assert(rlvl &gt;= 0);</a>
<a name="ln370">    mtnode_t *p = x-&gt;parent;</a>
<a name="ln371">    if (x-&gt;n &gt;= T-1) {</a>
<a name="ln372">      // we are done, if this node is fine the rest of the tree will be</a>
<a name="ln373">      break;</a>
<a name="ln374">    }</a>
<a name="ln375">    int pi = itr-&gt;s[rlvl].i;</a>
<a name="ln376">    assert(p-&gt;ptr[pi] == x);</a>
<a name="ln377">    if (pi &gt; 0 &amp;&amp; p-&gt;ptr[pi-1]-&gt;n &gt; T-1) {</a>
<a name="ln378">      *lasti += 1;</a>
<a name="ln379">      itr_dirty = true;</a>
<a name="ln380">      // steal one key from the left neighbour</a>
<a name="ln381">      pivot_right(b, p, pi-1);</a>
<a name="ln382">      break;</a>
<a name="ln383">    } else if (pi &lt; p-&gt;n &amp;&amp; p-&gt;ptr[pi+1]-&gt;n &gt; T-1) {</a>
<a name="ln384">      // steal one key from right neighbour</a>
<a name="ln385">      pivot_left(b, p, pi);</a>
<a name="ln386">      break;</a>
<a name="ln387">    } else if (pi &gt; 0) {</a>
<a name="ln388">      // fprintf(stderr, &quot;LEFT &quot;);</a>
<a name="ln389">      assert(p-&gt;ptr[pi-1]-&gt;n == T-1);</a>
<a name="ln390">      // merge with left neighbour</a>
<a name="ln391">      *lasti += T;</a>
<a name="ln392">      x = merge_node(b, p, pi-1);</a>
<a name="ln393">      if (lasti == &amp;itr-&gt;i) {</a>
<a name="ln394">        // TRICKY: we merged the node the iterator was on</a>
<a name="ln395">        itr-&gt;node = x;</a>
<a name="ln396">      }</a>
<a name="ln397">      itr-&gt;s[rlvl].i--;</a>
<a name="ln398">      itr_dirty = true;</a>
<a name="ln399">    } else {</a>
<a name="ln400">      // fprintf(stderr, &quot;RIGHT &quot;);</a>
<a name="ln401">      assert(pi &lt; p-&gt;n &amp;&amp; p-&gt;ptr[pi+1]-&gt;n == T-1);</a>
<a name="ln402">      merge_node(b, p, pi);</a>
<a name="ln403">      // no iter adjustment needed</a>
<a name="ln404">    }</a>
<a name="ln405">    lasti = &amp;itr-&gt;s[rlvl].i;</a>
<a name="ln406">    rlvl--;</a>
<a name="ln407">    x = p;</a>
<a name="ln408">  }</a>
<a name="ln409"> </a>
<a name="ln410">  // 6.</a>
<a name="ln411">  if (b-&gt;root-&gt;n == 0) {</a>
<a name="ln412">    if (itr-&gt;lvl &gt; 0) {</a>
<a name="ln413">      memmove(itr-&gt;s, itr-&gt;s+1, (size_t)(itr-&gt;lvl-1) * sizeof(*itr-&gt;s));</a>
<a name="ln414">      itr-&gt;lvl--;</a>
<a name="ln415">    }</a>
<a name="ln416">    if (b-&gt;root-&gt;level) {</a>
<a name="ln417">      mtnode_t *oldroot = b-&gt;root;</a>
<a name="ln418">      b-&gt;root = b-&gt;root-&gt;ptr[0];</a>
<a name="ln419">      b-&gt;root-&gt;parent = NULL;</a>
<a name="ln420">      xfree(oldroot);</a>
<a name="ln421">    } else {</a>
<a name="ln422">      // no items, nothing for iterator to point to</a>
<a name="ln423">      // not strictly needed, should handle delete right-most mark anyway</a>
<a name="ln424">      itr-&gt;node = NULL;</a>
<a name="ln425">    }</a>
<a name="ln426">  }</a>
<a name="ln427"> </a>
<a name="ln428">  if (itr-&gt;node &amp;&amp; itr_dirty) {</a>
<a name="ln429">    marktree_itr_fix_pos(b, itr);</a>
<a name="ln430">  }</a>
<a name="ln431"> </a>
<a name="ln432">  // BONUS STEP: fix the iterator, so that it points to the key afterwards</a>
<a name="ln433">  // TODO(bfredl): with &quot;rev&quot; should point before</a>
<a name="ln434">  // if (adjustment == 1) {</a>
<a name="ln435">  //   abort();</a>
<a name="ln436">  // }</a>
<a name="ln437">  if (adjustment == -1) {</a>
<a name="ln438">    // tricky: we stand at the deleted space in the previous leaf node.</a>
<a name="ln439">    // But the inner key is now the previous key we stole, so we need</a>
<a name="ln440">    // to skip that one as well.</a>
<a name="ln441">    marktree_itr_next(b, itr);</a>
<a name="ln442">    marktree_itr_next(b, itr);</a>
<a name="ln443">  } else {</a>
<a name="ln444">    if (itr-&gt;node &amp;&amp; itr-&gt;i &gt;= itr-&gt;node-&gt;n) {</a>
<a name="ln445">      // we deleted the last key of a leaf node</a>
<a name="ln446">      // go to the inner key after that.</a>
<a name="ln447">      assert(itr-&gt;node-&gt;level == 0);</a>
<a name="ln448">      marktree_itr_next(b, itr);</a>
<a name="ln449">    }</a>
<a name="ln450">  }</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">static mtnode_t *merge_node(MarkTree *b, mtnode_t *p, int i)</a>
<a name="ln454">{</a>
<a name="ln455">  mtnode_t *x = p-&gt;ptr[i], *y = p-&gt;ptr[i+1];</a>
<a name="ln456"> </a>
<a name="ln457">  x-&gt;key[x-&gt;n] = p-&gt;key[i];</a>
<a name="ln458">  refkey(b, x, x-&gt;n);</a>
<a name="ln459">  if (i &gt; 0) {</a>
<a name="ln460">    relative(p-&gt;key[i-1].pos, &amp;x-&gt;key[x-&gt;n].pos);</a>
<a name="ln461">  }</a>
<a name="ln462"> </a>
<a name="ln463">  memmove(&amp;x-&gt;key[x-&gt;n+1], y-&gt;key, (size_t)y-&gt;n * sizeof(mtkey_t));</a>
<a name="ln464">  for (int k = 0; k &lt; y-&gt;n; k++) {</a>
<a name="ln465">    refkey(b, x, x-&gt;n+1+k);</a>
<a name="ln466">    unrelative(x-&gt;key[x-&gt;n].pos, &amp;x-&gt;key[x-&gt;n+1+k].pos);</a>
<a name="ln467">  }</a>
<a name="ln468">  if (x-&gt;level) {</a>
<a name="ln469">    memmove(&amp;x-&gt;ptr[x-&gt;n+1], y-&gt;ptr, (size_t)(y-&gt;n + 1) * sizeof(mtnode_t *));</a>
<a name="ln470">    for (int k = 0; k &lt; y-&gt;n+1; k++) {</a>
<a name="ln471">      x-&gt;ptr[x-&gt;n+k+1]-&gt;parent = x;</a>
<a name="ln472">    }</a>
<a name="ln473">  }</a>
<a name="ln474">  x-&gt;n += y-&gt;n+1;</a>
<a name="ln475">  memmove(&amp;p-&gt;key[i], &amp;p-&gt;key[i + 1], (size_t)(p-&gt;n - i - 1) * sizeof(mtkey_t));</a>
<a name="ln476">  memmove(&amp;p-&gt;ptr[i + 1], &amp;p-&gt;ptr[i + 2],</a>
<a name="ln477">          (size_t)(p-&gt;n - i - 1) * sizeof(mtkey_t *));</a>
<a name="ln478">  p-&gt;n--;</a>
<a name="ln479">  xfree(y);</a>
<a name="ln480">  b-&gt;n_nodes--;</a>
<a name="ln481">  return x;</a>
<a name="ln482">}</a>
<a name="ln483"> </a>
<a name="ln484">// TODO(bfredl): as a potential &quot;micro&quot; optimization, pivoting should balance</a>
<a name="ln485">// the two nodes instead of stealing just one key</a>
<a name="ln486">static void pivot_right(MarkTree *b, mtnode_t *p, int i)</a>
<a name="ln487">{</a>
<a name="ln488">  mtnode_t *x = p-&gt;ptr[i], *y = p-&gt;ptr[i+1];</a>
<a name="ln489">  memmove(&amp;y-&gt;key[1], y-&gt;key, (size_t)y-&gt;n * sizeof(mtkey_t));</a>
<a name="ln490">  if (y-&gt;level) {</a>
<a name="ln491">    memmove(&amp;y-&gt;ptr[1], y-&gt;ptr, (size_t)(y-&gt;n + 1) * sizeof(mtnode_t *));</a>
<a name="ln492">  }</a>
<a name="ln493">  y-&gt;key[0] = p-&gt;key[i];</a>
<a name="ln494">  refkey(b, y, 0);</a>
<a name="ln495">  p-&gt;key[i] = x-&gt;key[x-&gt;n - 1];</a>
<a name="ln496">  refkey(b, p, i);</a>
<a name="ln497">  if (x-&gt;level) {</a>
<a name="ln498">    y-&gt;ptr[0] = x-&gt;ptr[x-&gt;n];</a>
<a name="ln499">    y-&gt;ptr[0]-&gt;parent = y;</a>
<a name="ln500">  }</a>
<a name="ln501">  x-&gt;n--;</a>
<a name="ln502">  y-&gt;n++;</a>
<a name="ln503">  if (i &gt; 0) {</a>
<a name="ln504">    unrelative(p-&gt;key[i-1].pos, &amp;p-&gt;key[i].pos);</a>
<a name="ln505">  }</a>
<a name="ln506">  relative(p-&gt;key[i].pos, &amp;y-&gt;key[0].pos);</a>
<a name="ln507">  for (int k = 1; k &lt; y-&gt;n; k++) {</a>
<a name="ln508">    unrelative(y-&gt;key[0].pos, &amp;y-&gt;key[k].pos);</a>
<a name="ln509">  }</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">static void pivot_left(MarkTree *b, mtnode_t *p, int i)</a>
<a name="ln513">{</a>
<a name="ln514">  mtnode_t *x = p-&gt;ptr[i], *y = p-&gt;ptr[i+1];</a>
<a name="ln515"> </a>
<a name="ln516">  // reverse from how we &quot;always&quot; do it. but pivot_left</a>
<a name="ln517">  // is just the inverse of pivot_right, so reverse it literally.</a>
<a name="ln518">  for (int k = 1; k &lt; y-&gt;n; k++) {</a>
<a name="ln519">    relative(y-&gt;key[0].pos, &amp;y-&gt;key[k].pos);</a>
<a name="ln520">  }</a>
<a name="ln521">  unrelative(p-&gt;key[i].pos, &amp;y-&gt;key[0].pos);</a>
<a name="ln522">  if (i &gt; 0) {</a>
<a name="ln523">    relative(p-&gt;key[i-1].pos, &amp;p-&gt;key[i].pos);</a>
<a name="ln524">  }</a>
<a name="ln525"> </a>
<a name="ln526">  x-&gt;key[x-&gt;n] = p-&gt;key[i];</a>
<a name="ln527">  refkey(b, x, x-&gt;n);</a>
<a name="ln528">  p-&gt;key[i] = y-&gt;key[0];</a>
<a name="ln529">  refkey(b, p, i);</a>
<a name="ln530">  if (x-&gt;level) {</a>
<a name="ln531">    x-&gt;ptr[x-&gt;n+1] = y-&gt;ptr[0];</a>
<a name="ln532">    x-&gt;ptr[x-&gt;n+1]-&gt;parent = x;</a>
<a name="ln533">  }</a>
<a name="ln534">  memmove(y-&gt;key, &amp;y-&gt;key[1], (size_t)(y-&gt;n-1) * sizeof(mtkey_t));</a>
<a name="ln535">  if (y-&gt;level) {</a>
<a name="ln536">    memmove(y-&gt;ptr, &amp;y-&gt;ptr[1], (size_t)y-&gt;n * sizeof(mtnode_t *));</a>
<a name="ln537">  }</a>
<a name="ln538">  x-&gt;n++;</a>
<a name="ln539">  y-&gt;n--;</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">/// frees all mem, resets tree to valid empty state</a>
<a name="ln543">void marktree_clear(MarkTree *b)</a>
<a name="ln544">{</a>
<a name="ln545">  if (b-&gt;root) {</a>
<a name="ln546">    marktree_free_node(b-&gt;root);</a>
<a name="ln547">    b-&gt;root = NULL;</a>
<a name="ln548">  }</a>
<a name="ln549">  if (b-&gt;id2node) {</a>
<a name="ln550">    pmap_free(uint64_t)(b-&gt;id2node);</a>
<a name="ln551">    b-&gt;id2node = NULL;</a>
<a name="ln552">  }</a>
<a name="ln553">  b-&gt;n_keys = 0;</a>
<a name="ln554">  b-&gt;n_nodes = 0;</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557">void marktree_free_node(mtnode_t *x)</a>
<a name="ln558">{</a>
<a name="ln559">  if (x-&gt;level) {</a>
<a name="ln560">    for (int i = 0; i &lt; x-&gt;n+1; i++) {</a>
<a name="ln561">      marktree_free_node(x-&gt;ptr[i]);</a>
<a name="ln562">    }</a>
<a name="ln563">  }</a>
<a name="ln564">  xfree(x);</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567">/// NB: caller must check not pair!</a>
<a name="ln568">uint64_t marktree_revise(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln569">{</a>
<a name="ln570">  uint64_t old_id = rawkey(itr).id;</a>
<a name="ln571">  pmap_del(uint64_t)(b-&gt;id2node, ANTIGRAVITY(old_id));</a>
<a name="ln572">  uint64_t new_id = (b-&gt;next_id += ID_INCR);</a>
<a name="ln573">  rawkey(itr).id = new_id + (RIGHT_GRAVITY&amp;old_id);</a>
<a name="ln574">  refkey(b, itr-&gt;node, itr-&gt;i);</a>
<a name="ln575">  return new_id;</a>
<a name="ln576">}</a>
<a name="ln577"> </a>
<a name="ln578">void marktree_move(MarkTree *b, MarkTreeIter *itr, int row, int col)</a>
<a name="ln579">{</a>
<a name="ln580">  uint64_t old_id = rawkey(itr).id;</a>
<a name="ln581">  // TODO(bfredl): optimize when moving a mark within a leaf without moving it</a>
<a name="ln582">  // across neighbours!</a>
<a name="ln583">  marktree_del_itr(b, itr, false);</a>
<a name="ln584">  marktree_put_key(b, row, col, old_id);</a>
<a name="ln585">  itr-&gt;node = NULL;  // itr might become invalid by put</a>
<a name="ln586">}</a>
<a name="ln587"> </a>
<a name="ln588">// itr functions</a>
<a name="ln589"> </a>
<a name="ln590">// TODO(bfredl): static inline?</a>
<a name="ln591">bool marktree_itr_get(MarkTree *b, int row, int col, MarkTreeIter *itr)</a>
<a name="ln592">{</a>
<a name="ln593">  return marktree_itr_get_ext(b, (mtpos_t){ row, col },</a>
<a name="ln594">                              itr, false, false, NULL);</a>
<a name="ln595">}</a>
<a name="ln596"> </a>
<a name="ln597">bool marktree_itr_get_ext(MarkTree *b, mtpos_t p, MarkTreeIter *itr,</a>
<a name="ln598">                          bool last, bool gravity, mtpos_t *oldbase)</a>
<a name="ln599">{</a>
<a name="ln600">  mtkey_t k = { .pos = p, .id = gravity ? RIGHT_GRAVITY : 0 };</a>
<a name="ln601">  if (last &amp;&amp; !gravity) {</a>
<a name="ln602">    k.id = UINT64_MAX;</a>
<a name="ln603">  }</a>
<a name="ln604">  if (b-&gt;n_keys == 0) {</a>
<a name="ln605">    itr-&gt;node = NULL;</a>
<a name="ln606">    return false;</a>
<a name="ln607">  }</a>
<a name="ln608">  itr-&gt;pos = (mtpos_t){ 0, 0 };</a>
<a name="ln609">  itr-&gt;node = b-&gt;root;</a>
<a name="ln610">  itr-&gt;lvl = 0;</a>
<a name="ln611">  if (oldbase) {</a>
<a name="ln612">    oldbase[itr-&gt;lvl] = itr-&gt;pos;</a>
<a name="ln613">  }</a>
<a name="ln614">  while (true) {</a>
<a name="ln615">    itr-&gt;i = marktree_getp_aux(itr-&gt;node, k, 0)+1;</a>
<a name="ln616"> </a>
<a name="ln617">    if (itr-&gt;node-&gt;level == 0) {</a>
<a name="ln618">      break;</a>
<a name="ln619">    }</a>
<a name="ln620"> </a>
<a name="ln621">    itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln622">    itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln623"> </a>
<a name="ln624">    if (itr-&gt;i &gt; 0) {</a>
<a name="ln625">      compose(&amp;itr-&gt;pos, itr-&gt;node-&gt;key[itr-&gt;i-1].pos);</a>
<a name="ln626">      relative(itr-&gt;node-&gt;key[itr-&gt;i-1].pos, &amp;k.pos);</a>
<a name="ln627">    }</a>
<a name="ln628">    itr-&gt;node = itr-&gt;node-&gt;ptr[itr-&gt;i];</a>
<a name="ln629">    itr-&gt;lvl++;</a>
<a name="ln630">    if (oldbase) {</a>
<a name="ln631">      oldbase[itr-&gt;lvl] = itr-&gt;pos;</a>
<a name="ln632">    }</a>
<a name="ln633">  }</a>
<a name="ln634"> </a>
<a name="ln635">  if (last) {</a>
<a name="ln636">    return marktree_itr_prev(b, itr);</a>
<a name="ln637">  } else if (itr-&gt;i &gt;= itr-&gt;node-&gt;n) {</a>
<a name="ln638">    return marktree_itr_next(b, itr);</a>
<a name="ln639">  }</a>
<a name="ln640">  return true;</a>
<a name="ln641">}</a>
<a name="ln642"> </a>
<a name="ln643">bool marktree_itr_first(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln644">{</a>
<a name="ln645">  itr-&gt;node = b-&gt;root;</a>
<a name="ln646">  if (b-&gt;n_keys == 0) {</a>
<a name="ln647">    return false;</a>
<a name="ln648">  }</a>
<a name="ln649"> </a>
<a name="ln650">  itr-&gt;i = 0;</a>
<a name="ln651">  itr-&gt;lvl = 0;</a>
<a name="ln652">  itr-&gt;pos = (mtpos_t){ 0, 0 };</a>
<a name="ln653">  while (itr-&gt;node-&gt;level &gt; 0) {</a>
<a name="ln654">    itr-&gt;s[itr-&gt;lvl].i = 0;</a>
<a name="ln655">    itr-&gt;s[itr-&gt;lvl].oldcol = 0;</a>
<a name="ln656">    itr-&gt;lvl++;</a>
<a name="ln657">    itr-&gt;node = itr-&gt;node-&gt;ptr[0];</a>
<a name="ln658">  }</a>
<a name="ln659">  return true;</a>
<a name="ln660">}</a>
<a name="ln661"> </a>
<a name="ln662">// gives the first key that is greater or equal to p</a>
<a name="ln663">int marktree_itr_last(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln664">{</a>
<a name="ln665">  if (b-&gt;n_keys == 0) {</a>
<a name="ln666">    itr-&gt;node = NULL;</a>
<a name="ln667">    return false;</a>
<a name="ln668">  }</a>
<a name="ln669">  itr-&gt;pos = (mtpos_t){ 0, 0 };</a>
<a name="ln670">  itr-&gt;node = b-&gt;root;</a>
<a name="ln671">  itr-&gt;lvl = 0;</a>
<a name="ln672">  while (true) {</a>
<a name="ln673">    itr-&gt;i = itr-&gt;node-&gt;n;</a>
<a name="ln674"> </a>
<a name="ln675">    if (itr-&gt;node-&gt;level == 0) {</a>
<a name="ln676">      break;</a>
<a name="ln677">    }</a>
<a name="ln678"> </a>
<a name="ln679">    itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln680">    itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln681"> </a>
<a name="ln682">    assert(itr-&gt;i &gt; 0);</a>
<a name="ln683">    compose(&amp;itr-&gt;pos, itr-&gt;node-&gt;key[itr-&gt;i-1].pos);</a>
<a name="ln684"> </a>
<a name="ln685">    itr-&gt;node = itr-&gt;node-&gt;ptr[itr-&gt;i];</a>
<a name="ln686">    itr-&gt;lvl++;</a>
<a name="ln687">  }</a>
<a name="ln688">  itr-&gt;i--;</a>
<a name="ln689">  return true;</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692">// TODO(bfredl): static inline</a>
<a name="ln693">bool marktree_itr_next(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln694">{</a>
<a name="ln695">  return marktree_itr_next_skip(b, itr, false, NULL);</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698">static bool marktree_itr_next_skip(MarkTree *b, MarkTreeIter *itr, bool skip,</a>
<a name="ln699">                                   mtpos_t oldbase[])</a>
<a name="ln700">{</a>
<a name="ln701">  if (!itr-&gt;node) {</a>
<a name="ln702">    return false;</a>
<a name="ln703">  }</a>
<a name="ln704">  itr-&gt;i++;</a>
<a name="ln705">  if (itr-&gt;node-&gt;level == 0 || skip) {</a>
<a name="ln706">    if (itr-&gt;i &lt; itr-&gt;node-&gt;n) {</a>
<a name="ln707">      // TODO(bfredl): this is the common case,</a>
<a name="ln708">      // and could be handled by inline wrapper</a>
<a name="ln709">      return true;</a>
<a name="ln710">    }</a>
<a name="ln711">    // we ran out of non-internal keys. Go up until we find an internal key</a>
<a name="ln712">    while (itr-&gt;i &gt;= itr-&gt;node-&gt;n) {</a>
<a name="ln713">      itr-&gt;node = itr-&gt;node-&gt;parent;</a>
<a name="ln714">      if (itr-&gt;node == NULL) {</a>
<a name="ln715">        return false;</a>
<a name="ln716">      }</a>
<a name="ln717">      itr-&gt;lvl--;</a>
<a name="ln718">      itr-&gt;i = itr-&gt;s[itr-&gt;lvl].i;</a>
<a name="ln719">      if (itr-&gt;i &gt; 0) {</a>
<a name="ln720">        itr-&gt;pos.row -= itr-&gt;node-&gt;key[itr-&gt;i-1].pos.row;</a>
<a name="ln721">        itr-&gt;pos.col = itr-&gt;s[itr-&gt;lvl].oldcol;</a>
<a name="ln722">      }</a>
<a name="ln723">    }</a>
<a name="ln724">  } else {</a>
<a name="ln725">    // we stood at an &quot;internal&quot; key. Go down to the first non-internal</a>
<a name="ln726">    // key after it.</a>
<a name="ln727">    while (itr-&gt;node-&gt;level &gt; 0) {</a>
<a name="ln728">      // internal key, there is always a child after</a>
<a name="ln729">      if (itr-&gt;i &gt; 0) {</a>
<a name="ln730">        itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln731">        compose(&amp;itr-&gt;pos, itr-&gt;node-&gt;key[itr-&gt;i-1].pos);</a>
<a name="ln732">      }</a>
<a name="ln733">      if (oldbase &amp;&amp; itr-&gt;i == 0) {</a>
<a name="ln734">        oldbase[itr-&gt;lvl+1] = oldbase[itr-&gt;lvl];</a>
<a name="ln735">      }</a>
<a name="ln736">      itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln737">      assert(itr-&gt;node-&gt;ptr[itr-&gt;i]-&gt;parent == itr-&gt;node);</a>
<a name="ln738">      itr-&gt;node = itr-&gt;node-&gt;ptr[itr-&gt;i];</a>
<a name="ln739">      itr-&gt;i = 0;</a>
<a name="ln740">      itr-&gt;lvl++;</a>
<a name="ln741">    }</a>
<a name="ln742">  }</a>
<a name="ln743">  return true;</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746">bool marktree_itr_prev(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln747">{</a>
<a name="ln748">  if (!itr-&gt;node) {</a>
<a name="ln749">    return false;</a>
<a name="ln750">  }</a>
<a name="ln751">  if (itr-&gt;node-&gt;level == 0) {</a>
<a name="ln752">    itr-&gt;i--;</a>
<a name="ln753">    if (itr-&gt;i &gt;= 0) {</a>
<a name="ln754">      // TODO(bfredl): this is the common case,</a>
<a name="ln755">      // and could be handled by inline wrapper</a>
<a name="ln756">      return true;</a>
<a name="ln757">    }</a>
<a name="ln758">    // we ran out of non-internal keys. Go up until we find a non-internal key</a>
<a name="ln759">    while (itr-&gt;i &lt; 0) {</a>
<a name="ln760">      itr-&gt;node = itr-&gt;node-&gt;parent;</a>
<a name="ln761">      if (itr-&gt;node == NULL) {</a>
<a name="ln762">        return false;</a>
<a name="ln763">      }</a>
<a name="ln764">      itr-&gt;lvl--;</a>
<a name="ln765">      itr-&gt;i = itr-&gt;s[itr-&gt;lvl].i-1;</a>
<a name="ln766">      if (itr-&gt;i &gt;= 0) {</a>
<a name="ln767">        itr-&gt;pos.row -= itr-&gt;node-&gt;key[itr-&gt;i].pos.row;</a>
<a name="ln768">        itr-&gt;pos.col = itr-&gt;s[itr-&gt;lvl].oldcol;</a>
<a name="ln769">      }</a>
<a name="ln770">    }</a>
<a name="ln771">  } else {</a>
<a name="ln772">    // we stood at an &quot;internal&quot; key. Go down to the last non-internal</a>
<a name="ln773">    // key before it.</a>
<a name="ln774">    while (itr-&gt;node-&gt;level &gt; 0) {</a>
<a name="ln775">      // internal key, there is always a child before</a>
<a name="ln776">      if (itr-&gt;i &gt; 0) {</a>
<a name="ln777">        itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln778">        compose(&amp;itr-&gt;pos, itr-&gt;node-&gt;key[itr-&gt;i-1].pos);</a>
<a name="ln779">      }</a>
<a name="ln780">      itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln781">      assert(itr-&gt;node-&gt;ptr[itr-&gt;i]-&gt;parent == itr-&gt;node);</a>
<a name="ln782">      itr-&gt;node = itr-&gt;node-&gt;ptr[itr-&gt;i];</a>
<a name="ln783">      itr-&gt;i = itr-&gt;node-&gt;n;</a>
<a name="ln784">      itr-&gt;lvl++;</a>
<a name="ln785">    }</a>
<a name="ln786">    itr-&gt;i--;</a>
<a name="ln787">  }</a>
<a name="ln788">  return true;</a>
<a name="ln789">}</a>
<a name="ln790"> </a>
<a name="ln791">void marktree_itr_rewind(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln792">{</a>
<a name="ln793">  if (!itr-&gt;node) {</a>
<a name="ln794">    return;</a>
<a name="ln795">  }</a>
<a name="ln796">  if (itr-&gt;node-&gt;level) {</a>
<a name="ln797">    marktree_itr_prev(b, itr);</a>
<a name="ln798">  }</a>
<a name="ln799">  itr-&gt;i = 0;</a>
<a name="ln800">}</a>
<a name="ln801"> </a>
<a name="ln802">bool marktree_itr_node_done(MarkTreeIter *itr)</a>
<a name="ln803">{</a>
<a name="ln804">  return !itr-&gt;node || itr-&gt;i == itr-&gt;node-&gt;n-1;</a>
<a name="ln805">}</a>
<a name="ln806"> </a>
<a name="ln807"> </a>
<a name="ln808">mtpos_t marktree_itr_pos(MarkTreeIter *itr)</a>
<a name="ln809">{</a>
<a name="ln810">  mtpos_t pos = rawkey(itr).pos;</a>
<a name="ln811">  unrelative(itr-&gt;pos, &amp;pos);</a>
<a name="ln812">  return pos;</a>
<a name="ln813">}</a>
<a name="ln814"> </a>
<a name="ln815">mtmark_t marktree_itr_current(MarkTreeIter *itr)</a>
<a name="ln816">{</a>
<a name="ln817">  if (itr-&gt;node) {</a>
<a name="ln818">    uint64_t keyid = rawkey(itr).id;</a>
<a name="ln819">    mtpos_t pos = marktree_itr_pos(itr);</a>
<a name="ln820">    mtmark_t mark = { .row = pos.row,</a>
<a name="ln821">                      .col = pos.col,</a>
<a name="ln822">                       .id = ANTIGRAVITY(keyid),</a>
<a name="ln823">                       .right_gravity = keyid &amp; RIGHT_GRAVITY };</a>
<a name="ln824">    return mark;</a>
<a name="ln825">  }</a>
<a name="ln826">  return (mtmark_t){ -1, -1, 0, false };</a>
<a name="ln827">}</a>
<a name="ln828"> </a>
<a name="ln829">static void swap_id(uint64_t *id1, uint64_t *id2)</a>
<a name="ln830">{</a>
<a name="ln831">  uint64_t temp = *id1;</a>
<a name="ln832">  *id1 = *id2;</a>
<a name="ln833">  *id2 = temp;</a>
<a name="ln834">}</a>
<a name="ln835"> </a>
<a name="ln836">bool marktree_splice(MarkTree *b,</a>
<a name="ln837">                     int start_line, int start_col,</a>
<a name="ln838">                     int old_extent_line, int old_extent_col,</a>
<a name="ln839">                     int new_extent_line, int new_extent_col)</a>
<a name="ln840">{</a>
<a name="ln841">  mtpos_t start = { start_line, start_col };</a>
<a name="ln842">  mtpos_t old_extent = { (int)old_extent_line, old_extent_col };</a>
<a name="ln843">  mtpos_t new_extent = { (int)new_extent_line, new_extent_col };</a>
<a name="ln844"> </a>
<a name="ln845">  bool may_delete = (old_extent.row != 0 || old_extent.col != 0);</a>
<a name="ln846">  bool same_line = old_extent.row == 0 &amp;&amp; new_extent.row == 0;</a>
<a name="ln847">  unrelative(start, &amp;old_extent);</a>
<a name="ln848">  unrelative(start, &amp;new_extent);</a>
<a name="ln849">  MarkTreeIter itr[1] = { 0 };</a>
<a name="ln850">  MarkTreeIter enditr[1] = { 0 };</a>
<a name="ln851"> </a>
<a name="ln852">  mtpos_t oldbase[MT_MAX_DEPTH];</a>
<a name="ln853"> </a>
<a name="ln854">  marktree_itr_get_ext(b, start, itr, false, true, oldbase);</a>
<a name="ln855">  if (!itr-&gt;node) {</a>
<a name="ln856">    // den e FÄRDIG</a>
<a name="ln857">    return false;</a>
<a name="ln858">  }</a>
<a name="ln859">  mtpos_t delta = { new_extent.row - old_extent.row,</a>
<a name="ln860">                    new_extent.col-old_extent.col };</a>
<a name="ln861"> </a>
<a name="ln862">  if (may_delete) {</a>
<a name="ln863">    mtpos_t ipos = marktree_itr_pos(itr);</a>
<a name="ln864">    if (!pos_leq(old_extent, ipos)</a>
<a name="ln865">        || (old_extent.row == ipos.row &amp;&amp; old_extent.col == ipos.col</a>
<a name="ln866">            &amp;&amp; !IS_RIGHT(rawkey(itr).id))) {</a>
<a name="ln867">      marktree_itr_get_ext(b, old_extent, enditr, true, true, NULL);</a>
<a name="ln868">      assert(enditr-&gt;node);</a>
<a name="ln869">      // &quot;assert&quot; (itr &lt;= enditr)</a>
<a name="ln870">    } else {</a>
<a name="ln871">      may_delete = false;</a>
<a name="ln872">    }</a>
<a name="ln873">  }</a>
<a name="ln874"> </a>
<a name="ln875">  bool past_right = false;</a>
<a name="ln876">  bool moved = false;</a>
<a name="ln877"> </a>
<a name="ln878">  // Follow the general strategy of messing things up and fix them later</a>
<a name="ln879">  // &quot;oldbase&quot; carries the information needed to calculate old position of</a>
<a name="ln880">  // children.</a>
<a name="ln881">  if (may_delete) {</a>
<a name="ln882">    while (itr-&gt;node &amp;&amp; !past_right) {</a>
<a name="ln883">      mtpos_t loc_start = start;</a>
<a name="ln884">      mtpos_t loc_old = old_extent;</a>
<a name="ln885">      relative(itr-&gt;pos, &amp;loc_start);</a>
<a name="ln886"> </a>
<a name="ln887">      relative(oldbase[itr-&gt;lvl], &amp;loc_old);</a>
<a name="ln888"> </a>
<a name="ln889">continue_same_node:</a>
<a name="ln890">      // NB: strictly should be less than the right gravity of loc_old, but</a>
<a name="ln891">      // the iter comparison below will already break on that.</a>
<a name="ln892">      if (!pos_leq(rawkey(itr).pos, loc_old)) {</a>
<a name="ln893">        break;</a>
<a name="ln894">      }</a>
<a name="ln895"> </a>
<a name="ln896">      if (IS_RIGHT(rawkey(itr).id)) {</a>
<a name="ln897">        while (rawkey(itr).id != rawkey(enditr).id</a>
<a name="ln898">               &amp;&amp; IS_RIGHT(rawkey(enditr).id)) {</a>
<a name="ln899">          marktree_itr_prev(b, enditr);</a>
<a name="ln900">        }</a>
<a name="ln901">        if (!IS_RIGHT(rawkey(enditr).id)) {</a>
<a name="ln902">          swap_id(&amp;rawkey(itr).id, &amp;rawkey(enditr).id);</a>
<a name="ln903">          refkey(b, itr-&gt;node, itr-&gt;i);</a>
<a name="ln904">          refkey(b, enditr-&gt;node, enditr-&gt;i);</a>
<a name="ln905">        } else {</a>
<a name="ln906">          past_right = true; // NOLINT</a>
<a name="ln907">          break;</a>
<a name="ln908">        }</a>
<a name="ln909">      }</a>
<a name="ln910"> </a>
<a name="ln911">      if (rawkey(itr).id == rawkey(enditr).id) {</a>
<a name="ln912">        // actually, will be past_right after this key</a>
<a name="ln913">        past_right = true;</a>
<a name="ln914">      }</a>
<a name="ln915"> </a>
<a name="ln916">      moved = true;</a>
<a name="ln917">      if (itr-&gt;node-&gt;level) {</a>
<a name="ln918">        oldbase[itr-&gt;lvl+1] = rawkey(itr).pos;</a>
<a name="ln919">        unrelative(oldbase[itr-&gt;lvl], &amp;oldbase[itr-&gt;lvl+1]);</a>
<a name="ln920">        rawkey(itr).pos = loc_start;</a>
<a name="ln921">        marktree_itr_next_skip(b, itr, false, oldbase);</a>
<a name="ln922">      } else {</a>
<a name="ln923">        rawkey(itr).pos = loc_start;</a>
<a name="ln924">        if (itr-&gt;i &lt; itr-&gt;node-&gt;n-1) {</a>
<a name="ln925">          itr-&gt;i++;</a>
<a name="ln926">          if (!past_right) {</a>
<a name="ln927">            goto continue_same_node;</a>
<a name="ln928">          }</a>
<a name="ln929">        } else {</a>
<a name="ln930">          marktree_itr_next(b, itr);</a>
<a name="ln931">        }</a>
<a name="ln932">      }</a>
<a name="ln933">    }</a>
<a name="ln934">    while (itr-&gt;node) {</a>
<a name="ln935">      mtpos_t loc_new = new_extent;</a>
<a name="ln936">      relative(itr-&gt;pos, &amp;loc_new);</a>
<a name="ln937">      mtpos_t limit = old_extent;</a>
<a name="ln938"> </a>
<a name="ln939">      relative(oldbase[itr-&gt;lvl], &amp;limit);</a>
<a name="ln940"> </a>
<a name="ln941">past_continue_same_node:</a>
<a name="ln942"> </a>
<a name="ln943">      if (pos_leq(limit, rawkey(itr).pos)) {</a>
<a name="ln944">        break;</a>
<a name="ln945">      }</a>
<a name="ln946"> </a>
<a name="ln947">      mtpos_t oldpos = rawkey(itr).pos;</a>
<a name="ln948">      rawkey(itr).pos = loc_new;</a>
<a name="ln949">      moved = true;</a>
<a name="ln950">      if (itr-&gt;node-&gt;level) {</a>
<a name="ln951">        oldbase[itr-&gt;lvl+1] = oldpos;</a>
<a name="ln952">        unrelative(oldbase[itr-&gt;lvl], &amp;oldbase[itr-&gt;lvl+1]);</a>
<a name="ln953"> </a>
<a name="ln954">        marktree_itr_next_skip(b, itr, false, oldbase);</a>
<a name="ln955">      } else {</a>
<a name="ln956">        if (itr-&gt;i &lt; itr-&gt;node-&gt;n-1) {</a>
<a name="ln957">          itr-&gt;i++;</a>
<a name="ln958">          goto past_continue_same_node;</a>
<a name="ln959">        } else {</a>
<a name="ln960">          marktree_itr_next(b, itr);</a>
<a name="ln961">        }</a>
<a name="ln962">      }</a>
<a name="ln963">    }</a>
<a name="ln964">  }</a>
<a name="ln965"> </a>
<a name="ln966"> </a>
<a name="ln967">  while (itr-&gt;node) {</a>
<a name="ln968">    unrelative(oldbase[itr-&gt;lvl], &amp;rawkey(itr).pos);</a>
<a name="ln969">    int realrow = rawkey(itr).pos.row;</a>
<a name="ln970">    assert(realrow &gt;= old_extent.row);</a>
<a name="ln971">    bool done = false;</a>
<a name="ln972">    if (realrow == old_extent.row) {</a>
<a name="ln973">      if (delta.col) {</a>
<a name="ln974">        rawkey(itr).pos.col += delta.col;</a>
<a name="ln975">        moved = true;</a>
<a name="ln976">      }</a>
<a name="ln977">    } else {</a>
<a name="ln978">      if (same_line) {</a>
<a name="ln979">        // optimization: column only adjustment can skip remaining rows</a>
<a name="ln980">        done = true;</a>
<a name="ln981">      }</a>
<a name="ln982">    }</a>
<a name="ln983">    if (delta.row) {</a>
<a name="ln984">      rawkey(itr).pos.row += delta.row;</a>
<a name="ln985">      moved = true;</a>
<a name="ln986">    }</a>
<a name="ln987">    relative(itr-&gt;pos, &amp;rawkey(itr).pos);</a>
<a name="ln988">    if (done) {</a>
<a name="ln989">      break;</a>
<a name="ln990">    }</a>
<a name="ln991">    marktree_itr_next_skip(b, itr, true, NULL);</a>
<a name="ln992">  }</a>
<a name="ln993">  return moved;</a>
<a name="ln994">}</a>
<a name="ln995"> </a>
<a name="ln996">void marktree_move_region(MarkTree *b,</a>
<a name="ln997">                          int start_row, colnr_T start_col,</a>
<a name="ln998">                          int extent_row, colnr_T extent_col,</a>
<a name="ln999">                          int new_row, colnr_T new_col)</a>
<a name="ln1000">{</a>
<a name="ln1001">  mtpos_t start = { start_row, start_col }, size = { extent_row, extent_col };</a>
<a name="ln1002">  mtpos_t end = size;</a>
<a name="ln1003">  unrelative(start, &amp;end);</a>
<a name="ln1004">  MarkTreeIter itr[1] = { 0 };</a>
<a name="ln1005">  marktree_itr_get_ext(b, start, itr, false, true, NULL);</a>
<a name="ln1006">  kvec_t(mtkey_t) saved = KV_INITIAL_VALUE;</a>
<a name="ln1007">  while (itr-&gt;node) {</a>
<a name="ln1008">    mtpos_t pos = marktree_itr_pos(itr);</a>
<a name="ln1009">    if (!pos_leq(pos, end) || (pos.row == end.row &amp;&amp; pos.col == end.col</a>
<a name="ln1010">                               &amp;&amp; rawkey(itr).id &amp; RIGHT_GRAVITY)) {</a>
<a name="ln1011">      break;</a>
<a name="ln1012">    }</a>
<a name="ln1013">    relative(start, &amp;pos);</a>
<a name="ln1014">    kv_push(saved, ((mtkey_t){ .pos = pos, .id = rawkey(itr).id }));</a>
<a name="ln1015">    marktree_del_itr(b, itr, false);</a>
<a name="ln1016">  }</a>
<a name="ln1017"> </a>
<a name="ln1018">  marktree_splice(b, start.row, start.col, size.row, size.col, 0, 0);</a>
<a name="ln1019">  mtpos_t new = { new_row, new_col };</a>
<a name="ln1020">  marktree_splice(b, new.row, new.col,</a>
<a name="ln1021">                  0, 0, size.row, size.col);</a>
<a name="ln1022"> </a>
<a name="ln1023">  for (size_t i = 0; i &lt; kv_size(saved); i++) {</a>
<a name="ln1024">    mtkey_t item = kv_A(saved, i);</a>
<a name="ln1025">    unrelative(new, &amp;item.pos);</a>
<a name="ln1026">    marktree_put_key(b, item.pos.row, item.pos.col, item.id);</a>
<a name="ln1027">  }</a>
<a name="ln1028">  kv_destroy(saved);</a>
<a name="ln1029">}</a>
<a name="ln1030"> </a>
<a name="ln1031">/// @param itr OPTIONAL. set itr to pos.</a>
<a name="ln1032">mtpos_t marktree_lookup(MarkTree *b, uint64_t id, MarkTreeIter *itr)</a>
<a name="ln1033">{</a>
<a name="ln1034">  mtnode_t *n = pmap_get(uint64_t)(b-&gt;id2node, id);</a>
<a name="ln1035">  if (n == NULL) {</a>
<a name="ln1036">    if (itr) {</a>
<a name="ln1037">      itr-&gt;node = NULL;</a>
<a name="ln1038">    }</a>
<a name="ln1039">    return (mtpos_t){ -1, -1 };</a>
<a name="ln1040">  }</a>
<a name="ln1041">  int i = 0;</a>
<a name="ln1042">  for (i = 0; i &lt; n-&gt;n; i++) {</a>
<a name="ln1043">    if (ANTIGRAVITY(n-&gt;key[i].id) == id) {</a>
<a name="ln1044">      goto found;</a>
<a name="ln1045">    }</a>
<a name="ln1046">  }</a>
<a name="ln1047">  abort();</a>
<a name="ln1048">found: {}</a>
<a name="ln1049">  mtpos_t pos = n-&gt;key[i].pos;</a>
<a name="ln1050">  if (itr) {</a>
<a name="ln1051">    itr-&gt;i = i;</a>
<a name="ln1052">    itr-&gt;node = n;</a>
<a name="ln1053">    itr-&gt;lvl = b-&gt;root-&gt;level - n-&gt;level;</a>
<a name="ln1054">  }</a>
<a name="ln1055">  while (n-&gt;parent != NULL) {</a>
<a name="ln1056">    mtnode_t *p = n-&gt;parent;</a>
<a name="ln1057">    for (i = 0; i &lt; p-&gt;n+1; i++) {</a>
<a name="ln1058">      if (p-&gt;ptr[i] == n) {</a>
<a name="ln1059">        goto found_node;</a>
<a name="ln1060">      }</a>
<a name="ln1061">    }</a>
<a name="ln1062">    abort();</a>
<a name="ln1063">found_node:</a>
<a name="ln1064">    if (itr) {</a>
<a name="ln1065">      itr-&gt;s[b-&gt;root-&gt;level-p-&gt;level].i = i;</a>
<a name="ln1066">    }</a>
<a name="ln1067">    if (i &gt; 0) {</a>
<a name="ln1068">      unrelative(p-&gt;key[i-1].pos, &amp;pos);</a>
<a name="ln1069">    }</a>
<a name="ln1070">    n = p;</a>
<a name="ln1071">  }</a>
<a name="ln1072">  if (itr) {</a>
<a name="ln1073">    marktree_itr_fix_pos(b, itr);</a>
<a name="ln1074">  }</a>
<a name="ln1075">  return pos;</a>
<a name="ln1076">}</a>
<a name="ln1077"> </a>
<a name="ln1078">static void marktree_itr_fix_pos(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln1079">{</a>
<a name="ln1080">  itr-&gt;pos = (mtpos_t){ 0, 0 };</a>
<a name="ln1081">  mtnode_t *x = b-&gt;root;</a>
<a name="ln1082">  for (int lvl = 0; lvl &lt; itr-&gt;lvl; lvl++) {</a>
<a name="ln1083">    itr-&gt;s[lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln1084">    int i = itr-&gt;s[lvl].i;</a>
<a name="ln1085">    if (i &gt; 0) {</a>
<a name="ln1086">      compose(&amp;itr-&gt;pos, x-&gt;key[i-1].pos);</a>
<a name="ln1087">    }</a>
<a name="ln1088">    assert(x-&gt;level);</a>
<a name="ln1089">    x = x-&gt;ptr[i];</a>
<a name="ln1090">  }</a>
<a name="ln1091">  assert(x == itr-&gt;node);</a>
<a name="ln1092">}</a>
<a name="ln1093"> </a>
<a name="ln1094">void marktree_check(MarkTree *b)</a>
<a name="ln1095">{</a>
<a name="ln1096">#ifndef NDEBUG</a>
<a name="ln1097">  if (b-&gt;root == NULL) {</a>
<a name="ln1098">    assert(b-&gt;n_keys == 0);</a>
<a name="ln1099">    assert(b-&gt;n_nodes == 0);</a>
<a name="ln1100">    assert(b-&gt;id2node == NULL || map_size(b-&gt;id2node) == 0);</a>
<a name="ln1101">    return;</a>
<a name="ln1102">  }</a>
<a name="ln1103"> </a>
<a name="ln1104">  mtpos_t dummy;</a>
<a name="ln1105">  bool last_right = false;</a>
<a name="ln1106">  size_t nkeys = check_node(b, b-&gt;root, &amp;dummy, &amp;last_right);</a>
<a name="ln1107">  assert(b-&gt;n_keys == nkeys);</a>
<a name="ln1108">  assert(b-&gt;n_keys == map_size(b-&gt;id2node));</a>
<a name="ln1109">#else</a>
<a name="ln1110">  // Do nothing, as assertions are required</a>
<a name="ln1111">  (void)b;</a>
<a name="ln1112">#endif</a>
<a name="ln1113">}</a>
<a name="ln1114"> </a>
<a name="ln1115">#ifndef NDEBUG</a>
<a name="ln1116">static size_t check_node(MarkTree *b, mtnode_t *x,</a>
<a name="ln1117">                         mtpos_t *last, bool *last_right)</a>
<a name="ln1118">{</a>
<a name="ln1119">  assert(x-&gt;n &lt;= 2 * T - 1);</a>
<a name="ln1120">  // TODO(bfredl): too strict if checking &quot;in repair&quot; post-delete tree.</a>
<a name="ln1121">  assert(x-&gt;n &gt;= (x != b-&gt;root ? T-1 : 0));</a>
<a name="ln1122">  size_t n_keys = (size_t)x-&gt;n;</a>
<a name="ln1123"> </a>
<a name="ln1124">  for (int i = 0; i &lt; x-&gt;n; i++) {</a>
<a name="ln1125">    if (x-&gt;level) {</a>
<a name="ln1126">      n_keys += check_node(b, x-&gt;ptr[i], last, last_right);</a>
<a name="ln1127">    } else {</a>
<a name="ln1128">      *last = (mtpos_t) { 0, 0 };</a>
<a name="ln1129">    }</a>
<a name="ln1130">    if (i &gt; 0) {</a>
<a name="ln1131">      unrelative(x-&gt;key[i-1].pos, last);</a>
<a name="ln1132">    }</a>
<a name="ln1133">    if (x-&gt;level) {</a>
<a name="ln1134">    }</a>
<a name="ln1135">    assert(pos_leq(*last, x-&gt;key[i].pos));</a>
<a name="ln1136">    if (last-&gt;row == x-&gt;key[i].pos.row &amp;&amp; last-&gt;col == x-&gt;key[i].pos.col) {</a>
<a name="ln1137">      assert(!*last_right || IS_RIGHT(x-&gt;key[i].id));</a>
<a name="ln1138">    }</a>
<a name="ln1139">    *last_right = IS_RIGHT(x-&gt;key[i].id);</a>
<a name="ln1140">    assert(x-&gt;key[i].pos.col &gt;= 0);</a>
<a name="ln1141">    assert(pmap_get(uint64_t)(b-&gt;id2node, ANTIGRAVITY(x-&gt;key[i].id)) == x);</a>
<a name="ln1142">  }</a>
<a name="ln1143"> </a>
<a name="ln1144">  if (x-&gt;level) {</a>
<a name="ln1145">    n_keys += check_node(b, x-&gt;ptr[x-&gt;n], last, last_right);</a>
<a name="ln1146">    unrelative(x-&gt;key[x-&gt;n-1].pos, last);</a>
<a name="ln1147"> </a>
<a name="ln1148">    for (int i = 0; i &lt; x-&gt;n+1; i++) {</a>
<a name="ln1149">      assert(x-&gt;ptr[i]-&gt;parent == x);</a>
<a name="ln1150">      assert(x-&gt;ptr[i]-&gt;level == x-&gt;level-1);</a>
<a name="ln1151">      // PARANOIA: check no double node ref</a>
<a name="ln1152">      for (int j = 0; j &lt; i; j++) {</a>
<a name="ln1153">        assert(x-&gt;ptr[i] != x-&gt;ptr[j]);</a>
<a name="ln1154">      }</a>
<a name="ln1155">    }</a>
<a name="ln1156">  } else {</a>
<a name="ln1157">    *last = x-&gt;key[x-&gt;n-1].pos;</a>
<a name="ln1158">  }</a>
<a name="ln1159">  return n_keys;</a>
<a name="ln1160">}</a>
<a name="ln1161">#endif</a>
<a name="ln1162"> </a>
<a name="ln1163">char *mt_inspect_rec(MarkTree *b)</a>
<a name="ln1164">{</a>
<a name="ln1165">  garray_T ga;</a>
<a name="ln1166">  ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln1167">  mtpos_t p = { 0, 0 };</a>
<a name="ln1168">  mt_inspect_node(b, &amp;ga, b-&gt;root, p);</a>
<a name="ln1169">  return ga.ga_data;</a>
<a name="ln1170">}</a>
<a name="ln1171"> </a>
<a name="ln1172">void mt_inspect_node(MarkTree *b, garray_T *ga, mtnode_t *n, mtpos_t off)</a>
<a name="ln1173">{</a>
<a name="ln1174">  static char buf[1024];</a>
<a name="ln1175">#define GA_PUT(x) ga_concat(ga, (char_u *)(x))</a>
<a name="ln1176">  GA_PUT(&quot;[&quot;);</a>
<a name="ln1177">  if (n-&gt;level) {</a>
<a name="ln1178">    mt_inspect_node(b, ga, n-&gt;ptr[0], off);</a>
<a name="ln1179">  }</a>
<a name="ln1180">  for (int i = 0; i &lt; n-&gt;n; i++) {</a>
<a name="ln1181">    mtpos_t p = n-&gt;key[i].pos;</a>
<a name="ln1182">    unrelative(off, &amp;p);</a>
<a name="ln1183">    snprintf((char *)buf, sizeof(buf), &quot;%d/%d&quot;, p.row, p.col);</a>
<a name="ln1184">    GA_PUT(buf);</a>
<a name="ln1185">    if (n-&gt;level) {</a>
<a name="ln1186">      mt_inspect_node(b, ga, n-&gt;ptr[i+1], p);</a>
<a name="ln1187">    } else {</a>
<a name="ln1188">      GA_PUT(&quot;,&quot;);</a>
<a name="ln1189">    }</a>
<a name="ln1190">  }</a>
<a name="ln1191">  GA_PUT(&quot;]&quot;);</a>
<a name="ln1192">#undef GA_PUT</a>
<a name="ln1193">}</a>
<a name="ln1194"> </a>

</code></pre>
<div class="balloon" rel="164"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to underflow of the buffer 'z->key'.</p></div>
<div class="balloon" rel="469"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'y->n + 1' operator to the 'size_t' type, not the result.</p></div>
<div class="balloon" rel="491"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'y->n + 1' operator to the 'size_t' type, not the result.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
