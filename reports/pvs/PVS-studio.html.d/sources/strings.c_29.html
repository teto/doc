
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>strings.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;inttypes.h&gt;</a>
<a name="ln5">#include &lt;stdarg.h&gt;</a>
<a name="ln6">#include &lt;stdbool.h&gt;</a>
<a name="ln7">#include &lt;string.h&gt;</a>
<a name="ln8">#include &lt;math.h&gt;</a>
<a name="ln9">#include &lt;assert.h&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;nvim/assert.h&quot;</a>
<a name="ln12">#include &quot;nvim/vim.h&quot;</a>
<a name="ln13">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln14">#include &quot;nvim/strings.h&quot;</a>
<a name="ln15">#include &quot;nvim/file_search.h&quot;</a>
<a name="ln16">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln17">#include &quot;nvim/charset.h&quot;</a>
<a name="ln18">#include &quot;nvim/diff.h&quot;</a>
<a name="ln19">#include &quot;nvim/edit.h&quot;</a>
<a name="ln20">#include &quot;nvim/eval.h&quot;</a>
<a name="ln21">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln22">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln23">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln24">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln25">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln26">#include &quot;nvim/fold.h&quot;</a>
<a name="ln27">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln28">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln29">#include &quot;nvim/mark.h&quot;</a>
<a name="ln30">#include &quot;nvim/math.h&quot;</a>
<a name="ln31">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln32">#include &quot;nvim/memfile.h&quot;</a>
<a name="ln33">#include &quot;nvim/memline.h&quot;</a>
<a name="ln34">#include &quot;nvim/memory.h&quot;</a>
<a name="ln35">#include &quot;nvim/message.h&quot;</a>
<a name="ln36">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln37">#include &quot;nvim/move.h&quot;</a>
<a name="ln38">#include &quot;nvim/option.h&quot;</a>
<a name="ln39">#include &quot;nvim/ops.h&quot;</a>
<a name="ln40">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln41">#include &quot;nvim/path.h&quot;</a>
<a name="ln42">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln43">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln44">#include &quot;nvim/screen.h&quot;</a>
<a name="ln45">#include &quot;nvim/search.h&quot;</a>
<a name="ln46">#include &quot;nvim/spell.h&quot;</a>
<a name="ln47">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln48">#include &quot;nvim/tag.h&quot;</a>
<a name="ln49">#include &quot;nvim/window.h&quot;</a>
<a name="ln50">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln51">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln52">#include &quot;nvim/eval/encode.h&quot;</a>
<a name="ln53"> </a>
<a name="ln54">/// Copy &quot;string&quot; into newly allocated memory.</a>
<a name="ln55">char_u *vim_strsave(const char_u *string)</a>
<a name="ln56">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln57">{</a>
<a name="ln58">  return (char_u *)xstrdup((char *)string);</a>
<a name="ln59">}</a>
<a name="ln60"> </a>
<a name="ln61">/// Copy up to `len` bytes of `string` into newly allocated memory and</a>
<a name="ln62">/// terminate with a NUL. The allocated memory always has size `len + 1`, even</a>
<a name="ln63">/// when `string` is shorter.</a>
<a name="ln64">char_u *vim_strnsave(const char_u *string, size_t len)</a>
<a name="ln65">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln66">{</a>
<a name="ln67">  // strncpy is intentional: some parts of Vim use `string` shorter than `len`</a>
<a name="ln68">  // and expect the remainder to be zeroed out.</a>
<a name="ln69">  return (char_u *)strncpy(xmallocz(len), (char *)string, len);</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72">/*</a>
<a name="ln73"> * Same as vim_strsave(), but any characters found in esc_chars are preceded</a>
<a name="ln74"> * by a backslash.</a>
<a name="ln75"> */</a>
<a name="ln76">char_u *vim_strsave_escaped(const char_u *string, const char_u *esc_chars)</a>
<a name="ln77">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln78">{</a>
<a name="ln79">  return vim_strsave_escaped_ext(string, esc_chars, '\\', false);</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82">/*</a>
<a name="ln83"> * Same as vim_strsave_escaped(), but when &quot;bsl&quot; is true also escape</a>
<a name="ln84"> * characters where rem_backslash() would remove the backslash.</a>
<a name="ln85"> * Escape the characters with &quot;cc&quot;.</a>
<a name="ln86"> */</a>
<a name="ln87">char_u *vim_strsave_escaped_ext(const char_u *string, const char_u *esc_chars,</a>
<a name="ln88">                                char_u cc, bool bsl)</a>
<a name="ln89">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln90">{</a>
<a name="ln91">  /*</a>
<a name="ln92">   * First count the number of backslashes required.</a>
<a name="ln93">   * Then allocate the memory and insert them.</a>
<a name="ln94">   */</a>
<a name="ln95">  size_t length = 1;                    // count the trailing NUL</a>
<a name="ln96">  for (const char_u *p = string; *p; p++) {</a>
<a name="ln97">    const size_t l = (size_t)(utfc_ptr2len(p));</a>
<a name="ln98">    if (l &gt; 1) {</a>
<a name="ln99">      length += l;                      // count a multibyte char</a>
<a name="ln100">      p += l - 1;</a>
<a name="ln101">      continue;</a>
<a name="ln102">    }</a>
<a name="ln103">    if (vim_strchr(esc_chars, *p) != NULL || (bsl &amp;&amp; rem_backslash(p)))</a>
<a name="ln104">      ++length;                         /* count a backslash */</a>
<a name="ln105">    ++length;                           /* count an ordinary char */</a>
<a name="ln106">  }</a>
<a name="ln107"> </a>
<a name="ln108">  char_u *escaped_string = xmalloc(length);</a>
<a name="ln109">  char_u *p2 = escaped_string;</a>
<a name="ln110">  for (const char_u *p = string; *p; p++) {</a>
<a name="ln111">    const size_t l = (size_t)(utfc_ptr2len(p));</a>
<a name="ln112">    if (l &gt; 1) {</a>
<a name="ln113">      memcpy(p2, p, l);</a>
<a name="ln114">      p2 += l;</a>
<a name="ln115">      p += l - 1;                     /* skip multibyte char  */</a>
<a name="ln116">      continue;</a>
<a name="ln117">    }</a>
<a name="ln118">    if (vim_strchr(esc_chars, *p) != NULL || (bsl &amp;&amp; rem_backslash(p)))</a>
<a name="ln119">      *p2++ = cc;</a>
<a name="ln120">    *p2++ = *p;</a>
<a name="ln121">  }</a>
<a name="ln122">  *p2 = NUL;</a>
<a name="ln123"> </a>
<a name="ln124">  return escaped_string;</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">/// Save a copy of an unquoted string</a>
<a name="ln128">///</a>
<a name="ln129">/// Turns string like `a\bc&quot;def\&quot;ghi\\\n&quot;jkl` into `a\bcdef&quot;ghi\\njkl`, for use</a>
<a name="ln130">/// in shell_build_argv: the only purpose of backslash is making next character</a>
<a name="ln131">/// be treated literally inside the double quotes, if this character is</a>
<a name="ln132">/// backslash or quote.</a>
<a name="ln133">///</a>
<a name="ln134">/// @param[in]  string  String to copy.</a>
<a name="ln135">/// @param[in]  length  Length of the string to copy.</a>
<a name="ln136">///</a>
<a name="ln137">/// @return [allocated] Copy of the string.</a>
<a name="ln138">char *vim_strnsave_unquoted(const char *const string, const size_t length)</a>
<a name="ln139">  FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln140">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln141">{</a>
<a name="ln142">#define ESCAPE_COND(p, inquote, string_end) \</a>
<a name="ln143">  (*p == '\\' &amp;&amp; inquote &amp;&amp; p + 1 &lt; string_end &amp;&amp; (p[1] == '\\' || p[1] == '&quot;'))</a>
<a name="ln144">  size_t ret_length = 0;</a>
<a name="ln145">  bool inquote = false;</a>
<a name="ln146">  const char *const string_end = string + length;</a>
<a name="ln147">  for (const char *p = string; p &lt; string_end; p++) {</a>
<a name="ln148">    if (*p == '&quot;') {</a>
<a name="ln149">      inquote = !inquote;</a>
<a name="ln150">    } else if (ESCAPE_COND(p, inquote, string_end)) {</a>
<a name="ln151">      ret_length++;</a>
<a name="ln152">      p++;</a>
<a name="ln153">    } else {</a>
<a name="ln154">      ret_length++;</a>
<a name="ln155">    }</a>
<a name="ln156">  }</a>
<a name="ln157"> </a>
<a name="ln158">  char *const ret = xmallocz(ret_length);</a>
<a name="ln159">  char *rp = ret;</a>
<a name="ln160">  inquote = false;</a>
<a name="ln161">  for (const char *p = string; p &lt; string_end; p++) {</a>
<a name="ln162">    if (*p == '&quot;') {</a>
<a name="ln163">      inquote = !inquote;</a>
<a name="ln164">    } else if (ESCAPE_COND(p, inquote, string_end)) {</a>
<a name="ln165">      *rp++ = *(++p);</a>
<a name="ln166">    } else {</a>
<a name="ln167">      *rp++ = *p;</a>
<a name="ln168">    }</a>
<a name="ln169">  }</a>
<a name="ln170">#undef ESCAPE_COND</a>
<a name="ln171"> </a>
<a name="ln172">  return ret;</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175">/*</a>
<a name="ln176"> * Escape &quot;string&quot; for use as a shell argument with system().</a>
<a name="ln177"> * This uses single quotes, except when we know we need to use double quotes</a>
<a name="ln178"> * (MS-Windows without 'shellslash' set).</a>
<a name="ln179"> * Escape a newline, depending on the 'shell' option.</a>
<a name="ln180"> * When &quot;do_special&quot; is true also replace &quot;!&quot;, &quot;%&quot;, &quot;#&quot; and things starting</a>
<a name="ln181"> * with &quot;&lt;&quot; like &quot;&lt;cfile&gt;&quot;.</a>
<a name="ln182"> * When &quot;do_newline&quot; is false do not escape newline unless it is csh shell.</a>
<a name="ln183"> * Returns the result in allocated memory.</a>
<a name="ln184"> */</a>
<a name="ln185">char_u *vim_strsave_shellescape(const char_u *string,</a>
<a name="ln186">                                bool do_special, bool do_newline)</a>
<a name="ln187">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln188">{</a>
<a name="ln189">  char_u      *d;</a>
<a name="ln190">  char_u      *escaped_string;</a>
<a name="ln191">  size_t l;</a>
<a name="ln192">  int csh_like;</a>
<a name="ln193"> </a>
<a name="ln194">  /* Only csh and similar shells expand '!' within single quotes.  For sh and</a>
<a name="ln195">   * the like we must not put a backslash before it, it will be taken</a>
<a name="ln196">   * literally.  If do_special is set the '!' will be escaped twice.</a>
<a name="ln197">   * Csh also needs to have &quot;\n&quot; escaped twice when do_special is set. */</a>
<a name="ln198">  csh_like = csh_like_shell();</a>
<a name="ln199"> </a>
<a name="ln200">  /* First count the number of extra bytes required. */</a>
<a name="ln201">  size_t length = STRLEN(string) + 3;       // two quotes and a trailing NUL</a>
<a name="ln202">  for (const char_u *p = string; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln203">#ifdef WIN32</a>
<a name="ln204">    if (!p_ssl) {</a>
<a name="ln205">      if (*p == '&quot;') {</a>
<a name="ln206">        length++;                       // &quot; -&gt; &quot;&quot;</a>
<a name="ln207">      }</a>
<a name="ln208">    } else</a>
<a name="ln209">#endif</a>
<a name="ln210">    if (*p == '\'') {</a>
<a name="ln211">      length += 3;                      // ' =&gt; '\''</a>
<a name="ln212">    }</a>
<a name="ln213">    if ((*p == '\n' &amp;&amp; (csh_like || do_newline))</a>
<a name="ln214">        || (*p == '!' &amp;&amp; (csh_like || do_special))) {</a>
<a name="ln215">      ++length;                         /* insert backslash */</a>
<a name="ln216">      if (csh_like &amp;&amp; do_special)</a>
<a name="ln217">        ++length;                       /* insert backslash */</a>
<a name="ln218">    }</a>
<a name="ln219">    if (do_special &amp;&amp; find_cmdline_var(p, &amp;l) &gt;= 0) {</a>
<a name="ln220">      ++length;                         /* insert backslash */</a>
<a name="ln221">      p += l - 1;</a>
<a name="ln222">    }</a>
<a name="ln223">  }</a>
<a name="ln224"> </a>
<a name="ln225">  /* Allocate memory for the result and fill it. */</a>
<a name="ln226">  escaped_string = xmalloc(length);</a>
<a name="ln227">  d = escaped_string;</a>
<a name="ln228"> </a>
<a name="ln229">  // add opening quote</a>
<a name="ln230">#ifdef WIN32</a>
<a name="ln231">  if (!p_ssl) {</a>
<a name="ln232">    *d++ = '&quot;';</a>
<a name="ln233">  } else</a>
<a name="ln234">#endif</a>
<a name="ln235">  *d++ = '\'';</a>
<a name="ln236"> </a>
<a name="ln237">  for (const char_u *p = string; *p != NUL; ) {</a>
<a name="ln238">#ifdef WIN32</a>
<a name="ln239">    if (!p_ssl) {</a>
<a name="ln240">      if (*p == '&quot;') {</a>
<a name="ln241">        *d++ = '&quot;';</a>
<a name="ln242">        *d++ = '&quot;';</a>
<a name="ln243">        p++;</a>
<a name="ln244">        continue;</a>
<a name="ln245">      }</a>
<a name="ln246">    } else</a>
<a name="ln247">#endif</a>
<a name="ln248">    if (*p == '\'') {</a>
<a name="ln249">      *d++ = '\'';</a>
<a name="ln250">      *d++ = '\\';</a>
<a name="ln251">      *d++ = '\'';</a>
<a name="ln252">      *d++ = '\'';</a>
<a name="ln253">      ++p;</a>
<a name="ln254">      continue;</a>
<a name="ln255">    }</a>
<a name="ln256">    if ((*p == '\n' &amp;&amp; (csh_like || do_newline))</a>
<a name="ln257">        || (*p == '!' &amp;&amp; (csh_like || do_special))) {</a>
<a name="ln258">      *d++ = '\\';</a>
<a name="ln259">      if (csh_like &amp;&amp; do_special)</a>
<a name="ln260">        *d++ = '\\';</a>
<a name="ln261">      *d++ = *p++;</a>
<a name="ln262">      continue;</a>
<a name="ln263">    }</a>
<a name="ln264">    if (do_special &amp;&amp; find_cmdline_var(p, &amp;l) &gt;= 0) {</a>
<a name="ln265">      *d++ = '\\';                    /* insert backslash */</a>
<a name="ln266">      while (--l != SIZE_MAX)                /* copy the var */</a>
<a name="ln267">        *d++ = *p++;</a>
<a name="ln268">      continue;</a>
<a name="ln269">    }</a>
<a name="ln270"> </a>
<a name="ln271">    MB_COPY_CHAR(p, d);</a>
<a name="ln272">  }</a>
<a name="ln273"> </a>
<a name="ln274">  // add terminating quote and finish with a NUL</a>
<a name="ln275"># ifdef WIN32</a>
<a name="ln276">  if (!p_ssl) {</a>
<a name="ln277">    *d++ = '&quot;';</a>
<a name="ln278">  } else</a>
<a name="ln279"># endif</a>
<a name="ln280">  *d++ = '\'';</a>
<a name="ln281">  *d = NUL;</a>
<a name="ln282"> </a>
<a name="ln283">  return escaped_string;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">/*</a>
<a name="ln287"> * Like vim_strsave(), but make all characters uppercase.</a>
<a name="ln288"> * This uses ASCII lower-to-upper case translation, language independent.</a>
<a name="ln289"> */</a>
<a name="ln290">char_u *vim_strsave_up(const char_u *string)</a>
<a name="ln291">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln292">{</a>
<a name="ln293">  char_u *p1;</a>
<a name="ln294"> </a>
<a name="ln295">  p1 = vim_strsave(string);</a>
<a name="ln296">  vim_strup(p1);</a>
<a name="ln297">  return p1;</a>
<a name="ln298">}</a>
<a name="ln299"> </a>
<a name="ln300">/*</a>
<a name="ln301"> * Like vim_strnsave(), but make all characters uppercase.</a>
<a name="ln302"> * This uses ASCII lower-to-upper case translation, language independent.</a>
<a name="ln303"> */</a>
<a name="ln304">char_u *vim_strnsave_up(const char_u *string, size_t len)</a>
<a name="ln305">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln306">{</a>
<a name="ln307">  char_u *p1 = vim_strnsave(string, len);</a>
<a name="ln308">  vim_strup(p1);</a>
<a name="ln309">  return p1;</a>
<a name="ln310">}</a>
<a name="ln311"> </a>
<a name="ln312">/*</a>
<a name="ln313"> * ASCII lower-to-upper case translation, language independent.</a>
<a name="ln314"> */</a>
<a name="ln315">void vim_strup(char_u *p)</a>
<a name="ln316">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln317">{</a>
<a name="ln318">  char_u c;</a>
<a name="ln319">  while ((c = *p) != NUL) {</a>
<a name="ln320">    *p++ = (char_u)(c &lt; 'a' || c &gt; 'z' ? c : c - 0x20);</a>
<a name="ln321">  }</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324">/// Make given string all upper-case or all lower-case</a>
<a name="ln325">///</a>
<a name="ln326">/// Handles multi-byte characters as good as possible.</a>
<a name="ln327">///</a>
<a name="ln328">/// @param[in]  orig  Input string.</a>
<a name="ln329">/// @param[in]  upper If true make uppercase, otherwise lowercase</a>
<a name="ln330">///</a>
<a name="ln331">/// @return [allocated] upper-cased string.</a>
<a name="ln332">char *strcase_save(const char *const orig, bool upper)</a>
<a name="ln333">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln334">{</a>
<a name="ln335">  char *res = xstrdup(orig);</a>
<a name="ln336"> </a>
<a name="ln337">  char *p = res;</a>
<a name="ln338">  while (*p != NUL) {</a>
<a name="ln339">    int c = utf_ptr2char((const char_u *)p);</a>
<a name="ln340">    int l = utf_ptr2len((const char_u *)p);</a>
<a name="ln341">    if (c == 0) {</a>
<a name="ln342">      // overlong sequence, use only the first byte</a>
<a name="ln343">      c = *p;</a>
<a name="ln344">      l = 1;</a>
<a name="ln345">    }</a>
<a name="ln346">    int uc = upper ? mb_toupper(c) : mb_tolower(c);</a>
<a name="ln347"> </a>
<a name="ln348">    // Reallocate string when byte count changes.  This is rare,</a>
<a name="ln349">    // thus it's OK to do another malloc()/free().</a>
<a name="ln350">    int newl = utf_char2len(uc);</a>
<a name="ln351">    if (newl != l) {</a>
<a name="ln352">      // TODO(philix): use xrealloc() in strcase_save()</a>
<a name="ln353">      char *s = xmalloc(STRLEN(res) + (size_t)(1 + newl - l));</a>
<a name="ln354">      memcpy(s, res, (size_t)(p - res));</a>
<a name="ln355">      STRCPY(s + (p - res) + newl, p + l);</a>
<a name="ln356">      p = s + (p - res);</a>
<a name="ln357">      xfree(res);</a>
<a name="ln358">      res = s;</a>
<a name="ln359">    }</a>
<a name="ln360"> </a>
<a name="ln361">    utf_char2bytes(uc, (char_u *)p);</a>
<a name="ln362">    p += newl;</a>
<a name="ln363">  }</a>
<a name="ln364"> </a>
<a name="ln365">  return res;</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368">/*</a>
<a name="ln369"> * delete spaces at the end of a string</a>
<a name="ln370"> */</a>
<a name="ln371">void del_trailing_spaces(char_u *ptr)</a>
<a name="ln372">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln373">{</a>
<a name="ln374">  char_u      *q;</a>
<a name="ln375"> </a>
<a name="ln376">  q = ptr + STRLEN(ptr);</a>
<a name="ln377">  while (--q &gt; ptr &amp;&amp; ascii_iswhite(q[0]) &amp;&amp; q[-1] != '\\' &amp;&amp; q[-1] != Ctrl_V)</a>
<a name="ln378">    *q = NUL;</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381">#if (!defined(HAVE_STRCASECMP) &amp;&amp; !defined(HAVE_STRICMP))</a>
<a name="ln382">/*</a>
<a name="ln383"> * Compare two strings, ignoring case, using current locale.</a>
<a name="ln384"> * Doesn't work for multi-byte characters.</a>
<a name="ln385"> * return 0 for match, &lt; 0 for smaller, &gt; 0 for bigger</a>
<a name="ln386"> */</a>
<a name="ln387">int vim_stricmp(const char *s1, const char *s2)</a>
<a name="ln388">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE</a>
<a name="ln389">{</a>
<a name="ln390">  int i;</a>
<a name="ln391"> </a>
<a name="ln392">  for (;; ) {</a>
<a name="ln393">    i = (int)TOLOWER_LOC(*s1) - (int)TOLOWER_LOC(*s2);</a>
<a name="ln394">    if (i != 0)</a>
<a name="ln395">      return i;                             /* this character different */</a>
<a name="ln396">    if (*s1 == NUL)</a>
<a name="ln397">      break;                                /* strings match until NUL */</a>
<a name="ln398">    ++s1;</a>
<a name="ln399">    ++s2;</a>
<a name="ln400">  }</a>
<a name="ln401">  return 0;                                 /* strings match */</a>
<a name="ln402">}</a>
<a name="ln403">#endif</a>
<a name="ln404"> </a>
<a name="ln405">#if (!defined(HAVE_STRNCASECMP) &amp;&amp; !defined(HAVE_STRNICMP))</a>
<a name="ln406">/*</a>
<a name="ln407"> * Compare two strings, for length &quot;len&quot;, ignoring case, using current locale.</a>
<a name="ln408"> * Doesn't work for multi-byte characters.</a>
<a name="ln409"> * return 0 for match, &lt; 0 for smaller, &gt; 0 for bigger</a>
<a name="ln410"> */</a>
<a name="ln411">int vim_strnicmp(const char *s1, const char *s2, size_t len)</a>
<a name="ln412">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE</a>
<a name="ln413">{</a>
<a name="ln414">  int i;</a>
<a name="ln415"> </a>
<a name="ln416">  while (len &gt; 0) {</a>
<a name="ln417">    i = (int)TOLOWER_LOC(*s1) - (int)TOLOWER_LOC(*s2);</a>
<a name="ln418">    if (i != 0)</a>
<a name="ln419">      return i;                             /* this character different */</a>
<a name="ln420">    if (*s1 == NUL)</a>
<a name="ln421">      break;                                /* strings match until NUL */</a>
<a name="ln422">    ++s1;</a>
<a name="ln423">    ++s2;</a>
<a name="ln424">    --len;</a>
<a name="ln425">  }</a>
<a name="ln426">  return 0;                                 /* strings match */</a>
<a name="ln427">}</a>
<a name="ln428">#endif</a>
<a name="ln429"> </a>
<a name="ln430">/// strchr() version which handles multibyte strings</a>
<a name="ln431">///</a>
<a name="ln432">/// @param[in]  string  String to search in.</a>
<a name="ln433">/// @param[in]  c  Character to search for.</a>
<a name="ln434">///</a>
<a name="ln435">/// @return Pointer to the first byte of the found character in string or NULL</a>
<a name="ln436">///         if it was not found or character is invalid. NUL character is never</a>
<a name="ln437">///         found, use `strlen()` instead.</a>
<a name="ln438">char_u *vim_strchr(const char_u *const string, const int c)</a>
<a name="ln439">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln440">{</a>
<a name="ln441">  if (c &lt;= 0) {</a>
<a name="ln442">    return NULL;</a>
<a name="ln443">  } else if (c &lt; 0x80) {</a>
<a name="ln444">    return (char_u *)strchr((const char *)string, c);</a>
<a name="ln445">  } else {</a>
<a name="ln446">    char u8char[MB_MAXBYTES + 1];</a>
<a name="ln447">    const int len = utf_char2bytes(c, (char_u *)u8char);</a>
<a name="ln448">    u8char[len] = NUL;</a>
<a name="ln449">    return (char_u *)strstr((const char *)string, u8char);</a>
<a name="ln450">  }</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">/*</a>
<a name="ln454"> * Sort an array of strings.</a>
<a name="ln455"> */</a>
<a name="ln456"> </a>
<a name="ln457">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln458"># include &quot;strings.c.generated.h&quot;</a>
<a name="ln459">#endif</a>
<a name="ln460">static int sort_compare(const void *s1, const void *s2)</a>
<a name="ln461">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln462">{</a>
<a name="ln463">  return STRCMP(*(char **)s1, *(char **)s2);</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466">void sort_strings(char_u **files, int count)</a>
<a name="ln467">{</a>
<a name="ln468">  qsort((void *)files, (size_t)count, sizeof(char_u *), sort_compare);</a>
<a name="ln469">}</a>
<a name="ln470"> </a>
<a name="ln471">/*</a>
<a name="ln472"> * Return true if string &quot;s&quot; contains a non-ASCII character (128 or higher).</a>
<a name="ln473"> * When &quot;s&quot; is NULL false is returned.</a>
<a name="ln474"> */</a>
<a name="ln475">bool has_non_ascii(const char_u *s)</a>
<a name="ln476">  FUNC_ATTR_PURE</a>
<a name="ln477">{</a>
<a name="ln478">  const char_u *p;</a>
<a name="ln479"> </a>
<a name="ln480">  if (s != NULL)</a>
<a name="ln481">    for (p = s; *p != NUL; ++p)</a>
<a name="ln482">      if (*p &gt;= 128)</a>
<a name="ln483">        return true;</a>
<a name="ln484">  return false;</a>
<a name="ln485">}</a>
<a name="ln486"> </a>
<a name="ln487">/// Return true if string &quot;s&quot; contains a non-ASCII character (128 or higher).</a>
<a name="ln488">/// When &quot;s&quot; is NULL false is returned.</a>
<a name="ln489">bool has_non_ascii_len(const char *const s, const size_t len)</a>
<a name="ln490">  FUNC_ATTR_PURE</a>
<a name="ln491">{</a>
<a name="ln492">  if (s != NULL) {</a>
<a name="ln493">    for (size_t i = 0; i &lt; len; i++) {</a>
<a name="ln494">      if ((uint8_t) s[i] &gt;= 128) {</a>
<a name="ln495">        return true;</a>
<a name="ln496">      }</a>
<a name="ln497">    }</a>
<a name="ln498">  }</a>
<a name="ln499">  return false;</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502">/*</a>
<a name="ln503"> * Concatenate two strings and return the result in allocated memory.</a>
<a name="ln504"> */</a>
<a name="ln505">char_u *concat_str(const char_u *restrict str1, const char_u *restrict str2)</a>
<a name="ln506">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln507">{</a>
<a name="ln508">  size_t l = STRLEN(str1);</a>
<a name="ln509">  char_u *dest = xmalloc(l + STRLEN(str2) + 1);</a>
<a name="ln510">  STRCPY(dest, str1);</a>
<a name="ln511">  STRCPY(dest + l, str2);</a>
<a name="ln512">  return dest;</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515"> </a>
<a name="ln516">static const char *const e_printf =</a>
<a name="ln517">    N_(&quot;E766: Insufficient arguments for printf()&quot;);</a>
<a name="ln518"> </a>
<a name="ln519">/// Get number argument from idxp entry in tvs</a>
<a name="ln520">///</a>
<a name="ln521">/// Will give an error message for VimL entry with invalid type or for</a>
<a name="ln522">/// insufficient entries.</a>
<a name="ln523">///</a>
<a name="ln524">/// @param[in]  tvs  List of VimL values. List is terminated by VAR_UNKNOWN</a>
<a name="ln525">///                  value.</a>
<a name="ln526">/// @param[in,out]  idxp  Index in a list. Will be incremented. Indexing starts</a>
<a name="ln527">///                       at 1.</a>
<a name="ln528">///</a>
<a name="ln529">/// @return Number value or 0 in case of error.</a>
<a name="ln530">static varnumber_T tv_nr(typval_T *tvs, int *idxp)</a>
<a name="ln531">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln532">{</a>
<a name="ln533">  int idx = *idxp - 1;</a>
<a name="ln534">  varnumber_T n = 0;</a>
<a name="ln535"> </a>
<a name="ln536">  if (tvs[idx].v_type == VAR_UNKNOWN) {</a>
<a name="ln537">    EMSG(_(e_printf));</a>
<a name="ln538">  } else {</a>
<a name="ln539">    (*idxp)++;</a>
<a name="ln540">    bool err = false;</a>
<a name="ln541">    n = tv_get_number_chk(&amp;tvs[idx], &amp;err);</a>
<a name="ln542">    if (err) {</a>
<a name="ln543">      n = 0;</a>
<a name="ln544">    }</a>
<a name="ln545">  }</a>
<a name="ln546">  return n;</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549">/// Get string argument from idxp entry in tvs</a>
<a name="ln550">///</a>
<a name="ln551">/// Will give an error message for VimL entry with invalid type or for</a>
<a name="ln552">/// insufficient entries.</a>
<a name="ln553">///</a>
<a name="ln554">/// @param[in]  tvs  List of VimL values. List is terminated by VAR_UNKNOWN</a>
<a name="ln555">///                  value.</a>
<a name="ln556">/// @param[in,out]  idxp  Index in a list. Will be incremented.</a>
<a name="ln557">/// @param[out]  tofree  If the idxp entry in tvs is not a String or a Number,</a>
<a name="ln558">///                      it will be converted to String in the same format</a>
<a name="ln559">///                      as &quot;:echo&quot; and stored in &quot;*tofree&quot;. The caller must</a>
<a name="ln560">///                      free &quot;*tofree&quot;.</a>
<a name="ln561">///</a>
<a name="ln562">/// @return String value or NULL in case of error.</a>
<a name="ln563">static const char *tv_str(typval_T *tvs, int *idxp, char **const tofree)</a>
<a name="ln564">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln565">{</a>
<a name="ln566">  int idx = *idxp - 1;</a>
<a name="ln567">  const char *s = NULL;</a>
<a name="ln568"> </a>
<a name="ln569">  if (tvs[idx].v_type == VAR_UNKNOWN) {</a>
<a name="ln570">    EMSG(_(e_printf));</a>
<a name="ln571">  } else {</a>
<a name="ln572">    (*idxp)++;</a>
<a name="ln573">    if (tvs[idx].v_type == VAR_STRING || tvs[idx].v_type == VAR_NUMBER) {</a>
<a name="ln574">      s = tv_get_string_chk(&amp;tvs[idx]);</a>
<a name="ln575">      *tofree = NULL;</a>
<a name="ln576">    } else {</a>
<a name="ln577">      s = *tofree = encode_tv2echo(&amp;tvs[idx], NULL);</a>
<a name="ln578">    }</a>
<a name="ln579">  }</a>
<a name="ln580">  return s;</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583">/// Get pointer argument from the next entry in tvs</a>
<a name="ln584">///</a>
<a name="ln585">/// Will give an error message for VimL entry with invalid type or for</a>
<a name="ln586">/// insufficient entries.</a>
<a name="ln587">///</a>
<a name="ln588">/// @param[in]  tvs  List of typval_T values.</a>
<a name="ln589">/// @param[in,out]  idxp  Pointer to the index of the current value.</a>
<a name="ln590">///</a>
<a name="ln591">/// @return Pointer stored in typval_T or NULL.</a>
<a name="ln592">static const void *tv_ptr(const typval_T *const tvs, int *const idxp)</a>
<a name="ln593">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln594">{</a>
<a name="ln595">#define OFF(attr) offsetof(union typval_vval_union, attr)</a>
<a name="ln596">  STATIC_ASSERT(</a>
<a name="ln597">      OFF(v_string) == OFF(v_list)</a>
<a name="ln598">      &amp;&amp; OFF(v_string) == OFF(v_dict)</a>
<a name="ln599">      &amp;&amp; OFF(v_string) == OFF(v_partial)</a>
<a name="ln600">      &amp;&amp; sizeof(tvs[0].vval.v_string) == sizeof(tvs[0].vval.v_list)</a>
<a name="ln601">      &amp;&amp; sizeof(tvs[0].vval.v_string) == sizeof(tvs[0].vval.v_dict)</a>
<a name="ln602">      &amp;&amp; sizeof(tvs[0].vval.v_string) == sizeof(tvs[0].vval.v_partial),</a>
<a name="ln603">      &quot;Strings, dictionaries, lists and partials are expected to be pointers, &quot;</a>
<a name="ln604">      &quot;so that all three of them can be accessed via v_string&quot;);</a>
<a name="ln605">#undef OFF</a>
<a name="ln606">  const int idx = *idxp - 1;</a>
<a name="ln607">  if (tvs[idx].v_type == VAR_UNKNOWN) {</a>
<a name="ln608">    EMSG(_(e_printf));</a>
<a name="ln609">    return NULL;</a>
<a name="ln610">  } else {</a>
<a name="ln611">    (*idxp)++;</a>
<a name="ln612">    return tvs[idx].vval.v_string;</a>
<a name="ln613">  }</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616">/// Get float argument from idxp entry in tvs</a>
<a name="ln617">///</a>
<a name="ln618">/// Will give an error message for VimL entry with invalid type or for</a>
<a name="ln619">/// insufficient entries.</a>
<a name="ln620">///</a>
<a name="ln621">/// @param[in]  tvs  List of VimL values. List is terminated by VAR_UNKNOWN</a>
<a name="ln622">///                  value.</a>
<a name="ln623">/// @param[in,out]  idxp  Index in a list. Will be incremented.</a>
<a name="ln624">///</a>
<a name="ln625">/// @return Floating-point value or zero in case of error.</a>
<a name="ln626">static float_T tv_float(typval_T *const tvs, int *const idxp)</a>
<a name="ln627">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln628">{</a>
<a name="ln629">  int idx = *idxp - 1;</a>
<a name="ln630">  float_T f = 0;</a>
<a name="ln631"> </a>
<a name="ln632">  if (tvs[idx].v_type == VAR_UNKNOWN) {</a>
<a name="ln633">    EMSG(_(e_printf));</a>
<a name="ln634">  } else {</a>
<a name="ln635">    (*idxp)++;</a>
<a name="ln636">    if (tvs[idx].v_type == VAR_FLOAT) {</a>
<a name="ln637">      f = tvs[idx].vval.v_float;</a>
<a name="ln638">    } else if (tvs[idx].v_type == VAR_NUMBER) {</a>
<a name="ln639">      f = (float_T)tvs[idx].vval.v_number;</a>
<a name="ln640">    } else {</a>
<a name="ln641">      EMSG(_(&quot;E807: Expected Float argument for printf()&quot;));</a>
<a name="ln642">    }</a>
<a name="ln643">  }</a>
<a name="ln644">  return f;</a>
<a name="ln645">}</a>
<a name="ln646"> </a>
<a name="ln647">// This code was included to provide a portable vsnprintf() and snprintf().</a>
<a name="ln648">// Some systems may provide their own, but we always use this one for</a>
<a name="ln649">// consistency.</a>
<a name="ln650">//</a>
<a name="ln651">// This code is based on snprintf.c - a portable implementation of snprintf</a>
<a name="ln652">// by Mark Martinec &lt;mark.martinec@ijs.si&gt;, Version 2.2, 2000-10-06.</a>
<a name="ln653">// Included with permission.  It was heavily modified to fit in Vim.</a>
<a name="ln654">// The original code, including useful comments, can be found here:</a>
<a name="ln655">//</a>
<a name="ln656">//     http://www.ijs.si/software/snprintf/</a>
<a name="ln657">//</a>
<a name="ln658">// This snprintf() only supports the following conversion specifiers:</a>
<a name="ln659">// s, c, b, B, d, u, o, x, X, p  (and synonyms: i, D, U, O - see below)</a>
<a name="ln660">// with flags: '-', '+', ' ', '0' and '#'.</a>
<a name="ln661">// An asterisk is supported for field width as well as precision.</a>
<a name="ln662">//</a>
<a name="ln663">// Limited support for floating point was added: 'f', 'e', 'E', 'g', 'G'.</a>
<a name="ln664">//</a>
<a name="ln665">// Length modifiers 'h' (short int), 'l' (long int) and &quot;ll&quot; (long long int) are</a>
<a name="ln666">// supported.</a>
<a name="ln667">//</a>
<a name="ln668">// The locale is not used, the string is used as a byte string.  This is only</a>
<a name="ln669">// relevant for double-byte encodings where the second byte may be '%'.</a>
<a name="ln670">//</a>
<a name="ln671">// It is permitted for &quot;str_m&quot; to be zero, and it is permitted to specify NULL</a>
<a name="ln672">// pointer for resulting string argument if &quot;str_m&quot; is zero (as per ISO C99).</a>
<a name="ln673">//</a>
<a name="ln674">// The return value is the number of characters which would be generated</a>
<a name="ln675">// for the given input, excluding the trailing NUL. If this value</a>
<a name="ln676">// is greater or equal to &quot;str_m&quot;, not all characters from the result</a>
<a name="ln677">// have been stored in str, output bytes beyond the (&quot;str_m&quot;-1) -th character</a>
<a name="ln678">// are discarded. If &quot;str_m&quot; is greater than zero it is guaranteed</a>
<a name="ln679">// the resulting string will be NUL-terminated.</a>
<a name="ln680"> </a>
<a name="ln681">// vim_vsnprintf_typval() can be invoked with either &quot;va_list&quot; or a list of</a>
<a name="ln682">// &quot;typval_T&quot;.  When the latter is not used it must be NULL.</a>
<a name="ln683"> </a>
<a name="ln684">/// Append a formatted value to the string</a>
<a name="ln685">///</a>
<a name="ln686">/// @see vim_vsnprintf_typval().</a>
<a name="ln687">int vim_snprintf_add(char *str, size_t str_m, char *fmt, ...)</a>
<a name="ln688">  FUNC_ATTR_PRINTF(3, 4)</a>
<a name="ln689">{</a>
<a name="ln690">  const size_t len = strlen(str);</a>
<a name="ln691">  size_t space;</a>
<a name="ln692"> </a>
<a name="ln693">  if (str_m &lt;= len) {</a>
<a name="ln694">    space = 0;</a>
<a name="ln695">  } else {</a>
<a name="ln696">    space = str_m - len;</a>
<a name="ln697">  }</a>
<a name="ln698">  va_list ap;</a>
<a name="ln699">  va_start(ap, fmt);</a>
<a name="ln700">  const int str_l = vim_vsnprintf(str + len, space, fmt, ap);</a>
<a name="ln701">  va_end(ap);</a>
<a name="ln702">  return str_l;</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705">/// Write formatted value to the string</a>
<a name="ln706">///</a>
<a name="ln707">/// @param[out]  str  String to write to.</a>
<a name="ln708">/// @param[in]  str_m  String length.</a>
<a name="ln709">/// @param[in]  fmt  String format.</a>
<a name="ln710">///</a>
<a name="ln711">/// @return Number of bytes excluding NUL byte that would be written to the</a>
<a name="ln712">///         string if str_m was greater or equal to the return value.</a>
<a name="ln713">int vim_snprintf(char *str, size_t str_m, const char *fmt, ...)</a>
<a name="ln714">  FUNC_ATTR_PRINTF(3, 4)</a>
<a name="ln715">{</a>
<a name="ln716">  va_list ap;</a>
<a name="ln717">  va_start(ap, fmt);</a>
<a name="ln718">  const int str_l = vim_vsnprintf(str, str_m, fmt, ap);</a>
<a name="ln719">  va_end(ap);</a>
<a name="ln720">  return str_l;</a>
<a name="ln721">}</a>
<a name="ln722"> </a>
<a name="ln723">// Return the representation of infinity for printf() function:</a>
<a name="ln724">// &quot;-inf&quot;, &quot;inf&quot;, &quot;+inf&quot;, &quot; inf&quot;, &quot;-INF&quot;, &quot;INF&quot;, &quot;+INF&quot; or &quot; INF&quot;.</a>
<a name="ln725">static const char *infinity_str(bool positive, char fmt_spec,</a>
<a name="ln726">                                int force_sign, int space_for_positive)</a>
<a name="ln727">{</a>
<a name="ln728">  static const char *table[] = {</a>
<a name="ln729">    &quot;-inf&quot;, &quot;inf&quot;, &quot;+inf&quot;, &quot; inf&quot;,</a>
<a name="ln730">    &quot;-INF&quot;, &quot;INF&quot;, &quot;+INF&quot;, &quot; INF&quot;</a>
<a name="ln731">  };</a>
<a name="ln732">  int idx = positive * (1 + force_sign + force_sign * space_for_positive);</a>
<a name="ln733">  if (ASCII_ISUPPER(fmt_spec)) {</a>
<a name="ln734">    idx += 4;</a>
<a name="ln735">  }</a>
<a name="ln736">  return table[idx];</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">int vim_vsnprintf(char *str, size_t str_m, const char *fmt, va_list ap)</a>
<a name="ln740">{</a>
<a name="ln741">  return vim_vsnprintf_typval(str, str_m, fmt, ap, NULL);</a>
<a name="ln742">}</a>
<a name="ln743"> </a>
<a name="ln744">/// Write formatted value to the string</a>
<a name="ln745">///</a>
<a name="ln746">/// @param[out]  str  String to write to.</a>
<a name="ln747">/// @param[in]  str_m  String length.</a>
<a name="ln748">/// @param[in]  fmt  String format.</a>
<a name="ln749">/// @param[in]  ap  Values that should be formatted. Ignored if tvs is not NULL.</a>
<a name="ln750">/// @param[in]  tvs  Values that should be formatted, for printf() VimL</a>
<a name="ln751">///                  function. Must be NULL in other cases.</a>
<a name="ln752">///</a>
<a name="ln753">/// @return Number of bytes excluding NUL byte that would be written to the</a>
<a name="ln754">///         string if str_m was greater or equal to the return value.</a>
<a name="ln755">int vim_vsnprintf_typval(</a>
<a name="ln756">    char *str, size_t str_m, const char *fmt, va_list ap, typval_T *const tvs)</a>
<a name="ln757">{</a>
<a name="ln758">  size_t str_l = 0;</a>
<a name="ln759">  bool str_avail = str_l &lt; str_m;</a>
<a name="ln760">  const char *p = fmt;</a>
<a name="ln761">  int arg_idx = 1;</a>
<a name="ln762"> </a>
<a name="ln763">  if (!p) {</a>
<a name="ln764">    p = &quot;&quot;;</a>
<a name="ln765">  }</a>
<a name="ln766">  while (*p) {</a>
<a name="ln767">    if (*p != '%') {</a>
<a name="ln768">      // copy up to the next '%' or NUL without any changes</a>
<a name="ln769">      size_t n = (size_t)(xstrchrnul(p + 1, '%') - p);</a>
<a name="ln770">      if (str_avail) {</a>
<a name="ln771">        size_t avail = str_m - str_l;</a>
<a name="ln772">        memmove(str + str_l, p, MIN(n, avail));</a>
<a name="ln773">        str_avail = n &lt; avail;</a>
<a name="ln774">      }</a>
<a name="ln775">      p += n;</a>
<a name="ln776">      assert(n &lt;= SIZE_MAX - str_l);</a>
<a name="ln777">      str_l += n;</a>
<a name="ln778">    } else {</a>
<a name="ln779">      size_t min_field_width = 0, precision = 0;</a>
<a name="ln780">      int zero_padding = 0, precision_specified = 0, justify_left = 0;</a>
<a name="ln781">      int alternate_form = 0, force_sign = 0;</a>
<a name="ln782"> </a>
<a name="ln783">      // if both ' ' and '+' flags appear, ' ' flag should be ignored</a>
<a name="ln784">      int space_for_positive = 1;</a>
<a name="ln785"> </a>
<a name="ln786">      // allowed values: \0, h, l, 2 (for ll), z, L</a>
<a name="ln787">      char length_modifier = '\0';</a>
<a name="ln788"> </a>
<a name="ln789">      // temporary buffer for simple numeric-&gt;string conversion</a>
<a name="ln790"># define TMP_LEN 350    // 1e308 seems reasonable as the maximum printable</a>
<a name="ln791">      char tmp[TMP_LEN];</a>
<a name="ln792"> </a>
<a name="ln793">      // string address in case of string argument</a>
<a name="ln794">      const char *str_arg = NULL;</a>
<a name="ln795"> </a>
<a name="ln796">      // natural field width of arg without padding and sign</a>
<a name="ln797">      size_t str_arg_l;</a>
<a name="ln798"> </a>
<a name="ln799">      // unsigned char argument value (only defined for c conversion);</a>
<a name="ln800">      // standard explicitly states the char argument for the c</a>
<a name="ln801">      // conversion is unsigned</a>
<a name="ln802">      unsigned char uchar_arg;</a>
<a name="ln803"> </a>
<a name="ln804">      // number of zeros to be inserted for numeric conversions as</a>
<a name="ln805">      // required by the precision or minimal field width</a>
<a name="ln806">      size_t number_of_zeros_to_pad = 0;</a>
<a name="ln807"> </a>
<a name="ln808">      // index into tmp where zero padding is to be inserted</a>
<a name="ln809">      size_t zero_padding_insertion_ind = 0;</a>
<a name="ln810"> </a>
<a name="ln811">      // current conversion specifier character</a>
<a name="ln812">      char fmt_spec = '\0';</a>
<a name="ln813"> </a>
<a name="ln814">      // buffer for 's' and 'S' specs</a>
<a name="ln815">      char *tofree = NULL;</a>
<a name="ln816"> </a>
<a name="ln817">      p++;  // skip '%'</a>
<a name="ln818"> </a>
<a name="ln819">      // parse flags</a>
<a name="ln820">      while (true) {</a>
<a name="ln821">        switch (*p) {</a>
<a name="ln822">          case '0': zero_padding = 1; p++; continue;</a>
<a name="ln823">          case '-': justify_left = 1; p++; continue;</a>
<a name="ln824">                    // if both '0' and '-' flags appear, '0' should be ignored</a>
<a name="ln825">          case '+': force_sign = 1; space_for_positive = 0; p++; continue;</a>
<a name="ln826">          case ' ': force_sign = 1; p++; continue;</a>
<a name="ln827">                    // if both ' ' and '+' flags appear, ' ' should be ignored</a>
<a name="ln828">          case '#': alternate_form = 1; p++; continue;</a>
<a name="ln829">          case '\'': p++; continue;</a>
<a name="ln830">          default: break;</a>
<a name="ln831">        }</a>
<a name="ln832">        break;</a>
<a name="ln833">      }</a>
<a name="ln834"> </a>
<a name="ln835">      // parse field width</a>
<a name="ln836">      if (*p == '*') {</a>
<a name="ln837">        p++;</a>
<a name="ln838">        const int j = tvs ? (int)tv_nr(tvs, &amp;arg_idx) : va_arg(ap, int);</a>
<a name="ln839">        if (j &gt;= 0) {</a>
<a name="ln840">          min_field_width = (size_t)j;</a>
<a name="ln841">        } else {</a>
<a name="ln842">          min_field_width = (size_t)-j;</a>
<a name="ln843">          justify_left = 1;</a>
<a name="ln844">        }</a>
<a name="ln845">      } else if (ascii_isdigit((int)(*p))) {</a>
<a name="ln846">        // size_t could be wider than unsigned int; make sure we treat</a>
<a name="ln847">        // argument like common implementations do</a>
<a name="ln848">        unsigned int uj = (unsigned)(*p++ - '0');</a>
<a name="ln849"> </a>
<a name="ln850">        while (ascii_isdigit((int)(*p))) {</a>
<a name="ln851">          uj = 10 * uj + (unsigned int)(*p++ - '0');</a>
<a name="ln852">        }</a>
<a name="ln853">        min_field_width = uj;</a>
<a name="ln854">      }</a>
<a name="ln855"> </a>
<a name="ln856">      // parse precision</a>
<a name="ln857">      if (*p == '.') {</a>
<a name="ln858">        p++;</a>
<a name="ln859">        precision_specified = 1;</a>
<a name="ln860">        if (*p == '*') {</a>
<a name="ln861">          const int j = tvs ? (int)tv_nr(tvs, &amp;arg_idx) : va_arg(ap, int);</a>
<a name="ln862">          p++;</a>
<a name="ln863">          if (j &gt;= 0) {</a>
<a name="ln864">            precision = (size_t)j;</a>
<a name="ln865">          } else {</a>
<a name="ln866">            precision_specified = 0;</a>
<a name="ln867">            precision = 0;</a>
<a name="ln868">          }</a>
<a name="ln869">        } else if (ascii_isdigit((int)(*p))) {</a>
<a name="ln870">          // size_t could be wider than unsigned int; make sure we</a>
<a name="ln871">          // treat argument like common implementations do</a>
<a name="ln872">          unsigned int uj = (unsigned)(*p++ - '0');</a>
<a name="ln873"> </a>
<a name="ln874">          while (ascii_isdigit((int)(*p))) {</a>
<a name="ln875">            uj = 10 * uj + (unsigned int)(*p++ - '0');</a>
<a name="ln876">          }</a>
<a name="ln877">          precision = uj;</a>
<a name="ln878">        }</a>
<a name="ln879">      }</a>
<a name="ln880"> </a>
<a name="ln881">      // parse 'h', 'l', 'll' and 'z' length modifiers</a>
<a name="ln882">      if (*p == 'h' || *p == 'l' || *p == 'z') {</a>
<a name="ln883">        length_modifier = *p;</a>
<a name="ln884">        p++;</a>
<a name="ln885">        if (length_modifier == 'l' &amp;&amp; *p == 'l') {  // ll, encoded as 2</a>
<a name="ln886">          length_modifier = '2';</a>
<a name="ln887">          p++;</a>
<a name="ln888">        }</a>
<a name="ln889">      }</a>
<a name="ln890"> </a>
<a name="ln891">      fmt_spec = *p;</a>
<a name="ln892"> </a>
<a name="ln893">      // common synonyms</a>
<a name="ln894">      switch (fmt_spec) {</a>
<a name="ln895">        case 'i': fmt_spec = 'd'; break;</a>
<a name="ln896">        case 'D': fmt_spec = 'd'; length_modifier = 'l'; break;</a>
<a name="ln897">        case 'U': fmt_spec = 'u'; length_modifier = 'l'; break;</a>
<a name="ln898">        case 'O': fmt_spec = 'o'; length_modifier = 'l'; break;</a>
<a name="ln899">        default: break;</a>
<a name="ln900">      }</a>
<a name="ln901"> </a>
<a name="ln902">      switch (fmt_spec) {</a>
<a name="ln903">        case 'b': case 'B':</a>
<a name="ln904">        case 'd': case 'u': case 'o': case 'x': case 'X':</a>
<a name="ln905">          if (tvs &amp;&amp; length_modifier == '\0') {</a>
<a name="ln906">            length_modifier = '2';</a>
<a name="ln907">          }</a>
<a name="ln908">      }</a>
<a name="ln909"> </a>
<a name="ln910">      // get parameter value, do initial processing</a>
<a name="ln911">      switch (fmt_spec) {</a>
<a name="ln912">        // '%' and 'c' behave similar to 's' regarding flags and field widths</a>
<a name="ln913">        case '%': case 'c': case 's': case 'S':</a>
<a name="ln914">          str_arg_l = 1;</a>
<a name="ln915">          switch (fmt_spec) {</a>
<a name="ln916">            case '%':</a>
<a name="ln917">              str_arg = p;</a>
<a name="ln918">              break;</a>
<a name="ln919"> </a>
<a name="ln920">            case 'c': {</a>
<a name="ln921">              const int j = tvs ? (int)tv_nr(tvs, &amp;arg_idx) : va_arg(ap, int);</a>
<a name="ln922">              // standard demands unsigned char</a>
<a name="ln923">              uchar_arg = (unsigned char)j;</a>
<a name="ln924">              str_arg = (char *)&amp;uchar_arg;</a>
<a name="ln925">              break;</a>
<a name="ln926">            }</a>
<a name="ln927"> </a>
<a name="ln928">            case 's':</a>
<a name="ln929">            case 'S':</a>
<a name="ln930">              str_arg = tvs ? tv_str(tvs, &amp;arg_idx, &amp;tofree)</a>
<a name="ln931">                            : va_arg(ap, const char *);</a>
<a name="ln932">              if (!str_arg) {</a>
<a name="ln933">                str_arg = &quot;[NULL]&quot;;</a>
<a name="ln934">                str_arg_l = 6;</a>
<a name="ln935">              } else if (!precision_specified) {</a>
<a name="ln936">                // make sure not to address string beyond the specified</a>
<a name="ln937">                // precision</a>
<a name="ln938">                str_arg_l = strlen(str_arg);</a>
<a name="ln939">              } else if (precision == 0) {</a>
<a name="ln940">                // truncate string if necessary as requested by precision</a>
<a name="ln941">                str_arg_l = 0;</a>
<a name="ln942">              } else {</a>
<a name="ln943">                // memchr on HP does not like n &gt; 2^31</a>
<a name="ln944">                // TODO(elmart): check if this still holds / is relevant</a>
<a name="ln945">                str_arg_l = (size_t)((char *)xmemscan(str_arg,</a>
<a name="ln946">                                                      NUL,</a>
<a name="ln947">                                                      MIN(precision,</a>
<a name="ln948">                                                          0x7fffffff))</a>
<a name="ln949">                                     - str_arg);</a>
<a name="ln950">              }</a>
<a name="ln951">              if (fmt_spec == 'S') {</a>
<a name="ln952">                if (min_field_width != 0) {</a>
<a name="ln953">                  min_field_width += (strlen(str_arg)</a>
<a name="ln954">                                      - mb_string2cells((char_u *)str_arg));</a>
<a name="ln955">                }</a>
<a name="ln956">                if (precision) {</a>
<a name="ln957">                  char_u  *p1;</a>
<a name="ln958">                  size_t  i = 0;</a>
<a name="ln959"> </a>
<a name="ln960">                  for (p1 = (char_u *)str_arg; *p1;</a>
<a name="ln961">                       p1 += mb_ptr2len(p1)) {</a>
<a name="ln962">                    i += (size_t)utf_ptr2cells(p1);</a>
<a name="ln963">                    if (i &gt; precision) {</a>
<a name="ln964">                      break;</a>
<a name="ln965">                    }</a>
<a name="ln966">                  }</a>
<a name="ln967">                  str_arg_l = precision = (size_t)(p1 - (char_u *)str_arg);</a>
<a name="ln968">                }</a>
<a name="ln969">              }</a>
<a name="ln970">              break;</a>
<a name="ln971"> </a>
<a name="ln972">            default:</a>
<a name="ln973">              break;</a>
<a name="ln974">          }</a>
<a name="ln975">          break;</a>
<a name="ln976"> </a>
<a name="ln977">        case 'd':</a>
<a name="ln978">        case 'u':</a>
<a name="ln979">        case 'b': case 'B':</a>
<a name="ln980">        case 'o':</a>
<a name="ln981">        case 'x': case 'X':</a>
<a name="ln982">        case 'p': {</a>
<a name="ln983">          // u, b, B, o, x, X and p conversion specifiers imply</a>
<a name="ln984">          // the value is unsigned; d implies a signed value</a>
<a name="ln985"> </a>
<a name="ln986">          // 0 if numeric argument is zero (or if pointer is NULL for 'p'),</a>
<a name="ln987">          // +1 if greater than zero (or non NULL for 'p'),</a>
<a name="ln988">          // -1 if negative (unsigned argument is never negative)</a>
<a name="ln989">          int arg_sign = 0;</a>
<a name="ln990"> </a>
<a name="ln991">          intmax_t arg = 0;</a>
<a name="ln992">          uintmax_t uarg = 0;</a>
<a name="ln993"> </a>
<a name="ln994">          // only defined for p conversion</a>
<a name="ln995">          const void *ptr_arg = NULL;</a>
<a name="ln996"> </a>
<a name="ln997">          if (fmt_spec == 'p') {</a>
<a name="ln998">            ptr_arg = tvs ? tv_ptr(tvs, &amp;arg_idx) : va_arg(ap, void *);</a>
<a name="ln999">            if (ptr_arg) {</a>
<a name="ln1000">              arg_sign = 1;</a>
<a name="ln1001">            }</a>
<a name="ln1002">          } else if (fmt_spec == 'd') {</a>
<a name="ln1003">            // signed</a>
<a name="ln1004">            switch (length_modifier) {</a>
<a name="ln1005">              case '\0': {</a>
<a name="ln1006">                arg = (int)(tvs ? tv_nr(tvs, &amp;arg_idx) : va_arg(ap, int));</a>
<a name="ln1007">                break;</a>
<a name="ln1008">              }</a>
<a name="ln1009">              case 'h': {</a>
<a name="ln1010">                // char and short arguments are passed as int16_t</a>
<a name="ln1011">                arg = (int16_t)(tvs ? tv_nr(tvs, &amp;arg_idx) : va_arg(ap, int));</a>
<a name="ln1012">                break;</a>
<a name="ln1013">              }</a>
<a name="ln1014">              case 'l': {</a>
<a name="ln1015">                arg = (tvs ? (long)tv_nr(tvs, &amp;arg_idx) : va_arg(ap, long));</a>
<a name="ln1016">                break;</a>
<a name="ln1017">              }</a>
<a name="ln1018">              case '2': {</a>
<a name="ln1019">                arg = (</a>
<a name="ln1020">                    tvs</a>
<a name="ln1021">                    ? (long long)tv_nr(tvs, &amp;arg_idx)  // NOLINT (runtime/int)</a>
<a name="ln1022">                    : va_arg(ap, long long));  // NOLINT (runtime/int)</a>
<a name="ln1023">                break;</a>
<a name="ln1024">              }</a>
<a name="ln1025">              case 'z': {</a>
<a name="ln1026">                arg = (tvs</a>
<a name="ln1027">                       ? (ptrdiff_t)tv_nr(tvs, &amp;arg_idx)</a>
<a name="ln1028">                       : va_arg(ap, ptrdiff_t));</a>
<a name="ln1029">                break;</a>
<a name="ln1030">              }</a>
<a name="ln1031">            }</a>
<a name="ln1032">            if (arg &gt; 0) {</a>
<a name="ln1033">              arg_sign =  1;</a>
<a name="ln1034">            } else if (arg &lt; 0) {</a>
<a name="ln1035">              arg_sign = -1;</a>
<a name="ln1036">            }</a>
<a name="ln1037">          } else {</a>
<a name="ln1038">            // unsigned</a>
<a name="ln1039">            switch (length_modifier) {</a>
<a name="ln1040">              case '\0': {</a>
<a name="ln1041">                uarg = (unsigned int)(tvs</a>
<a name="ln1042">                                      ? tv_nr(tvs, &amp;arg_idx)</a>
<a name="ln1043">                                      : va_arg(ap, unsigned int));</a>
<a name="ln1044">                break;</a>
<a name="ln1045">              }</a>
<a name="ln1046">              case 'h': {</a>
<a name="ln1047">                uarg = (uint16_t)(tvs</a>
<a name="ln1048">                                  ? tv_nr(tvs, &amp;arg_idx)</a>
<a name="ln1049">                                  : va_arg(ap, unsigned int));</a>
<a name="ln1050">                break;</a>
<a name="ln1051">              }</a>
<a name="ln1052">              case 'l': {</a>
<a name="ln1053">                uarg = (tvs</a>
<a name="ln1054">                        ? (unsigned long)tv_nr(tvs, &amp;arg_idx)</a>
<a name="ln1055">                        : va_arg(ap, unsigned long));</a>
<a name="ln1056">                break;</a>
<a name="ln1057">              }</a>
<a name="ln1058">              case '2': {</a>
<a name="ln1059">                uarg = (uintmax_t)(unsigned long long)(  // NOLINT (runtime/int)</a>
<a name="ln1060">                    tvs</a>
<a name="ln1061">                    ? ((unsigned long long)  // NOLINT (runtime/int)</a>
<a name="ln1062">                       tv_nr(tvs, &amp;arg_idx))</a>
<a name="ln1063">                    : va_arg(ap, unsigned long long));  // NOLINT (runtime/int)</a>
<a name="ln1064">                break;</a>
<a name="ln1065">              }</a>
<a name="ln1066">              case 'z': {</a>
<a name="ln1067">                uarg = (tvs</a>
<a name="ln1068">                        ? (size_t)tv_nr(tvs, &amp;arg_idx)</a>
<a name="ln1069">                        : va_arg(ap, size_t));</a>
<a name="ln1070">                break;</a>
<a name="ln1071">              }</a>
<a name="ln1072">            }</a>
<a name="ln1073">            arg_sign = (uarg != 0);</a>
<a name="ln1074">          }</a>
<a name="ln1075"> </a>
<a name="ln1076">          str_arg = tmp;</a>
<a name="ln1077">          str_arg_l = 0;</a>
<a name="ln1078"> </a>
<a name="ln1079">          // For d, i, u, o, x, and X conversions, if precision is specified,</a>
<a name="ln1080">          // '0' flag should be ignored. This is so with Solaris 2.6, Digital</a>
<a name="ln1081">          // UNIX 4.0, HPUX 10, Linux, FreeBSD, NetBSD; but not with Perl.</a>
<a name="ln1082">          if (precision_specified) {</a>
<a name="ln1083">            zero_padding = 0;</a>
<a name="ln1084">          }</a>
<a name="ln1085"> </a>
<a name="ln1086">          if (fmt_spec == 'd') {</a>
<a name="ln1087">            if (force_sign &amp;&amp; arg_sign &gt;= 0) {</a>
<a name="ln1088">              tmp[str_arg_l++] = space_for_positive ? ' ' : '+';</a>
<a name="ln1089">            }</a>
<a name="ln1090">            // leave negative numbers for snprintf to handle, to</a>
<a name="ln1091">            // avoid handling tricky cases like (short int)-32768</a>
<a name="ln1092">          } else if (alternate_form) {</a>
<a name="ln1093">            if (arg_sign != 0 &amp;&amp; (fmt_spec == 'x' || fmt_spec == 'X'</a>
<a name="ln1094">                                  || fmt_spec == 'b' || fmt_spec == 'B')) {</a>
<a name="ln1095">              tmp[str_arg_l++] = '0';</a>
<a name="ln1096">              tmp[str_arg_l++] = fmt_spec;</a>
<a name="ln1097">            }</a>
<a name="ln1098">            // alternate form should have no effect for p * conversion, but ...</a>
<a name="ln1099">          }</a>
<a name="ln1100"> </a>
<a name="ln1101">          zero_padding_insertion_ind = str_arg_l;</a>
<a name="ln1102">          if (!precision_specified) {</a>
<a name="ln1103">            precision = 1;  // default precision is 1</a>
<a name="ln1104">          }</a>
<a name="ln1105">          if (precision == 0 &amp;&amp; arg_sign == 0) {</a>
<a name="ln1106">            // when zero value is formatted with an explicit precision 0,</a>
<a name="ln1107">            // resulting formatted string is empty (d, i, u, b, B, o, x, X, p)</a>
<a name="ln1108">          } else {</a>
<a name="ln1109">            switch (fmt_spec) {</a>
<a name="ln1110">              case 'p': {  // pointer</a>
<a name="ln1111">                str_arg_l += (size_t)snprintf(tmp + str_arg_l,</a>
<a name="ln1112">                                              sizeof(tmp) - str_arg_l,</a>
<a name="ln1113">                                              &quot;%p&quot;, ptr_arg);</a>
<a name="ln1114">                break;</a>
<a name="ln1115">              }</a>
<a name="ln1116">              case 'd': {  // signed</a>
<a name="ln1117">                str_arg_l += (size_t)snprintf(tmp + str_arg_l,</a>
<a name="ln1118">                                              sizeof(tmp) - str_arg_l,</a>
<a name="ln1119">                                              &quot;%&quot; PRIdMAX, arg);</a>
<a name="ln1120">                break;</a>
<a name="ln1121">              }</a>
<a name="ln1122">              case 'b': case 'B': {  // binary</a>
<a name="ln1123">                size_t bits = 0;</a>
<a name="ln1124">                for (bits = sizeof(uintmax_t) * 8; bits &gt; 0; bits--) {</a>
<a name="ln1125">                  if ((uarg &gt;&gt; (bits - 1)) &amp; 0x1) {</a>
<a name="ln1126">                    break;</a>
<a name="ln1127">                  }</a>
<a name="ln1128">                }</a>
<a name="ln1129"> </a>
<a name="ln1130">                while (bits &gt; 0) {</a>
<a name="ln1131">                  tmp[str_arg_l++] = ((uarg &gt;&gt; --bits) &amp; 0x1) ? '1' : '0';</a>
<a name="ln1132">                }</a>
<a name="ln1133">                break;</a>
<a name="ln1134">              }</a>
<a name="ln1135">              default: {  // unsigned</a>
<a name="ln1136">                // construct a simple format string for snprintf</a>
<a name="ln1137">                char f[] = &quot;%&quot; PRIuMAX;</a>
<a name="ln1138">                f[sizeof(&quot;%&quot; PRIuMAX) - 1 - 1] = fmt_spec;</a>
<a name="ln1139">                assert(PRIuMAX[sizeof(PRIuMAX) - 1 - 1] == 'u');</a>
<a name="ln1140">                str_arg_l += (size_t)snprintf(tmp + str_arg_l,</a>
<a name="ln1141">                                              sizeof(tmp) - str_arg_l,</a>
<a name="ln1142">                                              f, uarg);</a>
<a name="ln1143">                break;</a>
<a name="ln1144">              }</a>
<a name="ln1145">            }</a>
<a name="ln1146">            assert(str_arg_l &lt; sizeof(tmp));</a>
<a name="ln1147"> </a>
<a name="ln1148">            // include the optional minus sign and possible &quot;0x&quot; in the region</a>
<a name="ln1149">            // before the zero padding insertion point</a>
<a name="ln1150">            if (zero_padding_insertion_ind &lt; str_arg_l</a>
<a name="ln1151">                &amp;&amp; tmp[zero_padding_insertion_ind] == '-') {</a>
<a name="ln1152">              zero_padding_insertion_ind++;</a>
<a name="ln1153">            }</a>
<a name="ln1154">            if (zero_padding_insertion_ind + 1 &lt; str_arg_l</a>
<a name="ln1155">                &amp;&amp; tmp[zero_padding_insertion_ind]   == '0'</a>
<a name="ln1156">                &amp;&amp; (tmp[zero_padding_insertion_ind + 1] == 'x'</a>
<a name="ln1157">                    || tmp[zero_padding_insertion_ind + 1] == 'X'</a>
<a name="ln1158">                    || tmp[zero_padding_insertion_ind + 1] == 'b'</a>
<a name="ln1159">                    || tmp[zero_padding_insertion_ind + 1] == 'B')) {</a>
<a name="ln1160">              zero_padding_insertion_ind += 2;</a>
<a name="ln1161">            }</a>
<a name="ln1162">          }</a>
<a name="ln1163"> </a>
<a name="ln1164">          {</a>
<a name="ln1165">            size_t num_of_digits = str_arg_l - zero_padding_insertion_ind;</a>
<a name="ln1166"> </a>
<a name="ln1167">            if (alternate_form &amp;&amp; fmt_spec == 'o'</a>
<a name="ln1168">                // unless zero is already the first character</a>
<a name="ln1169">                &amp;&amp; !(zero_padding_insertion_ind &lt; str_arg_l</a>
<a name="ln1170">                     &amp;&amp; tmp[zero_padding_insertion_ind] == '0')) {</a>
<a name="ln1171">              // assure leading zero for alternate-form octal numbers</a>
<a name="ln1172">              if (!precision_specified</a>
<a name="ln1173">                  || precision &lt; num_of_digits + 1) {</a>
<a name="ln1174">                // precision is increased to force the first character to be</a>
<a name="ln1175">                // zero, except if a zero value is formatted with an explicit</a>
<a name="ln1176">                // precision of zero</a>
<a name="ln1177">                precision = num_of_digits + 1;</a>
<a name="ln1178">              }</a>
<a name="ln1179">            }</a>
<a name="ln1180">            // zero padding to specified precision?</a>
<a name="ln1181">            if (num_of_digits &lt; precision) {</a>
<a name="ln1182">              number_of_zeros_to_pad = precision - num_of_digits;</a>
<a name="ln1183">            }</a>
<a name="ln1184">          }</a>
<a name="ln1185">          // zero padding to specified minimal field width?</a>
<a name="ln1186">          if (!justify_left &amp;&amp; zero_padding) {</a>
<a name="ln1187">            const int n = (int)(min_field_width - (str_arg_l</a>
<a name="ln1188">                                                   + number_of_zeros_to_pad));</a>
<a name="ln1189">            if (n &gt; 0) {</a>
<a name="ln1190">              number_of_zeros_to_pad += (size_t)n;</a>
<a name="ln1191">            }</a>
<a name="ln1192">          }</a>
<a name="ln1193">          break;</a>
<a name="ln1194">        }</a>
<a name="ln1195"> </a>
<a name="ln1196">        case 'f':</a>
<a name="ln1197">        case 'F':</a>
<a name="ln1198">        case 'e':</a>
<a name="ln1199">        case 'E':</a>
<a name="ln1200">        case 'g':</a>
<a name="ln1201">        case 'G':</a>
<a name="ln1202">          {</a>
<a name="ln1203">            // floating point</a>
<a name="ln1204">            char format[40];</a>
<a name="ln1205">            int remove_trailing_zeroes = false;</a>
<a name="ln1206"> </a>
<a name="ln1207">            double f = tvs ? tv_float(tvs, &amp;arg_idx) : va_arg(ap, double);</a>
<a name="ln1208">            double abs_f = f &lt; 0 ? -f : f;</a>
<a name="ln1209"> </a>
<a name="ln1210">            if (fmt_spec == 'g' || fmt_spec == 'G') {</a>
<a name="ln1211">              // can't use %g directly, cause it prints &quot;1.0&quot; as &quot;1&quot;</a>
<a name="ln1212">              if ((abs_f &gt;= 0.001 &amp;&amp; abs_f &lt; 10000000.0) || abs_f == 0.0) {</a>
<a name="ln1213">                fmt_spec = ASCII_ISUPPER(fmt_spec) ? 'F' : 'f';</a>
<a name="ln1214">              } else {</a>
<a name="ln1215">                fmt_spec = fmt_spec == 'g' ? 'e' : 'E';</a>
<a name="ln1216">              }</a>
<a name="ln1217">              remove_trailing_zeroes = true;</a>
<a name="ln1218">            }</a>
<a name="ln1219"> </a>
<a name="ln1220">            if (xisinf(f)</a>
<a name="ln1221">                || (strchr(&quot;fF&quot;, fmt_spec) != NULL &amp;&amp; abs_f &gt; 1.0e307)) {</a>
<a name="ln1222">              xstrlcpy(tmp, infinity_str(f &gt; 0.0, fmt_spec,</a>
<a name="ln1223">                                         force_sign, space_for_positive),</a>
<a name="ln1224">                       sizeof(tmp));</a>
<a name="ln1225">              str_arg_l = strlen(tmp);</a>
<a name="ln1226">              zero_padding = 0;</a>
<a name="ln1227">            } else if (xisnan(f)) {</a>
<a name="ln1228">              // Not a number: nan or NAN</a>
<a name="ln1229">              memmove(tmp, ASCII_ISUPPER(fmt_spec) ? &quot;NAN&quot; : &quot;nan&quot;, 4);</a>
<a name="ln1230">              str_arg_l = 3;</a>
<a name="ln1231">              zero_padding = 0;</a>
<a name="ln1232">            } else {</a>
<a name="ln1233">              // Regular float number</a>
<a name="ln1234">              format[0] = '%';</a>
<a name="ln1235">              size_t l = 1;</a>
<a name="ln1236">              if (force_sign) {</a>
<a name="ln1237">                format[l++] = space_for_positive ? ' ' : '+';</a>
<a name="ln1238">              }</a>
<a name="ln1239">              if (precision_specified) {</a>
<a name="ln1240">                size_t max_prec = TMP_LEN - 10;</a>
<a name="ln1241"> </a>
<a name="ln1242">                // make sure we don't get more digits than we have room for</a>
<a name="ln1243">                if ((fmt_spec == 'f' || fmt_spec == 'F') &amp;&amp; abs_f &gt; 1.0) {</a>
<a name="ln1244">                  max_prec -= (size_t)log10(abs_f);</a>
<a name="ln1245">                }</a>
<a name="ln1246">                if (precision &gt; max_prec) {</a>
<a name="ln1247">                  precision = max_prec;</a>
<a name="ln1248">                }</a>
<a name="ln1249">                l += (size_t)snprintf(format + l, sizeof(format) - l, &quot;.%d&quot;,</a>
<a name="ln1250">                                      (int)precision);</a>
<a name="ln1251">              }</a>
<a name="ln1252"> </a>
<a name="ln1253">              // Cast to char to avoid a conversion warning on Ubuntu 12.04.</a>
<a name="ln1254">              assert(l + 1 &lt; sizeof(format));</a>
<a name="ln1255">              format[l] = (char)(fmt_spec == 'F' ? 'f' : fmt_spec);</a>
<a name="ln1256">              format[l + 1] = NUL;</a>
<a name="ln1257"> </a>
<a name="ln1258">              str_arg_l = (size_t)snprintf(tmp, sizeof(tmp), format, f);</a>
<a name="ln1259">              assert(str_arg_l &lt; sizeof(tmp));</a>
<a name="ln1260"> </a>
<a name="ln1261">              if (remove_trailing_zeroes) {</a>
<a name="ln1262">                int i;</a>
<a name="ln1263">                char *tp;</a>
<a name="ln1264"> </a>
<a name="ln1265">                // using %g or %G: remove superfluous zeroes</a>
<a name="ln1266">                if (fmt_spec == 'f' || fmt_spec == 'F') {</a>
<a name="ln1267">                  tp = tmp + str_arg_l - 1;</a>
<a name="ln1268">                } else {</a>
<a name="ln1269">                  tp = (char *)vim_strchr((char_u *)tmp,</a>
<a name="ln1270">                                          fmt_spec == 'e' ? 'e' : 'E');</a>
<a name="ln1271">                  if (tp) {</a>
<a name="ln1272">                    // remove superfluous '+' and leading zeroes from exponent</a>
<a name="ln1273">                    if (tp[1] == '+') {</a>
<a name="ln1274">                      // change &quot;1.0e+07&quot; to &quot;1.0e07&quot;</a>
<a name="ln1275">                      STRMOVE(tp + 1, tp + 2);</a>
<a name="ln1276">                      str_arg_l--;</a>
<a name="ln1277">                    }</a>
<a name="ln1278">                    i = (tp[1] == '-') ? 2 : 1;</a>
<a name="ln1279">                    while (tp[i] == '0') {</a>
<a name="ln1280">                      // change &quot;1.0e07&quot; to &quot;1.0e7&quot;</a>
<a name="ln1281">                      STRMOVE(tp + i, tp + i + 1);</a>
<a name="ln1282">                      str_arg_l--;</a>
<a name="ln1283">                    }</a>
<a name="ln1284">                    tp--;</a>
<a name="ln1285">                  }</a>
<a name="ln1286">                }</a>
<a name="ln1287"> </a>
<a name="ln1288">                if (tp != NULL &amp;&amp; !precision_specified) {</a>
<a name="ln1289">                  // remove trailing zeroes, but keep the one just after a dot</a>
<a name="ln1290">                  while (tp &gt; tmp + 2 &amp;&amp; *tp == '0' &amp;&amp; tp[-1] != '.') {</a>
<a name="ln1291">                    STRMOVE(tp, tp + 1);</a>
<a name="ln1292">                    tp--;</a>
<a name="ln1293">                    str_arg_l--;</a>
<a name="ln1294">                  }</a>
<a name="ln1295">                }</a>
<a name="ln1296">              } else {</a>
<a name="ln1297">                // Be consistent: some printf(&quot;%e&quot;) use 1.0e+12 and some</a>
<a name="ln1298">                // 1.0e+012; remove one zero in the last case.</a>
<a name="ln1299">                char *tp = (char *)vim_strchr((char_u *)tmp,</a>
<a name="ln1300">                                              fmt_spec == 'e' ? 'e' : 'E');</a>
<a name="ln1301">                if (tp &amp;&amp; (tp[1] == '+' || tp[1] == '-') &amp;&amp; tp[2] == '0'</a>
<a name="ln1302">                    &amp;&amp; ascii_isdigit(tp[3]) &amp;&amp; ascii_isdigit(tp[4])) {</a>
<a name="ln1303">                  STRMOVE(tp + 2, tp + 3);</a>
<a name="ln1304">                  str_arg_l--;</a>
<a name="ln1305">                }</a>
<a name="ln1306">              }</a>
<a name="ln1307">            }</a>
<a name="ln1308">            if (zero_padding &amp;&amp; min_field_width &gt; str_arg_l</a>
<a name="ln1309">                &amp;&amp; (tmp[0] == '-' || force_sign)) {</a>
<a name="ln1310">              // Padding 0's should be inserted after the sign.</a>
<a name="ln1311">              number_of_zeros_to_pad = min_field_width - str_arg_l;</a>
<a name="ln1312">              zero_padding_insertion_ind = 1;</a>
<a name="ln1313">            }</a>
<a name="ln1314">            str_arg = tmp;</a>
<a name="ln1315">            break;</a>
<a name="ln1316">          }</a>
<a name="ln1317"> </a>
<a name="ln1318">        default:</a>
<a name="ln1319">          // unrecognized conversion specifier, keep format string as-is</a>
<a name="ln1320">          zero_padding = 0;  // turn zero padding off for non-numeric conversion</a>
<a name="ln1321">          justify_left = 1;</a>
<a name="ln1322">          min_field_width = 0;  // reset flags</a>
<a name="ln1323"> </a>
<a name="ln1324">          // discard the unrecognized conversion, just keep</a>
<a name="ln1325">          // the unrecognized conversion character</a>
<a name="ln1326">          str_arg = p;</a>
<a name="ln1327">          str_arg_l = 0;</a>
<a name="ln1328">          if (*p) {</a>
<a name="ln1329">            str_arg_l++;  // include invalid conversion specifier</a>
<a name="ln1330">          }</a>
<a name="ln1331">          // unchanged if not at end-of-string</a>
<a name="ln1332">          break;</a>
<a name="ln1333">      }</a>
<a name="ln1334"> </a>
<a name="ln1335">      if (*p) {</a>
<a name="ln1336">        p++;  // step over the just processed conversion specifier</a>
<a name="ln1337">      }</a>
<a name="ln1338"> </a>
<a name="ln1339">      // insert padding to the left as requested by min_field_width;</a>
<a name="ln1340">      // this does not include the zero padding in case of numerical conversions</a>
<a name="ln1341">      if (!justify_left) {</a>
<a name="ln1342">        assert(str_arg_l &lt;= SIZE_MAX - number_of_zeros_to_pad);</a>
<a name="ln1343">        if (min_field_width &gt; str_arg_l + number_of_zeros_to_pad) {</a>
<a name="ln1344">          // left padding with blank or zero</a>
<a name="ln1345">          size_t pn = min_field_width - (str_arg_l + number_of_zeros_to_pad);</a>
<a name="ln1346">          if (str_avail) {</a>
<a name="ln1347">            size_t avail = str_m - str_l;</a>
<a name="ln1348">            memset(str + str_l, zero_padding ? '0' : ' ', MIN(pn, avail));</a>
<a name="ln1349">            str_avail = pn &lt; avail;</a>
<a name="ln1350">          }</a>
<a name="ln1351">          assert(pn &lt;= SIZE_MAX - str_l);</a>
<a name="ln1352">          str_l += pn;</a>
<a name="ln1353">        }</a>
<a name="ln1354">      }</a>
<a name="ln1355"> </a>
<a name="ln1356">      // zero padding as requested by the precision or by the minimal</a>
<a name="ln1357">      // field width for numeric conversions required?</a>
<a name="ln1358">      if (number_of_zeros_to_pad == 0) {</a>
<a name="ln1359">        // will not copy first part of numeric right now,</a>
<a name="ln1360">        // force it to be copied later in its entirety</a>
<a name="ln1361">        zero_padding_insertion_ind = 0;</a>
<a name="ln1362">      } else {</a>
<a name="ln1363">        // insert first part of numerics (sign or '0x') before zero padding</a>
<a name="ln1364">        if (zero_padding_insertion_ind &gt; 0) {</a>
<a name="ln1365">          size_t zn = zero_padding_insertion_ind;</a>
<a name="ln1366">          if (str_avail) {</a>
<a name="ln1367">            size_t avail = str_m - str_l;</a>
<a name="ln1368">            memmove(str + str_l, str_arg, MIN(zn, avail));</a>
<a name="ln1369">            str_avail = zn &lt; avail;</a>
<a name="ln1370">          }</a>
<a name="ln1371">          assert(zn &lt;= SIZE_MAX - str_l);</a>
<a name="ln1372">          str_l += zn;</a>
<a name="ln1373">        }</a>
<a name="ln1374"> </a>
<a name="ln1375">        // insert zero padding as requested by precision or min field width</a>
<a name="ln1376">        size_t zn = number_of_zeros_to_pad;</a>
<a name="ln1377">        if (str_avail) {</a>
<a name="ln1378">          size_t avail = str_m - str_l;</a>
<a name="ln1379">          memset(str + str_l, '0', MIN(zn, avail));</a>
<a name="ln1380">          str_avail = zn &lt; avail;</a>
<a name="ln1381">        }</a>
<a name="ln1382">        assert(zn &lt;= SIZE_MAX - str_l);</a>
<a name="ln1383">        str_l += zn;</a>
<a name="ln1384">      }</a>
<a name="ln1385"> </a>
<a name="ln1386">      // insert formatted string</a>
<a name="ln1387">      // (or as-is conversion specifier for unknown conversions)</a>
<a name="ln1388">      if (str_arg_l &gt; zero_padding_insertion_ind) {</a>
<a name="ln1389">        size_t sn = str_arg_l - zero_padding_insertion_ind;</a>
<a name="ln1390">        if (str_avail) {</a>
<a name="ln1391">          size_t avail = str_m - str_l;</a>
<a name="ln1392">          memmove(str + str_l,</a>
<a name="ln1393">                  str_arg + zero_padding_insertion_ind,</a>
<a name="ln1394">                  MIN(sn, avail));</a>
<a name="ln1395">          str_avail = sn &lt; avail;</a>
<a name="ln1396">        }</a>
<a name="ln1397">        assert(sn &lt;= SIZE_MAX - str_l);</a>
<a name="ln1398">        str_l += sn;</a>
<a name="ln1399">      }</a>
<a name="ln1400"> </a>
<a name="ln1401">      // insert right padding</a>
<a name="ln1402">      if (justify_left) {</a>
<a name="ln1403">        assert(str_arg_l &lt;= SIZE_MAX - number_of_zeros_to_pad);</a>
<a name="ln1404">        if (min_field_width &gt; str_arg_l + number_of_zeros_to_pad) {</a>
<a name="ln1405">          // right blank padding to the field width</a>
<a name="ln1406">          size_t pn = min_field_width - (str_arg_l + number_of_zeros_to_pad);</a>
<a name="ln1407">          if (str_avail) {</a>
<a name="ln1408">            size_t avail = str_m - str_l;</a>
<a name="ln1409">            memset(str + str_l, ' ', MIN(pn, avail));</a>
<a name="ln1410">            str_avail = pn &lt; avail;</a>
<a name="ln1411">          }</a>
<a name="ln1412">          assert(pn &lt;= SIZE_MAX - str_l);</a>
<a name="ln1413">          str_l += pn;</a>
<a name="ln1414">        }</a>
<a name="ln1415">      }</a>
<a name="ln1416"> </a>
<a name="ln1417">      xfree(tofree);</a>
<a name="ln1418">    }</a>
<a name="ln1419">  }</a>
<a name="ln1420"> </a>
<a name="ln1421">  if (str_m &gt; 0) {</a>
<a name="ln1422">    // make sure the string is nul-terminated even at the expense of</a>
<a name="ln1423">    // overwriting the last character (shouldn't happen, but just in case)</a>
<a name="ln1424">    str[str_l &lt;= str_m - 1 ? str_l : str_m - 1] = '\0';</a>
<a name="ln1425">  }</a>
<a name="ln1426"> </a>
<a name="ln1427">  if (tvs &amp;&amp; tvs[arg_idx - 1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1428">    EMSG(_(&quot;E767: Too many arguments to printf()&quot;));</a>
<a name="ln1429">  }</a>
<a name="ln1430"> </a>
<a name="ln1431">  // return the number of characters formatted (excluding trailing nul</a>
<a name="ln1432">  // character); that is, the number of characters that would have been</a>
<a name="ln1433">  // written to the buffer if it were large enough.</a>
<a name="ln1434">  return (int)str_l;</a>
<a name="ln1435">}</a>

</code></pre>
<div class="balloon" rel="596"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v568/" target="_blank">V568</a> It's odd that 'sizeof()' operator evaluates the size of a pointer to a class, but not the size of the 'tvs[0].vval.v_list' class object.</p></div>
<div class="balloon" rel="596"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v568/" target="_blank">V568</a> It's odd that 'sizeof()' operator evaluates the size of a pointer to a class, but not the size of the 'tvs[0].vval.v_dict' class object.</p></div>
<div class="balloon" rel="596"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v568/" target="_blank">V568</a> It's odd that 'sizeof()' operator evaluates the size of a pointer to a class, but not the size of the 'tvs[0].vval.v_partial' class object.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
