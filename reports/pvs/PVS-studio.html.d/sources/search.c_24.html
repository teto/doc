
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>search.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/*</a>
<a name="ln5"> * search.c: code for normal mode searching commands</a>
<a name="ln6"> */</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;assert.h&gt;</a>
<a name="ln9">#include &lt;inttypes.h&gt;</a>
<a name="ln10">#include &lt;stdbool.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12">#include &lt;limits.h&gt;             /* for INT_MAX on MSVC */</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln15">#include &quot;nvim/vim.h&quot;</a>
<a name="ln16">#include &quot;nvim/search.h&quot;</a>
<a name="ln17">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln18">#include &quot;nvim/charset.h&quot;</a>
<a name="ln19">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln20">#include &quot;nvim/edit.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval.h&quot;</a>
<a name="ln22">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln23">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln24">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln25">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln26">#include &quot;nvim/fold.h&quot;</a>
<a name="ln27">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln28">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln29">#include &quot;nvim/indent.h&quot;</a>
<a name="ln30">#include &quot;nvim/main.h&quot;</a>
<a name="ln31">#include &quot;nvim/mark.h&quot;</a>
<a name="ln32">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln33">#include &quot;nvim/memline.h&quot;</a>
<a name="ln34">#include &quot;nvim/memory.h&quot;</a>
<a name="ln35">#include &quot;nvim/message.h&quot;</a>
<a name="ln36">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln37">#include &quot;nvim/move.h&quot;</a>
<a name="ln38">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln39">#include &quot;nvim/normal.h&quot;</a>
<a name="ln40">#include &quot;nvim/option.h&quot;</a>
<a name="ln41">#include &quot;nvim/path.h&quot;</a>
<a name="ln42">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln43">#include &quot;nvim/screen.h&quot;</a>
<a name="ln44">#include &quot;nvim/strings.h&quot;</a>
<a name="ln45">#include &quot;nvim/ui.h&quot;</a>
<a name="ln46">#include &quot;nvim/window.h&quot;</a>
<a name="ln47">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln48"> </a>
<a name="ln49"> </a>
<a name="ln50">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln51"># include &quot;search.c.generated.h&quot;</a>
<a name="ln52">#endif</a>
<a name="ln53">/*</a>
<a name="ln54"> * This file contains various searching-related routines. These fall into</a>
<a name="ln55"> * three groups:</a>
<a name="ln56"> * 1. string searches (for /, ?, n, and N)</a>
<a name="ln57"> * 2. character searches within a single line (for f, F, t, T, etc)</a>
<a name="ln58"> * 3. &quot;other&quot; kinds of searches like the '%' command, and 'word' searches.</a>
<a name="ln59"> */</a>
<a name="ln60"> </a>
<a name="ln61">/*</a>
<a name="ln62"> * String searches</a>
<a name="ln63"> *</a>
<a name="ln64"> * The string search functions are divided into two levels:</a>
<a name="ln65"> * lowest:  searchit(); uses a pos_T for starting position and found match.</a>
<a name="ln66"> * Highest: do_search(); uses curwin-&gt;w_cursor; calls searchit().</a>
<a name="ln67"> *</a>
<a name="ln68"> * The last search pattern is remembered for repeating the same search.</a>
<a name="ln69"> * This pattern is shared between the :g, :s, ? and / commands.</a>
<a name="ln70"> * This is in search_regcomp().</a>
<a name="ln71"> *</a>
<a name="ln72"> * The actual string matching is done using a heavily modified version of</a>
<a name="ln73"> * Henry Spencer's regular expression library.  See regexp.c.</a>
<a name="ln74"> */</a>
<a name="ln75"> </a>
<a name="ln76">/*</a>
<a name="ln77"> * Two search patterns are remembered: One for the :substitute command and</a>
<a name="ln78"> * one for other searches.  last_idx points to the one that was used the last</a>
<a name="ln79"> * time.</a>
<a name="ln80"> */</a>
<a name="ln81">static struct spat spats[2] =</a>
<a name="ln82">{</a>
<a name="ln83">  // Last used search pattern</a>
<a name="ln84">  [0] = {NULL, true, false, 0, {'/', false, false, 0L}, NULL},</a>
<a name="ln85">  // Last used substitute pattern</a>
<a name="ln86">  [1] = {NULL, true, false, 0, {'/', false, false, 0L}, NULL}</a>
<a name="ln87">};</a>
<a name="ln88"> </a>
<a name="ln89">static int last_idx = 0;        /* index in spats[] for RE_LAST */</a>
<a name="ln90"> </a>
<a name="ln91">static char_u lastc[2] = { NUL, NUL };    // last character searched for</a>
<a name="ln92">static Direction lastcdir = FORWARD;      // last direction of character search</a>
<a name="ln93">static int last_t_cmd = true;             // last search t_cmd</a>
<a name="ln94">static char_u lastc_bytes[MB_MAXBYTES + 1];</a>
<a name="ln95">static int lastc_bytelen = 1;             // &gt;1 for multi-byte char</a>
<a name="ln96"> </a>
<a name="ln97">// copy of spats[], for keeping the search patterns while executing autocmds</a>
<a name="ln98">static struct spat saved_spats[2];</a>
<a name="ln99">static int saved_spats_last_idx = 0;</a>
<a name="ln100">static bool saved_spats_no_hlsearch = false;</a>
<a name="ln101"> </a>
<a name="ln102">static char_u       *mr_pattern = NULL;    // pattern used by search_regcomp()</a>
<a name="ln103">static int mr_pattern_alloced = false;     // mr_pattern was allocated</a>
<a name="ln104"> </a>
<a name="ln105">/*</a>
<a name="ln106"> * Type used by find_pattern_in_path() to remember which included files have</a>
<a name="ln107"> * been searched already.</a>
<a name="ln108"> */</a>
<a name="ln109">typedef struct SearchedFile {</a>
<a name="ln110">  FILE        *fp;              /* File pointer */</a>
<a name="ln111">  char_u      *name;            /* Full name of file */</a>
<a name="ln112">  linenr_T lnum;                /* Line we were up to in file */</a>
<a name="ln113">  int matched;                  /* Found a match in this file */</a>
<a name="ln114">} SearchedFile;</a>
<a name="ln115"> </a>
<a name="ln116">/*</a>
<a name="ln117"> * translate search pattern for vim_regcomp()</a>
<a name="ln118"> *</a>
<a name="ln119"> * pat_save == RE_SEARCH: save pat in spats[RE_SEARCH].pat (normal search cmd)</a>
<a name="ln120"> * pat_save == RE_SUBST: save pat in spats[RE_SUBST].pat (:substitute command)</a>
<a name="ln121"> * pat_save == RE_BOTH: save pat in both patterns (:global command)</a>
<a name="ln122"> * pat_use  == RE_SEARCH: use previous search pattern if &quot;pat&quot; is NULL</a>
<a name="ln123"> * pat_use  == RE_SUBST: use previous substitute pattern if &quot;pat&quot; is NULL</a>
<a name="ln124"> * pat_use  == RE_LAST: use last used pattern if &quot;pat&quot; is NULL</a>
<a name="ln125"> * options &amp; SEARCH_HIS: put search string in history</a>
<a name="ln126"> * options &amp; SEARCH_KEEP: keep previous search pattern</a>
<a name="ln127"> *</a>
<a name="ln128"> * returns FAIL if failed, OK otherwise.</a>
<a name="ln129"> */</a>
<a name="ln130">int</a>
<a name="ln131">search_regcomp(</a>
<a name="ln132">    char_u *pat,</a>
<a name="ln133">    int pat_save,</a>
<a name="ln134">    int pat_use,</a>
<a name="ln135">    int options,</a>
<a name="ln136">    regmmatch_T *regmatch          /* return: pattern and ignore-case flag */</a>
<a name="ln137">)</a>
<a name="ln138">{</a>
<a name="ln139">  int magic;</a>
<a name="ln140">  int i;</a>
<a name="ln141"> </a>
<a name="ln142">  rc_did_emsg = FALSE;</a>
<a name="ln143">  magic = p_magic;</a>
<a name="ln144"> </a>
<a name="ln145">  /*</a>
<a name="ln146">   * If no pattern given, use a previously defined pattern.</a>
<a name="ln147">   */</a>
<a name="ln148">  if (pat == NULL || *pat == NUL) {</a>
<a name="ln149">    if (pat_use == RE_LAST)</a>
<a name="ln150">      i = last_idx;</a>
<a name="ln151">    else</a>
<a name="ln152">      i = pat_use;</a>
<a name="ln153">    if (spats[i].pat == NULL) {         /* pattern was never defined */</a>
<a name="ln154">      if (pat_use == RE_SUBST)</a>
<a name="ln155">        EMSG(_(e_nopresub));</a>
<a name="ln156">      else</a>
<a name="ln157">        EMSG(_(e_noprevre));</a>
<a name="ln158">      rc_did_emsg = TRUE;</a>
<a name="ln159">      return FAIL;</a>
<a name="ln160">    }</a>
<a name="ln161">    pat = spats[i].pat;</a>
<a name="ln162">    magic = spats[i].magic;</a>
<a name="ln163">    no_smartcase = spats[i].no_scs;</a>
<a name="ln164">  } else if (options &amp; SEARCH_HIS)      /* put new pattern in history */</a>
<a name="ln165">    add_to_history(HIST_SEARCH, pat, TRUE, NUL);</a>
<a name="ln166"> </a>
<a name="ln167">  if (mr_pattern_alloced) {</a>
<a name="ln168">    xfree(mr_pattern);</a>
<a name="ln169">    mr_pattern_alloced = FALSE;</a>
<a name="ln170">  }</a>
<a name="ln171"> </a>
<a name="ln172">  if (curwin-&gt;w_p_rl &amp;&amp; *curwin-&gt;w_p_rlc == 's') {</a>
<a name="ln173">    mr_pattern = reverse_text(pat);</a>
<a name="ln174">    mr_pattern_alloced = TRUE;</a>
<a name="ln175">  } else</a>
<a name="ln176">    mr_pattern = pat;</a>
<a name="ln177"> </a>
<a name="ln178">  /*</a>
<a name="ln179">   * Save the currently used pattern in the appropriate place,</a>
<a name="ln180">   * unless the pattern should not be remembered.</a>
<a name="ln181">   */</a>
<a name="ln182">  if (!(options &amp; SEARCH_KEEP) &amp;&amp; !cmdmod.keeppatterns) {</a>
<a name="ln183">    /* search or global command */</a>
<a name="ln184">    if (pat_save == RE_SEARCH || pat_save == RE_BOTH)</a>
<a name="ln185">      save_re_pat(RE_SEARCH, pat, magic);</a>
<a name="ln186">    /* substitute or global command */</a>
<a name="ln187">    if (pat_save == RE_SUBST || pat_save == RE_BOTH)</a>
<a name="ln188">      save_re_pat(RE_SUBST, pat, magic);</a>
<a name="ln189">  }</a>
<a name="ln190"> </a>
<a name="ln191">  regmatch-&gt;rmm_ic = ignorecase(pat);</a>
<a name="ln192">  regmatch-&gt;rmm_maxcol = 0;</a>
<a name="ln193">  regmatch-&gt;regprog = vim_regcomp(pat, magic ? RE_MAGIC : 0);</a>
<a name="ln194">  if (regmatch-&gt;regprog == NULL)</a>
<a name="ln195">    return FAIL;</a>
<a name="ln196">  return OK;</a>
<a name="ln197">}</a>
<a name="ln198"> </a>
<a name="ln199">/*</a>
<a name="ln200"> * Get search pattern used by search_regcomp().</a>
<a name="ln201"> */</a>
<a name="ln202">char_u *get_search_pat(void)</a>
<a name="ln203">{</a>
<a name="ln204">  return mr_pattern;</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207">/*</a>
<a name="ln208"> * Reverse text into allocated memory.</a>
<a name="ln209"> * Returns the allocated string.</a>
<a name="ln210"> *</a>
<a name="ln211"> * TODO(philix): move reverse_text() to strings.c</a>
<a name="ln212"> */</a>
<a name="ln213">char_u *reverse_text(char_u *s) FUNC_ATTR_NONNULL_RET</a>
<a name="ln214">{</a>
<a name="ln215">  /*</a>
<a name="ln216">   * Reverse the pattern.</a>
<a name="ln217">   */</a>
<a name="ln218">  size_t len = STRLEN(s);</a>
<a name="ln219">  char_u *rev = xmalloc(len + 1);</a>
<a name="ln220">  size_t rev_i = len;</a>
<a name="ln221">  for (size_t s_i = 0; s_i &lt; len; s_i++) {</a>
<a name="ln222">    const int mb_len = utfc_ptr2len(s + s_i);</a>
<a name="ln223">    rev_i -= mb_len;</a>
<a name="ln224">    memmove(rev + rev_i, s + s_i, mb_len);</a>
<a name="ln225">    s_i += mb_len - 1;</a>
<a name="ln226">  }</a>
<a name="ln227">  rev[len] = NUL;</a>
<a name="ln228"> </a>
<a name="ln229">  return rev;</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">void save_re_pat(int idx, char_u *pat, int magic)</a>
<a name="ln233">{</a>
<a name="ln234">  if (spats[idx].pat != pat) {</a>
<a name="ln235">    free_spat(&amp;spats[idx]);</a>
<a name="ln236">    spats[idx].pat = vim_strsave(pat);</a>
<a name="ln237">    spats[idx].magic = magic;</a>
<a name="ln238">    spats[idx].no_scs = no_smartcase;</a>
<a name="ln239">    spats[idx].timestamp = os_time();</a>
<a name="ln240">    spats[idx].additional_data = NULL;</a>
<a name="ln241">    last_idx = idx;</a>
<a name="ln242">    /* If 'hlsearch' set and search pat changed: need redraw. */</a>
<a name="ln243">    if (p_hls)</a>
<a name="ln244">      redraw_all_later(SOME_VALID);</a>
<a name="ln245">    set_no_hlsearch(false);</a>
<a name="ln246">  }</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">/*</a>
<a name="ln250"> * Save the search patterns, so they can be restored later.</a>
<a name="ln251"> * Used before/after executing autocommands and user functions.</a>
<a name="ln252"> */</a>
<a name="ln253">static int save_level = 0;</a>
<a name="ln254"> </a>
<a name="ln255">void save_search_patterns(void)</a>
<a name="ln256">{</a>
<a name="ln257">  if (save_level++ == 0) {</a>
<a name="ln258">    saved_spats[0] = spats[0];</a>
<a name="ln259">    if (spats[0].pat != NULL)</a>
<a name="ln260">      saved_spats[0].pat = vim_strsave(spats[0].pat);</a>
<a name="ln261">    saved_spats[1] = spats[1];</a>
<a name="ln262">    if (spats[1].pat != NULL)</a>
<a name="ln263">      saved_spats[1].pat = vim_strsave(spats[1].pat);</a>
<a name="ln264">    saved_spats_last_idx = last_idx;</a>
<a name="ln265">    saved_spats_no_hlsearch = no_hlsearch;</a>
<a name="ln266">  }</a>
<a name="ln267">}</a>
<a name="ln268"> </a>
<a name="ln269">void restore_search_patterns(void)</a>
<a name="ln270">{</a>
<a name="ln271">  if (--save_level == 0) {</a>
<a name="ln272">    free_spat(&amp;spats[0]);</a>
<a name="ln273">    spats[0] = saved_spats[0];</a>
<a name="ln274">    set_vv_searchforward();</a>
<a name="ln275">    free_spat(&amp;spats[1]);</a>
<a name="ln276">    spats[1] = saved_spats[1];</a>
<a name="ln277">    last_idx = saved_spats_last_idx;</a>
<a name="ln278">    set_no_hlsearch(saved_spats_no_hlsearch);</a>
<a name="ln279">  }</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">static inline void free_spat(struct spat *const spat)</a>
<a name="ln283">{</a>
<a name="ln284">  xfree(spat-&gt;pat);</a>
<a name="ln285">  tv_dict_unref(spat-&gt;additional_data);</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">#if defined(EXITFREE)</a>
<a name="ln289">void free_search_patterns(void)</a>
<a name="ln290">{</a>
<a name="ln291">  free_spat(&amp;spats[0]);</a>
<a name="ln292">  free_spat(&amp;spats[1]);</a>
<a name="ln293"> </a>
<a name="ln294">  memset(spats, 0, sizeof(spats));</a>
<a name="ln295"> </a>
<a name="ln296">  if (mr_pattern_alloced) {</a>
<a name="ln297">    xfree(mr_pattern);</a>
<a name="ln298">    mr_pattern_alloced = FALSE;</a>
<a name="ln299">    mr_pattern = NULL;</a>
<a name="ln300">  }</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303">#endif</a>
<a name="ln304"> </a>
<a name="ln305">// copy of spats[RE_SEARCH], for keeping the search patterns while incremental</a>
<a name="ln306">// searching</a>
<a name="ln307">static struct spat saved_last_search_spat;</a>
<a name="ln308">static int did_save_last_search_spat = 0;</a>
<a name="ln309">static int saved_last_idx = 0;</a>
<a name="ln310">static bool saved_no_hlsearch = false;</a>
<a name="ln311"> </a>
<a name="ln312">/// Save and restore the search pattern for incremental highlight search</a>
<a name="ln313">/// feature.</a>
<a name="ln314">///</a>
<a name="ln315">/// It's similar to but different from save_search_patterns() and</a>
<a name="ln316">/// restore_search_patterns(), because the search pattern must be restored when</a>
<a name="ln317">/// cancelling incremental searching even if it's called inside user functions.</a>
<a name="ln318">void save_last_search_pattern(void)</a>
<a name="ln319">{</a>
<a name="ln320">  if (++did_save_last_search_spat != 1) {</a>
<a name="ln321">    // nested call, nothing to do</a>
<a name="ln322">    return;</a>
<a name="ln323">  }</a>
<a name="ln324"> </a>
<a name="ln325">  saved_last_search_spat = spats[RE_SEARCH];</a>
<a name="ln326">  if (spats[RE_SEARCH].pat != NULL) {</a>
<a name="ln327">    saved_last_search_spat.pat = vim_strsave(spats[RE_SEARCH].pat);</a>
<a name="ln328">  }</a>
<a name="ln329">  saved_last_idx = last_idx;</a>
<a name="ln330">  saved_no_hlsearch = no_hlsearch;</a>
<a name="ln331">}</a>
<a name="ln332"> </a>
<a name="ln333">void restore_last_search_pattern(void)</a>
<a name="ln334">{</a>
<a name="ln335">  if (--did_save_last_search_spat &gt; 0) {</a>
<a name="ln336">    // nested call, nothing to do</a>
<a name="ln337">    return;</a>
<a name="ln338">  }</a>
<a name="ln339">  if (did_save_last_search_spat != 0) {</a>
<a name="ln340">    iemsg(&quot;restore_last_search_pattern() called more often than&quot;</a>
<a name="ln341">          &quot; save_last_search_pattern()&quot;);</a>
<a name="ln342">    return;</a>
<a name="ln343">  }</a>
<a name="ln344"> </a>
<a name="ln345">  xfree(spats[RE_SEARCH].pat);</a>
<a name="ln346">  spats[RE_SEARCH] = saved_last_search_spat;</a>
<a name="ln347">  saved_last_search_spat.pat = NULL;</a>
<a name="ln348">  set_vv_searchforward();</a>
<a name="ln349">  last_idx = saved_last_idx;</a>
<a name="ln350">  set_no_hlsearch(saved_no_hlsearch);</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">char_u *last_search_pattern(void)</a>
<a name="ln354">{</a>
<a name="ln355">  return spats[RE_SEARCH].pat;</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">/*</a>
<a name="ln359"> * Return TRUE when case should be ignored for search pattern &quot;pat&quot;.</a>
<a name="ln360"> * Uses the 'ignorecase' and 'smartcase' options.</a>
<a name="ln361"> */</a>
<a name="ln362">int ignorecase(char_u *pat)</a>
<a name="ln363">{</a>
<a name="ln364">  return ignorecase_opt(pat, p_ic, p_scs);</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">/// As ignorecase() put pass the &quot;ic&quot; and &quot;scs&quot; flags.</a>
<a name="ln368">int ignorecase_opt(char_u *pat, int ic_in, int scs)</a>
<a name="ln369">{</a>
<a name="ln370">  int ic = ic_in;</a>
<a name="ln371">  if (ic &amp;&amp; !no_smartcase &amp;&amp; scs</a>
<a name="ln372">      &amp;&amp; !(ctrl_x_mode_not_default() &amp;&amp; curbuf-&gt;b_p_inf)</a>
<a name="ln373">      ) {</a>
<a name="ln374">    ic = !pat_has_uppercase(pat);</a>
<a name="ln375">  }</a>
<a name="ln376">  no_smartcase = false;</a>
<a name="ln377"> </a>
<a name="ln378">  return ic;</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381">/// Returns true if pattern `pat` has an uppercase character.</a>
<a name="ln382">bool pat_has_uppercase(char_u *pat)</a>
<a name="ln383">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln384">{</a>
<a name="ln385">  char_u *p = pat;</a>
<a name="ln386"> </a>
<a name="ln387">  while (*p != NUL) {</a>
<a name="ln388">    const int l = mb_ptr2len(p);</a>
<a name="ln389"> </a>
<a name="ln390">    if (l &gt; 1) {</a>
<a name="ln391">      if (mb_isupper(utf_ptr2char(p))) {</a>
<a name="ln392">        return true;</a>
<a name="ln393">      }</a>
<a name="ln394">      p += l;</a>
<a name="ln395">    } else if (*p == '\\') {</a>
<a name="ln396">      if (p[1] == '_' &amp;&amp; p[2] != NUL) {  // skip &quot;\_X&quot;</a>
<a name="ln397">        p += 3;</a>
<a name="ln398">      } else if (p[1] == '%' &amp;&amp; p[2] != NUL) {  // skip &quot;\%X&quot;</a>
<a name="ln399">        p += 3;</a>
<a name="ln400">      } else if (p[1] != NUL) {  // skip &quot;\X&quot;</a>
<a name="ln401">        p += 2;</a>
<a name="ln402">      } else {</a>
<a name="ln403">        p += 1;</a>
<a name="ln404">      }</a>
<a name="ln405">    } else if (mb_isupper(*p)) {</a>
<a name="ln406">      return true;</a>
<a name="ln407">    } else {</a>
<a name="ln408">      p++;</a>
<a name="ln409">    }</a>
<a name="ln410">  }</a>
<a name="ln411">  return false;</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414">const char *last_csearch(void)</a>
<a name="ln415">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln416">{</a>
<a name="ln417">  return (const char *)lastc_bytes;</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">int last_csearch_forward(void)</a>
<a name="ln421">{</a>
<a name="ln422">  return lastcdir == FORWARD;</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425">int last_csearch_until(void)</a>
<a name="ln426">{</a>
<a name="ln427">  return last_t_cmd == TRUE;</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430">void set_last_csearch(int c, char_u *s, int len)</a>
<a name="ln431">{</a>
<a name="ln432">  *lastc = c;</a>
<a name="ln433">  lastc_bytelen = len;</a>
<a name="ln434">  if (len)</a>
<a name="ln435">    memcpy(lastc_bytes, s, len);</a>
<a name="ln436">  else</a>
<a name="ln437">    memset(lastc_bytes, 0, sizeof(lastc_bytes));</a>
<a name="ln438">}</a>
<a name="ln439"> </a>
<a name="ln440">void set_csearch_direction(Direction cdir)</a>
<a name="ln441">{</a>
<a name="ln442">  lastcdir = cdir;</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">void set_csearch_until(int t_cmd)</a>
<a name="ln446">{</a>
<a name="ln447">  last_t_cmd = t_cmd;</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450">char_u *last_search_pat(void)</a>
<a name="ln451">{</a>
<a name="ln452">  return spats[last_idx].pat;</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">/*</a>
<a name="ln456"> * Reset search direction to forward.  For &quot;gd&quot; and &quot;gD&quot; commands.</a>
<a name="ln457"> */</a>
<a name="ln458">void reset_search_dir(void)</a>
<a name="ln459">{</a>
<a name="ln460">  spats[0].off.dir = '/';</a>
<a name="ln461">  set_vv_searchforward();</a>
<a name="ln462">}</a>
<a name="ln463"> </a>
<a name="ln464">/*</a>
<a name="ln465"> * Set the last search pattern.  For &quot;:let @/ =&quot; and ShaDa file.</a>
<a name="ln466"> * Also set the saved search pattern, so that this works in an autocommand.</a>
<a name="ln467"> */</a>
<a name="ln468">void set_last_search_pat(const char_u *s, int idx, int magic, int setlast)</a>
<a name="ln469">{</a>
<a name="ln470">  free_spat(&amp;spats[idx]);</a>
<a name="ln471">  /* An empty string means that nothing should be matched. */</a>
<a name="ln472">  if (*s == NUL)</a>
<a name="ln473">    spats[idx].pat = NULL;</a>
<a name="ln474">  else</a>
<a name="ln475">    spats[idx].pat = (char_u *) xstrdup((char *) s);</a>
<a name="ln476">  spats[idx].timestamp = os_time();</a>
<a name="ln477">  spats[idx].additional_data = NULL;</a>
<a name="ln478">  spats[idx].magic = magic;</a>
<a name="ln479">  spats[idx].no_scs = FALSE;</a>
<a name="ln480">  spats[idx].off.dir = '/';</a>
<a name="ln481">  set_vv_searchforward();</a>
<a name="ln482">  spats[idx].off.line = FALSE;</a>
<a name="ln483">  spats[idx].off.end = FALSE;</a>
<a name="ln484">  spats[idx].off.off = 0;</a>
<a name="ln485">  if (setlast)</a>
<a name="ln486">    last_idx = idx;</a>
<a name="ln487">  if (save_level) {</a>
<a name="ln488">    free_spat(&amp;saved_spats[idx]);</a>
<a name="ln489">    saved_spats[idx] = spats[0];</a>
<a name="ln490">    if (spats[idx].pat == NULL)</a>
<a name="ln491">      saved_spats[idx].pat = NULL;</a>
<a name="ln492">    else</a>
<a name="ln493">      saved_spats[idx].pat = vim_strsave(spats[idx].pat);</a>
<a name="ln494">    saved_spats_last_idx = last_idx;</a>
<a name="ln495">  }</a>
<a name="ln496">  /* If 'hlsearch' set and search pat changed: need redraw. */</a>
<a name="ln497">  if (p_hls &amp;&amp; idx == last_idx &amp;&amp; !no_hlsearch)</a>
<a name="ln498">    redraw_all_later(SOME_VALID);</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">/*</a>
<a name="ln502"> * Get a regexp program for the last used search pattern.</a>
<a name="ln503"> * This is used for highlighting all matches in a window.</a>
<a name="ln504"> * Values returned in regmatch-&gt;regprog and regmatch-&gt;rmm_ic.</a>
<a name="ln505"> */</a>
<a name="ln506">void last_pat_prog(regmmatch_T *regmatch)</a>
<a name="ln507">{</a>
<a name="ln508">  if (spats[last_idx].pat == NULL) {</a>
<a name="ln509">    regmatch-&gt;regprog = NULL;</a>
<a name="ln510">    return;</a>
<a name="ln511">  }</a>
<a name="ln512">  ++emsg_off;           /* So it doesn't beep if bad expr */</a>
<a name="ln513">  (void)search_regcomp((char_u *)&quot;&quot;, 0, last_idx, SEARCH_KEEP, regmatch);</a>
<a name="ln514">  --emsg_off;</a>
<a name="ln515">}</a>
<a name="ln516"> </a>
<a name="ln517">/// lowest level search function.</a>
<a name="ln518">/// Search for 'count'th occurrence of pattern &quot;pat&quot; in direction &quot;dir&quot;.</a>
<a name="ln519">/// Start at position &quot;pos&quot; and return the found position in &quot;pos&quot;.</a>
<a name="ln520">///</a>
<a name="ln521">/// if (options &amp; SEARCH_MSG) == 0 don't give any messages</a>
<a name="ln522">/// if (options &amp; SEARCH_MSG) == SEARCH_NFMSG don't give 'notfound' messages</a>
<a name="ln523">/// if (options &amp; SEARCH_MSG) == SEARCH_MSG give all messages</a>
<a name="ln524">/// if (options &amp; SEARCH_HIS) put search pattern in history</a>
<a name="ln525">/// if (options &amp; SEARCH_END) return position at end of match</a>
<a name="ln526">/// if (options &amp; SEARCH_START) accept match at pos itself</a>
<a name="ln527">/// if (options &amp; SEARCH_KEEP) keep previous search pattern</a>
<a name="ln528">/// if (options &amp; SEARCH_FOLD) match only once in a closed fold</a>
<a name="ln529">/// if (options &amp; SEARCH_PEEK) check for typed char, cancel search</a>
<a name="ln530">/// if (options &amp; SEARCH_COL) start at pos-&gt;col instead of zero</a>
<a name="ln531">///</a>
<a name="ln532">/// @returns FAIL (zero) for failure, non-zero for success.</a>
<a name="ln533">///          the index of the first matching</a>
<a name="ln534">///          subpattern plus one; one if there was none.</a>
<a name="ln535">int searchit(</a>
<a name="ln536">    win_T       *win,          // window to search in; can be NULL for a</a>
<a name="ln537">                               // buffer without a window!</a>
<a name="ln538">    buf_T       *buf,</a>
<a name="ln539">    pos_T       *pos,</a>
<a name="ln540">    pos_T       *end_pos,      // set to end of the match, unless NULL</a>
<a name="ln541">    Direction dir,</a>
<a name="ln542">    char_u      *pat,</a>
<a name="ln543">    long count,</a>
<a name="ln544">    int options,</a>
<a name="ln545">    int pat_use,               // which pattern to use when &quot;pat&quot; is empty</a>
<a name="ln546">    searchit_arg_T *extra_arg  // optional extra arguments, can be NULL</a>
<a name="ln547">)</a>
<a name="ln548">{</a>
<a name="ln549">  int found;</a>
<a name="ln550">  linenr_T lnum;                /* no init to shut up Apollo cc */</a>
<a name="ln551">  regmmatch_T regmatch;</a>
<a name="ln552">  char_u      *ptr;</a>
<a name="ln553">  colnr_T matchcol;</a>
<a name="ln554">  lpos_T endpos;</a>
<a name="ln555">  lpos_T matchpos;</a>
<a name="ln556">  int loop;</a>
<a name="ln557">  pos_T start_pos;</a>
<a name="ln558">  int at_first_line;</a>
<a name="ln559">  int extra_col;</a>
<a name="ln560">  int start_char_len;</a>
<a name="ln561">  int match_ok;</a>
<a name="ln562">  long nmatched;</a>
<a name="ln563">  int submatch = 0;</a>
<a name="ln564">  bool first_match = true;</a>
<a name="ln565">  int save_called_emsg = called_emsg;</a>
<a name="ln566">  int break_loop = false;</a>
<a name="ln567">  linenr_T stop_lnum = 0;  // stop after this line number when != 0</a>
<a name="ln568">  proftime_T *tm = NULL;   // timeout limit or NULL</a>
<a name="ln569">  int *timed_out = NULL;   // set when timed out or NULL</a>
<a name="ln570"> </a>
<a name="ln571">  if (extra_arg != NULL) {</a>
<a name="ln572">      stop_lnum = extra_arg-&gt;sa_stop_lnum;</a>
<a name="ln573">      tm = extra_arg-&gt;sa_tm;</a>
<a name="ln574">      timed_out = &amp;extra_arg-&gt;sa_timed_out;</a>
<a name="ln575">  }</a>
<a name="ln576"> </a>
<a name="ln577">  if (search_regcomp(pat, RE_SEARCH, pat_use,</a>
<a name="ln578">          (options &amp; (SEARCH_HIS + SEARCH_KEEP)), &amp;regmatch) == FAIL) {</a>
<a name="ln579">    if ((options &amp; SEARCH_MSG) &amp;&amp; !rc_did_emsg)</a>
<a name="ln580">      EMSG2(_(&quot;E383: Invalid search string: %s&quot;), mr_pattern);</a>
<a name="ln581">    return FAIL;</a>
<a name="ln582">  }</a>
<a name="ln583"> </a>
<a name="ln584">  /*</a>
<a name="ln585">   * find the string</a>
<a name="ln586">   */</a>
<a name="ln587">  called_emsg = FALSE;</a>
<a name="ln588">  do {  /* loop for count */</a>
<a name="ln589">    // When not accepting a match at the start position set &quot;extra_col&quot; to a</a>
<a name="ln590">    // non-zero value.  Don't do that when starting at MAXCOL, since MAXCOL + 1</a>
<a name="ln591">    // is zero.</a>
<a name="ln592">    if (pos-&gt;col == MAXCOL) {</a>
<a name="ln593">      start_char_len = 0;</a>
<a name="ln594">    } else if (pos-&gt;lnum &gt;= 1</a>
<a name="ln595">               &amp;&amp; pos-&gt;lnum &lt;= buf-&gt;b_ml.ml_line_count</a>
<a name="ln596">               &amp;&amp; pos-&gt;col &lt; MAXCOL - 2) {</a>
<a name="ln597">      // Watch out for the &quot;col&quot; being MAXCOL - 2, used in a closed fold.</a>
<a name="ln598">      ptr = ml_get_buf(buf, pos-&gt;lnum, false);</a>
<a name="ln599">      if ((int)STRLEN(ptr) &lt;= pos-&gt;col) {</a>
<a name="ln600">        start_char_len = 1;</a>
<a name="ln601">      } else {</a>
<a name="ln602">        start_char_len = utfc_ptr2len(ptr + pos-&gt;col);</a>
<a name="ln603">      }</a>
<a name="ln604">    } else {</a>
<a name="ln605">      start_char_len = 1;</a>
<a name="ln606">    }</a>
<a name="ln607">    if (dir == FORWARD) {</a>
<a name="ln608">      extra_col = (options &amp; SEARCH_START) ? 0 : start_char_len;</a>
<a name="ln609">    } else {</a>
<a name="ln610">      extra_col = (options &amp; SEARCH_START) ? start_char_len : 0;</a>
<a name="ln611">    }</a>
<a name="ln612"> </a>
<a name="ln613">    start_pos = *pos;           /* remember start pos for detecting no match */</a>
<a name="ln614">    found = 0;                  /* default: not found */</a>
<a name="ln615">    at_first_line = TRUE;       /* default: start in first line */</a>
<a name="ln616">    if (pos-&gt;lnum == 0) {       /* correct lnum for when starting in line 0 */</a>
<a name="ln617">      pos-&gt;lnum = 1;</a>
<a name="ln618">      pos-&gt;col = 0;</a>
<a name="ln619">      at_first_line = FALSE;        /* not in first line now */</a>
<a name="ln620">    }</a>
<a name="ln621"> </a>
<a name="ln622">    /*</a>
<a name="ln623">     * Start searching in current line, unless searching backwards and</a>
<a name="ln624">     * we're in column 0.</a>
<a name="ln625">     * If we are searching backwards, in column 0, and not including the</a>
<a name="ln626">     * current position, gain some efficiency by skipping back a line.</a>
<a name="ln627">     * Otherwise begin the search in the current line.</a>
<a name="ln628">     */</a>
<a name="ln629">    if (dir == BACKWARD &amp;&amp; start_pos.col == 0</a>
<a name="ln630">        &amp;&amp; (options &amp; SEARCH_START) == 0) {</a>
<a name="ln631">      lnum = pos-&gt;lnum - 1;</a>
<a name="ln632">      at_first_line = FALSE;</a>
<a name="ln633">    } else</a>
<a name="ln634">      lnum = pos-&gt;lnum;</a>
<a name="ln635"> </a>
<a name="ln636">    for (loop = 0; loop &lt;= 1; ++loop) {     /* loop twice if 'wrapscan' set */</a>
<a name="ln637">      for (; lnum &gt; 0 &amp;&amp; lnum &lt;= buf-&gt;b_ml.ml_line_count;</a>
<a name="ln638">           lnum += dir, at_first_line = FALSE) {</a>
<a name="ln639">        /* Stop after checking &quot;stop_lnum&quot;, if it's set. */</a>
<a name="ln640">        if (stop_lnum != 0 &amp;&amp; (dir == FORWARD</a>
<a name="ln641">                               ? lnum &gt; stop_lnum : lnum &lt; stop_lnum))</a>
<a name="ln642">          break;</a>
<a name="ln643">        /* Stop after passing the &quot;tm&quot; time limit. */</a>
<a name="ln644">        if (tm != NULL &amp;&amp; profile_passed_limit(*tm))</a>
<a name="ln645">          break;</a>
<a name="ln646"> </a>
<a name="ln647">        // Look for a match somewhere in line &quot;lnum&quot;.</a>
<a name="ln648">        colnr_T col = at_first_line &amp;&amp; (options &amp; SEARCH_COL) ? pos-&gt;col : 0;</a>
<a name="ln649">        nmatched = vim_regexec_multi(&amp;regmatch, win, buf,</a>
<a name="ln650">                                     lnum, col, tm, timed_out);</a>
<a name="ln651">        // vim_regexec_multi() may clear &quot;regprog&quot;</a>
<a name="ln652">        if (regmatch.regprog == NULL) {</a>
<a name="ln653">          break;</a>
<a name="ln654">        }</a>
<a name="ln655">        // Abort searching on an error (e.g., out of stack).</a>
<a name="ln656">        if (called_emsg || (timed_out != NULL &amp;&amp; *timed_out)) {</a>
<a name="ln657">          break;</a>
<a name="ln658">        }</a>
<a name="ln659">        if (nmatched &gt; 0) {</a>
<a name="ln660">          /* match may actually be in another line when using \zs */</a>
<a name="ln661">          matchpos = regmatch.startpos[0];</a>
<a name="ln662">          endpos = regmatch.endpos[0];</a>
<a name="ln663">          submatch = first_submatch(&amp;regmatch);</a>
<a name="ln664">          /* &quot;lnum&quot; may be past end of buffer for &quot;\n\zs&quot;. */</a>
<a name="ln665">          if (lnum + matchpos.lnum &gt; buf-&gt;b_ml.ml_line_count)</a>
<a name="ln666">            ptr = (char_u *)&quot;&quot;;</a>
<a name="ln667">          else</a>
<a name="ln668">            ptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);</a>
<a name="ln669"> </a>
<a name="ln670">          /*</a>
<a name="ln671">           * Forward search in the first line: match should be after</a>
<a name="ln672">           * the start position. If not, continue at the end of the</a>
<a name="ln673">           * match (this is vi compatible) or on the next char.</a>
<a name="ln674">           */</a>
<a name="ln675">          if (dir == FORWARD &amp;&amp; at_first_line) {</a>
<a name="ln676">            match_ok = TRUE;</a>
<a name="ln677">            /*</a>
<a name="ln678">             * When the match starts in a next line it's certainly</a>
<a name="ln679">             * past the start position.</a>
<a name="ln680">             * When match lands on a NUL the cursor will be put</a>
<a name="ln681">             * one back afterwards, compare with that position,</a>
<a name="ln682">             * otherwise &quot;/$&quot; will get stuck on end of line.</a>
<a name="ln683">             */</a>
<a name="ln684">            while (matchpos.lnum == 0</a>
<a name="ln685">                   &amp;&amp; (((options &amp; SEARCH_END) &amp;&amp; first_match)</a>
<a name="ln686">                       ?  (nmatched == 1</a>
<a name="ln687">                           &amp;&amp; (int)endpos.col - 1</a>
<a name="ln688">                           &lt; (int)start_pos.col + extra_col)</a>
<a name="ln689">                       : ((int)matchpos.col</a>
<a name="ln690">                          - (ptr[matchpos.col] == NUL)</a>
<a name="ln691">                          &lt; (int)start_pos.col + extra_col))) {</a>
<a name="ln692">              /*</a>
<a name="ln693">               * If vi-compatible searching, continue at the end</a>
<a name="ln694">               * of the match, otherwise continue one position</a>
<a name="ln695">               * forward.</a>
<a name="ln696">               */</a>
<a name="ln697">              if (vim_strchr(p_cpo, CPO_SEARCH) != NULL) {</a>
<a name="ln698">                if (nmatched &gt; 1) {</a>
<a name="ln699">                  /* end is in next line, thus no match in</a>
<a name="ln700">                   * this line */</a>
<a name="ln701">                  match_ok = FALSE;</a>
<a name="ln702">                  break;</a>
<a name="ln703">                }</a>
<a name="ln704">                matchcol = endpos.col;</a>
<a name="ln705">                // for empty match (matchcol == matchpos.col): advance one char</a>
<a name="ln706">              } else {</a>
<a name="ln707">                // Prepare to start after first matched character.</a>
<a name="ln708">                matchcol = matchpos.col;</a>
<a name="ln709">              }</a>
<a name="ln710"> </a>
<a name="ln711">              if (matchcol == matchpos.col &amp;&amp; ptr[matchcol] != NUL) {</a>
<a name="ln712">                matchcol += utfc_ptr2len(ptr + matchcol);</a>
<a name="ln713">              }</a>
<a name="ln714"> </a>
<a name="ln715">              if (matchcol == 0 &amp;&amp; (options &amp; SEARCH_START)) {</a>
<a name="ln716">                break;</a>
<a name="ln717">              }</a>
<a name="ln718"> </a>
<a name="ln719">              if (ptr[matchcol] == NUL</a>
<a name="ln720">                  || (nmatched = vim_regexec_multi(&amp;regmatch, win, buf,</a>
<a name="ln721">                                                   lnum, matchcol, tm,</a>
<a name="ln722">                                                   timed_out)) == 0) {</a>
<a name="ln723">                match_ok = false;</a>
<a name="ln724">                break;</a>
<a name="ln725">              }</a>
<a name="ln726">              // vim_regexec_multi() may clear &quot;regprog&quot;</a>
<a name="ln727">              if (regmatch.regprog == NULL) {</a>
<a name="ln728">                break;</a>
<a name="ln729">              }</a>
<a name="ln730">              matchpos = regmatch.startpos[0];</a>
<a name="ln731">              endpos = regmatch.endpos[0];</a>
<a name="ln732">              submatch = first_submatch(&amp;regmatch);</a>
<a name="ln733"> </a>
<a name="ln734">              // This while-loop only works with matchpos.lnum == 0.</a>
<a name="ln735">              // For bigger values the next line pointer ptr might not be a</a>
<a name="ln736">              // buffer line.</a>
<a name="ln737">              if (matchpos.lnum != 0) {</a>
<a name="ln738">                break;</a>
<a name="ln739">              }</a>
<a name="ln740">              // Need to get the line pointer again, a multi-line search may</a>
<a name="ln741">              // have made it invalid.</a>
<a name="ln742">              ptr = ml_get_buf(buf, lnum, false);</a>
<a name="ln743">            }</a>
<a name="ln744">            if (!match_ok)</a>
<a name="ln745">              continue;</a>
<a name="ln746">          }</a>
<a name="ln747">          if (dir == BACKWARD) {</a>
<a name="ln748">            /*</a>
<a name="ln749">             * Now, if there are multiple matches on this line,</a>
<a name="ln750">             * we have to get the last one. Or the last one before</a>
<a name="ln751">             * the cursor, if we're on that line.</a>
<a name="ln752">             * When putting the new cursor at the end, compare</a>
<a name="ln753">             * relative to the end of the match.</a>
<a name="ln754">             */</a>
<a name="ln755">            match_ok = FALSE;</a>
<a name="ln756">            for (;; ) {</a>
<a name="ln757">              /* Remember a position that is before the start</a>
<a name="ln758">               * position, we use it if it's the last match in</a>
<a name="ln759">               * the line.  Always accept a position after</a>
<a name="ln760">               * wrapping around. */</a>
<a name="ln761">              if (loop</a>
<a name="ln762">                  || ((options &amp; SEARCH_END)</a>
<a name="ln763">                      ? (lnum + regmatch.endpos[0].lnum</a>
<a name="ln764">                         &lt; start_pos.lnum</a>
<a name="ln765">                         || (lnum + regmatch.endpos[0].lnum</a>
<a name="ln766">                             == start_pos.lnum</a>
<a name="ln767">                             &amp;&amp; (int)regmatch.endpos[0].col - 1</a>
<a name="ln768">                             &lt; (int)start_pos.col + extra_col))</a>
<a name="ln769">                      : (lnum + regmatch.startpos[0].lnum</a>
<a name="ln770">                         &lt; start_pos.lnum</a>
<a name="ln771">                         || (lnum + regmatch.startpos[0].lnum</a>
<a name="ln772">                             == start_pos.lnum</a>
<a name="ln773">                             &amp;&amp; (int)regmatch.startpos[0].col</a>
<a name="ln774">                             &lt; (int)start_pos.col + extra_col)))) {</a>
<a name="ln775">                match_ok = true;</a>
<a name="ln776">                matchpos = regmatch.startpos[0];</a>
<a name="ln777">                endpos = regmatch.endpos[0];</a>
<a name="ln778">                submatch = first_submatch(&amp;regmatch);</a>
<a name="ln779">              } else</a>
<a name="ln780">                break;</a>
<a name="ln781"> </a>
<a name="ln782">              // We found a valid match, now check if there is</a>
<a name="ln783">              // another one after it.</a>
<a name="ln784">              // If vi-compatible searching, continue at the end</a>
<a name="ln785">              // of the match, otherwise continue one position</a>
<a name="ln786">              // forward.</a>
<a name="ln787">              if (vim_strchr(p_cpo, CPO_SEARCH) != NULL) {</a>
<a name="ln788">                if (nmatched &gt; 1) {</a>
<a name="ln789">                  break;</a>
<a name="ln790">                }</a>
<a name="ln791">                matchcol = endpos.col;</a>
<a name="ln792">                // for empty match: advance one char</a>
<a name="ln793">                if (matchcol == matchpos.col</a>
<a name="ln794">                    &amp;&amp; ptr[matchcol] != NUL) {</a>
<a name="ln795">                  matchcol += mb_ptr2len(ptr + matchcol);</a>
<a name="ln796">                }</a>
<a name="ln797">              } else {</a>
<a name="ln798">                // Stop when the match is in a next line.</a>
<a name="ln799">                if (matchpos.lnum &gt; 0) {</a>
<a name="ln800">                  break;</a>
<a name="ln801">                }</a>
<a name="ln802">                matchcol = matchpos.col;</a>
<a name="ln803">                if (ptr[matchcol] != NUL) {</a>
<a name="ln804">                  matchcol += mb_ptr2len(ptr + matchcol);</a>
<a name="ln805">                }</a>
<a name="ln806">              }</a>
<a name="ln807">              if (ptr[matchcol] == NUL</a>
<a name="ln808">                  || (nmatched = vim_regexec_multi(</a>
<a name="ln809">                      &amp;regmatch, win, buf, lnum + matchpos.lnum, matchcol,</a>
<a name="ln810">                      tm, timed_out)) == 0) {</a>
<a name="ln811">                  // If the search timed out, we did find a match</a>
<a name="ln812">                  // but it might be the wrong one, so that's not</a>
<a name="ln813">                  // OK.</a>
<a name="ln814">                  if (tm != NULL &amp;&amp; profile_passed_limit(*tm)) {</a>
<a name="ln815">                      match_ok = false;</a>
<a name="ln816">                  }</a>
<a name="ln817">                  break;</a>
<a name="ln818">              }</a>
<a name="ln819">              // vim_regexec_multi() may clear &quot;regprog&quot;</a>
<a name="ln820">              if (regmatch.regprog == NULL) {</a>
<a name="ln821">                break;</a>
<a name="ln822">              }</a>
<a name="ln823">              // Need to get the line pointer again, a</a>
<a name="ln824">              // multi-line search may have made it invalid.</a>
<a name="ln825">              ptr = ml_get_buf(buf, lnum + matchpos.lnum, false);</a>
<a name="ln826">            }</a>
<a name="ln827"> </a>
<a name="ln828">            /*</a>
<a name="ln829">             * If there is only a match after the cursor, skip</a>
<a name="ln830">             * this match.</a>
<a name="ln831">             */</a>
<a name="ln832">            if (!match_ok)</a>
<a name="ln833">              continue;</a>
<a name="ln834">          }</a>
<a name="ln835"> </a>
<a name="ln836">          /* With the SEARCH_END option move to the last character</a>
<a name="ln837">           * of the match.  Don't do it for an empty match, end</a>
<a name="ln838">           * should be same as start then. */</a>
<a name="ln839">          if ((options &amp; SEARCH_END) &amp;&amp; !(options &amp; SEARCH_NOOF)</a>
<a name="ln840">              &amp;&amp; !(matchpos.lnum == endpos.lnum</a>
<a name="ln841">                   &amp;&amp; matchpos.col == endpos.col)) {</a>
<a name="ln842">            /* For a match in the first column, set the position</a>
<a name="ln843">             * on the NUL in the previous line. */</a>
<a name="ln844">            pos-&gt;lnum = lnum + endpos.lnum;</a>
<a name="ln845">            pos-&gt;col = endpos.col;</a>
<a name="ln846">            if (endpos.col == 0) {</a>
<a name="ln847">              if (pos-&gt;lnum &gt; 1) {              /* just in case */</a>
<a name="ln848">                --pos-&gt;lnum;</a>
<a name="ln849">                pos-&gt;col = (colnr_T)STRLEN(ml_get_buf(buf,</a>
<a name="ln850">                        pos-&gt;lnum, FALSE));</a>
<a name="ln851">              }</a>
<a name="ln852">            } else {</a>
<a name="ln853">              pos-&gt;col--;</a>
<a name="ln854">              if (pos-&gt;lnum &lt;= buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln855">                ptr = ml_get_buf(buf, pos-&gt;lnum, false);</a>
<a name="ln856">                pos-&gt;col -= utf_head_off(ptr, ptr + pos-&gt;col);</a>
<a name="ln857">              }</a>
<a name="ln858">            }</a>
<a name="ln859">            if (end_pos != NULL) {</a>
<a name="ln860">              end_pos-&gt;lnum = lnum + matchpos.lnum;</a>
<a name="ln861">              end_pos-&gt;col = matchpos.col;</a>
<a name="ln862">            }</a>
<a name="ln863">          } else {</a>
<a name="ln864">            pos-&gt;lnum = lnum + matchpos.lnum;</a>
<a name="ln865">            pos-&gt;col = matchpos.col;</a>
<a name="ln866">            if (end_pos != NULL) {</a>
<a name="ln867">              end_pos-&gt;lnum = lnum + endpos.lnum;</a>
<a name="ln868">              end_pos-&gt;col = endpos.col;</a>
<a name="ln869">            }</a>
<a name="ln870">          }</a>
<a name="ln871">          pos-&gt;coladd = 0;</a>
<a name="ln872">          if (end_pos != NULL) {</a>
<a name="ln873">            end_pos-&gt;coladd = 0;</a>
<a name="ln874">          }</a>
<a name="ln875">          found = 1;</a>
<a name="ln876">          first_match = false;</a>
<a name="ln877"> </a>
<a name="ln878">          /* Set variables used for 'incsearch' highlighting. */</a>
<a name="ln879">          search_match_lines = endpos.lnum - matchpos.lnum;</a>
<a name="ln880">          search_match_endcol = endpos.col;</a>
<a name="ln881">          break;</a>
<a name="ln882">        }</a>
<a name="ln883">        line_breakcheck();              /* stop if ctrl-C typed */</a>
<a name="ln884">        if (got_int)</a>
<a name="ln885">          break;</a>
<a name="ln886"> </a>
<a name="ln887">        /* Cancel searching if a character was typed.  Used for</a>
<a name="ln888">         * 'incsearch'.  Don't check too often, that would slowdown</a>
<a name="ln889">         * searching too much. */</a>
<a name="ln890">        if ((options &amp; SEARCH_PEEK)</a>
<a name="ln891">            &amp;&amp; ((lnum - pos-&gt;lnum) &amp; 0x3f) == 0</a>
<a name="ln892">            &amp;&amp; char_avail()) {</a>
<a name="ln893">          break_loop = TRUE;</a>
<a name="ln894">          break;</a>
<a name="ln895">        }</a>
<a name="ln896"> </a>
<a name="ln897">        if (loop &amp;&amp; lnum == start_pos.lnum)</a>
<a name="ln898">          break;                    /* if second loop, stop where started */</a>
<a name="ln899">      }</a>
<a name="ln900">      at_first_line = FALSE;</a>
<a name="ln901"> </a>
<a name="ln902">      // vim_regexec_multi() may clear &quot;regprog&quot;</a>
<a name="ln903">      if (regmatch.regprog == NULL) {</a>
<a name="ln904">        break;</a>
<a name="ln905">      }</a>
<a name="ln906"> </a>
<a name="ln907">      // Stop the search if wrapscan isn't set, &quot;stop_lnum&quot; is</a>
<a name="ln908">      // specified, after an interrupt, after a match and after looping</a>
<a name="ln909">      // twice.</a>
<a name="ln910">      if (!p_ws || stop_lnum != 0 || got_int || called_emsg</a>
<a name="ln911">          || (timed_out != NULL &amp;&amp; *timed_out)</a>
<a name="ln912">          || break_loop</a>
<a name="ln913">          || found || loop) {</a>
<a name="ln914">        break;</a>
<a name="ln915">      }</a>
<a name="ln916">      //</a>
<a name="ln917">      // If 'wrapscan' is set we continue at the other end of the file.</a>
<a name="ln918">      // If 'shortmess' does not contain 's', we give a message.</a>
<a name="ln919">      // This message is also remembered in keep_msg for when the screen</a>
<a name="ln920">      // is redrawn. The keep_msg is cleared whenever another message is</a>
<a name="ln921">      // written.</a>
<a name="ln922">      //</a>
<a name="ln923">      if (dir == BACKWARD) {        // start second loop at the other end</a>
<a name="ln924">        lnum = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln925">      } else {</a>
<a name="ln926">        lnum = 1;</a>
<a name="ln927">      }</a>
<a name="ln928">      if (!shortmess(SHM_SEARCH) &amp;&amp; (options &amp; SEARCH_MSG)) {</a>
<a name="ln929">        give_warning((char_u *)_(dir == BACKWARD</a>
<a name="ln930">                                 ? top_bot_msg : bot_top_msg), true);</a>
<a name="ln931">      }</a>
<a name="ln932">      if (extra_arg != NULL) {</a>
<a name="ln933">        extra_arg-&gt;sa_wrapped = true;</a>
<a name="ln934">      }</a>
<a name="ln935">    }</a>
<a name="ln936">    if (got_int || called_emsg</a>
<a name="ln937">        || (timed_out != NULL &amp;&amp; *timed_out)</a>
<a name="ln938">        || break_loop</a>
<a name="ln939">        ) {</a>
<a name="ln940">      break;</a>
<a name="ln941">    }</a>
<a name="ln942">  } while (--count &gt; 0 &amp;&amp; found);   // stop after count matches or no match</a>
<a name="ln943"> </a>
<a name="ln944">  vim_regfree(regmatch.regprog);</a>
<a name="ln945"> </a>
<a name="ln946">  called_emsg |= save_called_emsg;</a>
<a name="ln947"> </a>
<a name="ln948">  if (!found) {             /* did not find it */</a>
<a name="ln949">    if (got_int)</a>
<a name="ln950">      EMSG(_(e_interr));</a>
<a name="ln951">    else if ((options &amp; SEARCH_MSG) == SEARCH_MSG) {</a>
<a name="ln952">      if (p_ws)</a>
<a name="ln953">        EMSG2(_(e_patnotf2), mr_pattern);</a>
<a name="ln954">      else if (lnum == 0)</a>
<a name="ln955">        EMSG2(_(&quot;E384: search hit TOP without match for: %s&quot;),</a>
<a name="ln956">            mr_pattern);</a>
<a name="ln957">      else</a>
<a name="ln958">        EMSG2(_(&quot;E385: search hit BOTTOM without match for: %s&quot;),</a>
<a name="ln959">            mr_pattern);</a>
<a name="ln960">    }</a>
<a name="ln961">    return FAIL;</a>
<a name="ln962">  }</a>
<a name="ln963"> </a>
<a name="ln964">  /* A pattern like &quot;\n\zs&quot; may go past the last line. */</a>
<a name="ln965">  if (pos-&gt;lnum &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln966">    pos-&gt;lnum = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln967">    pos-&gt;col = (int)STRLEN(ml_get_buf(buf, pos-&gt;lnum, FALSE));</a>
<a name="ln968">    if (pos-&gt;col &gt; 0)</a>
<a name="ln969">      --pos-&gt;col;</a>
<a name="ln970">  }</a>
<a name="ln971"> </a>
<a name="ln972">  return submatch + 1;</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975">void set_search_direction(int cdir)</a>
<a name="ln976">{</a>
<a name="ln977">  spats[0].off.dir = cdir;</a>
<a name="ln978">}</a>
<a name="ln979"> </a>
<a name="ln980">static void set_vv_searchforward(void)</a>
<a name="ln981">{</a>
<a name="ln982">  set_vim_var_nr(VV_SEARCHFORWARD, (long)(spats[0].off.dir == '/'));</a>
<a name="ln983">}</a>
<a name="ln984"> </a>
<a name="ln985">// Return the number of the first subpat that matched.</a>
<a name="ln986">// Return zero if none of them matched.</a>
<a name="ln987">static int first_submatch(regmmatch_T *rp)</a>
<a name="ln988">{</a>
<a name="ln989">  int submatch;</a>
<a name="ln990"> </a>
<a name="ln991">  for (submatch = 1;; ++submatch) {</a>
<a name="ln992">    if (rp-&gt;startpos[submatch].lnum &gt;= 0)</a>
<a name="ln993">      break;</a>
<a name="ln994">    if (submatch == 9) {</a>
<a name="ln995">      submatch = 0;</a>
<a name="ln996">      break;</a>
<a name="ln997">    }</a>
<a name="ln998">  }</a>
<a name="ln999">  return submatch;</a>
<a name="ln1000">}</a>
<a name="ln1001"> </a>
<a name="ln1002">/*</a>
<a name="ln1003"> * Highest level string search function.</a>
<a name="ln1004"> * Search for the 'count'th occurrence of pattern 'pat' in direction 'dirc'</a>
<a name="ln1005"> *		  If 'dirc' is 0: use previous dir.</a>
<a name="ln1006"> *    If 'pat' is NULL or empty : use previous string.</a>
<a name="ln1007"> *    If 'options &amp; SEARCH_REV' : go in reverse of previous dir.</a>
<a name="ln1008"> *    If 'options &amp; SEARCH_ECHO': echo the search command and handle options</a>
<a name="ln1009"> *    If 'options &amp; SEARCH_MSG' : may give error message</a>
<a name="ln1010"> *    If 'options &amp; SEARCH_OPT' : interpret optional flags</a>
<a name="ln1011"> *    If 'options &amp; SEARCH_HIS' : put search pattern in history</a>
<a name="ln1012"> *    If 'options &amp; SEARCH_NOOF': don't add offset to position</a>
<a name="ln1013"> *    If 'options &amp; SEARCH_MARK': set previous context mark</a>
<a name="ln1014"> *    If 'options &amp; SEARCH_KEEP': keep previous search pattern</a>
<a name="ln1015"> *    If 'options &amp; SEARCH_START': accept match at curpos itself</a>
<a name="ln1016"> *    If 'options &amp; SEARCH_PEEK': check for typed char, cancel search</a>
<a name="ln1017"> *</a>
<a name="ln1018"> * Careful: If spats[0].off.line == TRUE and spats[0].off.off == 0 this</a>
<a name="ln1019"> * makes the movement linewise without moving the match position.</a>
<a name="ln1020"> *</a>
<a name="ln1021"> * Return 0 for failure, 1 for found, 2 for found and line offset added.</a>
<a name="ln1022"> */</a>
<a name="ln1023">int do_search(</a>
<a name="ln1024">    oparg_T         *oap,           // can be NULL</a>
<a name="ln1025">    int dirc,                       // '/' or '?'</a>
<a name="ln1026">    int search_delim,  // delimiter for search, e.g. '%' in s%regex%replacement</a>
<a name="ln1027">    char_u          *pat,</a>
<a name="ln1028">    long count,</a>
<a name="ln1029">    int options,</a>
<a name="ln1030">    searchit_arg_T  *sia        // optional arguments or NULL</a>
<a name="ln1031">)</a>
<a name="ln1032">{</a>
<a name="ln1033">  pos_T pos;                    /* position of the last match */</a>
<a name="ln1034">  char_u          *searchstr;</a>
<a name="ln1035">  struct soffset old_off;</a>
<a name="ln1036">  int retval;                   /* Return value */</a>
<a name="ln1037">  char_u          *p;</a>
<a name="ln1038">  long c;</a>
<a name="ln1039">  char_u          *dircp;</a>
<a name="ln1040">  char_u          *strcopy = NULL;</a>
<a name="ln1041">  char_u          *ps;</a>
<a name="ln1042">  char_u          *msgbuf = NULL;</a>
<a name="ln1043">  size_t          len;</a>
<a name="ln1044">  bool            has_offset = false;</a>
<a name="ln1045">#define SEARCH_STAT_BUF_LEN 12</a>
<a name="ln1046"> </a>
<a name="ln1047">  /*</a>
<a name="ln1048">   * A line offset is not remembered, this is vi compatible.</a>
<a name="ln1049">   */</a>
<a name="ln1050">  if (spats[0].off.line &amp;&amp; vim_strchr(p_cpo, CPO_LINEOFF) != NULL) {</a>
<a name="ln1051">    spats[0].off.line = FALSE;</a>
<a name="ln1052">    spats[0].off.off = 0;</a>
<a name="ln1053">  }</a>
<a name="ln1054"> </a>
<a name="ln1055">  /*</a>
<a name="ln1056">   * Save the values for when (options &amp; SEARCH_KEEP) is used.</a>
<a name="ln1057">   * (there is no &quot;if ()&quot; around this because gcc wants them initialized)</a>
<a name="ln1058">   */</a>
<a name="ln1059">  old_off = spats[0].off;</a>
<a name="ln1060"> </a>
<a name="ln1061">  pos = curwin-&gt;w_cursor;       /* start searching at the cursor position */</a>
<a name="ln1062"> </a>
<a name="ln1063">  /*</a>
<a name="ln1064">   * Find out the direction of the search.</a>
<a name="ln1065">   */</a>
<a name="ln1066">  if (dirc == 0)</a>
<a name="ln1067">    dirc = spats[0].off.dir;</a>
<a name="ln1068">  else {</a>
<a name="ln1069">    spats[0].off.dir = dirc;</a>
<a name="ln1070">    set_vv_searchforward();</a>
<a name="ln1071">  }</a>
<a name="ln1072">  if (options &amp; SEARCH_REV) {</a>
<a name="ln1073">    if (dirc == '/')</a>
<a name="ln1074">      dirc = '?';</a>
<a name="ln1075">    else</a>
<a name="ln1076">      dirc = '/';</a>
<a name="ln1077">  }</a>
<a name="ln1078"> </a>
<a name="ln1079">  /* If the cursor is in a closed fold, don't find another match in the same</a>
<a name="ln1080">   * fold. */</a>
<a name="ln1081">  if (dirc == '/') {</a>
<a name="ln1082">    if (hasFolding(pos.lnum, NULL, &amp;pos.lnum))</a>
<a name="ln1083">      pos.col = MAXCOL - 2;             /* avoid overflow when adding 1 */</a>
<a name="ln1084">  } else {</a>
<a name="ln1085">    if (hasFolding(pos.lnum, &amp;pos.lnum, NULL))</a>
<a name="ln1086">      pos.col = 0;</a>
<a name="ln1087">  }</a>
<a name="ln1088"> </a>
<a name="ln1089">  /*</a>
<a name="ln1090">   * Turn 'hlsearch' highlighting back on.</a>
<a name="ln1091">   */</a>
<a name="ln1092">  if (no_hlsearch &amp;&amp; !(options &amp; SEARCH_KEEP)) {</a>
<a name="ln1093">    redraw_all_later(SOME_VALID);</a>
<a name="ln1094">    set_no_hlsearch(false);</a>
<a name="ln1095">  }</a>
<a name="ln1096"> </a>
<a name="ln1097">  /*</a>
<a name="ln1098">   * Repeat the search when pattern followed by ';', e.g. &quot;/foo/;?bar&quot;.</a>
<a name="ln1099">   */</a>
<a name="ln1100">  for (;; ) {</a>
<a name="ln1101">    bool show_top_bot_msg = false;</a>
<a name="ln1102"> </a>
<a name="ln1103">    searchstr = pat;</a>
<a name="ln1104">    dircp = NULL;</a>
<a name="ln1105">    // use previous pattern</a>
<a name="ln1106">    if (pat == NULL || *pat == NUL || *pat == search_delim) {</a>
<a name="ln1107">      if (spats[RE_SEARCH].pat == NULL) {           // no previous pattern</a>
<a name="ln1108">        searchstr = spats[RE_SUBST].pat;</a>
<a name="ln1109">        if (searchstr == NULL) {</a>
<a name="ln1110">          EMSG(_(e_noprevre));</a>
<a name="ln1111">          retval = 0;</a>
<a name="ln1112">          goto end_do_search;</a>
<a name="ln1113">        }</a>
<a name="ln1114">      } else {</a>
<a name="ln1115">        /* make search_regcomp() use spats[RE_SEARCH].pat */</a>
<a name="ln1116">        searchstr = (char_u *)&quot;&quot;;</a>
<a name="ln1117">      }</a>
<a name="ln1118">    }</a>
<a name="ln1119"> </a>
<a name="ln1120">    if (pat != NULL &amp;&amp; *pat != NUL) {   /* look for (new) offset */</a>
<a name="ln1121">      /*</a>
<a name="ln1122">       * Find end of regular expression.</a>
<a name="ln1123">       * If there is a matching '/' or '?', toss it.</a>
<a name="ln1124">       */</a>
<a name="ln1125">      ps = strcopy;</a>
<a name="ln1126">      p = skip_regexp(pat, search_delim, p_magic, &amp;strcopy);</a>
<a name="ln1127">      if (strcopy != ps) {</a>
<a name="ln1128">        /* made a copy of &quot;pat&quot; to change &quot;\?&quot; to &quot;?&quot; */</a>
<a name="ln1129">        searchcmdlen += (int)(STRLEN(pat) - STRLEN(strcopy));</a>
<a name="ln1130">        pat = strcopy;</a>
<a name="ln1131">        searchstr = strcopy;</a>
<a name="ln1132">      }</a>
<a name="ln1133">      if (*p == search_delim) {</a>
<a name="ln1134">        dircp = p;              // remember where we put the NUL</a>
<a name="ln1135">        *p++ = NUL;</a>
<a name="ln1136">      }</a>
<a name="ln1137">      spats[0].off.line = FALSE;</a>
<a name="ln1138">      spats[0].off.end = FALSE;</a>
<a name="ln1139">      spats[0].off.off = 0;</a>
<a name="ln1140">      // Check for a line offset or a character offset.</a>
<a name="ln1141">      // For get_address (echo off) we don't check for a character</a>
<a name="ln1142">      // offset, because it is meaningless and the 's' could be a</a>
<a name="ln1143">      // substitute command.</a>
<a name="ln1144">      if (*p == '+' || *p == '-' || ascii_isdigit(*p)) {</a>
<a name="ln1145">        spats[0].off.line = true;</a>
<a name="ln1146">      } else if ((options &amp; SEARCH_OPT)</a>
<a name="ln1147">                 &amp;&amp; (*p == 'e' || *p == 's' || *p == 'b')) {</a>
<a name="ln1148">        if (*p == 'e') {  // end</a>
<a name="ln1149">          spats[0].off.end = true;</a>
<a name="ln1150">        }</a>
<a name="ln1151">        p++;</a>
<a name="ln1152">      }</a>
<a name="ln1153">      if (ascii_isdigit(*p) || *p == '+' || *p == '-') {      /* got an offset */</a>
<a name="ln1154">        /* 'nr' or '+nr' or '-nr' */</a>
<a name="ln1155">        if (ascii_isdigit(*p) || ascii_isdigit(*(p + 1)))</a>
<a name="ln1156">          spats[0].off.off = atol((char *)p);</a>
<a name="ln1157">        else if (*p == '-')                 /* single '-' */</a>
<a name="ln1158">          spats[0].off.off = -1;</a>
<a name="ln1159">        else                                /* single '+' */</a>
<a name="ln1160">          spats[0].off.off = 1;</a>
<a name="ln1161">        ++p;</a>
<a name="ln1162">        while (ascii_isdigit(*p))           /* skip number */</a>
<a name="ln1163">          ++p;</a>
<a name="ln1164">      }</a>
<a name="ln1165"> </a>
<a name="ln1166">      /* compute length of search command for get_address() */</a>
<a name="ln1167">      searchcmdlen += (int)(p - pat);</a>
<a name="ln1168"> </a>
<a name="ln1169">      pat = p;                              /* put pat after search command */</a>
<a name="ln1170">    }</a>
<a name="ln1171"> </a>
<a name="ln1172">    if ((options &amp; SEARCH_ECHO) &amp;&amp; messaging() &amp;&amp; !msg_silent</a>
<a name="ln1173">        &amp;&amp; (!cmd_silent || !shortmess(SHM_SEARCHCOUNT))) {</a>
<a name="ln1174">      char_u      *trunc;</a>
<a name="ln1175">      char_u      off_buf[40];</a>
<a name="ln1176">      size_t      off_len = 0;</a>
<a name="ln1177"> </a>
<a name="ln1178">      // Compute msg_row early.</a>
<a name="ln1179">      msg_start();</a>
<a name="ln1180"> </a>
<a name="ln1181">      // Get the offset, so we know how long it is.</a>
<a name="ln1182">      if (!cmd_silent</a>
<a name="ln1183">          &amp;&amp; (spats[0].off.line || spats[0].off.end || spats[0].off.off)) {</a>
<a name="ln1184">        p = off_buf;  // -V507</a>
<a name="ln1185">        *p++ = dirc;</a>
<a name="ln1186">        if (spats[0].off.end) {</a>
<a name="ln1187">          *p++ = 'e';</a>
<a name="ln1188">        } else if (!spats[0].off.line) {</a>
<a name="ln1189">          *p++ = 's';</a>
<a name="ln1190">        }</a>
<a name="ln1191">        if (spats[0].off.off &gt; 0 || spats[0].off.line) {</a>
<a name="ln1192">          *p++ = '+';</a>
<a name="ln1193">        }</a>
<a name="ln1194">        *p = NUL;</a>
<a name="ln1195">        if (spats[0].off.off != 0 || spats[0].off.line) {</a>
<a name="ln1196">          snprintf((char *)p, sizeof(off_buf) - 1 - (p - off_buf),</a>
<a name="ln1197">                   &quot;%&quot; PRId64, spats[0].off.off);</a>
<a name="ln1198">        }</a>
<a name="ln1199">        off_len = STRLEN(off_buf);</a>
<a name="ln1200">      }</a>
<a name="ln1201"> </a>
<a name="ln1202">      if (*searchstr == NUL) {</a>
<a name="ln1203">        p = spats[0].pat;</a>
<a name="ln1204">      } else {</a>
<a name="ln1205">        p = searchstr;</a>
<a name="ln1206">      }</a>
<a name="ln1207"> </a>
<a name="ln1208">      if (!shortmess(SHM_SEARCHCOUNT) || cmd_silent) {</a>
<a name="ln1209">        // Reserve enough space for the search pattern + offset +</a>
<a name="ln1210">        // search stat.  Use all the space available, so that the</a>
<a name="ln1211">        // search state is right aligned.  If there is not enough space</a>
<a name="ln1212">        // msg_strtrunc() will shorten in the middle.</a>
<a name="ln1213">        if (ui_has(kUIMessages)) {</a>
<a name="ln1214">          len = 0;  // adjusted below</a>
<a name="ln1215">        } else if (msg_scrolled != 0 &amp;&amp; !cmd_silent) {</a>
<a name="ln1216">          // Use all the columns.</a>
<a name="ln1217">          len = (Rows - msg_row) * Columns - 1;</a>
<a name="ln1218">        } else {</a>
<a name="ln1219">          // Use up to 'showcmd' column.</a>
<a name="ln1220">          len = (Rows - msg_row - 1) * Columns + sc_col - 1;</a>
<a name="ln1221">        }</a>
<a name="ln1222">        if (len &lt; STRLEN(p) + off_len + SEARCH_STAT_BUF_LEN + 3) {</a>
<a name="ln1223">          len = STRLEN(p) + off_len + SEARCH_STAT_BUF_LEN + 3;</a>
<a name="ln1224">        }</a>
<a name="ln1225">      } else {</a>
<a name="ln1226">        // Reserve enough space for the search pattern + offset.</a>
<a name="ln1227">        len = STRLEN(p) + off_len + 3;</a>
<a name="ln1228">      }</a>
<a name="ln1229"> </a>
<a name="ln1230">      xfree(msgbuf);</a>
<a name="ln1231">      msgbuf = xmalloc(len);</a>
<a name="ln1232">      memset(msgbuf, ' ', len);</a>
<a name="ln1233">      msgbuf[len - 1] = NUL;</a>
<a name="ln1234"> </a>
<a name="ln1235">      // do not fill the msgbuf buffer, if cmd_silent is set, leave it</a>
<a name="ln1236">      // empty for the search_stat feature.</a>
<a name="ln1237">      if (!cmd_silent) {</a>
<a name="ln1238">        msgbuf[0] = dirc;</a>
<a name="ln1239">        if (utf_iscomposing(utf_ptr2char(p))) {</a>
<a name="ln1240">          // Use a space to draw the composing char on.</a>
<a name="ln1241">          msgbuf[1] = ' ';</a>
<a name="ln1242">          memmove(msgbuf + 2, p, STRLEN(p));</a>
<a name="ln1243">        } else {</a>
<a name="ln1244">          memmove(msgbuf + 1, p, STRLEN(p));</a>
<a name="ln1245">        }</a>
<a name="ln1246">        if (off_len &gt; 0) {</a>
<a name="ln1247">          memmove(msgbuf + STRLEN(p) + 1, off_buf, off_len);</a>
<a name="ln1248">        }</a>
<a name="ln1249"> </a>
<a name="ln1250">        trunc = msg_strtrunc(msgbuf, true);</a>
<a name="ln1251">        if (trunc != NULL) {</a>
<a name="ln1252">          xfree(msgbuf);</a>
<a name="ln1253">          msgbuf = trunc;</a>
<a name="ln1254">        }</a>
<a name="ln1255"> </a>
<a name="ln1256">        // The search pattern could be shown on the right in rightleft</a>
<a name="ln1257">        // mode, but the 'ruler' and 'showcmd' area use it too, thus</a>
<a name="ln1258">        // it would be blanked out again very soon.  Show it on the</a>
<a name="ln1259">        // left, but do reverse the text.</a>
<a name="ln1260">        if (curwin-&gt;w_p_rl &amp;&amp; *curwin-&gt;w_p_rlc == 's') {</a>
<a name="ln1261">          char_u *r = reverse_text(trunc != NULL ? trunc : msgbuf);</a>
<a name="ln1262">          xfree(msgbuf);</a>
<a name="ln1263">          msgbuf = r;</a>
<a name="ln1264">          // move reversed text to beginning of buffer</a>
<a name="ln1265">          while (*r == ' ') {</a>
<a name="ln1266">            r++;</a>
<a name="ln1267">          }</a>
<a name="ln1268">          size_t pat_len = msgbuf + STRLEN(msgbuf) - r;</a>
<a name="ln1269">          memmove(msgbuf, r, pat_len);</a>
<a name="ln1270">          // overwrite old text</a>
<a name="ln1271">          if ((size_t)(r - msgbuf) &gt;= pat_len) {</a>
<a name="ln1272">            memset(r, ' ', pat_len);</a>
<a name="ln1273">          } else {</a>
<a name="ln1274">            memset(msgbuf + pat_len, ' ', r - msgbuf);</a>
<a name="ln1275">          }</a>
<a name="ln1276">        }</a>
<a name="ln1277">        msg_outtrans(msgbuf);</a>
<a name="ln1278">        msg_clr_eos();</a>
<a name="ln1279">        msg_check();</a>
<a name="ln1280"> </a>
<a name="ln1281">        gotocmdline(false);</a>
<a name="ln1282">        ui_flush();</a>
<a name="ln1283">        msg_nowait = true;  // don't wait for this message</a>
<a name="ln1284">      }</a>
<a name="ln1285">    }</a>
<a name="ln1286"> </a>
<a name="ln1287">    /*</a>
<a name="ln1288">     * If there is a character offset, subtract it from the current</a>
<a name="ln1289">     * position, so we don't get stuck at &quot;?pat?e+2&quot; or &quot;/pat/s-2&quot;.</a>
<a name="ln1290">     * Skip this if pos.col is near MAXCOL (closed fold).</a>
<a name="ln1291">     * This is not done for a line offset, because then we would not be vi</a>
<a name="ln1292">     * compatible.</a>
<a name="ln1293">     */</a>
<a name="ln1294">    if (!spats[0].off.line &amp;&amp; spats[0].off.off &amp;&amp; pos.col &lt; MAXCOL - 2) {</a>
<a name="ln1295">      if (spats[0].off.off &gt; 0) {</a>
<a name="ln1296">        for (c = spats[0].off.off; c; --c)</a>
<a name="ln1297">          if (decl(&amp;pos) == -1)</a>
<a name="ln1298">            break;</a>
<a name="ln1299">        if (c) {                        /* at start of buffer */</a>
<a name="ln1300">          pos.lnum = 0;                 /* allow lnum == 0 here */</a>
<a name="ln1301">          pos.col = MAXCOL;</a>
<a name="ln1302">        }</a>
<a name="ln1303">      } else {</a>
<a name="ln1304">        for (c = spats[0].off.off; c; ++c)</a>
<a name="ln1305">          if (incl(&amp;pos) == -1)</a>
<a name="ln1306">            break;</a>
<a name="ln1307">        if (c) {                        /* at end of buffer */</a>
<a name="ln1308">          pos.lnum = curbuf-&gt;b_ml.ml_line_count + 1;</a>
<a name="ln1309">          pos.col = 0;</a>
<a name="ln1310">        }</a>
<a name="ln1311">      }</a>
<a name="ln1312">    }</a>
<a name="ln1313"> </a>
<a name="ln1314">    c = searchit(curwin, curbuf, &amp;pos, NULL, dirc == '/' ? FORWARD : BACKWARD,</a>
<a name="ln1315">                 searchstr, count,</a>
<a name="ln1316">                 (spats[0].off.end * SEARCH_END</a>
<a name="ln1317">                  + (options</a>
<a name="ln1318">                     &amp; (SEARCH_KEEP + SEARCH_PEEK + SEARCH_HIS + SEARCH_MSG</a>
<a name="ln1319">                        + SEARCH_START</a>
<a name="ln1320">                        + ((pat != NULL &amp;&amp; *pat == ';') ? 0 : SEARCH_NOOF)))),</a>
<a name="ln1321">                 RE_LAST, sia);</a>
<a name="ln1322"> </a>
<a name="ln1323">    if (dircp != NULL) {</a>
<a name="ln1324">      *dircp = search_delim;  // restore second '/' or '?' for normal_cmd()</a>
<a name="ln1325">    }</a>
<a name="ln1326"> </a>
<a name="ln1327">    if (!shortmess(SHM_SEARCH)</a>
<a name="ln1328">        &amp;&amp; ((dirc == '/' &amp;&amp; lt(pos, curwin-&gt;w_cursor))</a>
<a name="ln1329">            || (dirc == '?' &amp;&amp; lt(curwin-&gt;w_cursor, pos)))) {</a>
<a name="ln1330">      show_top_bot_msg = true;</a>
<a name="ln1331">    }</a>
<a name="ln1332"> </a>
<a name="ln1333">    if (c == FAIL) {</a>
<a name="ln1334">      retval = 0;</a>
<a name="ln1335">      goto end_do_search;</a>
<a name="ln1336">    }</a>
<a name="ln1337">    if (spats[0].off.end &amp;&amp; oap != NULL)</a>
<a name="ln1338">      oap-&gt;inclusive = true;        /* 'e' includes last character */</a>
<a name="ln1339"> </a>
<a name="ln1340">    retval = 1;                     /* pattern found */</a>
<a name="ln1341"> </a>
<a name="ln1342">    /*</a>
<a name="ln1343">     * Add character and/or line offset</a>
<a name="ln1344">     */</a>
<a name="ln1345">    if (!(options &amp; SEARCH_NOOF) || (pat != NULL &amp;&amp; *pat == ';')) {</a>
<a name="ln1346">      pos_T org_pos = pos;</a>
<a name="ln1347"> </a>
<a name="ln1348">      if (spats[0].off.line) {  // Add the offset to the line number.</a>
<a name="ln1349">        c = pos.lnum + spats[0].off.off;</a>
<a name="ln1350">        if (c &lt; 1)</a>
<a name="ln1351">          pos.lnum = 1;</a>
<a name="ln1352">        else if (c &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln1353">          pos.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1354">        else</a>
<a name="ln1355">          pos.lnum = c;</a>
<a name="ln1356">        pos.col = 0;</a>
<a name="ln1357"> </a>
<a name="ln1358">        retval = 2;                 /* pattern found, line offset added */</a>
<a name="ln1359">      } else if (pos.col &lt; MAXCOL - 2) {      /* just in case */</a>
<a name="ln1360">        /* to the right, check for end of file */</a>
<a name="ln1361">        c = spats[0].off.off;</a>
<a name="ln1362">        if (c &gt; 0) {</a>
<a name="ln1363">          while (c-- &gt; 0)</a>
<a name="ln1364">            if (incl(&amp;pos) == -1)</a>
<a name="ln1365">              break;</a>
<a name="ln1366">        }</a>
<a name="ln1367">        /* to the left, check for start of file */</a>
<a name="ln1368">        else {</a>
<a name="ln1369">          while (c++ &lt; 0)</a>
<a name="ln1370">            if (decl(&amp;pos) == -1)</a>
<a name="ln1371">              break;</a>
<a name="ln1372">        }</a>
<a name="ln1373">      }</a>
<a name="ln1374">      if (!equalpos(pos, org_pos)) {</a>
<a name="ln1375">        has_offset = true;</a>
<a name="ln1376">      }</a>
<a name="ln1377">    }</a>
<a name="ln1378"> </a>
<a name="ln1379">    // Show [1/15] if 'S' is not in 'shortmess'.</a>
<a name="ln1380">    if ((options &amp; SEARCH_ECHO)</a>
<a name="ln1381">        &amp;&amp; messaging()</a>
<a name="ln1382">        &amp;&amp; !msg_silent</a>
<a name="ln1383">        &amp;&amp; c != FAIL</a>
<a name="ln1384">        &amp;&amp; !shortmess(SHM_SEARCHCOUNT)</a>
<a name="ln1385">        &amp;&amp; msgbuf != NULL) {</a>
<a name="ln1386">      search_stat(dirc, &amp;pos, show_top_bot_msg, msgbuf,</a>
<a name="ln1387">                  (count != 1</a>
<a name="ln1388">                   || has_offset</a>
<a name="ln1389">                   || (!(fdo_flags &amp; FDO_SEARCH)</a>
<a name="ln1390">                       &amp;&amp; hasFolding(curwin-&gt;w_cursor.lnum, NULL, NULL))));</a>
<a name="ln1391">    }</a>
<a name="ln1392"> </a>
<a name="ln1393">    // The search command can be followed by a ';' to do another search.</a>
<a name="ln1394">    // For example: &quot;/pat/;/foo/+3;?bar&quot;</a>
<a name="ln1395">    // This is like doing another search command, except:</a>
<a name="ln1396">    // - The remembered direction '/' or '?' is from the first search.</a>
<a name="ln1397">    // - When an error happens the cursor isn't moved at all.</a>
<a name="ln1398">    // Don't do this when called by get_address() (it handles ';' itself).</a>
<a name="ln1399">    if (!(options &amp; SEARCH_OPT) || pat == NULL || *pat != ';') {</a>
<a name="ln1400">      break;</a>
<a name="ln1401">    }</a>
<a name="ln1402"> </a>
<a name="ln1403">    dirc = *++pat;</a>
<a name="ln1404">    search_delim = dirc;</a>
<a name="ln1405">    if (dirc != '?' &amp;&amp; dirc != '/') {</a>
<a name="ln1406">      retval = 0;</a>
<a name="ln1407">      EMSG(_(&quot;E386: Expected '?' or '/'  after ';'&quot;));</a>
<a name="ln1408">      goto end_do_search;</a>
<a name="ln1409">    }</a>
<a name="ln1410">    ++pat;</a>
<a name="ln1411">  }</a>
<a name="ln1412"> </a>
<a name="ln1413">  if (options &amp; SEARCH_MARK)</a>
<a name="ln1414">    setpcmark();</a>
<a name="ln1415">  curwin-&gt;w_cursor = pos;</a>
<a name="ln1416">  curwin-&gt;w_set_curswant = TRUE;</a>
<a name="ln1417"> </a>
<a name="ln1418">end_do_search:</a>
<a name="ln1419">  if ((options &amp; SEARCH_KEEP) || cmdmod.keeppatterns)</a>
<a name="ln1420">    spats[0].off = old_off;</a>
<a name="ln1421">  xfree(msgbuf);</a>
<a name="ln1422"> </a>
<a name="ln1423">  return retval;</a>
<a name="ln1424">}</a>
<a name="ln1425"> </a>
<a name="ln1426">/*</a>
<a name="ln1427"> * search_for_exact_line(buf, pos, dir, pat)</a>
<a name="ln1428"> *</a>
<a name="ln1429"> * Search for a line starting with the given pattern (ignoring leading</a>
<a name="ln1430"> * white-space), starting from pos and going in direction &quot;dir&quot;. &quot;pos&quot; will</a>
<a name="ln1431"> * contain the position of the match found.    Blank lines match only if</a>
<a name="ln1432"> * ADDING is set.  If p_ic is set then the pattern must be in lowercase.</a>
<a name="ln1433"> * Return OK for success, or FAIL if no line found.</a>
<a name="ln1434"> */</a>
<a name="ln1435">int search_for_exact_line(buf_T *buf, pos_T *pos, Direction dir, char_u *pat)</a>
<a name="ln1436">{</a>
<a name="ln1437">  linenr_T start = 0;</a>
<a name="ln1438">  char_u      *ptr;</a>
<a name="ln1439">  char_u      *p;</a>
<a name="ln1440"> </a>
<a name="ln1441">  if (buf-&gt;b_ml.ml_line_count == 0)</a>
<a name="ln1442">    return FAIL;</a>
<a name="ln1443">  for (;; ) {</a>
<a name="ln1444">    pos-&gt;lnum += dir;</a>
<a name="ln1445">    if (pos-&gt;lnum &lt; 1) {</a>
<a name="ln1446">      if (p_ws) {</a>
<a name="ln1447">        pos-&gt;lnum = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln1448">        if (!shortmess(SHM_SEARCH))</a>
<a name="ln1449">          give_warning((char_u *)_(top_bot_msg), true);</a>
<a name="ln1450">      } else {</a>
<a name="ln1451">        pos-&gt;lnum = 1;</a>
<a name="ln1452">        break;</a>
<a name="ln1453">      }</a>
<a name="ln1454">    } else if (pos-&gt;lnum &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1455">      if (p_ws) {</a>
<a name="ln1456">        pos-&gt;lnum = 1;</a>
<a name="ln1457">        if (!shortmess(SHM_SEARCH))</a>
<a name="ln1458">          give_warning((char_u *)_(bot_top_msg), true);</a>
<a name="ln1459">      } else {</a>
<a name="ln1460">        pos-&gt;lnum = 1;</a>
<a name="ln1461">        break;</a>
<a name="ln1462">      }</a>
<a name="ln1463">    }</a>
<a name="ln1464">    if (pos-&gt;lnum == start)</a>
<a name="ln1465">      break;</a>
<a name="ln1466">    if (start == 0)</a>
<a name="ln1467">      start = pos-&gt;lnum;</a>
<a name="ln1468">    ptr = ml_get_buf(buf, pos-&gt;lnum, FALSE);</a>
<a name="ln1469">    p = skipwhite(ptr);</a>
<a name="ln1470">    pos-&gt;col = (colnr_T) (p - ptr);</a>
<a name="ln1471"> </a>
<a name="ln1472">    /* when adding lines the matching line may be empty but it is not</a>
<a name="ln1473">     * ignored because we are interested in the next line -- Acevedo */</a>
<a name="ln1474">    if ((compl_cont_status &amp; CONT_ADDING)</a>
<a name="ln1475">        &amp;&amp; !(compl_cont_status &amp; CONT_SOL)) {</a>
<a name="ln1476">      if (mb_strcmp_ic((bool)p_ic, (const char *)p, (const char *)pat) == 0) {</a>
<a name="ln1477">        return OK;</a>
<a name="ln1478">      }</a>
<a name="ln1479">    } else if (*p != NUL) {  // Ignore empty lines.</a>
<a name="ln1480">      // Expanding lines or words.</a>
<a name="ln1481">      assert(compl_length &gt;= 0);</a>
<a name="ln1482">      if ((p_ic ? mb_strnicmp(p, pat, (size_t)compl_length)</a>
<a name="ln1483">           : STRNCMP(p, pat, compl_length)) == 0)</a>
<a name="ln1484">        return OK;</a>
<a name="ln1485">    }</a>
<a name="ln1486">  }</a>
<a name="ln1487">  return FAIL;</a>
<a name="ln1488">}</a>
<a name="ln1489"> </a>
<a name="ln1490">/*</a>
<a name="ln1491"> * Character Searches</a>
<a name="ln1492"> */</a>
<a name="ln1493"> </a>
<a name="ln1494">/*</a>
<a name="ln1495"> * Search for a character in a line.  If &quot;t_cmd&quot; is FALSE, move to the</a>
<a name="ln1496"> * position of the character, otherwise move to just before the char.</a>
<a name="ln1497"> * Do this &quot;cap-&gt;count1&quot; times.</a>
<a name="ln1498"> * Return FAIL or OK.</a>
<a name="ln1499"> */</a>
<a name="ln1500">int searchc(cmdarg_T *cap, int t_cmd)</a>
<a name="ln1501">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1502">{</a>
<a name="ln1503">  int c = cap-&gt;nchar;                   // char to search for</a>
<a name="ln1504">  Direction dir = cap-&gt;arg;             // TRUE for searching forward</a>
<a name="ln1505">  long count = cap-&gt;count1;             // repeat count</a>
<a name="ln1506">  int col;</a>
<a name="ln1507">  char_u              *p;</a>
<a name="ln1508">  int len;</a>
<a name="ln1509">  int stop = TRUE;</a>
<a name="ln1510"> </a>
<a name="ln1511">  if (c != NUL) {       /* normal search: remember args for repeat */</a>
<a name="ln1512">    if (!KeyStuffed) {      /* don't remember when redoing */</a>
<a name="ln1513">      *lastc = c;</a>
<a name="ln1514">      set_csearch_direction(dir);</a>
<a name="ln1515">      set_csearch_until(t_cmd);</a>
<a name="ln1516">      lastc_bytelen = utf_char2bytes(c, lastc_bytes);</a>
<a name="ln1517">      if (cap-&gt;ncharC1 != 0) {</a>
<a name="ln1518">        lastc_bytelen += utf_char2bytes(cap-&gt;ncharC1,</a>
<a name="ln1519">                                        lastc_bytes + lastc_bytelen);</a>
<a name="ln1520">        if (cap-&gt;ncharC2 != 0) {</a>
<a name="ln1521">          lastc_bytelen += utf_char2bytes(cap-&gt;ncharC2,</a>
<a name="ln1522">                                          lastc_bytes + lastc_bytelen);</a>
<a name="ln1523">        }</a>
<a name="ln1524">      }</a>
<a name="ln1525">    }</a>
<a name="ln1526">  } else {            // repeat previous search</a>
<a name="ln1527">    if (*lastc == NUL &amp;&amp; lastc_bytelen == 1) {</a>
<a name="ln1528">      return FAIL;</a>
<a name="ln1529">    }</a>
<a name="ln1530">    if (dir) {        // repeat in opposite direction</a>
<a name="ln1531">      dir = -lastcdir;</a>
<a name="ln1532">    } else {</a>
<a name="ln1533">      dir = lastcdir;</a>
<a name="ln1534">    }</a>
<a name="ln1535">    t_cmd = last_t_cmd;</a>
<a name="ln1536">    c = *lastc;</a>
<a name="ln1537">    /* For multi-byte re-use last lastc_bytes[] and lastc_bytelen. */</a>
<a name="ln1538"> </a>
<a name="ln1539">    /* Force a move of at least one char, so &quot;;&quot; and &quot;,&quot; will move the</a>
<a name="ln1540">     * cursor, even if the cursor is right in front of char we are looking</a>
<a name="ln1541">     * at. */</a>
<a name="ln1542">    if (vim_strchr(p_cpo, CPO_SCOLON) == NULL &amp;&amp; count == 1 &amp;&amp; t_cmd)</a>
<a name="ln1543">      stop = FALSE;</a>
<a name="ln1544">  }</a>
<a name="ln1545"> </a>
<a name="ln1546">  if (dir == BACKWARD)</a>
<a name="ln1547">    cap-&gt;oap-&gt;inclusive = false;</a>
<a name="ln1548">  else</a>
<a name="ln1549">    cap-&gt;oap-&gt;inclusive = true;</a>
<a name="ln1550"> </a>
<a name="ln1551">  p = get_cursor_line_ptr();</a>
<a name="ln1552">  col = curwin-&gt;w_cursor.col;</a>
<a name="ln1553">  len = (int)STRLEN(p);</a>
<a name="ln1554"> </a>
<a name="ln1555">  while (count--) {</a>
<a name="ln1556">    for (;; ) {</a>
<a name="ln1557">      if (dir &gt; 0) {</a>
<a name="ln1558">        col += utfc_ptr2len(p + col);</a>
<a name="ln1559">        if (col &gt;= len) {</a>
<a name="ln1560">          return FAIL;</a>
<a name="ln1561">        }</a>
<a name="ln1562">      } else {</a>
<a name="ln1563">        if (col == 0) {</a>
<a name="ln1564">          return FAIL;</a>
<a name="ln1565">        }</a>
<a name="ln1566">        col -= utf_head_off(p, p + col - 1) + 1;</a>
<a name="ln1567">      }</a>
<a name="ln1568">      if (lastc_bytelen == 1) {</a>
<a name="ln1569">        if (p[col] == c &amp;&amp; stop) {</a>
<a name="ln1570">          break;</a>
<a name="ln1571">        }</a>
<a name="ln1572">      } else if (STRNCMP(p + col, lastc_bytes, lastc_bytelen) == 0 &amp;&amp; stop) {</a>
<a name="ln1573">        break;</a>
<a name="ln1574">      }</a>
<a name="ln1575">      stop = true;</a>
<a name="ln1576">    }</a>
<a name="ln1577">  }</a>
<a name="ln1578"> </a>
<a name="ln1579">  if (t_cmd) {</a>
<a name="ln1580">    // Backup to before the character (possibly double-byte).</a>
<a name="ln1581">    col -= dir;</a>
<a name="ln1582">    if (dir &lt; 0) {</a>
<a name="ln1583">      // Landed on the search char which is lastc_bytelen long.</a>
<a name="ln1584">      col += lastc_bytelen - 1;</a>
<a name="ln1585">    } else {</a>
<a name="ln1586">      // To previous char, which may be multi-byte.</a>
<a name="ln1587">      col -= utf_head_off(p, p + col);</a>
<a name="ln1588">    }</a>
<a name="ln1589">  }</a>
<a name="ln1590">  curwin-&gt;w_cursor.col = col;</a>
<a name="ln1591"> </a>
<a name="ln1592">  return OK;</a>
<a name="ln1593">}</a>
<a name="ln1594"> </a>
<a name="ln1595">/*</a>
<a name="ln1596"> * &quot;Other&quot; Searches</a>
<a name="ln1597"> */</a>
<a name="ln1598"> </a>
<a name="ln1599">/*</a>
<a name="ln1600"> * findmatch - find the matching paren or brace</a>
<a name="ln1601"> *</a>
<a name="ln1602"> * Improvement over vi: Braces inside quotes are ignored.</a>
<a name="ln1603"> */</a>
<a name="ln1604">pos_T *findmatch(oparg_T *oap, int initc)</a>
<a name="ln1605">{</a>
<a name="ln1606">  return findmatchlimit(oap, initc, 0, 0);</a>
<a name="ln1607">}</a>
<a name="ln1608"> </a>
<a name="ln1609">// Return true if the character before &quot;linep[col]&quot; equals &quot;ch&quot;.</a>
<a name="ln1610">// Return false if &quot;col&quot; is zero.</a>
<a name="ln1611">// Update &quot;*prevcol&quot; to the column of the previous character, unless &quot;prevcol&quot;</a>
<a name="ln1612">// is NULL.</a>
<a name="ln1613">// Handles multibyte string correctly.</a>
<a name="ln1614">static bool check_prevcol(char_u *linep, int col, int ch, int *prevcol)</a>
<a name="ln1615">{</a>
<a name="ln1616">  col--;</a>
<a name="ln1617">  if (col &gt; 0) {</a>
<a name="ln1618">    col -= utf_head_off(linep, linep + col);</a>
<a name="ln1619">  }</a>
<a name="ln1620">  if (prevcol) {</a>
<a name="ln1621">    *prevcol = col;</a>
<a name="ln1622">  }</a>
<a name="ln1623">  return (col &gt;= 0 &amp;&amp; linep[col] == ch) ? true : false;</a>
<a name="ln1624">}</a>
<a name="ln1625"> </a>
<a name="ln1626">/*</a>
<a name="ln1627"> * Raw string start is found at linep[startpos.col - 1].</a>
<a name="ln1628"> * Return true if the matching end can be found between startpos and endpos.</a>
<a name="ln1629"> */</a>
<a name="ln1630">static bool find_rawstring_end(char_u *linep, pos_T *startpos, pos_T *endpos)</a>
<a name="ln1631">{</a>
<a name="ln1632">  char_u *p;</a>
<a name="ln1633">  char_u *delim_copy;</a>
<a name="ln1634">  size_t delim_len;</a>
<a name="ln1635">  linenr_T lnum;</a>
<a name="ln1636"> </a>
<a name="ln1637">  for (p = linep + startpos-&gt;col + 1; *p &amp;&amp; *p != '('; p++) {}</a>
<a name="ln1638"> </a>
<a name="ln1639">  delim_len = (p - linep) - startpos-&gt;col - 1;</a>
<a name="ln1640">  delim_copy = vim_strnsave(linep + startpos-&gt;col + 1, delim_len);</a>
<a name="ln1641">  bool found = false;</a>
<a name="ln1642">  for (lnum = startpos-&gt;lnum; lnum &lt;= endpos-&gt;lnum; lnum++) {</a>
<a name="ln1643">    char_u *line = ml_get(lnum);</a>
<a name="ln1644"> </a>
<a name="ln1645">    for (p = line + (lnum == startpos-&gt;lnum ? startpos-&gt;col + 1 : 0); *p; p++) {</a>
<a name="ln1646">      if (lnum == endpos-&gt;lnum &amp;&amp; (colnr_T)(p - line) &gt;= endpos-&gt;col) {</a>
<a name="ln1647">        break;</a>
<a name="ln1648">      }</a>
<a name="ln1649">      if (*p == ')'</a>
<a name="ln1650">          &amp;&amp; STRNCMP(delim_copy, p + 1, delim_len) == 0</a>
<a name="ln1651">          &amp;&amp; p[delim_len + 1] == '&quot;') {</a>
<a name="ln1652">        found = true;</a>
<a name="ln1653">        break;</a>
<a name="ln1654">      }</a>
<a name="ln1655">    }</a>
<a name="ln1656">    if (found) {</a>
<a name="ln1657">      break;</a>
<a name="ln1658">    }</a>
<a name="ln1659">  }</a>
<a name="ln1660">  xfree(delim_copy);</a>
<a name="ln1661">  return found;</a>
<a name="ln1662">}</a>
<a name="ln1663"> </a>
<a name="ln1664">/// Check matchpairs option for &quot;*initc&quot;.</a>
<a name="ln1665">/// If there is a match set &quot;*initc&quot; to the matching character and &quot;*findc&quot; to</a>
<a name="ln1666">/// the opposite character.  Set &quot;*backwards&quot; to the direction.</a>
<a name="ln1667">/// When &quot;switchit&quot; is true swap the direction.</a>
<a name="ln1668">static void find_mps_values(int *initc, int *findc, bool *backwards,</a>
<a name="ln1669">                            bool switchit)</a>
<a name="ln1670">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1671">{</a>
<a name="ln1672">  char_u *ptr = curbuf-&gt;b_p_mps;</a>
<a name="ln1673"> </a>
<a name="ln1674">  while (*ptr != NUL) {</a>
<a name="ln1675">    if (utf_ptr2char(ptr) == *initc) {</a>
<a name="ln1676">      if (switchit) {</a>
<a name="ln1677">        *findc = *initc;</a>
<a name="ln1678">        *initc = utf_ptr2char(ptr + utfc_ptr2len(ptr) + 1);</a>
<a name="ln1679">        *backwards = true;</a>
<a name="ln1680">      } else {</a>
<a name="ln1681">        *findc = utf_ptr2char(ptr + utfc_ptr2len(ptr) + 1);</a>
<a name="ln1682">        *backwards = false;</a>
<a name="ln1683">      }</a>
<a name="ln1684">      return;</a>
<a name="ln1685">    }</a>
<a name="ln1686">    char_u *prev = ptr;</a>
<a name="ln1687">    ptr += utfc_ptr2len(ptr) + 1;</a>
<a name="ln1688">    if (utf_ptr2char(ptr) == *initc) {</a>
<a name="ln1689">      if (switchit) {</a>
<a name="ln1690">        *findc = *initc;</a>
<a name="ln1691">        *initc = utf_ptr2char(prev);</a>
<a name="ln1692">        *backwards = false;</a>
<a name="ln1693">      } else {</a>
<a name="ln1694">        *findc = utf_ptr2char(prev);</a>
<a name="ln1695">        *backwards = true;</a>
<a name="ln1696">      }</a>
<a name="ln1697">      return;</a>
<a name="ln1698">    }</a>
<a name="ln1699">    ptr += utfc_ptr2len(ptr);</a>
<a name="ln1700">    if (*ptr == ',') {</a>
<a name="ln1701">      ptr++;</a>
<a name="ln1702">    }</a>
<a name="ln1703">  }</a>
<a name="ln1704">}</a>
<a name="ln1705"> </a>
<a name="ln1706">/*</a>
<a name="ln1707"> * findmatchlimit -- find the matching paren or brace, if it exists within</a>
<a name="ln1708"> * maxtravel lines of the cursor.  A maxtravel of 0 means search until falling</a>
<a name="ln1709"> * off the edge of the file.</a>
<a name="ln1710"> *</a>
<a name="ln1711"> * &quot;initc&quot; is the character to find a match for.  NUL means to find the</a>
<a name="ln1712"> * character at or after the cursor. Special values:</a>
<a name="ln1713"> * '*'  look for C-style comment / *</a>
<a name="ln1714"> * '/'  look for C-style comment / *, ignoring comment-end</a>
<a name="ln1715"> * '#'  look for preprocessor directives</a>
<a name="ln1716"> * 'R'  look for raw string start: R&quot;delim(text)delim&quot; (only backwards)</a>
<a name="ln1717"> *</a>
<a name="ln1718"> * flags: FM_BACKWARD	search backwards (when initc is '/', '*' or '#')</a>
<a name="ln1719"> *	  FM_FORWARD	search forwards (when initc is '/', '*' or '#')</a>
<a name="ln1720"> *	  FM_BLOCKSTOP	stop at start/end of block ({ or } in column 0)</a>
<a name="ln1721"> *	  FM_SKIPCOMM	skip comments (not implemented yet!)</a>
<a name="ln1722"> *</a>
<a name="ln1723"> * &quot;oap&quot; is only used to set oap-&gt;motion_type for a linewise motion, it can be</a>
<a name="ln1724"> * NULL</a>
<a name="ln1725"> */</a>
<a name="ln1726"> </a>
<a name="ln1727">pos_T *findmatchlimit(oparg_T *oap, int initc, int flags, int64_t maxtravel)</a>
<a name="ln1728">{</a>
<a name="ln1729">  static pos_T pos;                     // current search position</a>
<a name="ln1730">  int findc = 0;                        // matching brace</a>
<a name="ln1731">  int count = 0;                        // cumulative number of braces</a>
<a name="ln1732">  bool backwards = false;               // init for gcc</a>
<a name="ln1733">  bool raw_string = false;              // search for raw string</a>
<a name="ln1734">  bool inquote = false;                 // true when inside quotes</a>
<a name="ln1735">  char_u      *ptr;</a>
<a name="ln1736">  int hash_dir = 0;                     // Direction searched for # things</a>
<a name="ln1737">  int comment_dir = 0;                  // Direction searched for comments</a>
<a name="ln1738">  int traveled = 0;                     // how far we've searched so far</a>
<a name="ln1739">  bool ignore_cend = false;             // ignore comment end</a>
<a name="ln1740">  int match_escaped = 0;                // search for escaped match</a>
<a name="ln1741">  int dir;                              // Direction to search</a>
<a name="ln1742">  int comment_col = MAXCOL;             // start of / / comment</a>
<a name="ln1743">  bool lispcomm = false;                // inside of Lisp-style comment</a>
<a name="ln1744">  bool lisp = curbuf-&gt;b_p_lisp;         // engage Lisp-specific hacks ;)</a>
<a name="ln1745"> </a>
<a name="ln1746">  pos = curwin-&gt;w_cursor;</a>
<a name="ln1747">  pos.coladd = 0;</a>
<a name="ln1748">  char_u *linep = ml_get(pos.lnum);     // pointer to current line</a>
<a name="ln1749"> </a>
<a name="ln1750">  // vi compatible matching</a>
<a name="ln1751">  bool cpo_match = (vim_strchr(p_cpo, CPO_MATCH) != NULL);</a>
<a name="ln1752">  // don't recognize backslashes</a>
<a name="ln1753">  bool cpo_bsl = (vim_strchr(p_cpo, CPO_MATCHBSL) != NULL);</a>
<a name="ln1754"> </a>
<a name="ln1755">  /* Direction to search when initc is '/', '*' or '#' */</a>
<a name="ln1756">  if (flags &amp; FM_BACKWARD)</a>
<a name="ln1757">    dir = BACKWARD;</a>
<a name="ln1758">  else if (flags &amp; FM_FORWARD)</a>
<a name="ln1759">    dir = FORWARD;</a>
<a name="ln1760">  else</a>
<a name="ln1761">    dir = 0;</a>
<a name="ln1762"> </a>
<a name="ln1763">  /*</a>
<a name="ln1764">   * if initc given, look in the table for the matching character</a>
<a name="ln1765">   * '/' and '*' are special cases: look for start or end of comment.</a>
<a name="ln1766">   * When '/' is used, we ignore running backwards into a star-slash, for</a>
<a name="ln1767">   * &quot;[*&quot; command, we just want to find any comment.</a>
<a name="ln1768">   */</a>
<a name="ln1769">  if (initc == '/' || initc == '*' || initc == 'R') {</a>
<a name="ln1770">    comment_dir = dir;</a>
<a name="ln1771">    if (initc == '/')</a>
<a name="ln1772">      ignore_cend = true;</a>
<a name="ln1773">    backwards = (dir == FORWARD) ? false : true;</a>
<a name="ln1774">    raw_string = (initc == 'R');</a>
<a name="ln1775">    initc = NUL;</a>
<a name="ln1776">  } else if (initc != '#' &amp;&amp; initc != NUL) {</a>
<a name="ln1777">    find_mps_values(&amp;initc, &amp;findc, &amp;backwards, true);</a>
<a name="ln1778">    if (findc == NUL) {</a>
<a name="ln1779">      return NULL;</a>
<a name="ln1780">    }</a>
<a name="ln1781">  } else {</a>
<a name="ln1782">    /*</a>
<a name="ln1783">     * Either initc is '#', or no initc was given and we need to look</a>
<a name="ln1784">     * under the cursor.</a>
<a name="ln1785">     */</a>
<a name="ln1786">    if (initc == '#') {</a>
<a name="ln1787">      hash_dir = dir;</a>
<a name="ln1788">    } else {</a>
<a name="ln1789">      /*</a>
<a name="ln1790">       * initc was not given, must look for something to match under</a>
<a name="ln1791">       * or near the cursor.</a>
<a name="ln1792">       * Only check for special things when 'cpo' doesn't have '%'.</a>
<a name="ln1793">       */</a>
<a name="ln1794">      if (!cpo_match) {</a>
<a name="ln1795">        /* Are we before or at #if, #else etc.? */</a>
<a name="ln1796">        ptr = skipwhite(linep);</a>
<a name="ln1797">        if (*ptr == '#' &amp;&amp; pos.col &lt;= (colnr_T)(ptr - linep)) {</a>
<a name="ln1798">          ptr = skipwhite(ptr + 1);</a>
<a name="ln1799">          if (   STRNCMP(ptr, &quot;if&quot;, 2) == 0</a>
<a name="ln1800">                 || STRNCMP(ptr, &quot;endif&quot;, 5) == 0</a>
<a name="ln1801">                 || STRNCMP(ptr, &quot;el&quot;, 2) == 0)</a>
<a name="ln1802">            hash_dir = 1;</a>
<a name="ln1803">        }</a>
<a name="ln1804">        /* Are we on a comment? */</a>
<a name="ln1805">        else if (linep[pos.col] == '/') {</a>
<a name="ln1806">          if (linep[pos.col + 1] == '*') {</a>
<a name="ln1807">            comment_dir = FORWARD;</a>
<a name="ln1808">            backwards = false;</a>
<a name="ln1809">            pos.col++;</a>
<a name="ln1810">          } else if (pos.col &gt; 0 &amp;&amp; linep[pos.col - 1] == '*') {</a>
<a name="ln1811">            comment_dir = BACKWARD;</a>
<a name="ln1812">            backwards = true;</a>
<a name="ln1813">            pos.col--;</a>
<a name="ln1814">          }</a>
<a name="ln1815">        } else if (linep[pos.col] == '*') {</a>
<a name="ln1816">          if (linep[pos.col + 1] == '/') {</a>
<a name="ln1817">            comment_dir = BACKWARD;</a>
<a name="ln1818">            backwards = true;</a>
<a name="ln1819">          } else if (pos.col &gt; 0 &amp;&amp; linep[pos.col - 1] == '/') {</a>
<a name="ln1820">            comment_dir = FORWARD;</a>
<a name="ln1821">            backwards = false;</a>
<a name="ln1822">          }</a>
<a name="ln1823">        }</a>
<a name="ln1824">      }</a>
<a name="ln1825"> </a>
<a name="ln1826">      /*</a>
<a name="ln1827">       * If we are not on a comment or the # at the start of a line, then</a>
<a name="ln1828">       * look for brace anywhere on this line after the cursor.</a>
<a name="ln1829">       */</a>
<a name="ln1830">      if (!hash_dir &amp;&amp; !comment_dir) {</a>
<a name="ln1831">        /*</a>
<a name="ln1832">         * Find the brace under or after the cursor.</a>
<a name="ln1833">         * If beyond the end of the line, use the last character in</a>
<a name="ln1834">         * the line.</a>
<a name="ln1835">         */</a>
<a name="ln1836">        if (linep[pos.col] == NUL &amp;&amp; pos.col)</a>
<a name="ln1837">          --pos.col;</a>
<a name="ln1838">        for (;; ) {</a>
<a name="ln1839">          initc = PTR2CHAR(linep + pos.col);</a>
<a name="ln1840">          if (initc == NUL)</a>
<a name="ln1841">            break;</a>
<a name="ln1842"> </a>
<a name="ln1843">          find_mps_values(&amp;initc, &amp;findc, &amp;backwards, false);</a>
<a name="ln1844">          if (findc) {</a>
<a name="ln1845">            break;</a>
<a name="ln1846">          }</a>
<a name="ln1847">          pos.col += utfc_ptr2len(linep + pos.col);</a>
<a name="ln1848">        }</a>
<a name="ln1849">        if (!findc) {</a>
<a name="ln1850">          /* no brace in the line, maybe use &quot;  #if&quot; then */</a>
<a name="ln1851">          if (!cpo_match &amp;&amp; *skipwhite(linep) == '#')</a>
<a name="ln1852">            hash_dir = 1;</a>
<a name="ln1853">          else</a>
<a name="ln1854">            return NULL;</a>
<a name="ln1855">        } else if (!cpo_bsl) {</a>
<a name="ln1856">          int col, bslcnt = 0;</a>
<a name="ln1857"> </a>
<a name="ln1858">          /* Set &quot;match_escaped&quot; if there are an odd number of</a>
<a name="ln1859">           * backslashes. */</a>
<a name="ln1860">          for (col = pos.col; check_prevcol(linep, col, '\\', &amp;col); )</a>
<a name="ln1861">            bslcnt++;</a>
<a name="ln1862">          match_escaped = (bslcnt &amp; 1);</a>
<a name="ln1863">        }</a>
<a name="ln1864">      }</a>
<a name="ln1865">    }</a>
<a name="ln1866">    if (hash_dir) {</a>
<a name="ln1867">      /*</a>
<a name="ln1868">       * Look for matching #if, #else, #elif, or #endif</a>
<a name="ln1869">       */</a>
<a name="ln1870">      if (oap != NULL) {</a>
<a name="ln1871">        oap-&gt;motion_type = kMTLineWise;  // Linewise for this case only</a>
<a name="ln1872">      }</a>
<a name="ln1873">      if (initc != '#') {</a>
<a name="ln1874">        ptr = skipwhite(skipwhite(linep) + 1);</a>
<a name="ln1875">        if (STRNCMP(ptr, &quot;if&quot;, 2) == 0 || STRNCMP(ptr, &quot;el&quot;, 2) == 0)</a>
<a name="ln1876">          hash_dir = 1;</a>
<a name="ln1877">        else if (STRNCMP(ptr, &quot;endif&quot;, 5) == 0)</a>
<a name="ln1878">          hash_dir = -1;</a>
<a name="ln1879">        else</a>
<a name="ln1880">          return NULL;</a>
<a name="ln1881">      }</a>
<a name="ln1882">      pos.col = 0;</a>
<a name="ln1883">      while (!got_int) {</a>
<a name="ln1884">        if (hash_dir &gt; 0) {</a>
<a name="ln1885">          if (pos.lnum == curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln1886">            break;</a>
<a name="ln1887">        } else if (pos.lnum == 1)</a>
<a name="ln1888">          break;</a>
<a name="ln1889">        pos.lnum += hash_dir;</a>
<a name="ln1890">        linep = ml_get(pos.lnum);</a>
<a name="ln1891">        line_breakcheck();              /* check for CTRL-C typed */</a>
<a name="ln1892">        ptr = skipwhite(linep);</a>
<a name="ln1893">        if (*ptr != '#')</a>
<a name="ln1894">          continue;</a>
<a name="ln1895">        pos.col = (colnr_T) (ptr - linep);</a>
<a name="ln1896">        ptr = skipwhite(ptr + 1);</a>
<a name="ln1897">        if (hash_dir &gt; 0) {</a>
<a name="ln1898">          if (STRNCMP(ptr, &quot;if&quot;, 2) == 0)</a>
<a name="ln1899">            count++;</a>
<a name="ln1900">          else if (STRNCMP(ptr, &quot;el&quot;, 2) == 0) {</a>
<a name="ln1901">            if (count == 0)</a>
<a name="ln1902">              return &amp;pos;</a>
<a name="ln1903">          } else if (STRNCMP(ptr, &quot;endif&quot;, 5) == 0) {</a>
<a name="ln1904">            if (count == 0)</a>
<a name="ln1905">              return &amp;pos;</a>
<a name="ln1906">            count--;</a>
<a name="ln1907">          }</a>
<a name="ln1908">        } else {</a>
<a name="ln1909">          if (STRNCMP(ptr, &quot;if&quot;, 2) == 0) {</a>
<a name="ln1910">            if (count == 0)</a>
<a name="ln1911">              return &amp;pos;</a>
<a name="ln1912">            count--;</a>
<a name="ln1913">          } else if (initc == '#' &amp;&amp; STRNCMP(ptr, &quot;el&quot;, 2) == 0) {</a>
<a name="ln1914">            if (count == 0)</a>
<a name="ln1915">              return &amp;pos;</a>
<a name="ln1916">          } else if (STRNCMP(ptr, &quot;endif&quot;, 5) == 0)</a>
<a name="ln1917">            count++;</a>
<a name="ln1918">        }</a>
<a name="ln1919">      }</a>
<a name="ln1920">      return NULL;</a>
<a name="ln1921">    }</a>
<a name="ln1922">  }</a>
<a name="ln1923"> </a>
<a name="ln1924">  // This is just guessing: when 'rightleft' is set, search for a matching</a>
<a name="ln1925">  // paren/brace in the other direction.</a>
<a name="ln1926">  if (curwin-&gt;w_p_rl &amp;&amp; vim_strchr((char_u *)&quot;()[]{}&lt;&gt;&quot;, initc) != NULL) {</a>
<a name="ln1927">    backwards = !backwards;</a>
<a name="ln1928">  }</a>
<a name="ln1929"> </a>
<a name="ln1930">  int do_quotes = -1;                 // check for quotes in current line</a>
<a name="ln1931">  int at_start;                       // do_quotes value at start position</a>
<a name="ln1932">  TriState start_in_quotes = kNone;   // start position is in quotes</a>
<a name="ln1933">  pos_T match_pos;                    // Where last slash-star was found</a>
<a name="ln1934">  clearpos(&amp;match_pos);</a>
<a name="ln1935"> </a>
<a name="ln1936">  /* backward search: Check if this line contains a single-line comment */</a>
<a name="ln1937">  if ((backwards &amp;&amp; comment_dir)</a>
<a name="ln1938">      || lisp</a>
<a name="ln1939">      )</a>
<a name="ln1940">    comment_col = check_linecomment(linep);</a>
<a name="ln1941">  if (lisp &amp;&amp; comment_col != MAXCOL &amp;&amp; pos.col &gt; (colnr_T)comment_col) {</a>
<a name="ln1942">    lispcomm = true;        // find match inside this comment</a>
<a name="ln1943">  }</a>
<a name="ln1944">  while (!got_int) {</a>
<a name="ln1945">    /*</a>
<a name="ln1946">     * Go to the next position, forward or backward. We could use</a>
<a name="ln1947">     * inc() and dec() here, but that is much slower</a>
<a name="ln1948">     */</a>
<a name="ln1949">    if (backwards) {</a>
<a name="ln1950">      /* char to match is inside of comment, don't search outside */</a>
<a name="ln1951">      if (lispcomm &amp;&amp; pos.col &lt; (colnr_T)comment_col)</a>
<a name="ln1952">        break;</a>
<a name="ln1953">      if (pos.col == 0) {               /* at start of line, go to prev. one */</a>
<a name="ln1954">        if (pos.lnum == 1)              /* start of file */</a>
<a name="ln1955">          break;</a>
<a name="ln1956">        --pos.lnum;</a>
<a name="ln1957"> </a>
<a name="ln1958">        if (maxtravel &gt; 0 &amp;&amp; ++traveled &gt; maxtravel)</a>
<a name="ln1959">          break;</a>
<a name="ln1960"> </a>
<a name="ln1961">        linep = ml_get(pos.lnum);</a>
<a name="ln1962">        pos.col = (colnr_T)STRLEN(linep);         /* pos.col on trailing NUL */</a>
<a name="ln1963">        do_quotes = -1;</a>
<a name="ln1964">        line_breakcheck();</a>
<a name="ln1965"> </a>
<a name="ln1966">        /* Check if this line contains a single-line comment */</a>
<a name="ln1967">        if (comment_dir</a>
<a name="ln1968">            || lisp</a>
<a name="ln1969">            )</a>
<a name="ln1970">          comment_col = check_linecomment(linep);</a>
<a name="ln1971">        /* skip comment */</a>
<a name="ln1972">        if (lisp &amp;&amp; comment_col != MAXCOL)</a>
<a name="ln1973">          pos.col = comment_col;</a>
<a name="ln1974">      } else {</a>
<a name="ln1975">        pos.col--;</a>
<a name="ln1976">        pos.col -= utf_head_off(linep, linep + pos.col);</a>
<a name="ln1977">      }</a>
<a name="ln1978">    } else {                          /* forward search */</a>
<a name="ln1979">      if (linep[pos.col] == NUL</a>
<a name="ln1980">          /* at end of line, go to next one */</a>
<a name="ln1981">          /* don't search for match in comment */</a>
<a name="ln1982">          || (lisp &amp;&amp; comment_col != MAXCOL</a>
<a name="ln1983">              &amp;&amp; pos.col == (colnr_T)comment_col)</a>
<a name="ln1984">          ) {</a>
<a name="ln1985">        if (pos.lnum == curbuf-&gt;b_ml.ml_line_count          /* end of file */</a>
<a name="ln1986">            /* line is exhausted and comment with it,</a>
<a name="ln1987">             * don't search for match in code */</a>
<a name="ln1988">            || lispcomm</a>
<a name="ln1989">            )</a>
<a name="ln1990">          break;</a>
<a name="ln1991">        ++pos.lnum;</a>
<a name="ln1992"> </a>
<a name="ln1993">        if (maxtravel &amp;&amp; traveled++ &gt; maxtravel)</a>
<a name="ln1994">          break;</a>
<a name="ln1995"> </a>
<a name="ln1996">        linep = ml_get(pos.lnum);</a>
<a name="ln1997">        pos.col = 0;</a>
<a name="ln1998">        do_quotes = -1;</a>
<a name="ln1999">        line_breakcheck();</a>
<a name="ln2000">        if (lisp)           /* find comment pos in new line */</a>
<a name="ln2001">          comment_col = check_linecomment(linep);</a>
<a name="ln2002">      } else {</a>
<a name="ln2003">        pos.col += utfc_ptr2len(linep + pos.col);</a>
<a name="ln2004">      }</a>
<a name="ln2005">    }</a>
<a name="ln2006"> </a>
<a name="ln2007">    // If FM_BLOCKSTOP given, stop at a '{' or '}' in column 0.</a>
<a name="ln2008">    if (pos.col == 0 &amp;&amp; (flags &amp; FM_BLOCKSTOP)</a>
<a name="ln2009">        &amp;&amp; (linep[0] == '{' || linep[0] == '}')) {</a>
<a name="ln2010">      if (linep[0] == findc &amp;&amp; count == 0) {  // match!</a>
<a name="ln2011">        return &amp;pos;</a>
<a name="ln2012">      }</a>
<a name="ln2013">      break;  // out of scope</a>
<a name="ln2014">    }</a>
<a name="ln2015"> </a>
<a name="ln2016">    if (comment_dir) {</a>
<a name="ln2017">      /* Note: comments do not nest, and we ignore quotes in them */</a>
<a name="ln2018">      /* TODO: ignore comment brackets inside strings */</a>
<a name="ln2019">      if (comment_dir == FORWARD) {</a>
<a name="ln2020">        if (linep[pos.col] == '*' &amp;&amp; linep[pos.col + 1] == '/') {</a>
<a name="ln2021">          pos.col++;</a>
<a name="ln2022">          return &amp;pos;</a>
<a name="ln2023">        }</a>
<a name="ln2024">      } else {    /* Searching backwards */</a>
<a name="ln2025">        /*</a>
<a name="ln2026">         * A comment may contain / * or / /, it may also start or end</a>
<a name="ln2027">         * with / * /. Ignore a / * after / / and after *.</a>
<a name="ln2028">         */</a>
<a name="ln2029">        if (pos.col == 0)</a>
<a name="ln2030">          continue;</a>
<a name="ln2031">        else if (raw_string)</a>
<a name="ln2032">        {</a>
<a name="ln2033">          if (linep[pos.col - 1] == 'R'</a>
<a name="ln2034">              &amp;&amp; linep[pos.col] == '&quot;'</a>
<a name="ln2035">              &amp;&amp; vim_strchr(linep + pos.col + 1, '(') != NULL)</a>
<a name="ln2036">          {</a>
<a name="ln2037">            /* Possible start of raw string. Now that we have the</a>
<a name="ln2038">             * delimiter we can check if it ends before where we</a>
<a name="ln2039">             * started searching, or before the previously found</a>
<a name="ln2040">             * raw string start. */</a>
<a name="ln2041">            if (!find_rawstring_end(linep, &amp;pos,</a>
<a name="ln2042">                  count &gt; 0 ? &amp;match_pos : &amp;curwin-&gt;w_cursor))</a>
<a name="ln2043">            {</a>
<a name="ln2044">              count++;</a>
<a name="ln2045">              match_pos = pos;</a>
<a name="ln2046">              match_pos.col--;</a>
<a name="ln2047">            }</a>
<a name="ln2048">            linep = ml_get(pos.lnum); /* may have been released */</a>
<a name="ln2049">          }</a>
<a name="ln2050">        } else if (  linep[pos.col - 1] == '/'</a>
<a name="ln2051">                   &amp;&amp; linep[pos.col] == '*'</a>
<a name="ln2052">                   &amp;&amp; (pos.col == 1 || linep[pos.col - 2] != '*')</a>
<a name="ln2053">                   &amp;&amp; (int)pos.col &lt; comment_col) {</a>
<a name="ln2054">          count++;</a>
<a name="ln2055">          match_pos = pos;</a>
<a name="ln2056">          match_pos.col--;</a>
<a name="ln2057">        } else if (linep[pos.col - 1] == '*' &amp;&amp; linep[pos.col] == '/') {</a>
<a name="ln2058">          if (count &gt; 0)</a>
<a name="ln2059">            pos = match_pos;</a>
<a name="ln2060">          else if (pos.col &gt; 1 &amp;&amp; linep[pos.col - 2] == '/'</a>
<a name="ln2061">                   &amp;&amp; (int)pos.col &lt;= comment_col)</a>
<a name="ln2062">            pos.col -= 2;</a>
<a name="ln2063">          else if (ignore_cend)</a>
<a name="ln2064">            continue;</a>
<a name="ln2065">          else</a>
<a name="ln2066">            return NULL;</a>
<a name="ln2067">          return &amp;pos;</a>
<a name="ln2068">        }</a>
<a name="ln2069">      }</a>
<a name="ln2070">      continue;</a>
<a name="ln2071">    }</a>
<a name="ln2072"> </a>
<a name="ln2073">    /*</a>
<a name="ln2074">     * If smart matching ('cpoptions' does not contain '%'), braces inside</a>
<a name="ln2075">     * of quotes are ignored, but only if there is an even number of</a>
<a name="ln2076">     * quotes in the line.</a>
<a name="ln2077">     */</a>
<a name="ln2078">    if (cpo_match)</a>
<a name="ln2079">      do_quotes = 0;</a>
<a name="ln2080">    else if (do_quotes == -1) {</a>
<a name="ln2081">      /*</a>
<a name="ln2082">       * Count the number of quotes in the line, skipping \&quot; and '&quot;'.</a>
<a name="ln2083">       * Watch out for &quot;\\&quot;.</a>
<a name="ln2084">       */</a>
<a name="ln2085">      at_start = do_quotes;</a>
<a name="ln2086">      for (ptr = linep; *ptr; ++ptr) {</a>
<a name="ln2087">        if (ptr == linep + pos.col + backwards)</a>
<a name="ln2088">          at_start = (do_quotes &amp; 1);</a>
<a name="ln2089">        if (*ptr == '&quot;'</a>
<a name="ln2090">            &amp;&amp; (ptr == linep || ptr[-1] != '\'' || ptr[1] != '\''))</a>
<a name="ln2091">          ++do_quotes;</a>
<a name="ln2092">        if (*ptr == '\\' &amp;&amp; ptr[1] != NUL)</a>
<a name="ln2093">          ++ptr;</a>
<a name="ln2094">      }</a>
<a name="ln2095">      do_quotes &amp;= 1;               /* result is 1 with even number of quotes */</a>
<a name="ln2096"> </a>
<a name="ln2097">      /*</a>
<a name="ln2098">       * If we find an uneven count, check current line and previous</a>
<a name="ln2099">       * one for a '\' at the end.</a>
<a name="ln2100">       */</a>
<a name="ln2101">      if (!do_quotes) {</a>
<a name="ln2102">        inquote = false;</a>
<a name="ln2103">        if (ptr[-1] == '\\') {</a>
<a name="ln2104">          do_quotes = 1;</a>
<a name="ln2105">          if (start_in_quotes == kNone) {</a>
<a name="ln2106">            // Do we need to use at_start here?</a>
<a name="ln2107">            inquote = true;</a>
<a name="ln2108">            start_in_quotes = kTrue;</a>
<a name="ln2109">          } else if (backwards) {</a>
<a name="ln2110">            inquote = true;</a>
<a name="ln2111">          }</a>
<a name="ln2112">        }</a>
<a name="ln2113">        if (pos.lnum &gt; 1) {</a>
<a name="ln2114">          ptr = ml_get(pos.lnum - 1);</a>
<a name="ln2115">          if (*ptr &amp;&amp; *(ptr + STRLEN(ptr) - 1) == '\\') {</a>
<a name="ln2116">            do_quotes = 1;</a>
<a name="ln2117">            if (start_in_quotes == kNone) {</a>
<a name="ln2118">              inquote = at_start;</a>
<a name="ln2119">              if (inquote) {</a>
<a name="ln2120">                start_in_quotes = kTrue;</a>
<a name="ln2121">              }</a>
<a name="ln2122">            } else if (!backwards) {</a>
<a name="ln2123">              inquote = true;</a>
<a name="ln2124">            }</a>
<a name="ln2125">          }</a>
<a name="ln2126"> </a>
<a name="ln2127">          /* ml_get() only keeps one line, need to get linep again */</a>
<a name="ln2128">          linep = ml_get(pos.lnum);</a>
<a name="ln2129">        }</a>
<a name="ln2130">      }</a>
<a name="ln2131">    }</a>
<a name="ln2132">    if (start_in_quotes == kNone) {</a>
<a name="ln2133">      start_in_quotes = kFalse;</a>
<a name="ln2134">    }</a>
<a name="ln2135"> </a>
<a name="ln2136">    /*</a>
<a name="ln2137">     * If 'smartmatch' is set:</a>
<a name="ln2138">     *   Things inside quotes are ignored by setting 'inquote'.  If we</a>
<a name="ln2139">     *   find a quote without a preceding '\' invert 'inquote'.  At the</a>
<a name="ln2140">     *   end of a line not ending in '\' we reset 'inquote'.</a>
<a name="ln2141">     *</a>
<a name="ln2142">     *   In lines with an uneven number of quotes (without preceding '\')</a>
<a name="ln2143">     *   we do not know which part to ignore. Therefore we only set</a>
<a name="ln2144">     *   inquote if the number of quotes in a line is even, unless this</a>
<a name="ln2145">     *   line or the previous one ends in a '\'.  Complicated, isn't it?</a>
<a name="ln2146">     */</a>
<a name="ln2147">    const int c = PTR2CHAR(linep + pos.col);</a>
<a name="ln2148">    switch (c) {</a>
<a name="ln2149">    case NUL:</a>
<a name="ln2150">      /* at end of line without trailing backslash, reset inquote */</a>
<a name="ln2151">      if (pos.col == 0 || linep[pos.col - 1] != '\\') {</a>
<a name="ln2152">        inquote = false;</a>
<a name="ln2153">        start_in_quotes = kFalse;</a>
<a name="ln2154">      }</a>
<a name="ln2155">      break;</a>
<a name="ln2156"> </a>
<a name="ln2157">    case '&quot;':</a>
<a name="ln2158">      /* a quote that is preceded with an odd number of backslashes is</a>
<a name="ln2159">       * ignored */</a>
<a name="ln2160">      if (do_quotes) {</a>
<a name="ln2161">        int col;</a>
<a name="ln2162"> </a>
<a name="ln2163">        for (col = pos.col - 1; col &gt;= 0; --col)</a>
<a name="ln2164">          if (linep[col] != '\\')</a>
<a name="ln2165">            break;</a>
<a name="ln2166">        if ((((int)pos.col - 1 - col) &amp; 1) == 0) {</a>
<a name="ln2167">          inquote = !inquote;</a>
<a name="ln2168">          start_in_quotes = kFalse;</a>
<a name="ln2169">        }</a>
<a name="ln2170">      }</a>
<a name="ln2171">      break;</a>
<a name="ln2172"> </a>
<a name="ln2173">    /*</a>
<a name="ln2174">     * If smart matching ('cpoptions' does not contain '%'):</a>
<a name="ln2175">     *   Skip things in single quotes: 'x' or '\x'.  Be careful for single</a>
<a name="ln2176">     *   single quotes, eg jon's.  Things like '\233' or '\x3f' are not</a>
<a name="ln2177">     *   skipped, there is never a brace in them.</a>
<a name="ln2178">     *   Ignore this when finding matches for `'.</a>
<a name="ln2179">     */</a>
<a name="ln2180">    case '\'':</a>
<a name="ln2181">      if (!cpo_match &amp;&amp; initc != '\'' &amp;&amp; findc != '\'') {</a>
<a name="ln2182">        if (backwards) {</a>
<a name="ln2183">          if (pos.col &gt; 1) {</a>
<a name="ln2184">            if (linep[pos.col - 2] == '\'') {</a>
<a name="ln2185">              pos.col -= 2;</a>
<a name="ln2186">              break;</a>
<a name="ln2187">            } else if (linep[pos.col - 2] == '\\'</a>
<a name="ln2188">                       &amp;&amp; pos.col &gt; 2 &amp;&amp; linep[pos.col - 3] == '\'') {</a>
<a name="ln2189">              pos.col -= 3;</a>
<a name="ln2190">              break;</a>
<a name="ln2191">            }</a>
<a name="ln2192">          }</a>
<a name="ln2193">        } else if (linep[pos.col + 1]) {  // forward search</a>
<a name="ln2194">          if (linep[pos.col + 1] == '\\'</a>
<a name="ln2195">              &amp;&amp; linep[pos.col + 2] &amp;&amp; linep[pos.col + 3] == '\'') {</a>
<a name="ln2196">            pos.col += 3;</a>
<a name="ln2197">            break;</a>
<a name="ln2198">          } else if (linep[pos.col + 2] == '\'') {</a>
<a name="ln2199">            pos.col += 2;</a>
<a name="ln2200">            break;</a>
<a name="ln2201">          }</a>
<a name="ln2202">        }</a>
<a name="ln2203">      }</a>
<a name="ln2204">      FALLTHROUGH;</a>
<a name="ln2205"> </a>
<a name="ln2206">    default:</a>
<a name="ln2207">      /*</a>
<a name="ln2208">       * For Lisp skip over backslashed (), {} and [].</a>
<a name="ln2209">       * (actually, we skip #\( et al)</a>
<a name="ln2210">       */</a>
<a name="ln2211">      if (curbuf-&gt;b_p_lisp</a>
<a name="ln2212">          &amp;&amp; vim_strchr((char_u *)&quot;(){}[]&quot;, c) != NULL</a>
<a name="ln2213">          &amp;&amp; pos.col &gt; 1</a>
<a name="ln2214">          &amp;&amp; check_prevcol(linep, pos.col, '\\', NULL)</a>
<a name="ln2215">          &amp;&amp; check_prevcol(linep, pos.col - 1, '#', NULL))</a>
<a name="ln2216">        break;</a>
<a name="ln2217"> </a>
<a name="ln2218">      /* Check for match outside of quotes, and inside of</a>
<a name="ln2219">       * quotes when the start is also inside of quotes. */</a>
<a name="ln2220">      if ((!inquote || start_in_quotes == kTrue)</a>
<a name="ln2221">          &amp;&amp; (c == initc || c == findc)) {</a>
<a name="ln2222">        int col, bslcnt = 0;</a>
<a name="ln2223"> </a>
<a name="ln2224">        if (!cpo_bsl) {</a>
<a name="ln2225">          for (col = pos.col; check_prevcol(linep, col, '\\', &amp;col); )</a>
<a name="ln2226">            bslcnt++;</a>
<a name="ln2227">        }</a>
<a name="ln2228">        /* Only accept a match when 'M' is in 'cpo' or when escaping</a>
<a name="ln2229">         * is what we expect. */</a>
<a name="ln2230">        if (cpo_bsl || (bslcnt &amp; 1) == match_escaped) {</a>
<a name="ln2231">          if (c == initc)</a>
<a name="ln2232">            count++;</a>
<a name="ln2233">          else {</a>
<a name="ln2234">            if (count == 0)</a>
<a name="ln2235">              return &amp;pos;</a>
<a name="ln2236">            count--;</a>
<a name="ln2237">          }</a>
<a name="ln2238">        }</a>
<a name="ln2239">      }</a>
<a name="ln2240">    }</a>
<a name="ln2241">  }</a>
<a name="ln2242"> </a>
<a name="ln2243">  if (comment_dir == BACKWARD &amp;&amp; count &gt; 0) {</a>
<a name="ln2244">    pos = match_pos;</a>
<a name="ln2245">    return &amp;pos;</a>
<a name="ln2246">  }</a>
<a name="ln2247">  return (pos_T *)NULL;         /* never found it */</a>
<a name="ln2248">}</a>
<a name="ln2249"> </a>
<a name="ln2250">/*</a>
<a name="ln2251"> * Check if line[] contains a / / comment.</a>
<a name="ln2252"> * Return MAXCOL if not, otherwise return the column.</a>
<a name="ln2253"> * TODO: skip strings.</a>
<a name="ln2254"> */</a>
<a name="ln2255">static int check_linecomment(const char_u *line)</a>
<a name="ln2256">{</a>
<a name="ln2257">  const char_u *p = line;  // scan from start</a>
<a name="ln2258">  // skip Lispish one-line comments</a>
<a name="ln2259">  if (curbuf-&gt;b_p_lisp) {</a>
<a name="ln2260">    if (vim_strchr(p, ';') != NULL) {   /* there may be comments */</a>
<a name="ln2261">      int in_str = FALSE;       /* inside of string */</a>
<a name="ln2262"> </a>
<a name="ln2263">      while ((p = vim_strpbrk(p, (char_u *)&quot;\&quot;;&quot;)) != NULL) {</a>
<a name="ln2264">        if (*p == '&quot;') {</a>
<a name="ln2265">          if (in_str) {</a>
<a name="ln2266">            if (*(p - 1) != '\\')             /* skip escaped quote */</a>
<a name="ln2267">              in_str = FALSE;</a>
<a name="ln2268">          } else if (p == line || ((p - line) &gt;= 2</a>
<a name="ln2269">                                   /* skip #\&quot; form */</a>
<a name="ln2270">                                   &amp;&amp; *(p - 1) != '\\' &amp;&amp; *(p - 2) != '#'))</a>
<a name="ln2271">            in_str = TRUE;</a>
<a name="ln2272">        } else if (!in_str &amp;&amp; ((p - line) &lt; 2</a>
<a name="ln2273">                               || (*(p - 1) != '\\' &amp;&amp; *(p - 2) != '#')))</a>
<a name="ln2274">          break;                /* found! */</a>
<a name="ln2275">        ++p;</a>
<a name="ln2276">      }</a>
<a name="ln2277">    } else</a>
<a name="ln2278">      p = NULL;</a>
<a name="ln2279">  } else</a>
<a name="ln2280">    while ((p = vim_strchr(p, '/')) != NULL) {</a>
<a name="ln2281">      /* accept a double /, unless it's preceded with * and followed by *,</a>
<a name="ln2282">       * because * / / * is an end and start of a C comment */</a>
<a name="ln2283">      if (p[1] == '/' &amp;&amp; (p == line || p[-1] != '*' || p[2] != '*'))</a>
<a name="ln2284">        break;</a>
<a name="ln2285">      ++p;</a>
<a name="ln2286">    }</a>
<a name="ln2287"> </a>
<a name="ln2288">  if (p == NULL)</a>
<a name="ln2289">    return MAXCOL;</a>
<a name="ln2290">  return (int)(p - line);</a>
<a name="ln2291">}</a>
<a name="ln2292"> </a>
<a name="ln2293">/*</a>
<a name="ln2294"> * Move cursor briefly to character matching the one under the cursor.</a>
<a name="ln2295"> * Used for Insert mode and &quot;r&quot; command.</a>
<a name="ln2296"> * Show the match only if it is visible on the screen.</a>
<a name="ln2297"> * If there isn't a match, then beep.</a>
<a name="ln2298"> */</a>
<a name="ln2299">void</a>
<a name="ln2300">showmatch(</a>
<a name="ln2301">    int c                      // char to show match for</a>
<a name="ln2302">)</a>
<a name="ln2303">{</a>
<a name="ln2304">  pos_T       *lpos, save_cursor;</a>
<a name="ln2305">  pos_T mpos;</a>
<a name="ln2306">  colnr_T vcol;</a>
<a name="ln2307">  long *so = curwin-&gt;w_p_so &gt;= 0 ? &amp;curwin-&gt;w_p_so : &amp;p_so;</a>
<a name="ln2308">  long *siso = curwin-&gt;w_p_siso &gt;= 0 ? &amp;curwin-&gt;w_p_siso : &amp;p_siso;</a>
<a name="ln2309">  long save_so;</a>
<a name="ln2310">  long save_siso;</a>
<a name="ln2311">  int save_state;</a>
<a name="ln2312">  colnr_T save_dollar_vcol;</a>
<a name="ln2313">  char_u      *p;</a>
<a name="ln2314"> </a>
<a name="ln2315">  /*</a>
<a name="ln2316">   * Only show match for chars in the 'matchpairs' option.</a>
<a name="ln2317">   */</a>
<a name="ln2318">  /* 'matchpairs' is &quot;x:y,x:y&quot; */</a>
<a name="ln2319">  for (p = curbuf-&gt;b_p_mps; *p != NUL; ++p) {</a>
<a name="ln2320">    if (PTR2CHAR(p) == c &amp;&amp; (curwin-&gt;w_p_rl ^ p_ri))</a>
<a name="ln2321">      break;</a>
<a name="ln2322">    p += utfc_ptr2len(p) + 1;</a>
<a name="ln2323">    if (PTR2CHAR(p) == c &amp;&amp; !(curwin-&gt;w_p_rl ^ p_ri)) {</a>
<a name="ln2324">      break;</a>
<a name="ln2325">    }</a>
<a name="ln2326">    p += utfc_ptr2len(p);</a>
<a name="ln2327">    if (*p == NUL) {</a>
<a name="ln2328">      return;</a>
<a name="ln2329">    }</a>
<a name="ln2330">  }</a>
<a name="ln2331">  if (*p == NUL) {</a>
<a name="ln2332">    return;</a>
<a name="ln2333">  }</a>
<a name="ln2334"> </a>
<a name="ln2335">  if ((lpos = findmatch(NULL, NUL)) == NULL) {  // no match, so beep</a>
<a name="ln2336">    vim_beep(BO_MATCH);</a>
<a name="ln2337">  } else if (lpos-&gt;lnum &gt;= curwin-&gt;w_topline</a>
<a name="ln2338">      &amp;&amp; lpos-&gt;lnum &lt; curwin-&gt;w_botline) {</a>
<a name="ln2339">    if (!curwin-&gt;w_p_wrap) {</a>
<a name="ln2340">      getvcol(curwin, lpos, NULL, &amp;vcol, NULL);</a>
<a name="ln2341">    }</a>
<a name="ln2342">    if (curwin-&gt;w_p_wrap</a>
<a name="ln2343">        || (vcol &gt;= curwin-&gt;w_leftcol</a>
<a name="ln2344">            &amp;&amp; vcol &lt; curwin-&gt;w_leftcol + curwin-&gt;w_width_inner)) {</a>
<a name="ln2345">      mpos = *lpos;  // save the pos, update_screen() may change it</a>
<a name="ln2346">      save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln2347">      save_so = *so;</a>
<a name="ln2348">      save_siso = *siso;</a>
<a name="ln2349">      // Handle &quot;$&quot; in 'cpo': If the ')' is typed on top of the &quot;$&quot;,</a>
<a name="ln2350">      // stop displaying the &quot;$&quot;.</a>
<a name="ln2351">      if (dollar_vcol &gt;= 0 &amp;&amp; dollar_vcol == curwin-&gt;w_virtcol) {</a>
<a name="ln2352">        dollar_vcol = -1;</a>
<a name="ln2353">      }</a>
<a name="ln2354">      curwin-&gt;w_virtcol++;              // do display ')' just before &quot;$&quot;</a>
<a name="ln2355">      update_screen(VALID);             // show the new char first</a>
<a name="ln2356"> </a>
<a name="ln2357">      save_dollar_vcol = dollar_vcol;</a>
<a name="ln2358">      save_state = State;</a>
<a name="ln2359">      State = SHOWMATCH;</a>
<a name="ln2360">      ui_cursor_shape();                // may show different cursor shape</a>
<a name="ln2361">      curwin-&gt;w_cursor = mpos;          // move to matching char</a>
<a name="ln2362">      *so = 0;                          // don't use 'scrolloff' here</a>
<a name="ln2363">      *siso = 0;                        // don't use 'sidescrolloff' here</a>
<a name="ln2364">      showruler(false);</a>
<a name="ln2365">      setcursor();</a>
<a name="ln2366">      ui_flush();</a>
<a name="ln2367">      /* Restore dollar_vcol(), because setcursor() may call curs_rows()</a>
<a name="ln2368">       * which resets it if the matching position is in a previous line</a>
<a name="ln2369">       * and has a higher column number. */</a>
<a name="ln2370">      dollar_vcol = save_dollar_vcol;</a>
<a name="ln2371"> </a>
<a name="ln2372">      /*</a>
<a name="ln2373">       * brief pause, unless 'm' is present in 'cpo' and a character is</a>
<a name="ln2374">       * available.</a>
<a name="ln2375">       */</a>
<a name="ln2376">      if (vim_strchr(p_cpo, CPO_SHOWMATCH) != NULL) {</a>
<a name="ln2377">        os_delay(p_mat * 100L + 8, true);</a>
<a name="ln2378">      } else if (!char_avail()) {</a>
<a name="ln2379">        os_delay(p_mat * 100L + 9, false);</a>
<a name="ln2380">      }</a>
<a name="ln2381">      curwin-&gt;w_cursor = save_cursor;           // restore cursor position</a>
<a name="ln2382">      *so = save_so;</a>
<a name="ln2383">      *siso = save_siso;</a>
<a name="ln2384">      State = save_state;</a>
<a name="ln2385">      ui_cursor_shape();                // may show different cursor shape</a>
<a name="ln2386">    }</a>
<a name="ln2387">  }</a>
<a name="ln2388">}</a>
<a name="ln2389"> </a>
<a name="ln2390">// Find the start of the next sentence, searching in the direction specified</a>
<a name="ln2391">// by the &quot;dir&quot; argument.  The cursor is positioned on the start of the next</a>
<a name="ln2392">// sentence when found.  If the next sentence is found, return OK.  Return FAIL</a>
<a name="ln2393">// otherwise.  See &quot;:h sentence&quot; for the precise definition of a &quot;sentence&quot;</a>
<a name="ln2394">// text object.</a>
<a name="ln2395">int findsent(Direction dir, long count)</a>
<a name="ln2396">{</a>
<a name="ln2397">  pos_T pos, tpos;</a>
<a name="ln2398">  int c;</a>
<a name="ln2399">  int         (*func)(pos_T *);</a>
<a name="ln2400">  bool noskip = false;              // do not skip blanks</a>
<a name="ln2401"> </a>
<a name="ln2402">  pos = curwin-&gt;w_cursor;</a>
<a name="ln2403">  if (dir == FORWARD)</a>
<a name="ln2404">    func = incl;</a>
<a name="ln2405">  else</a>
<a name="ln2406">    func = decl;</a>
<a name="ln2407"> </a>
<a name="ln2408">  while (count--) {</a>
<a name="ln2409">    const pos_T prev_pos = pos;</a>
<a name="ln2410"> </a>
<a name="ln2411">    // if on an empty line, skip up to a non-empty line</a>
<a name="ln2412">    if (gchar_pos(&amp;pos) == NUL) {</a>
<a name="ln2413">      do {</a>
<a name="ln2414">        if ((*func)(&amp;pos) == -1) {</a>
<a name="ln2415">          break;</a>
<a name="ln2416">        }</a>
<a name="ln2417">      } while (gchar_pos(&amp;pos) == NUL);</a>
<a name="ln2418">      if (dir == FORWARD) {</a>
<a name="ln2419">        goto found;</a>
<a name="ln2420">      }</a>
<a name="ln2421">    // if on the start of a paragraph or a section and searching forward,</a>
<a name="ln2422">    // go to the next line</a>
<a name="ln2423">    } else if (dir == FORWARD &amp;&amp; pos.col == 0</a>
<a name="ln2424">               &amp;&amp; startPS(pos.lnum, NUL, false)) {</a>
<a name="ln2425">      if (pos.lnum == curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2426">        return FAIL;</a>
<a name="ln2427">      }</a>
<a name="ln2428">      pos.lnum++;</a>
<a name="ln2429">      goto found;</a>
<a name="ln2430">    } else if (dir == BACKWARD) {</a>
<a name="ln2431">      decl(&amp;pos);</a>
<a name="ln2432">    }</a>
<a name="ln2433"> </a>
<a name="ln2434">    // go back to the previous non-white non-punctuation character</a>
<a name="ln2435">    bool found_dot = false;</a>
<a name="ln2436">    while (c = gchar_pos(&amp;pos), ascii_iswhite(c)</a>
<a name="ln2437">           || vim_strchr((char_u *)&quot;.!?)]\&quot;'&quot;, c) != NULL) {</a>
<a name="ln2438">      tpos = pos;</a>
<a name="ln2439">      if (decl(&amp;tpos) == -1 || (LINEEMPTY(tpos.lnum) &amp;&amp; dir == FORWARD)) {</a>
<a name="ln2440">        break;</a>
<a name="ln2441">      }</a>
<a name="ln2442">      if (found_dot) {</a>
<a name="ln2443">        break;</a>
<a name="ln2444">      }</a>
<a name="ln2445">      if (vim_strchr((char_u *) &quot;.!?&quot;, c) != NULL) {</a>
<a name="ln2446">        found_dot = true;</a>
<a name="ln2447">      }</a>
<a name="ln2448">      if (vim_strchr((char_u *) &quot;)]\&quot;'&quot;, c) != NULL</a>
<a name="ln2449">          &amp;&amp; vim_strchr((char_u *) &quot;.!?)]\&quot;'&quot;, gchar_pos(&amp;tpos)) == NULL) {</a>
<a name="ln2450">        break;</a>
<a name="ln2451">      }</a>
<a name="ln2452">      decl(&amp;pos);</a>
<a name="ln2453">    }</a>
<a name="ln2454"> </a>
<a name="ln2455">    // remember the line where the search started</a>
<a name="ln2456">    const int startlnum = pos.lnum;</a>
<a name="ln2457">    const bool cpo_J = vim_strchr(p_cpo, CPO_ENDOFSENT) != NULL;</a>
<a name="ln2458"> </a>
<a name="ln2459">    for (;; ) {                 /* find end of sentence */</a>
<a name="ln2460">      c = gchar_pos(&amp;pos);</a>
<a name="ln2461">      if (c == NUL || (pos.col == 0 &amp;&amp; startPS(pos.lnum, NUL, FALSE))) {</a>
<a name="ln2462">        if (dir == BACKWARD &amp;&amp; pos.lnum != startlnum)</a>
<a name="ln2463">          ++pos.lnum;</a>
<a name="ln2464">        break;</a>
<a name="ln2465">      }</a>
<a name="ln2466">      if (c == '.' || c == '!' || c == '?') {</a>
<a name="ln2467">        tpos = pos;</a>
<a name="ln2468">        do</a>
<a name="ln2469">          if ((c = inc(&amp;tpos)) == -1)</a>
<a name="ln2470">            break;</a>
<a name="ln2471">        while (vim_strchr((char_u *)&quot;)]\&quot;'&quot;, c = gchar_pos(&amp;tpos))</a>
<a name="ln2472">               != NULL);</a>
<a name="ln2473">        if (c == -1  || (!cpo_J &amp;&amp; (c == ' ' || c == '\t')) || c == NUL</a>
<a name="ln2474">            || (cpo_J &amp;&amp; (c == ' ' &amp;&amp; inc(&amp;tpos) &gt;= 0</a>
<a name="ln2475">                          &amp;&amp; gchar_pos(&amp;tpos) == ' '))) {</a>
<a name="ln2476">          pos = tpos;</a>
<a name="ln2477">          if (gchar_pos(&amp;pos) == NUL)           /* skip NUL at EOL */</a>
<a name="ln2478">            inc(&amp;pos);</a>
<a name="ln2479">          break;</a>
<a name="ln2480">        }</a>
<a name="ln2481">      }</a>
<a name="ln2482">      if ((*func)(&amp;pos) == -1) {</a>
<a name="ln2483">        if (count)</a>
<a name="ln2484">          return FAIL;</a>
<a name="ln2485">        noskip = true;</a>
<a name="ln2486">        break;</a>
<a name="ln2487">      }</a>
<a name="ln2488">    }</a>
<a name="ln2489">found:</a>
<a name="ln2490">    /* skip white space */</a>
<a name="ln2491">    while (!noskip &amp;&amp; ((c = gchar_pos(&amp;pos)) == ' ' || c == '\t'))</a>
<a name="ln2492">      if (incl(&amp;pos) == -1)</a>
<a name="ln2493">        break;</a>
<a name="ln2494"> </a>
<a name="ln2495">    if (equalpos(prev_pos, pos)) {</a>
<a name="ln2496">      // didn't actually move, advance one character and try again</a>
<a name="ln2497">      if ((*func)(&amp;pos) == -1) {</a>
<a name="ln2498">        if (count) {</a>
<a name="ln2499">          return FAIL;</a>
<a name="ln2500">        }</a>
<a name="ln2501">        break;</a>
<a name="ln2502">      }</a>
<a name="ln2503">      count++;</a>
<a name="ln2504">    }</a>
<a name="ln2505">  }</a>
<a name="ln2506"> </a>
<a name="ln2507">  setpcmark();</a>
<a name="ln2508">  curwin-&gt;w_cursor = pos;</a>
<a name="ln2509">  return OK;</a>
<a name="ln2510">}</a>
<a name="ln2511"> </a>
<a name="ln2512">/*</a>
<a name="ln2513"> * Find the next paragraph or section in direction 'dir'.</a>
<a name="ln2514"> * Paragraphs are currently supposed to be separated by empty lines.</a>
<a name="ln2515"> * If 'what' is NUL we go to the next paragraph.</a>
<a name="ln2516"> * If 'what' is '{' or '}' we go to the next section.</a>
<a name="ln2517"> * If 'both' is TRUE also stop at '}'.</a>
<a name="ln2518"> * Return TRUE if the next paragraph or section was found.</a>
<a name="ln2519"> */</a>
<a name="ln2520">bool</a>
<a name="ln2521">findpar (</a>
<a name="ln2522">    bool *pincl,        /* Return: true if last char is to be included */</a>
<a name="ln2523">    int dir,</a>
<a name="ln2524">    long count,</a>
<a name="ln2525">    int what,</a>
<a name="ln2526">    int both</a>
<a name="ln2527">)</a>
<a name="ln2528">{</a>
<a name="ln2529">  linenr_T curr;</a>
<a name="ln2530">  bool did_skip;            /* true after separating lines have been skipped */</a>
<a name="ln2531">  bool first;               /* true on first line */</a>
<a name="ln2532">  linenr_T fold_first;      /* first line of a closed fold */</a>
<a name="ln2533">  linenr_T fold_last;       /* last line of a closed fold */</a>
<a name="ln2534">  bool fold_skipped;        /* true if a closed fold was skipped this</a>
<a name="ln2535">                               iteration */</a>
<a name="ln2536"> </a>
<a name="ln2537">  curr = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2538"> </a>
<a name="ln2539">  while (count--) {</a>
<a name="ln2540">    did_skip = false;</a>
<a name="ln2541">    for (first = true;; first = false) {</a>
<a name="ln2542">      if (*ml_get(curr) != NUL)</a>
<a name="ln2543">        did_skip = true;</a>
<a name="ln2544"> </a>
<a name="ln2545">      /* skip folded lines */</a>
<a name="ln2546">      fold_skipped = false;</a>
<a name="ln2547">      if (first &amp;&amp; hasFolding(curr, &amp;fold_first, &amp;fold_last)) {</a>
<a name="ln2548">        curr = ((dir &gt; 0) ? fold_last : fold_first) + dir;</a>
<a name="ln2549">        fold_skipped = true;</a>
<a name="ln2550">      }</a>
<a name="ln2551"> </a>
<a name="ln2552">      if (!first &amp;&amp; did_skip &amp;&amp; startPS(curr, what, both))</a>
<a name="ln2553">        break;</a>
<a name="ln2554"> </a>
<a name="ln2555">      if (fold_skipped)</a>
<a name="ln2556">        curr -= dir;</a>
<a name="ln2557">      if ((curr += dir) &lt; 1 || curr &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2558">        if (count)</a>
<a name="ln2559">          return false;</a>
<a name="ln2560">        curr -= dir;</a>
<a name="ln2561">        break;</a>
<a name="ln2562">      }</a>
<a name="ln2563">    }</a>
<a name="ln2564">  }</a>
<a name="ln2565">  setpcmark();</a>
<a name="ln2566">  if (both &amp;&amp; *ml_get(curr) == '}')     /* include line with '}' */</a>
<a name="ln2567">    ++curr;</a>
<a name="ln2568">  curwin-&gt;w_cursor.lnum = curr;</a>
<a name="ln2569">  if (curr == curbuf-&gt;b_ml.ml_line_count &amp;&amp; what != '}') {</a>
<a name="ln2570">    char_u *line = ml_get(curr);</a>
<a name="ln2571"> </a>
<a name="ln2572">    // Put the cursor on the last character in the last line and make the</a>
<a name="ln2573">    // motion inclusive.</a>
<a name="ln2574">    if ((curwin-&gt;w_cursor.col = (colnr_T)STRLEN(line)) != 0) {</a>
<a name="ln2575">      curwin-&gt;w_cursor.col--;</a>
<a name="ln2576">      curwin-&gt;w_cursor.col -= utf_head_off(line, line + curwin-&gt;w_cursor.col);</a>
<a name="ln2577">      *pincl = true;</a>
<a name="ln2578">    }</a>
<a name="ln2579">  } else</a>
<a name="ln2580">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln2581">  return true;</a>
<a name="ln2582">}</a>
<a name="ln2583"> </a>
<a name="ln2584">/*</a>
<a name="ln2585"> * check if the string 's' is a nroff macro that is in option 'opt'</a>
<a name="ln2586"> */</a>
<a name="ln2587">static int inmacro(char_u *opt, char_u *s)</a>
<a name="ln2588">{</a>
<a name="ln2589">  char_u      *macro;</a>
<a name="ln2590"> </a>
<a name="ln2591">  for (macro = opt; macro[0]; ++macro) {</a>
<a name="ln2592">    /* Accept two characters in the option being equal to two characters</a>
<a name="ln2593">     * in the line.  A space in the option matches with a space in the</a>
<a name="ln2594">     * line or the line having ended. */</a>
<a name="ln2595">    if (       (macro[0] == s[0]</a>
<a name="ln2596">                || (macro[0] == ' '</a>
<a name="ln2597">                    &amp;&amp; (s[0] == NUL || s[0] == ' ')))</a>
<a name="ln2598">               &amp;&amp; (macro[1] == s[1]</a>
<a name="ln2599">                   || ((macro[1] == NUL || macro[1] == ' ')</a>
<a name="ln2600">                       &amp;&amp; (s[0] == NUL || s[1] == NUL || s[1] == ' '))))</a>
<a name="ln2601">      break;</a>
<a name="ln2602">    ++macro;</a>
<a name="ln2603">    if (macro[0] == NUL)</a>
<a name="ln2604">      break;</a>
<a name="ln2605">  }</a>
<a name="ln2606">  return macro[0] != NUL;</a>
<a name="ln2607">}</a>
<a name="ln2608"> </a>
<a name="ln2609">/*</a>
<a name="ln2610"> * startPS: return TRUE if line 'lnum' is the start of a section or paragraph.</a>
<a name="ln2611"> * If 'para' is '{' or '}' only check for sections.</a>
<a name="ln2612"> * If 'both' is TRUE also stop at '}'</a>
<a name="ln2613"> */</a>
<a name="ln2614">int startPS(linenr_T lnum, int para, int both)</a>
<a name="ln2615">{</a>
<a name="ln2616">  char_u      *s;</a>
<a name="ln2617"> </a>
<a name="ln2618">  s = ml_get(lnum);</a>
<a name="ln2619">  if (*s == para || *s == '\f' || (both &amp;&amp; *s == '}')) {</a>
<a name="ln2620">    return true;</a>
<a name="ln2621">  }</a>
<a name="ln2622">  if (*s == '.' &amp;&amp; (inmacro(p_sections, s + 1)</a>
<a name="ln2623">                    || (!para &amp;&amp; inmacro(p_para, s + 1)))) {</a>
<a name="ln2624">    return true;</a>
<a name="ln2625">  }</a>
<a name="ln2626">  return false;</a>
<a name="ln2627">}</a>
<a name="ln2628"> </a>
<a name="ln2629">/*</a>
<a name="ln2630"> * The following routines do the word searches performed by the 'w', 'W',</a>
<a name="ln2631"> * 'b', 'B', 'e', and 'E' commands.</a>
<a name="ln2632"> */</a>
<a name="ln2633"> </a>
<a name="ln2634">/*</a>
<a name="ln2635"> * To perform these searches, characters are placed into one of three</a>
<a name="ln2636"> * classes, and transitions between classes determine word boundaries.</a>
<a name="ln2637"> *</a>
<a name="ln2638"> * The classes are:</a>
<a name="ln2639"> *</a>
<a name="ln2640"> * 0 - white space</a>
<a name="ln2641"> * 1 - punctuation</a>
<a name="ln2642"> * 2 or higher - keyword characters (letters, digits and underscore)</a>
<a name="ln2643"> */</a>
<a name="ln2644"> </a>
<a name="ln2645">static int cls_bigword;         /* TRUE for &quot;W&quot;, &quot;B&quot; or &quot;E&quot; */</a>
<a name="ln2646"> </a>
<a name="ln2647">/*</a>
<a name="ln2648"> * cls() - returns the class of character at curwin-&gt;w_cursor</a>
<a name="ln2649"> *</a>
<a name="ln2650"> * If a 'W', 'B', or 'E' motion is being done (cls_bigword == TRUE), chars</a>
<a name="ln2651"> * from class 2 and higher are reported as class 1 since only white space</a>
<a name="ln2652"> * boundaries are of interest.</a>
<a name="ln2653"> */</a>
<a name="ln2654">static int cls(void)</a>
<a name="ln2655">{</a>
<a name="ln2656">  int c;</a>
<a name="ln2657"> </a>
<a name="ln2658">  c = gchar_cursor();</a>
<a name="ln2659">  if (c == ' ' || c == '\t' || c == NUL) {</a>
<a name="ln2660">    return 0;</a>
<a name="ln2661">  }</a>
<a name="ln2662"> </a>
<a name="ln2663">  c = utf_class(c);</a>
<a name="ln2664"> </a>
<a name="ln2665">  // If cls_bigword is TRUE, report all non-blanks as class 1.</a>
<a name="ln2666">  if (c != 0 &amp;&amp; cls_bigword) {</a>
<a name="ln2667">    return 1;</a>
<a name="ln2668">  }</a>
<a name="ln2669">  return c;</a>
<a name="ln2670">}</a>
<a name="ln2671"> </a>
<a name="ln2672">/*</a>
<a name="ln2673"> * fwd_word(count, type, eol) - move forward one word</a>
<a name="ln2674"> *</a>
<a name="ln2675"> * Returns FAIL if the cursor was already at the end of the file.</a>
<a name="ln2676"> * If eol is TRUE, last word stops at end of line (for operators).</a>
<a name="ln2677"> */</a>
<a name="ln2678">int</a>
<a name="ln2679">fwd_word(</a>
<a name="ln2680">    long count,</a>
<a name="ln2681">    int bigword,                /* &quot;W&quot;, &quot;E&quot; or &quot;B&quot; */</a>
<a name="ln2682">    int eol</a>
<a name="ln2683">)</a>
<a name="ln2684">{</a>
<a name="ln2685">  int sclass;               /* starting class */</a>
<a name="ln2686">  int i;</a>
<a name="ln2687">  int last_line;</a>
<a name="ln2688"> </a>
<a name="ln2689">  curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2690">  cls_bigword = bigword;</a>
<a name="ln2691">  while (--count &gt;= 0) {</a>
<a name="ln2692">    /* When inside a range of folded lines, move to the last char of the</a>
<a name="ln2693">     * last line. */</a>
<a name="ln2694">    if (hasFolding(curwin-&gt;w_cursor.lnum, NULL, &amp;curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln2695">      coladvance(MAXCOL);</a>
<a name="ln2696">    }</a>
<a name="ln2697">    sclass = cls();</a>
<a name="ln2698"> </a>
<a name="ln2699">    /*</a>
<a name="ln2700">     * We always move at least one character, unless on the last</a>
<a name="ln2701">     * character in the buffer.</a>
<a name="ln2702">     */</a>
<a name="ln2703">    last_line = (curwin-&gt;w_cursor.lnum == curbuf-&gt;b_ml.ml_line_count);</a>
<a name="ln2704">    i = inc_cursor();</a>
<a name="ln2705">    if (i == -1 || (i &gt;= 1 &amp;&amp; last_line))     /* started at last char in file */</a>
<a name="ln2706">      return FAIL;</a>
<a name="ln2707">    if (i &gt;= 1 &amp;&amp; eol &amp;&amp; count == 0)          /* started at last char in line */</a>
<a name="ln2708">      return OK;</a>
<a name="ln2709"> </a>
<a name="ln2710">    /*</a>
<a name="ln2711">     * Go one char past end of current word (if any)</a>
<a name="ln2712">     */</a>
<a name="ln2713">    if (sclass != 0)</a>
<a name="ln2714">      while (cls() == sclass) {</a>
<a name="ln2715">        i = inc_cursor();</a>
<a name="ln2716">        if (i == -1 || (i &gt;= 1 &amp;&amp; eol &amp;&amp; count == 0))</a>
<a name="ln2717">          return OK;</a>
<a name="ln2718">      }</a>
<a name="ln2719"> </a>
<a name="ln2720">    /*</a>
<a name="ln2721">     * go to next non-white</a>
<a name="ln2722">     */</a>
<a name="ln2723">    while (cls() == 0) {</a>
<a name="ln2724">      /*</a>
<a name="ln2725">       * We'll stop if we land on a blank line</a>
<a name="ln2726">       */</a>
<a name="ln2727">      if (curwin-&gt;w_cursor.col == 0 &amp;&amp; *get_cursor_line_ptr() == NUL)</a>
<a name="ln2728">        break;</a>
<a name="ln2729"> </a>
<a name="ln2730">      i = inc_cursor();</a>
<a name="ln2731">      if (i == -1 || (i &gt;= 1 &amp;&amp; eol &amp;&amp; count == 0))</a>
<a name="ln2732">        return OK;</a>
<a name="ln2733">    }</a>
<a name="ln2734">  }</a>
<a name="ln2735">  return OK;</a>
<a name="ln2736">}</a>
<a name="ln2737"> </a>
<a name="ln2738">/*</a>
<a name="ln2739"> * bck_word() - move backward 'count' words</a>
<a name="ln2740"> *</a>
<a name="ln2741"> * If stop is TRUE and we are already on the start of a word, move one less.</a>
<a name="ln2742"> *</a>
<a name="ln2743"> * Returns FAIL if top of the file was reached.</a>
<a name="ln2744"> */</a>
<a name="ln2745">int bck_word(long count, int bigword, int stop)</a>
<a name="ln2746">{</a>
<a name="ln2747">  int sclass;               /* starting class */</a>
<a name="ln2748"> </a>
<a name="ln2749">  curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2750">  cls_bigword = bigword;</a>
<a name="ln2751">  while (--count &gt;= 0) {</a>
<a name="ln2752">    /* When inside a range of folded lines, move to the first char of the</a>
<a name="ln2753">     * first line. */</a>
<a name="ln2754">    if (hasFolding(curwin-&gt;w_cursor.lnum, &amp;curwin-&gt;w_cursor.lnum, NULL))</a>
<a name="ln2755">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln2756">    sclass = cls();</a>
<a name="ln2757">    if (dec_cursor() == -1)             /* started at start of file */</a>
<a name="ln2758">      return FAIL;</a>
<a name="ln2759"> </a>
<a name="ln2760">    if (!stop || sclass == cls() || sclass == 0) {</a>
<a name="ln2761">      /*</a>
<a name="ln2762">       * Skip white space before the word.</a>
<a name="ln2763">       * Stop on an empty line.</a>
<a name="ln2764">       */</a>
<a name="ln2765">      while (cls() == 0) {</a>
<a name="ln2766">        if (curwin-&gt;w_cursor.col == 0</a>
<a name="ln2767">            &amp;&amp; LINEEMPTY(curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln2768">          goto finished;</a>
<a name="ln2769">        }</a>
<a name="ln2770">        if (dec_cursor() == -1) {       // hit start of file, stop here</a>
<a name="ln2771">          return OK;</a>
<a name="ln2772">        }</a>
<a name="ln2773">      }</a>
<a name="ln2774"> </a>
<a name="ln2775">      /*</a>
<a name="ln2776">       * Move backward to start of this word.</a>
<a name="ln2777">       */</a>
<a name="ln2778">      if (skip_chars(cls(), BACKWARD))</a>
<a name="ln2779">        return OK;</a>
<a name="ln2780">    }</a>
<a name="ln2781"> </a>
<a name="ln2782">    inc_cursor();                       /* overshot - forward one */</a>
<a name="ln2783">finished:</a>
<a name="ln2784">    stop = FALSE;</a>
<a name="ln2785">  }</a>
<a name="ln2786">  return OK;</a>
<a name="ln2787">}</a>
<a name="ln2788"> </a>
<a name="ln2789">/*</a>
<a name="ln2790"> * end_word() - move to the end of the word</a>
<a name="ln2791"> *</a>
<a name="ln2792"> * There is an apparent bug in the 'e' motion of the real vi. At least on the</a>
<a name="ln2793"> * System V Release 3 version for the 80386. Unlike 'b' and 'w', the 'e'</a>
<a name="ln2794"> * motion crosses blank lines. When the real vi crosses a blank line in an</a>
<a name="ln2795"> * 'e' motion, the cursor is placed on the FIRST character of the next</a>
<a name="ln2796"> * non-blank line. The 'E' command, however, works correctly. Since this</a>
<a name="ln2797"> * appears to be a bug, I have not duplicated it here.</a>
<a name="ln2798"> *</a>
<a name="ln2799"> * Returns FAIL if end of the file was reached.</a>
<a name="ln2800"> *</a>
<a name="ln2801"> * If stop is TRUE and we are already on the end of a word, move one less.</a>
<a name="ln2802"> * If empty is TRUE stop on an empty line.</a>
<a name="ln2803"> */</a>
<a name="ln2804">int end_word(long count, int bigword, int stop, int empty)</a>
<a name="ln2805">{</a>
<a name="ln2806">  int sclass;               /* starting class */</a>
<a name="ln2807"> </a>
<a name="ln2808">  curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2809">  cls_bigword = bigword;</a>
<a name="ln2810">  while (--count &gt;= 0) {</a>
<a name="ln2811">    /* When inside a range of folded lines, move to the last char of the</a>
<a name="ln2812">     * last line. */</a>
<a name="ln2813">    if (hasFolding(curwin-&gt;w_cursor.lnum, NULL, &amp;curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln2814">      coladvance(MAXCOL);</a>
<a name="ln2815">    }</a>
<a name="ln2816">    sclass = cls();</a>
<a name="ln2817">    if (inc_cursor() == -1)</a>
<a name="ln2818">      return FAIL;</a>
<a name="ln2819"> </a>
<a name="ln2820">    /*</a>
<a name="ln2821">     * If we're in the middle of a word, we just have to move to the end</a>
<a name="ln2822">     * of it.</a>
<a name="ln2823">     */</a>
<a name="ln2824">    if (cls() == sclass &amp;&amp; sclass != 0) {</a>
<a name="ln2825">      /*</a>
<a name="ln2826">       * Move forward to end of the current word</a>
<a name="ln2827">       */</a>
<a name="ln2828">      if (skip_chars(sclass, FORWARD))</a>
<a name="ln2829">        return FAIL;</a>
<a name="ln2830">    } else if (!stop || sclass == 0) {</a>
<a name="ln2831">      /*</a>
<a name="ln2832">       * We were at the end of a word. Go to the end of the next word.</a>
<a name="ln2833">       * First skip white space, if 'empty' is TRUE, stop at empty line.</a>
<a name="ln2834">       */</a>
<a name="ln2835">      while (cls() == 0) {</a>
<a name="ln2836">        if (empty &amp;&amp; curwin-&gt;w_cursor.col == 0</a>
<a name="ln2837">            &amp;&amp; LINEEMPTY(curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln2838">          goto finished;</a>
<a name="ln2839">        }</a>
<a name="ln2840">        if (inc_cursor() == -1) {           // hit end of file, stop here</a>
<a name="ln2841">          return FAIL;</a>
<a name="ln2842">        }</a>
<a name="ln2843">      }</a>
<a name="ln2844"> </a>
<a name="ln2845">      /*</a>
<a name="ln2846">       * Move forward to the end of this word.</a>
<a name="ln2847">       */</a>
<a name="ln2848">      if (skip_chars(cls(), FORWARD))</a>
<a name="ln2849">        return FAIL;</a>
<a name="ln2850">    }</a>
<a name="ln2851">    dec_cursor();                       /* overshot - one char backward */</a>
<a name="ln2852">finished:</a>
<a name="ln2853">    stop = FALSE;                       /* we move only one word less */</a>
<a name="ln2854">  }</a>
<a name="ln2855">  return OK;</a>
<a name="ln2856">}</a>
<a name="ln2857"> </a>
<a name="ln2858">/*</a>
<a name="ln2859"> * Move back to the end of the word.</a>
<a name="ln2860"> *</a>
<a name="ln2861"> * Returns FAIL if start of the file was reached.</a>
<a name="ln2862"> */</a>
<a name="ln2863">int</a>
<a name="ln2864">bckend_word(</a>
<a name="ln2865">    long count,</a>
<a name="ln2866">    int bigword,                /* TRUE for &quot;B&quot; */</a>
<a name="ln2867">    int eol                    /* TRUE: stop at end of line. */</a>
<a name="ln2868">)</a>
<a name="ln2869">{</a>
<a name="ln2870">  int sclass;               /* starting class */</a>
<a name="ln2871">  int i;</a>
<a name="ln2872"> </a>
<a name="ln2873">  curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2874">  cls_bigword = bigword;</a>
<a name="ln2875">  while (--count &gt;= 0) {</a>
<a name="ln2876">    sclass = cls();</a>
<a name="ln2877">    if ((i = dec_cursor()) == -1)</a>
<a name="ln2878">      return FAIL;</a>
<a name="ln2879">    if (eol &amp;&amp; i == 1)</a>
<a name="ln2880">      return OK;</a>
<a name="ln2881"> </a>
<a name="ln2882">    /*</a>
<a name="ln2883">     * Move backward to before the start of this word.</a>
<a name="ln2884">     */</a>
<a name="ln2885">    if (sclass != 0) {</a>
<a name="ln2886">      while (cls() == sclass)</a>
<a name="ln2887">        if ((i = dec_cursor()) == -1 || (eol &amp;&amp; i == 1))</a>
<a name="ln2888">          return OK;</a>
<a name="ln2889">    }</a>
<a name="ln2890"> </a>
<a name="ln2891">    /*</a>
<a name="ln2892">     * Move backward to end of the previous word</a>
<a name="ln2893">     */</a>
<a name="ln2894">    while (cls() == 0) {</a>
<a name="ln2895">      if (curwin-&gt;w_cursor.col == 0 &amp;&amp; LINEEMPTY(curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln2896">        break;</a>
<a name="ln2897">      }</a>
<a name="ln2898">      if ((i = dec_cursor()) == -1 || (eol &amp;&amp; i == 1)) {</a>
<a name="ln2899">        return OK;</a>
<a name="ln2900">      }</a>
<a name="ln2901">    }</a>
<a name="ln2902">  }</a>
<a name="ln2903">  return OK;</a>
<a name="ln2904">}</a>
<a name="ln2905"> </a>
<a name="ln2906">/*</a>
<a name="ln2907"> * Skip a row of characters of the same class.</a>
<a name="ln2908"> * Return TRUE when end-of-file reached, FALSE otherwise.</a>
<a name="ln2909"> */</a>
<a name="ln2910">static int skip_chars(int cclass, int dir)</a>
<a name="ln2911">{</a>
<a name="ln2912">  while (cls() == cclass)</a>
<a name="ln2913">    if ((dir == FORWARD ? inc_cursor() : dec_cursor()) == -1)</a>
<a name="ln2914">      return TRUE;</a>
<a name="ln2915">  return FALSE;</a>
<a name="ln2916">}</a>
<a name="ln2917"> </a>
<a name="ln2918">/*</a>
<a name="ln2919"> * Go back to the start of the word or the start of white space</a>
<a name="ln2920"> */</a>
<a name="ln2921">static void back_in_line(void)</a>
<a name="ln2922">{</a>
<a name="ln2923">  int sclass;                       /* starting class */</a>
<a name="ln2924"> </a>
<a name="ln2925">  sclass = cls();</a>
<a name="ln2926">  for (;; ) {</a>
<a name="ln2927">    if (curwin-&gt;w_cursor.col == 0)          /* stop at start of line */</a>
<a name="ln2928">      break;</a>
<a name="ln2929">    dec_cursor();</a>
<a name="ln2930">    if (cls() != sclass) {                  /* stop at start of word */</a>
<a name="ln2931">      inc_cursor();</a>
<a name="ln2932">      break;</a>
<a name="ln2933">    }</a>
<a name="ln2934">  }</a>
<a name="ln2935">}</a>
<a name="ln2936"> </a>
<a name="ln2937">static void find_first_blank(pos_T *posp)</a>
<a name="ln2938">{</a>
<a name="ln2939">  int c;</a>
<a name="ln2940"> </a>
<a name="ln2941">  while (decl(posp) != -1) {</a>
<a name="ln2942">    c = gchar_pos(posp);</a>
<a name="ln2943">    if (!ascii_iswhite(c)) {</a>
<a name="ln2944">      incl(posp);</a>
<a name="ln2945">      break;</a>
<a name="ln2946">    }</a>
<a name="ln2947">  }</a>
<a name="ln2948">}</a>
<a name="ln2949"> </a>
<a name="ln2950">/*</a>
<a name="ln2951"> * Skip count/2 sentences and count/2 separating white spaces.</a>
<a name="ln2952"> */</a>
<a name="ln2953">static void</a>
<a name="ln2954">findsent_forward(</a>
<a name="ln2955">    long count,</a>
<a name="ln2956">    int at_start_sent              /* cursor is at start of sentence */</a>
<a name="ln2957">)</a>
<a name="ln2958">{</a>
<a name="ln2959">  while (count--) {</a>
<a name="ln2960">    findsent(FORWARD, 1L);</a>
<a name="ln2961">    if (at_start_sent)</a>
<a name="ln2962">      find_first_blank(&amp;curwin-&gt;w_cursor);</a>
<a name="ln2963">    if (count == 0 || at_start_sent)</a>
<a name="ln2964">      decl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln2965">    at_start_sent = !at_start_sent;</a>
<a name="ln2966">  }</a>
<a name="ln2967">}</a>
<a name="ln2968"> </a>
<a name="ln2969">/*</a>
<a name="ln2970"> * Find word under cursor, cursor at end.</a>
<a name="ln2971"> * Used while an operator is pending, and in Visual mode.</a>
<a name="ln2972"> */</a>
<a name="ln2973">int</a>
<a name="ln2974">current_word(</a>
<a name="ln2975">    oparg_T *oap,</a>
<a name="ln2976">    long count,</a>
<a name="ln2977">    int include,                    /* TRUE: include word and white space */</a>
<a name="ln2978">    int bigword                    /* FALSE == word, TRUE == WORD */</a>
<a name="ln2979">)</a>
<a name="ln2980">{</a>
<a name="ln2981">  pos_T start_pos;</a>
<a name="ln2982">  pos_T pos;</a>
<a name="ln2983">  bool inclusive = true;</a>
<a name="ln2984">  int include_white = FALSE;</a>
<a name="ln2985"> </a>
<a name="ln2986">  cls_bigword = bigword;</a>
<a name="ln2987">  clearpos(&amp;start_pos);</a>
<a name="ln2988"> </a>
<a name="ln2989">  /* Correct cursor when 'selection' is exclusive */</a>
<a name="ln2990">  if (VIsual_active &amp;&amp; *p_sel == 'e' &amp;&amp; lt(VIsual, curwin-&gt;w_cursor))</a>
<a name="ln2991">    dec_cursor();</a>
<a name="ln2992"> </a>
<a name="ln2993">  /*</a>
<a name="ln2994">   * When Visual mode is not active, or when the VIsual area is only one</a>
<a name="ln2995">   * character, select the word and/or white space under the cursor.</a>
<a name="ln2996">   */</a>
<a name="ln2997">  if (!VIsual_active || equalpos(curwin-&gt;w_cursor, VIsual)) {</a>
<a name="ln2998">    /*</a>
<a name="ln2999">     * Go to start of current word or white space.</a>
<a name="ln3000">     */</a>
<a name="ln3001">    back_in_line();</a>
<a name="ln3002">    start_pos = curwin-&gt;w_cursor;</a>
<a name="ln3003"> </a>
<a name="ln3004">    /*</a>
<a name="ln3005">     * If the start is on white space, and white space should be included</a>
<a name="ln3006">     * (&quot;	word&quot;), or start is not on white space, and white space should</a>
<a name="ln3007">     * not be included (&quot;word&quot;), find end of word.</a>
<a name="ln3008">     */</a>
<a name="ln3009">    if ((cls() == 0) == include) {</a>
<a name="ln3010">      if (end_word(1L, bigword, TRUE, TRUE) == FAIL)</a>
<a name="ln3011">        return FAIL;</a>
<a name="ln3012">    } else {</a>
<a name="ln3013">      /*</a>
<a name="ln3014">       * If the start is not on white space, and white space should be</a>
<a name="ln3015">       * included (&quot;word	 &quot;), or start is on white space and white</a>
<a name="ln3016">       * space should not be included (&quot;	 &quot;), find start of word.</a>
<a name="ln3017">       * If we end up in the first column of the next line (single char</a>
<a name="ln3018">       * word) back up to end of the line.</a>
<a name="ln3019">       */</a>
<a name="ln3020">      fwd_word(1L, bigword, TRUE);</a>
<a name="ln3021">      if (curwin-&gt;w_cursor.col == 0)</a>
<a name="ln3022">        decl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3023">      else</a>
<a name="ln3024">        oneleft();</a>
<a name="ln3025"> </a>
<a name="ln3026">      if (include)</a>
<a name="ln3027">        include_white = TRUE;</a>
<a name="ln3028">    }</a>
<a name="ln3029"> </a>
<a name="ln3030">    if (VIsual_active) {</a>
<a name="ln3031">      /* should do something when inclusive == false ! */</a>
<a name="ln3032">      VIsual = start_pos;</a>
<a name="ln3033">      redraw_curbuf_later(INVERTED);            /* update the inversion */</a>
<a name="ln3034">    } else {</a>
<a name="ln3035">      oap-&gt;start = start_pos;</a>
<a name="ln3036">      oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln3037">    }</a>
<a name="ln3038">    --count;</a>
<a name="ln3039">  }</a>
<a name="ln3040"> </a>
<a name="ln3041">  /*</a>
<a name="ln3042">   * When count is still &gt; 0, extend with more objects.</a>
<a name="ln3043">   */</a>
<a name="ln3044">  while (count &gt; 0) {</a>
<a name="ln3045">    inclusive = true;</a>
<a name="ln3046">    if (VIsual_active &amp;&amp; lt(curwin-&gt;w_cursor, VIsual)) {</a>
<a name="ln3047">      /*</a>
<a name="ln3048">       * In Visual mode, with cursor at start: move cursor back.</a>
<a name="ln3049">       */</a>
<a name="ln3050">      if (decl(&amp;curwin-&gt;w_cursor) == -1)</a>
<a name="ln3051">        return FAIL;</a>
<a name="ln3052">      if (include != (cls() != 0)) {</a>
<a name="ln3053">        if (bck_word(1L, bigword, TRUE) == FAIL)</a>
<a name="ln3054">          return FAIL;</a>
<a name="ln3055">      } else {</a>
<a name="ln3056">        if (bckend_word(1L, bigword, TRUE) == FAIL)</a>
<a name="ln3057">          return FAIL;</a>
<a name="ln3058">        (void)incl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3059">      }</a>
<a name="ln3060">    } else {</a>
<a name="ln3061">      /*</a>
<a name="ln3062">       * Move cursor forward one word and/or white area.</a>
<a name="ln3063">       */</a>
<a name="ln3064">      if (incl(&amp;curwin-&gt;w_cursor) == -1)</a>
<a name="ln3065">        return FAIL;</a>
<a name="ln3066">      if (include != (cls() == 0)) {</a>
<a name="ln3067">        if (fwd_word(1L, bigword, TRUE) == FAIL &amp;&amp; count &gt; 1)</a>
<a name="ln3068">          return FAIL;</a>
<a name="ln3069">        /*</a>
<a name="ln3070">         * If end is just past a new-line, we don't want to include</a>
<a name="ln3071">         * the first character on the line.</a>
<a name="ln3072">         * Put cursor on last char of white.</a>
<a name="ln3073">         */</a>
<a name="ln3074">        if (oneleft() == FAIL)</a>
<a name="ln3075">          inclusive = false;</a>
<a name="ln3076">      } else {</a>
<a name="ln3077">        if (end_word(1L, bigword, TRUE, TRUE) == FAIL)</a>
<a name="ln3078">          return FAIL;</a>
<a name="ln3079">      }</a>
<a name="ln3080">    }</a>
<a name="ln3081">    --count;</a>
<a name="ln3082">  }</a>
<a name="ln3083"> </a>
<a name="ln3084">  if (include_white &amp;&amp; (cls() != 0</a>
<a name="ln3085">                        || (curwin-&gt;w_cursor.col == 0 &amp;&amp; !inclusive))) {</a>
<a name="ln3086">    /*</a>
<a name="ln3087">     * If we don't include white space at the end, move the start</a>
<a name="ln3088">     * to include some white space there. This makes &quot;daw&quot; work</a>
<a name="ln3089">     * better on the last word in a sentence (and &quot;2daw&quot; on last-but-one</a>
<a name="ln3090">     * word).  Also when &quot;2daw&quot; deletes &quot;word.&quot; at the end of the line</a>
<a name="ln3091">     * (cursor is at start of next line).</a>
<a name="ln3092">     * But don't delete white space at start of line (indent).</a>
<a name="ln3093">     */</a>
<a name="ln3094">    pos = curwin-&gt;w_cursor;     /* save cursor position */</a>
<a name="ln3095">    curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3096">    if (oneleft() == OK) {</a>
<a name="ln3097">      back_in_line();</a>
<a name="ln3098">      if (cls() == 0 &amp;&amp; curwin-&gt;w_cursor.col &gt; 0) {</a>
<a name="ln3099">        if (VIsual_active)</a>
<a name="ln3100">          VIsual = curwin-&gt;w_cursor;</a>
<a name="ln3101">        else</a>
<a name="ln3102">          oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln3103">      }</a>
<a name="ln3104">    }</a>
<a name="ln3105">    curwin-&gt;w_cursor = pos;     /* put cursor back at end */</a>
<a name="ln3106">  }</a>
<a name="ln3107"> </a>
<a name="ln3108">  if (VIsual_active) {</a>
<a name="ln3109">    if (*p_sel == 'e' &amp;&amp; inclusive &amp;&amp; ltoreq(VIsual, curwin-&gt;w_cursor))</a>
<a name="ln3110">      inc_cursor();</a>
<a name="ln3111">    if (VIsual_mode == 'V') {</a>
<a name="ln3112">      VIsual_mode = 'v';</a>
<a name="ln3113">      redraw_cmdline = TRUE;                    /* show mode later */</a>
<a name="ln3114">    }</a>
<a name="ln3115">  } else</a>
<a name="ln3116">    oap-&gt;inclusive = inclusive;</a>
<a name="ln3117"> </a>
<a name="ln3118">  return OK;</a>
<a name="ln3119">}</a>
<a name="ln3120"> </a>
<a name="ln3121">/*</a>
<a name="ln3122"> * Find sentence(s) under the cursor, cursor at end.</a>
<a name="ln3123"> * When Visual active, extend it by one or more sentences.</a>
<a name="ln3124"> */</a>
<a name="ln3125">int current_sent(oparg_T *oap, long count, int include)</a>
<a name="ln3126">{</a>
<a name="ln3127">  pos_T start_pos;</a>
<a name="ln3128">  pos_T pos;</a>
<a name="ln3129">  int start_blank;</a>
<a name="ln3130">  int c;</a>
<a name="ln3131">  int at_start_sent;</a>
<a name="ln3132">  long ncount;</a>
<a name="ln3133"> </a>
<a name="ln3134">  start_pos = curwin-&gt;w_cursor;</a>
<a name="ln3135">  pos = start_pos;</a>
<a name="ln3136">  findsent(FORWARD, 1L);        /* Find start of next sentence. */</a>
<a name="ln3137"> </a>
<a name="ln3138">  /*</a>
<a name="ln3139">   * When the Visual area is bigger than one character: Extend it.</a>
<a name="ln3140">   */</a>
<a name="ln3141">  if (VIsual_active &amp;&amp; !equalpos(start_pos, VIsual)) {</a>
<a name="ln3142">extend:</a>
<a name="ln3143">    if (lt(start_pos, VIsual)) {</a>
<a name="ln3144">      /*</a>
<a name="ln3145">       * Cursor at start of Visual area.</a>
<a name="ln3146">       * Find out where we are:</a>
<a name="ln3147">       * - in the white space before a sentence</a>
<a name="ln3148">       * - in a sentence or just after it</a>
<a name="ln3149">       * - at the start of a sentence</a>
<a name="ln3150">       */</a>
<a name="ln3151">      at_start_sent = TRUE;</a>
<a name="ln3152">      decl(&amp;pos);</a>
<a name="ln3153">      while (lt(pos, curwin-&gt;w_cursor)) {</a>
<a name="ln3154">        c = gchar_pos(&amp;pos);</a>
<a name="ln3155">        if (!ascii_iswhite(c)) {</a>
<a name="ln3156">          at_start_sent = FALSE;</a>
<a name="ln3157">          break;</a>
<a name="ln3158">        }</a>
<a name="ln3159">        incl(&amp;pos);</a>
<a name="ln3160">      }</a>
<a name="ln3161">      if (!at_start_sent) {</a>
<a name="ln3162">        findsent(BACKWARD, 1L);</a>
<a name="ln3163">        if (equalpos(curwin-&gt;w_cursor, start_pos))</a>
<a name="ln3164">          at_start_sent = TRUE;            /* exactly at start of sentence */</a>
<a name="ln3165">        else</a>
<a name="ln3166">          /* inside a sentence, go to its end (start of next) */</a>
<a name="ln3167">          findsent(FORWARD, 1L);</a>
<a name="ln3168">      }</a>
<a name="ln3169">      if (include)              /* &quot;as&quot; gets twice as much as &quot;is&quot; */</a>
<a name="ln3170">        count *= 2;</a>
<a name="ln3171">      while (count--) {</a>
<a name="ln3172">        if (at_start_sent)</a>
<a name="ln3173">          find_first_blank(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3174">        c = gchar_cursor();</a>
<a name="ln3175">        if (!at_start_sent || (!include &amp;&amp; !ascii_iswhite(c)))</a>
<a name="ln3176">          findsent(BACKWARD, 1L);</a>
<a name="ln3177">        at_start_sent = !at_start_sent;</a>
<a name="ln3178">      }</a>
<a name="ln3179">    } else {</a>
<a name="ln3180">      /*</a>
<a name="ln3181">       * Cursor at end of Visual area.</a>
<a name="ln3182">       * Find out where we are:</a>
<a name="ln3183">       * - just before a sentence</a>
<a name="ln3184">       * - just before or in the white space before a sentence</a>
<a name="ln3185">       * - in a sentence</a>
<a name="ln3186">       */</a>
<a name="ln3187">      incl(&amp;pos);</a>
<a name="ln3188">      at_start_sent = TRUE;</a>
<a name="ln3189">      if (!equalpos(pos, curwin-&gt;w_cursor)) {     /* not just before a sentence */</a>
<a name="ln3190">        at_start_sent = FALSE;</a>
<a name="ln3191">        while (lt(pos, curwin-&gt;w_cursor)) {</a>
<a name="ln3192">          c = gchar_pos(&amp;pos);</a>
<a name="ln3193">          if (!ascii_iswhite(c)) {</a>
<a name="ln3194">            at_start_sent = TRUE;</a>
<a name="ln3195">            break;</a>
<a name="ln3196">          }</a>
<a name="ln3197">          incl(&amp;pos);</a>
<a name="ln3198">        }</a>
<a name="ln3199">        if (at_start_sent)              /* in the sentence */</a>
<a name="ln3200">          findsent(BACKWARD, 1L);</a>
<a name="ln3201">        else                    /* in/before white before a sentence */</a>
<a name="ln3202">          curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3203">      }</a>
<a name="ln3204"> </a>
<a name="ln3205">      if (include)              /* &quot;as&quot; gets twice as much as &quot;is&quot; */</a>
<a name="ln3206">        count *= 2;</a>
<a name="ln3207">      findsent_forward(count, at_start_sent);</a>
<a name="ln3208">      if (*p_sel == 'e')</a>
<a name="ln3209">        ++curwin-&gt;w_cursor.col;</a>
<a name="ln3210">    }</a>
<a name="ln3211">    return OK;</a>
<a name="ln3212">  }</a>
<a name="ln3213"> </a>
<a name="ln3214">  /*</a>
<a name="ln3215">   * If the cursor started on a blank, check if it is just before the start</a>
<a name="ln3216">   * of the next sentence.</a>
<a name="ln3217">   */</a>
<a name="ln3218">  while (c = gchar_pos(&amp;pos), ascii_iswhite(c))</a>
<a name="ln3219">    incl(&amp;pos);</a>
<a name="ln3220">  if (equalpos(pos, curwin-&gt;w_cursor)) {</a>
<a name="ln3221">    start_blank = TRUE;</a>
<a name="ln3222">    find_first_blank(&amp;start_pos);       /* go back to first blank */</a>
<a name="ln3223">  } else {</a>
<a name="ln3224">    start_blank = FALSE;</a>
<a name="ln3225">    findsent(BACKWARD, 1L);</a>
<a name="ln3226">    start_pos = curwin-&gt;w_cursor;</a>
<a name="ln3227">  }</a>
<a name="ln3228">  if (include)</a>
<a name="ln3229">    ncount = count * 2;</a>
<a name="ln3230">  else {</a>
<a name="ln3231">    ncount = count;</a>
<a name="ln3232">    if (start_blank)</a>
<a name="ln3233">      --ncount;</a>
<a name="ln3234">  }</a>
<a name="ln3235">  if (ncount &gt; 0)</a>
<a name="ln3236">    findsent_forward(ncount, TRUE);</a>
<a name="ln3237">  else</a>
<a name="ln3238">    decl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3239"> </a>
<a name="ln3240">  if (include) {</a>
<a name="ln3241">    /*</a>
<a name="ln3242">     * If the blank in front of the sentence is included, exclude the</a>
<a name="ln3243">     * blanks at the end of the sentence, go back to the first blank.</a>
<a name="ln3244">     * If there are no trailing blanks, try to include leading blanks.</a>
<a name="ln3245">     */</a>
<a name="ln3246">    if (start_blank) {</a>
<a name="ln3247">      find_first_blank(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3248">      c = gchar_pos(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3249">      if (ascii_iswhite(c))</a>
<a name="ln3250">        decl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3251">    } else if (c = gchar_cursor(), !ascii_iswhite(c))</a>
<a name="ln3252">      find_first_blank(&amp;start_pos);</a>
<a name="ln3253">  }</a>
<a name="ln3254"> </a>
<a name="ln3255">  if (VIsual_active) {</a>
<a name="ln3256">    /* Avoid getting stuck with &quot;is&quot; on a single space before a sentence. */</a>
<a name="ln3257">    if (equalpos(start_pos, curwin-&gt;w_cursor))</a>
<a name="ln3258">      goto extend;</a>
<a name="ln3259">    if (*p_sel == 'e')</a>
<a name="ln3260">      ++curwin-&gt;w_cursor.col;</a>
<a name="ln3261">    VIsual = start_pos;</a>
<a name="ln3262">    VIsual_mode = 'v';</a>
<a name="ln3263">    redraw_cmdline = true;    // show mode later</a>
<a name="ln3264">    redraw_curbuf_later(INVERTED);      // update the inversion</a>
<a name="ln3265">  } else {</a>
<a name="ln3266">    /* include a newline after the sentence, if there is one */</a>
<a name="ln3267">    if (incl(&amp;curwin-&gt;w_cursor) == -1)</a>
<a name="ln3268">      oap-&gt;inclusive = true;</a>
<a name="ln3269">    else</a>
<a name="ln3270">      oap-&gt;inclusive = false;</a>
<a name="ln3271">    oap-&gt;start = start_pos;</a>
<a name="ln3272">    oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln3273">  }</a>
<a name="ln3274">  return OK;</a>
<a name="ln3275">}</a>
<a name="ln3276"> </a>
<a name="ln3277">/*</a>
<a name="ln3278"> * Find block under the cursor, cursor at end.</a>
<a name="ln3279"> * &quot;what&quot; and &quot;other&quot; are two matching parenthesis/brace/etc.</a>
<a name="ln3280"> */</a>
<a name="ln3281">int</a>
<a name="ln3282">current_block(</a>
<a name="ln3283">    oparg_T *oap,</a>
<a name="ln3284">    long count,</a>
<a name="ln3285">    int include,                    /* TRUE == include white space */</a>
<a name="ln3286">    int what,                       /* '(', '{', etc. */</a>
<a name="ln3287">    int other                      /* ')', '}', etc. */</a>
<a name="ln3288">)</a>
<a name="ln3289">{</a>
<a name="ln3290">  pos_T old_pos;</a>
<a name="ln3291">  pos_T       *pos = NULL;</a>
<a name="ln3292">  pos_T start_pos;</a>
<a name="ln3293">  pos_T       *end_pos;</a>
<a name="ln3294">  pos_T old_start, old_end;</a>
<a name="ln3295">  char_u      *save_cpo;</a>
<a name="ln3296">  int sol = FALSE;                      /* '{' at start of line */</a>
<a name="ln3297"> </a>
<a name="ln3298">  old_pos = curwin-&gt;w_cursor;</a>
<a name="ln3299">  old_end = curwin-&gt;w_cursor;           /* remember where we started */</a>
<a name="ln3300">  old_start = old_end;</a>
<a name="ln3301"> </a>
<a name="ln3302">  /*</a>
<a name="ln3303">   * If we start on '(', '{', ')', '}', etc., use the whole block inclusive.</a>
<a name="ln3304">   */</a>
<a name="ln3305">  if (!VIsual_active || equalpos(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln3306">    setpcmark();</a>
<a name="ln3307">    if (what == '{')                    /* ignore indent */</a>
<a name="ln3308">      while (inindent(1))</a>
<a name="ln3309">        if (inc_cursor() != 0)</a>
<a name="ln3310">          break;</a>
<a name="ln3311">    if (gchar_cursor() == what)</a>
<a name="ln3312">      /* cursor on '(' or '{', move cursor just after it */</a>
<a name="ln3313">      ++curwin-&gt;w_cursor.col;</a>
<a name="ln3314">  } else if (lt(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln3315">    old_start = VIsual;</a>
<a name="ln3316">    curwin-&gt;w_cursor = VIsual;              /* cursor at low end of Visual */</a>
<a name="ln3317">  } else</a>
<a name="ln3318">    old_end = VIsual;</a>
<a name="ln3319"> </a>
<a name="ln3320">  // Search backwards for unclosed '(', '{', etc..</a>
<a name="ln3321">  // Put this position in start_pos.</a>
<a name="ln3322">  // Ignore quotes here.  Keep the &quot;M&quot; flag in 'cpo', as that is what the</a>
<a name="ln3323">  // user wants.</a>
<a name="ln3324">  save_cpo = p_cpo;</a>
<a name="ln3325">  p_cpo = (char_u *)(vim_strchr(p_cpo, CPO_MATCHBSL) != NULL ? &quot;%M&quot; : &quot;%&quot;);</a>
<a name="ln3326">  while (count-- &gt; 0) {</a>
<a name="ln3327">    if ((pos = findmatch(NULL, what)) == NULL) {</a>
<a name="ln3328">      break;</a>
<a name="ln3329">    }</a>
<a name="ln3330">    curwin-&gt;w_cursor = *pos;</a>
<a name="ln3331">    start_pos = *pos;  // the findmatch for end_pos will overwrite *pos</a>
<a name="ln3332">  }</a>
<a name="ln3333">  p_cpo = save_cpo;</a>
<a name="ln3334"> </a>
<a name="ln3335">  /*</a>
<a name="ln3336">   * Search for matching ')', '}', etc.</a>
<a name="ln3337">   * Put this position in curwin-&gt;w_cursor.</a>
<a name="ln3338">   */</a>
<a name="ln3339">  if (pos == NULL || (end_pos = findmatch(NULL, other)) == NULL) {</a>
<a name="ln3340">    curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3341">    return FAIL;</a>
<a name="ln3342">  }</a>
<a name="ln3343">  curwin-&gt;w_cursor = *end_pos;</a>
<a name="ln3344"> </a>
<a name="ln3345">  // Try to exclude the '(', '{', ')', '}', etc. when &quot;include&quot; is FALSE.</a>
<a name="ln3346">  // If the ending '}', ')' or ']' is only preceded by indent, skip that</a>
<a name="ln3347">  // indent. But only if the resulting area is not smaller than what we</a>
<a name="ln3348">  // started with.</a>
<a name="ln3349">  while (!include) {</a>
<a name="ln3350">    incl(&amp;start_pos);</a>
<a name="ln3351">    sol = (curwin-&gt;w_cursor.col == 0);</a>
<a name="ln3352">    decl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3353">    while (inindent(1)) {</a>
<a name="ln3354">      sol = TRUE;</a>
<a name="ln3355">      if (decl(&amp;curwin-&gt;w_cursor) != 0) {</a>
<a name="ln3356">        break;</a>
<a name="ln3357">      }</a>
<a name="ln3358">    }</a>
<a name="ln3359"> </a>
<a name="ln3360">    /*</a>
<a name="ln3361">     * In Visual mode, when the resulting area is not bigger than what we</a>
<a name="ln3362">     * started with, extend it to the next block, and then exclude again.</a>
<a name="ln3363">     */</a>
<a name="ln3364">    if (!lt(start_pos, old_start) &amp;&amp; !lt(old_end, curwin-&gt;w_cursor)</a>
<a name="ln3365">        &amp;&amp; VIsual_active) {</a>
<a name="ln3366">      curwin-&gt;w_cursor = old_start;</a>
<a name="ln3367">      decl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3368">      if ((pos = findmatch(NULL, what)) == NULL) {</a>
<a name="ln3369">        curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3370">        return FAIL;</a>
<a name="ln3371">      }</a>
<a name="ln3372">      start_pos = *pos;</a>
<a name="ln3373">      curwin-&gt;w_cursor = *pos;</a>
<a name="ln3374">      if ((end_pos = findmatch(NULL, other)) == NULL) {</a>
<a name="ln3375">        curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3376">        return FAIL;</a>
<a name="ln3377">      }</a>
<a name="ln3378">      curwin-&gt;w_cursor = *end_pos;</a>
<a name="ln3379">    } else</a>
<a name="ln3380">      break;</a>
<a name="ln3381">  }</a>
<a name="ln3382"> </a>
<a name="ln3383">  if (VIsual_active) {</a>
<a name="ln3384">    if (*p_sel == 'e') {</a>
<a name="ln3385">      inc(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3386">    }</a>
<a name="ln3387">    if (sol &amp;&amp; gchar_cursor() != NUL) {</a>
<a name="ln3388">      inc(&amp;curwin-&gt;w_cursor);  // include the line break</a>
<a name="ln3389">    }</a>
<a name="ln3390">    VIsual = start_pos;</a>
<a name="ln3391">    VIsual_mode = 'v';</a>
<a name="ln3392">    redraw_curbuf_later(INVERTED);      /* update the inversion */</a>
<a name="ln3393">    showmode();</a>
<a name="ln3394">  } else {</a>
<a name="ln3395">    oap-&gt;start = start_pos;</a>
<a name="ln3396">    oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln3397">    oap-&gt;inclusive = false;</a>
<a name="ln3398">    if (sol)</a>
<a name="ln3399">      incl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3400">    else if (ltoreq(start_pos, curwin-&gt;w_cursor))</a>
<a name="ln3401">      /* Include the character under the cursor. */</a>
<a name="ln3402">      oap-&gt;inclusive = true;</a>
<a name="ln3403">    else</a>
<a name="ln3404">      /* End is before the start (no text in between &lt;&gt;, [], etc.): don't</a>
<a name="ln3405">       * operate on any text. */</a>
<a name="ln3406">      curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3407">  }</a>
<a name="ln3408"> </a>
<a name="ln3409">  return OK;</a>
<a name="ln3410">}</a>
<a name="ln3411"> </a>
<a name="ln3412"> </a>
<a name="ln3413">/*</a>
<a name="ln3414"> * Return TRUE if the cursor is on a &quot;&lt;aaa&gt;&quot; tag.  Ignore &quot;&lt;aaa/&gt;&quot;.</a>
<a name="ln3415"> * When &quot;end_tag&quot; is TRUE return TRUE if the cursor is on &quot;&lt;/aaa&gt;&quot;.</a>
<a name="ln3416"> */</a>
<a name="ln3417">static int in_html_tag(int end_tag)</a>
<a name="ln3418">{</a>
<a name="ln3419">  char_u      *line = get_cursor_line_ptr();</a>
<a name="ln3420">  char_u      *p;</a>
<a name="ln3421">  int c;</a>
<a name="ln3422">  int lc = NUL;</a>
<a name="ln3423">  pos_T pos;</a>
<a name="ln3424"> </a>
<a name="ln3425">  for (p = line + curwin-&gt;w_cursor.col; p &gt; line; ) {</a>
<a name="ln3426">    if (*p == '&lt;') {           // find '&lt;' under/before cursor</a>
<a name="ln3427">      break;</a>
<a name="ln3428">    }</a>
<a name="ln3429">    MB_PTR_BACK(line, p);</a>
<a name="ln3430">    if (*p == '&gt;') {           // find '&gt;' before cursor</a>
<a name="ln3431">      break;</a>
<a name="ln3432">    }</a>
<a name="ln3433">  }</a>
<a name="ln3434">  if (*p != '&lt;') {</a>
<a name="ln3435">    return false;</a>
<a name="ln3436">  }</a>
<a name="ln3437"> </a>
<a name="ln3438">  pos.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3439">  pos.col = (colnr_T)(p - line);</a>
<a name="ln3440"> </a>
<a name="ln3441">  MB_PTR_ADV(p);</a>
<a name="ln3442">  if (end_tag) {</a>
<a name="ln3443">    // check that there is a '/' after the '&lt;'</a>
<a name="ln3444">    return *p == '/';</a>
<a name="ln3445">  }</a>
<a name="ln3446"> </a>
<a name="ln3447">  /* check that there is no '/' after the '&lt;' */</a>
<a name="ln3448">  if (*p == '/')</a>
<a name="ln3449">    return FALSE;</a>
<a name="ln3450"> </a>
<a name="ln3451">  /* check that the matching '&gt;' is not preceded by '/' */</a>
<a name="ln3452">  for (;; ) {</a>
<a name="ln3453">    if (inc(&amp;pos) &lt; 0)</a>
<a name="ln3454">      return FALSE;</a>
<a name="ln3455">    c = *ml_get_pos(&amp;pos);</a>
<a name="ln3456">    if (c == '&gt;')</a>
<a name="ln3457">      break;</a>
<a name="ln3458">    lc = c;</a>
<a name="ln3459">  }</a>
<a name="ln3460">  return lc != '/';</a>
<a name="ln3461">}</a>
<a name="ln3462"> </a>
<a name="ln3463">/*</a>
<a name="ln3464"> * Find tag block under the cursor, cursor at end.</a>
<a name="ln3465"> */</a>
<a name="ln3466">int</a>
<a name="ln3467">current_tagblock(</a>
<a name="ln3468">    oparg_T *oap,</a>
<a name="ln3469">    long count_arg,</a>
<a name="ln3470">    bool include                  // true == include white space</a>
<a name="ln3471">)</a>
<a name="ln3472">{</a>
<a name="ln3473">  long count = count_arg;</a>
<a name="ln3474">  pos_T old_pos;</a>
<a name="ln3475">  pos_T start_pos;</a>
<a name="ln3476">  pos_T end_pos;</a>
<a name="ln3477">  pos_T old_start, old_end;</a>
<a name="ln3478">  char_u      *p;</a>
<a name="ln3479">  char_u      *cp;</a>
<a name="ln3480">  int len;</a>
<a name="ln3481">  bool do_include = include;</a>
<a name="ln3482">  bool save_p_ws = p_ws;</a>
<a name="ln3483">  int retval = FAIL;</a>
<a name="ln3484">  int is_inclusive = true;</a>
<a name="ln3485"> </a>
<a name="ln3486">  p_ws = false;</a>
<a name="ln3487"> </a>
<a name="ln3488">  old_pos = curwin-&gt;w_cursor;</a>
<a name="ln3489">  old_end = curwin-&gt;w_cursor;               /* remember where we started */</a>
<a name="ln3490">  old_start = old_end;</a>
<a name="ln3491">  if (!VIsual_active || *p_sel == 'e')</a>
<a name="ln3492">    decl(&amp;old_end);                         /* old_end is inclusive */</a>
<a name="ln3493"> </a>
<a name="ln3494">  /*</a>
<a name="ln3495">   * If we start on &quot;&lt;aaa&gt;&quot; select that block.</a>
<a name="ln3496">   */</a>
<a name="ln3497">  if (!VIsual_active || equalpos(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln3498">    setpcmark();</a>
<a name="ln3499"> </a>
<a name="ln3500">    /* ignore indent */</a>
<a name="ln3501">    while (inindent(1))</a>
<a name="ln3502">      if (inc_cursor() != 0)</a>
<a name="ln3503">        break;</a>
<a name="ln3504"> </a>
<a name="ln3505">    if (in_html_tag(FALSE)) {</a>
<a name="ln3506">      /* cursor on start tag, move to its '&gt;' */</a>
<a name="ln3507">      while (*get_cursor_pos_ptr() != '&gt;')</a>
<a name="ln3508">        if (inc_cursor() &lt; 0)</a>
<a name="ln3509">          break;</a>
<a name="ln3510">    } else if (in_html_tag(TRUE)) {</a>
<a name="ln3511">      /* cursor on end tag, move to just before it */</a>
<a name="ln3512">      while (*get_cursor_pos_ptr() != '&lt;')</a>
<a name="ln3513">        if (dec_cursor() &lt; 0)</a>
<a name="ln3514">          break;</a>
<a name="ln3515">      dec_cursor();</a>
<a name="ln3516">      old_end = curwin-&gt;w_cursor;</a>
<a name="ln3517">    }</a>
<a name="ln3518">  } else if (lt(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln3519">    old_start = VIsual;</a>
<a name="ln3520">    curwin-&gt;w_cursor = VIsual;              /* cursor at low end of Visual */</a>
<a name="ln3521">  } else</a>
<a name="ln3522">    old_end = VIsual;</a>
<a name="ln3523"> </a>
<a name="ln3524">again:</a>
<a name="ln3525">  /*</a>
<a name="ln3526">   * Search backwards for unclosed &quot;&lt;aaa&gt;&quot;.</a>
<a name="ln3527">   * Put this position in start_pos.</a>
<a name="ln3528">   */</a>
<a name="ln3529">  for (long n = 0; n &lt; count; n++) {</a>
<a name="ln3530">    if (do_searchpair(</a>
<a name="ln3531">        &quot;&lt;[^ \t&gt;/!]\\+\\%(\\_s\\_[^&gt;]\\{-}[^/]&gt;\\|$\\|\\_s\\=&gt;\\)&quot;,</a>
<a name="ln3532">        &quot;&quot;,</a>
<a name="ln3533">        &quot;&lt;/[^&gt;]*&gt;&quot;, BACKWARD, NULL, 0,</a>
<a name="ln3534">        NULL, (linenr_T)0, 0L) &lt;= 0) {</a>
<a name="ln3535">      curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3536">      goto theend;</a>
<a name="ln3537">    }</a>
<a name="ln3538">  }</a>
<a name="ln3539">  start_pos = curwin-&gt;w_cursor;</a>
<a name="ln3540"> </a>
<a name="ln3541">  /*</a>
<a name="ln3542">   * Search for matching &quot;&lt;/aaa&gt;&quot;.  First isolate the &quot;aaa&quot;.</a>
<a name="ln3543">   */</a>
<a name="ln3544">  inc_cursor();</a>
<a name="ln3545">  p = get_cursor_pos_ptr();</a>
<a name="ln3546">  for (cp = p;</a>
<a name="ln3547">       *cp != NUL &amp;&amp; *cp != '&gt;' &amp;&amp; !ascii_iswhite(*cp);</a>
<a name="ln3548">       MB_PTR_ADV(cp)) {</a>
<a name="ln3549">  }</a>
<a name="ln3550">  len = (int)(cp - p);</a>
<a name="ln3551">  if (len == 0) {</a>
<a name="ln3552">    curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3553">    goto theend;</a>
<a name="ln3554">  }</a>
<a name="ln3555">  const size_t spat_len = len + 39;</a>
<a name="ln3556">  char *const spat = xmalloc(spat_len);</a>
<a name="ln3557">  const size_t epat_len = len + 9;</a>
<a name="ln3558">  char *const epat = xmalloc(epat_len);</a>
<a name="ln3559">  snprintf(spat, spat_len,</a>
<a name="ln3560">           &quot;&lt;%.*s\\&gt;\\%%(\\_s\\_[^&gt;]\\{-}\\_[^/]&gt;\\|\\_s\\?&gt;\\)\\c&quot;, len, p);</a>
<a name="ln3561">  snprintf(epat, epat_len, &quot;&lt;/%.*s&gt;\\c&quot;, len, p);</a>
<a name="ln3562"> </a>
<a name="ln3563">  const int r = do_searchpair(spat, &quot;&quot;, epat, FORWARD, NULL,</a>
<a name="ln3564">                              0, NULL, (linenr_T)0, 0L);</a>
<a name="ln3565"> </a>
<a name="ln3566">  xfree(spat);</a>
<a name="ln3567">  xfree(epat);</a>
<a name="ln3568"> </a>
<a name="ln3569">  if (r &lt; 1 || lt(curwin-&gt;w_cursor, old_end)) {</a>
<a name="ln3570">    /* Can't find other end or it's before the previous end.  Could be a</a>
<a name="ln3571">     * HTML tag that doesn't have a matching end.  Search backwards for</a>
<a name="ln3572">     * another starting tag. */</a>
<a name="ln3573">    count = 1;</a>
<a name="ln3574">    curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3575">    goto again;</a>
<a name="ln3576">  }</a>
<a name="ln3577"> </a>
<a name="ln3578">  if (do_include) {</a>
<a name="ln3579">    // Include up to the '&gt;'.</a>
<a name="ln3580">    while (*get_cursor_pos_ptr() != '&gt;') {</a>
<a name="ln3581">      if (inc_cursor() &lt; 0) {</a>
<a name="ln3582">        break;</a>
<a name="ln3583">      }</a>
<a name="ln3584">    }</a>
<a name="ln3585">  } else {</a>
<a name="ln3586">    char_u *c = get_cursor_pos_ptr();</a>
<a name="ln3587">    // Exclude the '&lt;' of the end tag.</a>
<a name="ln3588">    // If the closing tag is on new line, do not decrement cursor, but make</a>
<a name="ln3589">    // operation exclusive, so that the linefeed will be selected</a>
<a name="ln3590">    if (*c == '&lt;' &amp;&amp; !VIsual_active &amp;&amp; curwin-&gt;w_cursor.col == 0) {</a>
<a name="ln3591">      // do not decrement cursor</a>
<a name="ln3592">      is_inclusive = false;</a>
<a name="ln3593">    } else if (*c == '&lt;') {</a>
<a name="ln3594">      dec_cursor();</a>
<a name="ln3595">    }</a>
<a name="ln3596">  }</a>
<a name="ln3597">  end_pos = curwin-&gt;w_cursor;</a>
<a name="ln3598"> </a>
<a name="ln3599">  if (!do_include) {</a>
<a name="ln3600">    /* Exclude the start tag. */</a>
<a name="ln3601">    curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3602">    while (inc_cursor() &gt;= 0)</a>
<a name="ln3603">      if (*get_cursor_pos_ptr() == '&gt;') {</a>
<a name="ln3604">        inc_cursor();</a>
<a name="ln3605">        start_pos = curwin-&gt;w_cursor;</a>
<a name="ln3606">        break;</a>
<a name="ln3607">      }</a>
<a name="ln3608">    curwin-&gt;w_cursor = end_pos;</a>
<a name="ln3609"> </a>
<a name="ln3610">    // If we are in Visual mode and now have the same text as before set</a>
<a name="ln3611">    // &quot;do_include&quot; and try again.</a>
<a name="ln3612">    if (VIsual_active</a>
<a name="ln3613">        &amp;&amp; equalpos(start_pos, old_start)</a>
<a name="ln3614">        &amp;&amp; equalpos(end_pos, old_end)) {</a>
<a name="ln3615">      do_include = true;</a>
<a name="ln3616">      curwin-&gt;w_cursor = old_start;</a>
<a name="ln3617">      count = count_arg;</a>
<a name="ln3618">      goto again;</a>
<a name="ln3619">    }</a>
<a name="ln3620">  }</a>
<a name="ln3621"> </a>
<a name="ln3622">  if (VIsual_active) {</a>
<a name="ln3623">    /* If the end is before the start there is no text between tags, select</a>
<a name="ln3624">     * the char under the cursor. */</a>
<a name="ln3625">    if (lt(end_pos, start_pos)) {</a>
<a name="ln3626">      curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3627">    } else if (*p_sel == 'e') {</a>
<a name="ln3628">      inc_cursor();</a>
<a name="ln3629">    }</a>
<a name="ln3630">    VIsual = start_pos;</a>
<a name="ln3631">    VIsual_mode = 'v';</a>
<a name="ln3632">    redraw_curbuf_later(INVERTED);      /* update the inversion */</a>
<a name="ln3633">    showmode();</a>
<a name="ln3634">  } else {</a>
<a name="ln3635">    oap-&gt;start = start_pos;</a>
<a name="ln3636">    oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln3637">    if (lt(end_pos, start_pos)) {</a>
<a name="ln3638">      /* End is before the start: there is no text between tags; operate</a>
<a name="ln3639">       * on an empty area. */</a>
<a name="ln3640">      curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3641">      oap-&gt;inclusive = false;</a>
<a name="ln3642">    } else {</a>
<a name="ln3643">      oap-&gt;inclusive = is_inclusive;</a>
<a name="ln3644">    }</a>
<a name="ln3645">  }</a>
<a name="ln3646">  retval = OK;</a>
<a name="ln3647"> </a>
<a name="ln3648">theend:</a>
<a name="ln3649">  p_ws = save_p_ws;</a>
<a name="ln3650">  return retval;</a>
<a name="ln3651">}</a>
<a name="ln3652"> </a>
<a name="ln3653">int</a>
<a name="ln3654">current_par(</a>
<a name="ln3655">    oparg_T *oap,</a>
<a name="ln3656">    long count,</a>
<a name="ln3657">    int include,                    /* TRUE == include white space */</a>
<a name="ln3658">    int type                       /* 'p' for paragraph, 'S' for section */</a>
<a name="ln3659">)</a>
<a name="ln3660">{</a>
<a name="ln3661">  linenr_T start_lnum;</a>
<a name="ln3662">  linenr_T end_lnum;</a>
<a name="ln3663">  int white_in_front;</a>
<a name="ln3664">  int dir;</a>
<a name="ln3665">  int start_is_white;</a>
<a name="ln3666">  int prev_start_is_white;</a>
<a name="ln3667">  int retval = OK;</a>
<a name="ln3668">  int do_white = FALSE;</a>
<a name="ln3669">  int t;</a>
<a name="ln3670">  int i;</a>
<a name="ln3671"> </a>
<a name="ln3672">  if (type == 'S')          /* not implemented yet */</a>
<a name="ln3673">    return FAIL;</a>
<a name="ln3674"> </a>
<a name="ln3675">  start_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3676"> </a>
<a name="ln3677">  /*</a>
<a name="ln3678">   * When visual area is more than one line: extend it.</a>
<a name="ln3679">   */</a>
<a name="ln3680">  if (VIsual_active &amp;&amp; start_lnum != VIsual.lnum) {</a>
<a name="ln3681">extend:</a>
<a name="ln3682">    if (start_lnum &lt; VIsual.lnum)</a>
<a name="ln3683">      dir = BACKWARD;</a>
<a name="ln3684">    else</a>
<a name="ln3685">      dir = FORWARD;</a>
<a name="ln3686">    for (i = count; --i &gt;= 0; ) {</a>
<a name="ln3687">      if (start_lnum ==</a>
<a name="ln3688">          (dir == BACKWARD ? 1 : curbuf-&gt;b_ml.ml_line_count)) {</a>
<a name="ln3689">        retval = FAIL;</a>
<a name="ln3690">        break;</a>
<a name="ln3691">      }</a>
<a name="ln3692"> </a>
<a name="ln3693">      prev_start_is_white = -1;</a>
<a name="ln3694">      for (t = 0; t &lt; 2; ++t) {</a>
<a name="ln3695">        start_lnum += dir;</a>
<a name="ln3696">        start_is_white = linewhite(start_lnum);</a>
<a name="ln3697">        if (prev_start_is_white == start_is_white) {</a>
<a name="ln3698">          start_lnum -= dir;</a>
<a name="ln3699">          break;</a>
<a name="ln3700">        }</a>
<a name="ln3701">        for (;; ) {</a>
<a name="ln3702">          if (start_lnum == (dir == BACKWARD</a>
<a name="ln3703">                             ? 1 : curbuf-&gt;b_ml.ml_line_count))</a>
<a name="ln3704">            break;</a>
<a name="ln3705">          if (start_is_white != linewhite(start_lnum + dir)</a>
<a name="ln3706">              || (!start_is_white</a>
<a name="ln3707">                  &amp;&amp; startPS(start_lnum + (dir &gt; 0</a>
<a name="ln3708">                                           ? 1 : 0), 0, 0)))</a>
<a name="ln3709">            break;</a>
<a name="ln3710">          start_lnum += dir;</a>
<a name="ln3711">        }</a>
<a name="ln3712">        if (!include)</a>
<a name="ln3713">          break;</a>
<a name="ln3714">        if (start_lnum == (dir == BACKWARD</a>
<a name="ln3715">                           ? 1 : curbuf-&gt;b_ml.ml_line_count))</a>
<a name="ln3716">          break;</a>
<a name="ln3717">        prev_start_is_white = start_is_white;</a>
<a name="ln3718">      }</a>
<a name="ln3719">    }</a>
<a name="ln3720">    curwin-&gt;w_cursor.lnum = start_lnum;</a>
<a name="ln3721">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3722">    return retval;</a>
<a name="ln3723">  }</a>
<a name="ln3724"> </a>
<a name="ln3725">  /*</a>
<a name="ln3726">   * First move back to the start_lnum of the paragraph or white lines</a>
<a name="ln3727">   */</a>
<a name="ln3728">  white_in_front = linewhite(start_lnum);</a>
<a name="ln3729">  while (start_lnum &gt; 1) {</a>
<a name="ln3730">    if (white_in_front) {           /* stop at first white line */</a>
<a name="ln3731">      if (!linewhite(start_lnum - 1))</a>
<a name="ln3732">        break;</a>
<a name="ln3733">    } else {          /* stop at first non-white line of start of paragraph */</a>
<a name="ln3734">      if (linewhite(start_lnum - 1) || startPS(start_lnum, 0, 0))</a>
<a name="ln3735">        break;</a>
<a name="ln3736">    }</a>
<a name="ln3737">    --start_lnum;</a>
<a name="ln3738">  }</a>
<a name="ln3739"> </a>
<a name="ln3740">  /*</a>
<a name="ln3741">   * Move past the end of any white lines.</a>
<a name="ln3742">   */</a>
<a name="ln3743">  end_lnum = start_lnum;</a>
<a name="ln3744">  while (end_lnum &lt;= curbuf-&gt;b_ml.ml_line_count &amp;&amp; linewhite(end_lnum))</a>
<a name="ln3745">    ++end_lnum;</a>
<a name="ln3746"> </a>
<a name="ln3747">  --end_lnum;</a>
<a name="ln3748">  i = count;</a>
<a name="ln3749">  if (!include &amp;&amp; white_in_front)</a>
<a name="ln3750">    --i;</a>
<a name="ln3751">  while (i--) {</a>
<a name="ln3752">    if (end_lnum == curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln3753">      return FAIL;</a>
<a name="ln3754"> </a>
<a name="ln3755">    if (!include)</a>
<a name="ln3756">      do_white = linewhite(end_lnum + 1);</a>
<a name="ln3757"> </a>
<a name="ln3758">    if (include || !do_white) {</a>
<a name="ln3759">      ++end_lnum;</a>
<a name="ln3760">      /*</a>
<a name="ln3761">       * skip to end of paragraph</a>
<a name="ln3762">       */</a>
<a name="ln3763">      while (end_lnum &lt; curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln3764">             &amp;&amp; !linewhite(end_lnum + 1)</a>
<a name="ln3765">             &amp;&amp; !startPS(end_lnum + 1, 0, 0))</a>
<a name="ln3766">        ++end_lnum;</a>
<a name="ln3767">    }</a>
<a name="ln3768"> </a>
<a name="ln3769">    if (i == 0 &amp;&amp; white_in_front &amp;&amp; include)</a>
<a name="ln3770">      break;</a>
<a name="ln3771"> </a>
<a name="ln3772">    /*</a>
<a name="ln3773">     * skip to end of white lines after paragraph</a>
<a name="ln3774">     */</a>
<a name="ln3775">    if (include || do_white)</a>
<a name="ln3776">      while (end_lnum &lt; curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln3777">             &amp;&amp; linewhite(end_lnum + 1))</a>
<a name="ln3778">        ++end_lnum;</a>
<a name="ln3779">  }</a>
<a name="ln3780"> </a>
<a name="ln3781">  /*</a>
<a name="ln3782">   * If there are no empty lines at the end, try to find some empty lines at</a>
<a name="ln3783">   * the start (unless that has been done already).</a>
<a name="ln3784">   */</a>
<a name="ln3785">  if (!white_in_front &amp;&amp; !linewhite(end_lnum) &amp;&amp; include)</a>
<a name="ln3786">    while (start_lnum &gt; 1 &amp;&amp; linewhite(start_lnum - 1))</a>
<a name="ln3787">      --start_lnum;</a>
<a name="ln3788"> </a>
<a name="ln3789">  if (VIsual_active) {</a>
<a name="ln3790">    // Problem: when doing &quot;Vipipip&quot; nothing happens in a single white</a>
<a name="ln3791">    // line, we get stuck there.  Trap this here.</a>
<a name="ln3792">    if (VIsual_mode == 'V' &amp;&amp; start_lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln3793">      goto extend;</a>
<a name="ln3794">    }</a>
<a name="ln3795">    if (VIsual.lnum != start_lnum) {</a>
<a name="ln3796">        VIsual.lnum = start_lnum;</a>
<a name="ln3797">        VIsual.col = 0;</a>
<a name="ln3798">    }</a>
<a name="ln3799">    VIsual_mode = 'V';</a>
<a name="ln3800">    redraw_curbuf_later(INVERTED);      /* update the inversion */</a>
<a name="ln3801">    showmode();</a>
<a name="ln3802">  } else {</a>
<a name="ln3803">    oap-&gt;start.lnum = start_lnum;</a>
<a name="ln3804">    oap-&gt;start.col = 0;</a>
<a name="ln3805">    oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln3806">  }</a>
<a name="ln3807">  curwin-&gt;w_cursor.lnum = end_lnum;</a>
<a name="ln3808">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3809"> </a>
<a name="ln3810">  return OK;</a>
<a name="ln3811">}</a>
<a name="ln3812"> </a>
<a name="ln3813"> </a>
<a name="ln3814">/*</a>
<a name="ln3815"> * Search quote char from string line[col].</a>
<a name="ln3816"> * Quote character escaped by one of the characters in &quot;escape&quot; is not counted</a>
<a name="ln3817"> * as a quote.</a>
<a name="ln3818"> * Returns column number of &quot;quotechar&quot; or -1 when not found.</a>
<a name="ln3819"> */</a>
<a name="ln3820">static int</a>
<a name="ln3821">find_next_quote(</a>
<a name="ln3822">    char_u *line,</a>
<a name="ln3823">    int col,</a>
<a name="ln3824">    int quotechar,</a>
<a name="ln3825">    char_u *escape            /* escape characters, can be NULL */</a>
<a name="ln3826">)</a>
<a name="ln3827">{</a>
<a name="ln3828">  int c;</a>
<a name="ln3829"> </a>
<a name="ln3830">  for (;; ) {</a>
<a name="ln3831">    c = line[col];</a>
<a name="ln3832">    if (c == NUL) {</a>
<a name="ln3833">      return -1;</a>
<a name="ln3834">    } else if (escape != NULL &amp;&amp; vim_strchr(escape, c)) {</a>
<a name="ln3835">      col++;</a>
<a name="ln3836">    } else if (c == quotechar) {</a>
<a name="ln3837">      break;</a>
<a name="ln3838">    }</a>
<a name="ln3839">    col += mb_ptr2len(line + col);</a>
<a name="ln3840">  }</a>
<a name="ln3841">  return col;</a>
<a name="ln3842">}</a>
<a name="ln3843"> </a>
<a name="ln3844">/*</a>
<a name="ln3845"> * Search backwards in &quot;line&quot; from column &quot;col_start&quot; to find &quot;quotechar&quot;.</a>
<a name="ln3846"> * Quote character escaped by one of the characters in &quot;escape&quot; is not counted</a>
<a name="ln3847"> * as a quote.</a>
<a name="ln3848"> * Return the found column or zero.</a>
<a name="ln3849"> */</a>
<a name="ln3850">static int</a>
<a name="ln3851">find_prev_quote(</a>
<a name="ln3852">    char_u *line,</a>
<a name="ln3853">    int col_start,</a>
<a name="ln3854">    int quotechar,</a>
<a name="ln3855">    char_u *escape            /* escape characters, can be NULL */</a>
<a name="ln3856">)</a>
<a name="ln3857">{</a>
<a name="ln3858">  int n;</a>
<a name="ln3859"> </a>
<a name="ln3860">  while (col_start &gt; 0) {</a>
<a name="ln3861">    col_start--;</a>
<a name="ln3862">    col_start -= utf_head_off(line, line + col_start);</a>
<a name="ln3863">    n = 0;</a>
<a name="ln3864">    if (escape != NULL)</a>
<a name="ln3865">      while (col_start - n &gt; 0 &amp;&amp; vim_strchr(escape,</a>
<a name="ln3866">                 line[col_start - n - 1]) != NULL)</a>
<a name="ln3867">        ++n;</a>
<a name="ln3868">    if (n &amp; 1)</a>
<a name="ln3869">      col_start -= n;           /* uneven number of escape chars, skip it */</a>
<a name="ln3870">    else if (line[col_start] == quotechar)</a>
<a name="ln3871">      break;</a>
<a name="ln3872">  }</a>
<a name="ln3873">  return col_start;</a>
<a name="ln3874">}</a>
<a name="ln3875"> </a>
<a name="ln3876">// Find quote under the cursor, cursor at end.</a>
<a name="ln3877">// Returns true if found, else false.</a>
<a name="ln3878">bool current_quote(</a>
<a name="ln3879">    oparg_T *oap,</a>
<a name="ln3880">    long count,</a>
<a name="ln3881">    bool include,                 // true == include quote char</a>
<a name="ln3882">    int quotechar                 // Quote character</a>
<a name="ln3883">)</a>
<a name="ln3884">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3885">{</a>
<a name="ln3886">  char_u      *line = get_cursor_line_ptr();</a>
<a name="ln3887">  int col_end;</a>
<a name="ln3888">  int col_start = curwin-&gt;w_cursor.col;</a>
<a name="ln3889">  bool inclusive = false;</a>
<a name="ln3890">  bool vis_empty = true;                // Visual selection &lt;= 1 char</a>
<a name="ln3891">  bool vis_bef_curs = false;            // Visual starts before cursor</a>
<a name="ln3892">  bool did_exclusive_adj = false;       // adjusted pos for 'selection'</a>
<a name="ln3893">  bool inside_quotes = false;           // Looks like &quot;i'&quot; done before</a>
<a name="ln3894">  bool selected_quote = false;          // Has quote inside selection</a>
<a name="ln3895">  int i;</a>
<a name="ln3896">  bool restore_vis_bef = false;         // resotre VIsual on abort</a>
<a name="ln3897"> </a>
<a name="ln3898">  // When 'selection' is &quot;exclusive&quot; move the cursor to where it would be</a>
<a name="ln3899">  // with 'selection' &quot;inclusive&quot;, so that the logic is the same for both.</a>
<a name="ln3900">  // The cursor then is moved forward after adjusting the area.</a>
<a name="ln3901">  if (VIsual_active) {</a>
<a name="ln3902">    // this only works within one line</a>
<a name="ln3903">    if (VIsual.lnum != curwin-&gt;w_cursor.lnum) {</a>
<a name="ln3904">        return false;</a>
<a name="ln3905">    }</a>
<a name="ln3906"> </a>
<a name="ln3907">    vis_bef_curs = lt(VIsual, curwin-&gt;w_cursor);</a>
<a name="ln3908">    vis_empty = equalpos(VIsual, curwin-&gt;w_cursor);</a>
<a name="ln3909">    if (*p_sel == 'e') {</a>
<a name="ln3910">      if (vis_bef_curs) {</a>
<a name="ln3911">        dec_cursor();</a>
<a name="ln3912">        did_exclusive_adj = true;</a>
<a name="ln3913">      } else if (!vis_empty) {</a>
<a name="ln3914">        dec(&amp;VIsual);</a>
<a name="ln3915">        did_exclusive_adj = true;</a>
<a name="ln3916">      }</a>
<a name="ln3917">      vis_empty = equalpos(VIsual, curwin-&gt;w_cursor);</a>
<a name="ln3918">      if (!vis_bef_curs &amp;&amp; !vis_empty) {</a>
<a name="ln3919">        // VIsual needs to be start of Visual selection.</a>
<a name="ln3920">        pos_T t = curwin-&gt;w_cursor;</a>
<a name="ln3921"> </a>
<a name="ln3922">        curwin-&gt;w_cursor = VIsual;</a>
<a name="ln3923">        VIsual = t;</a>
<a name="ln3924">        vis_bef_curs = true;</a>
<a name="ln3925">        restore_vis_bef = true;</a>
<a name="ln3926">      }</a>
<a name="ln3927">    }</a>
<a name="ln3928">  }</a>
<a name="ln3929"> </a>
<a name="ln3930">  if (!vis_empty) {</a>
<a name="ln3931">    /* Check if the existing selection exactly spans the text inside</a>
<a name="ln3932">     * quotes. */</a>
<a name="ln3933">    if (vis_bef_curs) {</a>
<a name="ln3934">      inside_quotes = VIsual.col &gt; 0</a>
<a name="ln3935">                      &amp;&amp; line[VIsual.col - 1] == quotechar</a>
<a name="ln3936">                      &amp;&amp; line[curwin-&gt;w_cursor.col] != NUL</a>
<a name="ln3937">                      &amp;&amp; line[curwin-&gt;w_cursor.col + 1] == quotechar;</a>
<a name="ln3938">      i = VIsual.col;</a>
<a name="ln3939">      col_end = curwin-&gt;w_cursor.col;</a>
<a name="ln3940">    } else {</a>
<a name="ln3941">      inside_quotes = curwin-&gt;w_cursor.col &gt; 0</a>
<a name="ln3942">                      &amp;&amp; line[curwin-&gt;w_cursor.col - 1] == quotechar</a>
<a name="ln3943">                      &amp;&amp; line[VIsual.col] != NUL</a>
<a name="ln3944">                      &amp;&amp; line[VIsual.col + 1] == quotechar;</a>
<a name="ln3945">      i = curwin-&gt;w_cursor.col;</a>
<a name="ln3946">      col_end = VIsual.col;</a>
<a name="ln3947">    }</a>
<a name="ln3948"> </a>
<a name="ln3949">    /* Find out if we have a quote in the selection. */</a>
<a name="ln3950">    while (i &lt;= col_end)</a>
<a name="ln3951">      if (line[i++] == quotechar) {</a>
<a name="ln3952">        selected_quote = true;</a>
<a name="ln3953">        break;</a>
<a name="ln3954">      }</a>
<a name="ln3955">  }</a>
<a name="ln3956"> </a>
<a name="ln3957">  if (!vis_empty &amp;&amp; line[col_start] == quotechar) {</a>
<a name="ln3958">    /* Already selecting something and on a quote character.  Find the</a>
<a name="ln3959">     * next quoted string. */</a>
<a name="ln3960">    if (vis_bef_curs) {</a>
<a name="ln3961">      /* Assume we are on a closing quote: move to after the next</a>
<a name="ln3962">       * opening quote. */</a>
<a name="ln3963">      col_start = find_next_quote(line, col_start + 1, quotechar, NULL);</a>
<a name="ln3964">      if (col_start &lt; 0) {</a>
<a name="ln3965">        goto abort_search;</a>
<a name="ln3966">      }</a>
<a name="ln3967">      col_end = find_next_quote(line, col_start + 1, quotechar,</a>
<a name="ln3968">          curbuf-&gt;b_p_qe);</a>
<a name="ln3969">      if (col_end &lt; 0) {</a>
<a name="ln3970">        /* We were on a starting quote perhaps? */</a>
<a name="ln3971">        col_end = col_start;</a>
<a name="ln3972">        col_start = curwin-&gt;w_cursor.col;</a>
<a name="ln3973">      }</a>
<a name="ln3974">    } else {</a>
<a name="ln3975">      col_end = find_prev_quote(line, col_start, quotechar, NULL);</a>
<a name="ln3976">      if (line[col_end] != quotechar) {</a>
<a name="ln3977">        goto abort_search;</a>
<a name="ln3978">      }</a>
<a name="ln3979">      col_start = find_prev_quote(line, col_end, quotechar,</a>
<a name="ln3980">          curbuf-&gt;b_p_qe);</a>
<a name="ln3981">      if (line[col_start] != quotechar) {</a>
<a name="ln3982">        /* We were on an ending quote perhaps? */</a>
<a name="ln3983">        col_start = col_end;</a>
<a name="ln3984">        col_end = curwin-&gt;w_cursor.col;</a>
<a name="ln3985">      }</a>
<a name="ln3986">    }</a>
<a name="ln3987">  } else if (line[col_start] == quotechar</a>
<a name="ln3988">             || !vis_empty</a>
<a name="ln3989">             ) {</a>
<a name="ln3990">    int first_col = col_start;</a>
<a name="ln3991"> </a>
<a name="ln3992">    if (!vis_empty) {</a>
<a name="ln3993">      if (vis_bef_curs)</a>
<a name="ln3994">        first_col = find_next_quote(line, col_start, quotechar, NULL);</a>
<a name="ln3995">      else</a>
<a name="ln3996">        first_col = find_prev_quote(line, col_start, quotechar, NULL);</a>
<a name="ln3997">    }</a>
<a name="ln3998">    /* The cursor is on a quote, we don't know if it's the opening or</a>
<a name="ln3999">     * closing quote.  Search from the start of the line to find out.</a>
<a name="ln4000">     * Also do this when there is a Visual area, a' may leave the cursor</a>
<a name="ln4001">     * in between two strings. */</a>
<a name="ln4002">    col_start = 0;</a>
<a name="ln4003">    for (;; ) {</a>
<a name="ln4004">      /* Find open quote character. */</a>
<a name="ln4005">      col_start = find_next_quote(line, col_start, quotechar, NULL);</a>
<a name="ln4006">      if (col_start &lt; 0 || col_start &gt; first_col) {</a>
<a name="ln4007">        goto abort_search;</a>
<a name="ln4008">      }</a>
<a name="ln4009">      // Find close quote character.</a>
<a name="ln4010">      col_end = find_next_quote(line, col_start + 1, quotechar,</a>
<a name="ln4011">          curbuf-&gt;b_p_qe);</a>
<a name="ln4012">      if (col_end &lt; 0) {</a>
<a name="ln4013">        goto abort_search;</a>
<a name="ln4014">      }</a>
<a name="ln4015">      // If is cursor between start and end quote character, it is</a>
<a name="ln4016">      // target text object.</a>
<a name="ln4017">      if (col_start &lt;= first_col &amp;&amp; first_col &lt;= col_end) {</a>
<a name="ln4018">        break;</a>
<a name="ln4019">      }</a>
<a name="ln4020">      col_start = col_end + 1;</a>
<a name="ln4021">    }</a>
<a name="ln4022">  } else {</a>
<a name="ln4023">    /* Search backward for a starting quote. */</a>
<a name="ln4024">    col_start = find_prev_quote(line, col_start, quotechar, curbuf-&gt;b_p_qe);</a>
<a name="ln4025">    if (line[col_start] != quotechar) {</a>
<a name="ln4026">      /* No quote before the cursor, look after the cursor. */</a>
<a name="ln4027">      col_start = find_next_quote(line, col_start, quotechar, NULL);</a>
<a name="ln4028">      if (col_start &lt; 0) {</a>
<a name="ln4029">        goto abort_search;</a>
<a name="ln4030">      }</a>
<a name="ln4031">    }</a>
<a name="ln4032"> </a>
<a name="ln4033">    /* Find close quote character. */</a>
<a name="ln4034">    col_end = find_next_quote(line, col_start + 1, quotechar,</a>
<a name="ln4035">                              curbuf-&gt;b_p_qe);</a>
<a name="ln4036">    if (col_end &lt; 0) {</a>
<a name="ln4037">      goto abort_search;</a>
<a name="ln4038">    }</a>
<a name="ln4039">  }</a>
<a name="ln4040"> </a>
<a name="ln4041">  // When &quot;include&quot; is true, include spaces after closing quote or before</a>
<a name="ln4042">  // the starting quote.</a>
<a name="ln4043">  if (include) {</a>
<a name="ln4044">    if (ascii_iswhite(line[col_end + 1]))</a>
<a name="ln4045">      while (ascii_iswhite(line[col_end + 1]))</a>
<a name="ln4046">        ++col_end;</a>
<a name="ln4047">    else</a>
<a name="ln4048">      while (col_start &gt; 0 &amp;&amp; ascii_iswhite(line[col_start - 1]))</a>
<a name="ln4049">        --col_start;</a>
<a name="ln4050">  }</a>
<a name="ln4051"> </a>
<a name="ln4052">  /* Set start position.  After vi&quot; another i&quot; must include the &quot;.</a>
<a name="ln4053">   * For v2i&quot; include the quotes. */</a>
<a name="ln4054">  if (!include &amp;&amp; count &lt; 2</a>
<a name="ln4055">      &amp;&amp; (vis_empty || !inside_quotes)</a>
<a name="ln4056">      )</a>
<a name="ln4057">    ++col_start;</a>
<a name="ln4058">  curwin-&gt;w_cursor.col = col_start;</a>
<a name="ln4059">  if (VIsual_active) {</a>
<a name="ln4060">    /* Set the start of the Visual area when the Visual area was empty, we</a>
<a name="ln4061">     * were just inside quotes or the Visual area didn't start at a quote</a>
<a name="ln4062">     * and didn't include a quote.</a>
<a name="ln4063">     */</a>
<a name="ln4064">    if (vis_empty</a>
<a name="ln4065">        || (vis_bef_curs</a>
<a name="ln4066">            &amp;&amp; !selected_quote</a>
<a name="ln4067">            &amp;&amp; (inside_quotes</a>
<a name="ln4068">                || (line[VIsual.col] != quotechar</a>
<a name="ln4069">                    &amp;&amp; (VIsual.col == 0</a>
<a name="ln4070">                        || line[VIsual.col - 1] != quotechar))))) {</a>
<a name="ln4071">      VIsual = curwin-&gt;w_cursor;</a>
<a name="ln4072">      redraw_curbuf_later(INVERTED);</a>
<a name="ln4073">    }</a>
<a name="ln4074">  } else {</a>
<a name="ln4075">    oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln4076">    oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln4077">  }</a>
<a name="ln4078"> </a>
<a name="ln4079">  /* Set end position. */</a>
<a name="ln4080">  curwin-&gt;w_cursor.col = col_end;</a>
<a name="ln4081">  if ((include || count &gt; 1</a>
<a name="ln4082">       /* After vi&quot; another i&quot; must include the &quot;. */</a>
<a name="ln4083">       || (!vis_empty &amp;&amp; inside_quotes)</a>
<a name="ln4084">       ) &amp;&amp; inc_cursor() == 2)</a>
<a name="ln4085">    inclusive = true;</a>
<a name="ln4086">  if (VIsual_active) {</a>
<a name="ln4087">    if (vis_empty || vis_bef_curs) {</a>
<a name="ln4088">      // decrement cursor when 'selection' is not exclusive</a>
<a name="ln4089">      if (*p_sel != 'e') {</a>
<a name="ln4090">        dec_cursor();</a>
<a name="ln4091">      }</a>
<a name="ln4092">    } else {</a>
<a name="ln4093">      /* Cursor is at start of Visual area.  Set the end of the Visual</a>
<a name="ln4094">       * area when it was just inside quotes or it didn't end at a</a>
<a name="ln4095">       * quote. */</a>
<a name="ln4096">      if (inside_quotes</a>
<a name="ln4097">          || (!selected_quote</a>
<a name="ln4098">              &amp;&amp; line[VIsual.col] != quotechar</a>
<a name="ln4099">              &amp;&amp; (line[VIsual.col] == NUL</a>
<a name="ln4100">                  || line[VIsual.col + 1] != quotechar))) {</a>
<a name="ln4101">        dec_cursor();</a>
<a name="ln4102">        VIsual = curwin-&gt;w_cursor;</a>
<a name="ln4103">      }</a>
<a name="ln4104">      curwin-&gt;w_cursor.col = col_start;</a>
<a name="ln4105">    }</a>
<a name="ln4106">    if (VIsual_mode == 'V') {</a>
<a name="ln4107">      VIsual_mode = 'v';</a>
<a name="ln4108">      redraw_cmdline = TRUE;                    /* show mode later */</a>
<a name="ln4109">    }</a>
<a name="ln4110">  } else {</a>
<a name="ln4111">    /* Set inclusive and other oap's flags. */</a>
<a name="ln4112">    oap-&gt;inclusive = inclusive;</a>
<a name="ln4113">  }</a>
<a name="ln4114"> </a>
<a name="ln4115">  return true;</a>
<a name="ln4116"> </a>
<a name="ln4117">abort_search:</a>
<a name="ln4118">  if (VIsual_active &amp;&amp; *p_sel == 'e') {</a>
<a name="ln4119">    if (did_exclusive_adj) {</a>
<a name="ln4120">      inc_cursor();</a>
<a name="ln4121">    }</a>
<a name="ln4122">    if (restore_vis_bef) {</a>
<a name="ln4123">       pos_T t = curwin-&gt;w_cursor;</a>
<a name="ln4124"> </a>
<a name="ln4125">       curwin-&gt;w_cursor = VIsual;</a>
<a name="ln4126">       VIsual = t;</a>
<a name="ln4127">    }</a>
<a name="ln4128">  }</a>
<a name="ln4129">  return false;</a>
<a name="ln4130">}</a>
<a name="ln4131"> </a>
<a name="ln4132"> </a>
<a name="ln4133"> </a>
<a name="ln4134">/*</a>
<a name="ln4135"> * Find next search match under cursor, cursor at end.</a>
<a name="ln4136"> * Used while an operator is pending, and in Visual mode.</a>
<a name="ln4137"> */</a>
<a name="ln4138">int</a>
<a name="ln4139">current_search(</a>
<a name="ln4140">    long count,</a>
<a name="ln4141">    bool forward  // true for forward, false for backward</a>
<a name="ln4142">)</a>
<a name="ln4143">{</a>
<a name="ln4144">  bool old_p_ws = p_ws;</a>
<a name="ln4145">  pos_T save_VIsual = VIsual;</a>
<a name="ln4146"> </a>
<a name="ln4147">  /* Correct cursor when 'selection' is exclusive */</a>
<a name="ln4148">  if (VIsual_active &amp;&amp; *p_sel == 'e' &amp;&amp; lt(VIsual, curwin-&gt;w_cursor))</a>
<a name="ln4149">    dec_cursor();</a>
<a name="ln4150"> </a>
<a name="ln4151">  pos_T end_pos;                // end position of the pattern match</a>
<a name="ln4152">  pos_T orig_pos;               // position of the cursor at beginning</a>
<a name="ln4153">  pos_T pos;                    // position after the pattern</a>
<a name="ln4154">  int result;                   // result of various function calls</a>
<a name="ln4155"> </a>
<a name="ln4156">  // When searching forward and the cursor is at the start of the Visual</a>
<a name="ln4157">  // area, skip the first search backward, otherwise it doesn't move.</a>
<a name="ln4158">  const bool skip_first_backward = forward &amp;&amp; VIsual_active</a>
<a name="ln4159">    &amp;&amp; lt(curwin-&gt;w_cursor, VIsual);</a>
<a name="ln4160"> </a>
<a name="ln4161">  orig_pos = pos = curwin-&gt;w_cursor;</a>
<a name="ln4162">  if (VIsual_active) {</a>
<a name="ln4163">    // Searching further will extend the match.</a>
<a name="ln4164">    if (forward) {</a>
<a name="ln4165">      incl(&amp;pos);</a>
<a name="ln4166">    } else {</a>
<a name="ln4167">      decl(&amp;pos);</a>
<a name="ln4168">    }</a>
<a name="ln4169">  }</a>
<a name="ln4170"> </a>
<a name="ln4171">  // Is the pattern is zero-width?, this time, don't care about the direction</a>
<a name="ln4172">  int zero_width = is_zero_width(spats[last_idx].pat, true, &amp;curwin-&gt;w_cursor,</a>
<a name="ln4173">                                 FORWARD);</a>
<a name="ln4174">  if (zero_width == -1) {</a>
<a name="ln4175">    return FAIL;  // pattern not found</a>
<a name="ln4176">  }</a>
<a name="ln4177"> </a>
<a name="ln4178">  // The trick is to first search backwards and then search forward again,</a>
<a name="ln4179">  // so that a match at the current cursor position will be correctly</a>
<a name="ln4180">  // captured.  When &quot;forward&quot; is false do it the other way around.</a>
<a name="ln4181">  for (int i = 0; i &lt; 2; i++) {</a>
<a name="ln4182">    int dir;</a>
<a name="ln4183">    if (forward) {</a>
<a name="ln4184">      if (i == 0 &amp;&amp; skip_first_backward) {</a>
<a name="ln4185">        continue;</a>
<a name="ln4186">      }</a>
<a name="ln4187">      dir = i;</a>
<a name="ln4188">    } else {</a>
<a name="ln4189">      dir = !i;</a>
<a name="ln4190">    }</a>
<a name="ln4191"> </a>
<a name="ln4192">    int flags = 0;</a>
<a name="ln4193"> </a>
<a name="ln4194">    if (!dir &amp;&amp; !zero_width) {</a>
<a name="ln4195">      flags = SEARCH_END;</a>
<a name="ln4196">    }</a>
<a name="ln4197">    end_pos = pos;</a>
<a name="ln4198"> </a>
<a name="ln4199">    // wrapping should not occur in the first round</a>
<a name="ln4200">    if (i == 0) {</a>
<a name="ln4201">      p_ws = false;</a>
<a name="ln4202">    }</a>
<a name="ln4203"> </a>
<a name="ln4204">    result = searchit(curwin, curbuf, &amp;pos, &amp;end_pos,</a>
<a name="ln4205">                      (dir ? FORWARD : BACKWARD),</a>
<a name="ln4206">                      spats[last_idx].pat, i ? count : 1,</a>
<a name="ln4207">                      SEARCH_KEEP | flags, RE_SEARCH, NULL);</a>
<a name="ln4208"> </a>
<a name="ln4209">    p_ws = old_p_ws;</a>
<a name="ln4210"> </a>
<a name="ln4211">    // First search may fail, but then start searching from the</a>
<a name="ln4212">    // beginning of the file (cursor might be on the search match)</a>
<a name="ln4213">    // except when Visual mode is active, so that extending the visual</a>
<a name="ln4214">    // selection works.</a>
<a name="ln4215">    if (i == 1 &amp;&amp; !result) {  // not found, abort */</a>
<a name="ln4216">      curwin-&gt;w_cursor = orig_pos;</a>
<a name="ln4217">      if (VIsual_active)</a>
<a name="ln4218">        VIsual = save_VIsual;</a>
<a name="ln4219">      return FAIL;</a>
<a name="ln4220">    } else if (i == 0 &amp;&amp; !result) {</a>
<a name="ln4221">      if (forward) {  // try again from start of buffer</a>
<a name="ln4222">        clearpos(&amp;pos);</a>
<a name="ln4223">      } else {  // try again from end of buffer</a>
<a name="ln4224">                // searching backwards, so set pos to last line and col</a>
<a name="ln4225">        pos.lnum = curwin-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln4226">        pos.col  = (colnr_T)STRLEN(</a>
<a name="ln4227">            ml_get(curwin-&gt;w_buffer-&gt;b_ml.ml_line_count));</a>
<a name="ln4228">      }</a>
<a name="ln4229">    }</a>
<a name="ln4230">  }</a>
<a name="ln4231"> </a>
<a name="ln4232">  pos_T start_pos = pos;</a>
<a name="ln4233"> </a>
<a name="ln4234">  if (!VIsual_active) {</a>
<a name="ln4235">    VIsual = start_pos;</a>
<a name="ln4236">  }</a>
<a name="ln4237"> </a>
<a name="ln4238">  // put the cursor after the match</a>
<a name="ln4239">  curwin-&gt;w_cursor = end_pos;</a>
<a name="ln4240">  if (lt(VIsual, end_pos) &amp;&amp; forward) {</a>
<a name="ln4241">    if (skip_first_backward) {</a>
<a name="ln4242">      // put the cursor on the start of the match</a>
<a name="ln4243">      curwin-&gt;w_cursor = pos;</a>
<a name="ln4244">    } else {</a>
<a name="ln4245">      // put the cursor on last character of match</a>
<a name="ln4246">      dec_cursor();</a>
<a name="ln4247">    }</a>
<a name="ln4248">  } else if (VIsual_active &amp;&amp; lt(curwin-&gt;w_cursor, VIsual) &amp;&amp; forward) {</a>
<a name="ln4249">    curwin-&gt;w_cursor = pos;   // put the cursor on the start of the match</a>
<a name="ln4250">  }</a>
<a name="ln4251">  VIsual_active = true;</a>
<a name="ln4252">  VIsual_mode = 'v';</a>
<a name="ln4253"> </a>
<a name="ln4254">  if (*p_sel == 'e') {</a>
<a name="ln4255">    // Correction for exclusive selection depends on the direction.</a>
<a name="ln4256">    if (forward &amp;&amp; ltoreq(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln4257">      inc_cursor();</a>
<a name="ln4258">    } else if (!forward &amp;&amp; ltoreq(curwin-&gt;w_cursor, VIsual)) {</a>
<a name="ln4259">      inc(&amp;VIsual);</a>
<a name="ln4260">    }</a>
<a name="ln4261">  }</a>
<a name="ln4262"> </a>
<a name="ln4263">  if (fdo_flags &amp; FDO_SEARCH &amp;&amp; KeyTyped) {</a>
<a name="ln4264">    foldOpenCursor();</a>
<a name="ln4265">  }</a>
<a name="ln4266"> </a>
<a name="ln4267">  may_start_select('c');</a>
<a name="ln4268">  setmouse();</a>
<a name="ln4269">  redraw_curbuf_later(INVERTED);</a>
<a name="ln4270">  showmode();</a>
<a name="ln4271"> </a>
<a name="ln4272">  return OK;</a>
<a name="ln4273">}</a>
<a name="ln4274"> </a>
<a name="ln4275">/// Check if the pattern is zero-width.</a>
<a name="ln4276">/// If move is true, check from the beginning of the buffer,</a>
<a name="ln4277">/// else from position &quot;cur&quot;.</a>
<a name="ln4278">/// &quot;direction&quot; is FORWARD or BACKWARD.</a>
<a name="ln4279">/// Returns TRUE, FALSE or -1 for failure.</a>
<a name="ln4280">static int</a>
<a name="ln4281">is_zero_width(char_u *pattern, int move, pos_T *cur, Direction direction)</a>
<a name="ln4282">{</a>
<a name="ln4283">  regmmatch_T regmatch;</a>
<a name="ln4284">  int nmatched = 0;</a>
<a name="ln4285">  int result = -1;</a>
<a name="ln4286">  pos_T pos;</a>
<a name="ln4287">  int save_called_emsg = called_emsg;</a>
<a name="ln4288">  int flag = 0;</a>
<a name="ln4289"> </a>
<a name="ln4290">  if (pattern == NULL) {</a>
<a name="ln4291">    pattern = spats[last_idx].pat;</a>
<a name="ln4292">  }</a>
<a name="ln4293"> </a>
<a name="ln4294">  if (search_regcomp(pattern, RE_SEARCH, RE_SEARCH,</a>
<a name="ln4295">          SEARCH_KEEP, &amp;regmatch) == FAIL)</a>
<a name="ln4296">    return -1;</a>
<a name="ln4297"> </a>
<a name="ln4298">  // init startcol correctly</a>
<a name="ln4299">  regmatch.startpos[0].col = -1;</a>
<a name="ln4300">  // move to match</a>
<a name="ln4301">  if (move) {</a>
<a name="ln4302">    clearpos(&amp;pos);</a>
<a name="ln4303">  } else {</a>
<a name="ln4304">    pos = *cur;</a>
<a name="ln4305">    // accept a match at the cursor position</a>
<a name="ln4306">    flag = SEARCH_START;</a>
<a name="ln4307">  }</a>
<a name="ln4308">  if (searchit(curwin, curbuf, &amp;pos, NULL, direction, pattern, 1,</a>
<a name="ln4309">               SEARCH_KEEP + flag, RE_SEARCH, NULL) != FAIL) {</a>
<a name="ln4310">    // Zero-width pattern should match somewhere, then we can check if</a>
<a name="ln4311">    // start and end are in the same position.</a>
<a name="ln4312">    called_emsg = false;</a>
<a name="ln4313">    do {</a>
<a name="ln4314">      regmatch.startpos[0].col++;</a>
<a name="ln4315">      nmatched = vim_regexec_multi(&amp;regmatch, curwin, curbuf,</a>
<a name="ln4316">                                   pos.lnum, regmatch.startpos[0].col,</a>
<a name="ln4317">                                   NULL, NULL);</a>
<a name="ln4318">      if (nmatched != 0) {</a>
<a name="ln4319">        break;</a>
<a name="ln4320">      }</a>
<a name="ln4321">    } while (regmatch.regprog != NULL</a>
<a name="ln4322">             &amp;&amp; direction == FORWARD</a>
<a name="ln4323">             ? regmatch.startpos[0].col &lt; pos.col</a>
<a name="ln4324">             : regmatch.startpos[0].col &gt; pos.col);</a>
<a name="ln4325"> </a>
<a name="ln4326">    if (!called_emsg) {</a>
<a name="ln4327">      result = (nmatched != 0</a>
<a name="ln4328">                &amp;&amp; regmatch.startpos[0].lnum == regmatch.endpos[0].lnum</a>
<a name="ln4329">                &amp;&amp; regmatch.startpos[0].col == regmatch.endpos[0].col);</a>
<a name="ln4330">    }</a>
<a name="ln4331">  }</a>
<a name="ln4332"> </a>
<a name="ln4333">  called_emsg |= save_called_emsg;</a>
<a name="ln4334">  vim_regfree(regmatch.regprog);</a>
<a name="ln4335">  return result;</a>
<a name="ln4336">}</a>
<a name="ln4337"> </a>
<a name="ln4338">/*</a>
<a name="ln4339"> * return TRUE if line 'lnum' is empty or has white chars only.</a>
<a name="ln4340"> */</a>
<a name="ln4341">int linewhite(linenr_T lnum)</a>
<a name="ln4342">{</a>
<a name="ln4343">  char_u  *p;</a>
<a name="ln4344"> </a>
<a name="ln4345">  p = skipwhite(ml_get(lnum));</a>
<a name="ln4346">  return *p == NUL;</a>
<a name="ln4347">}</a>
<a name="ln4348"> </a>
<a name="ln4349">// Add the search count &quot;[3/19]&quot; to &quot;msgbuf&quot;.</a>
<a name="ln4350">// When &quot;recompute&quot; is true Always recompute the numbers.</a>
<a name="ln4351">static void search_stat(int dirc, pos_T *pos,</a>
<a name="ln4352">                        bool show_top_bot_msg, char_u *msgbuf, bool recompute)</a>
<a name="ln4353">{</a>
<a name="ln4354">    int       save_ws = p_ws;</a>
<a name="ln4355">    int       wraparound = false;</a>
<a name="ln4356">    pos_T     p = (*pos);</a>
<a name="ln4357">    static  pos_T   lastpos = { 0, 0, 0 };</a>
<a name="ln4358">    static int      cur = 0;</a>
<a name="ln4359">    static int      cnt = 0;</a>
<a name="ln4360">    static int      chgtick = 0;</a>
<a name="ln4361">    static char_u   *lastpat = NULL;</a>
<a name="ln4362">    static buf_T    *lbuf = NULL;</a>
<a name="ln4363">    proftime_T  start;</a>
<a name="ln4364">#define OUT_OF_TIME 999</a>
<a name="ln4365"> </a>
<a name="ln4366">    wraparound = ((dirc == '?' &amp;&amp; lt(lastpos, p))</a>
<a name="ln4367">                  || (dirc == '/' &amp;&amp; lt(p, lastpos)));</a>
<a name="ln4368"> </a>
<a name="ln4369">    // If anything relevant changed the count has to be recomputed.</a>
<a name="ln4370">    // STRNICMP ignores case, but we should not ignore case.</a>
<a name="ln4371">    // Unfortunately, there is no STRNICMP function.</a>
<a name="ln4372">    if (!(chgtick == buf_get_changedtick(curbuf)</a>
<a name="ln4373">          &amp;&amp; lastpat != NULL  // supress clang/NULL passed as nonnull parameter</a>
<a name="ln4374">          &amp;&amp; STRNICMP(lastpat, spats[last_idx].pat, STRLEN(lastpat)) == 0</a>
<a name="ln4375">          &amp;&amp; STRLEN(lastpat) == STRLEN(spats[last_idx].pat)</a>
<a name="ln4376">          &amp;&amp; equalpos(lastpos, curwin-&gt;w_cursor)</a>
<a name="ln4377">          &amp;&amp; lbuf == curbuf)</a>
<a name="ln4378">        || wraparound || cur &lt; 0 || cur &gt; 99 || recompute) {</a>
<a name="ln4379">      cur = 0;</a>
<a name="ln4380">      cnt = 0;</a>
<a name="ln4381">      clearpos(&amp;lastpos);</a>
<a name="ln4382">      lbuf = curbuf;</a>
<a name="ln4383">    }</a>
<a name="ln4384"> </a>
<a name="ln4385">    if (equalpos(lastpos, curwin-&gt;w_cursor) &amp;&amp; !wraparound</a>
<a name="ln4386">        &amp;&amp; (dirc == '/' ? cur &lt; cnt : cur &gt; 0)) {</a>
<a name="ln4387">      cur += dirc == '/' ? 1 : -1;</a>
<a name="ln4388">    } else {</a>
<a name="ln4389">      p_ws = false;</a>
<a name="ln4390">      start = profile_setlimit(20L);</a>
<a name="ln4391">      while (!got_int &amp;&amp; searchit(curwin, curbuf, &amp;lastpos, NULL,</a>
<a name="ln4392">                                  FORWARD, NULL, 1, SEARCH_KEEP, RE_LAST,</a>
<a name="ln4393">                                  NULL) != FAIL) {</a>
<a name="ln4394">        // Stop after passing the time limit.</a>
<a name="ln4395">        if (profile_passed_limit(start)) {</a>
<a name="ln4396">          cnt = OUT_OF_TIME;</a>
<a name="ln4397">          cur = OUT_OF_TIME;</a>
<a name="ln4398">          break;</a>
<a name="ln4399">        }</a>
<a name="ln4400">        cnt++;</a>
<a name="ln4401">        if (ltoreq(lastpos, p)) {</a>
<a name="ln4402">          cur++;</a>
<a name="ln4403">        }</a>
<a name="ln4404">        fast_breakcheck();</a>
<a name="ln4405">        if (cnt &gt; 99) {</a>
<a name="ln4406">          break;</a>
<a name="ln4407">        }</a>
<a name="ln4408">      }</a>
<a name="ln4409">      if (got_int) {</a>
<a name="ln4410">        cur = -1;  // abort</a>
<a name="ln4411">      }</a>
<a name="ln4412">    }</a>
<a name="ln4413">    if (cur &gt; 0) {</a>
<a name="ln4414">      char t[SEARCH_STAT_BUF_LEN] = &quot;&quot;;</a>
<a name="ln4415">      int len;</a>
<a name="ln4416"> </a>
<a name="ln4417">      if (curwin-&gt;w_p_rl &amp;&amp; *curwin-&gt;w_p_rlc == 's') {</a>
<a name="ln4418">        if (cur == OUT_OF_TIME) {</a>
<a name="ln4419">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[?\?/?]&quot;);</a>
<a name="ln4420">        } else if (cnt &gt; 99 &amp;&amp; cur &gt; 99) {</a>
<a name="ln4421">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[&gt;99/&gt;99]&quot;);</a>
<a name="ln4422">        } else if (cnt &gt; 99) {</a>
<a name="ln4423">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[&gt;99/%d]&quot;, cur);</a>
<a name="ln4424">        } else {</a>
<a name="ln4425">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[%d/%d]&quot;, cnt, cur);</a>
<a name="ln4426">        }</a>
<a name="ln4427">      } else {</a>
<a name="ln4428">        if (cur == OUT_OF_TIME) {</a>
<a name="ln4429">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[?/??]&quot;);</a>
<a name="ln4430">        } else if (cnt &gt; 99 &amp;&amp; cur &gt; 99) {</a>
<a name="ln4431">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[&gt;99/&gt;99]&quot;);</a>
<a name="ln4432">        } else if (cnt &gt; 99) {</a>
<a name="ln4433">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[%d/&gt;99]&quot;, cur);</a>
<a name="ln4434">        } else {</a>
<a name="ln4435">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[%d/%d]&quot;, cur, cnt);</a>
<a name="ln4436">        }</a>
<a name="ln4437">      }</a>
<a name="ln4438"> </a>
<a name="ln4439">      len = STRLEN(t);</a>
<a name="ln4440">      if (show_top_bot_msg &amp;&amp; len + 2 &lt; SEARCH_STAT_BUF_LEN) {</a>
<a name="ln4441">        memmove(t + 2, t, len);</a>
<a name="ln4442">        t[0] = 'W';</a>
<a name="ln4443">        t[1] = ' ';</a>
<a name="ln4444">        len += 2;</a>
<a name="ln4445">      }</a>
<a name="ln4446"> </a>
<a name="ln4447">      memmove(msgbuf + STRLEN(msgbuf) - len, t, len);</a>
<a name="ln4448">      if (dirc == '?' &amp;&amp; cur == 100) {</a>
<a name="ln4449">        cur = -1;</a>
<a name="ln4450">      }</a>
<a name="ln4451"> </a>
<a name="ln4452">      xfree(lastpat);</a>
<a name="ln4453">      lastpat = vim_strsave(spats[last_idx].pat);</a>
<a name="ln4454">      chgtick = buf_get_changedtick(curbuf);</a>
<a name="ln4455">      lbuf    = curbuf;</a>
<a name="ln4456">      lastpos = p;</a>
<a name="ln4457"> </a>
<a name="ln4458">      // keep the message even after redraw, but don't put in history</a>
<a name="ln4459">      msg_hist_off = true;</a>
<a name="ln4460">      msg_ext_set_kind(&quot;search_count&quot;);</a>
<a name="ln4461">      give_warning(msgbuf, false);</a>
<a name="ln4462">      msg_hist_off = false;</a>
<a name="ln4463">    }</a>
<a name="ln4464">    p_ws = save_ws;</a>
<a name="ln4465">}</a>
<a name="ln4466"> </a>
<a name="ln4467">/*</a>
<a name="ln4468"> * Find identifiers or defines in included files.</a>
<a name="ln4469"> * If p_ic &amp;&amp; (compl_cont_status &amp; CONT_SOL) then ptr must be in lowercase.</a>
<a name="ln4470"> */</a>
<a name="ln4471">void</a>
<a name="ln4472">find_pattern_in_path(</a>
<a name="ln4473">    char_u *ptr,            // pointer to search pattern</a>
<a name="ln4474">    Direction dir,          // direction of expansion</a>
<a name="ln4475">    size_t len,             // length of search pattern</a>
<a name="ln4476">    bool whole,             // match whole words only</a>
<a name="ln4477">    bool skip_comments,     // don't match inside comments</a>
<a name="ln4478">    int type,               // Type of search; are we looking for a type?</a>
<a name="ln4479">                            // a macro?</a>
<a name="ln4480">    long count,</a>
<a name="ln4481">    int action,             // What to do when we find it</a>
<a name="ln4482">    linenr_T start_lnum,    // first line to start searching</a>
<a name="ln4483">    linenr_T end_lnum       // last line for searching</a>
<a name="ln4484">)</a>
<a name="ln4485">{</a>
<a name="ln4486">  SearchedFile *files;                  /* Stack of included files */</a>
<a name="ln4487">  SearchedFile *bigger;                 /* When we need more space */</a>
<a name="ln4488">  int max_path_depth = 50;</a>
<a name="ln4489">  long match_count = 1;</a>
<a name="ln4490"> </a>
<a name="ln4491">  char_u      *pat;</a>
<a name="ln4492">  char_u      *new_fname;</a>
<a name="ln4493">  char_u      *curr_fname = curbuf-&gt;b_fname;</a>
<a name="ln4494">  char_u      *prev_fname = NULL;</a>
<a name="ln4495">  linenr_T lnum;</a>
<a name="ln4496">  int depth;</a>
<a name="ln4497">  int depth_displayed;                  /* For type==CHECK_PATH */</a>
<a name="ln4498">  int old_files;</a>
<a name="ln4499">  int already_searched;</a>
<a name="ln4500">  char_u      *file_line;</a>
<a name="ln4501">  char_u      *line;</a>
<a name="ln4502">  char_u      *p;</a>
<a name="ln4503">  char_u save_char;</a>
<a name="ln4504">  int define_matched;</a>
<a name="ln4505">  regmatch_T regmatch;</a>
<a name="ln4506">  regmatch_T incl_regmatch;</a>
<a name="ln4507">  regmatch_T def_regmatch;</a>
<a name="ln4508">  bool matched = false;</a>
<a name="ln4509">  bool did_show = false;</a>
<a name="ln4510">  bool found = false;</a>
<a name="ln4511">  int i;</a>
<a name="ln4512">  char_u      *already = NULL;</a>
<a name="ln4513">  char_u      *startp = NULL;</a>
<a name="ln4514">  char_u      *inc_opt = NULL;</a>
<a name="ln4515">  win_T       *curwin_save = NULL;</a>
<a name="ln4516">  const int l_g_do_tagpreview = g_do_tagpreview;</a>
<a name="ln4517"> </a>
<a name="ln4518">  regmatch.regprog = NULL;</a>
<a name="ln4519">  incl_regmatch.regprog = NULL;</a>
<a name="ln4520">  def_regmatch.regprog = NULL;</a>
<a name="ln4521"> </a>
<a name="ln4522">  file_line = xmalloc(LSIZE);</a>
<a name="ln4523"> </a>
<a name="ln4524">  if (type != CHECK_PATH &amp;&amp; type != FIND_DEFINE</a>
<a name="ln4525">      /* when CONT_SOL is set compare &quot;ptr&quot; with the beginning of the line</a>
<a name="ln4526">       * is faster than quote_meta/regcomp/regexec &quot;ptr&quot; -- Acevedo */</a>
<a name="ln4527">      &amp;&amp; !(compl_cont_status &amp; CONT_SOL)</a>
<a name="ln4528">      ) {</a>
<a name="ln4529">    pat = xmalloc(len + 5);</a>
<a name="ln4530">    assert(len &lt;= INT_MAX);</a>
<a name="ln4531">    sprintf((char *)pat, whole ? &quot;\\&lt;%.*s\\&gt;&quot; : &quot;%.*s&quot;, (int)len, ptr);</a>
<a name="ln4532">    /* ignore case according to p_ic, p_scs and pat */</a>
<a name="ln4533">    regmatch.rm_ic = ignorecase(pat);</a>
<a name="ln4534">    regmatch.regprog = vim_regcomp(pat, p_magic ? RE_MAGIC : 0);</a>
<a name="ln4535">    xfree(pat);</a>
<a name="ln4536">    if (regmatch.regprog == NULL)</a>
<a name="ln4537">      goto fpip_end;</a>
<a name="ln4538">  }</a>
<a name="ln4539">  inc_opt = (*curbuf-&gt;b_p_inc == NUL) ? p_inc : curbuf-&gt;b_p_inc;</a>
<a name="ln4540">  if (*inc_opt != NUL) {</a>
<a name="ln4541">    incl_regmatch.regprog = vim_regcomp(inc_opt, p_magic ? RE_MAGIC : 0);</a>
<a name="ln4542">    if (incl_regmatch.regprog == NULL)</a>
<a name="ln4543">      goto fpip_end;</a>
<a name="ln4544">    incl_regmatch.rm_ic = FALSE;        /* don't ignore case in incl. pat. */</a>
<a name="ln4545">  }</a>
<a name="ln4546">  if (type == FIND_DEFINE &amp;&amp; (*curbuf-&gt;b_p_def != NUL || *p_def != NUL)) {</a>
<a name="ln4547">    def_regmatch.regprog = vim_regcomp(*curbuf-&gt;b_p_def == NUL</a>
<a name="ln4548">        ? p_def : curbuf-&gt;b_p_def, p_magic ? RE_MAGIC : 0);</a>
<a name="ln4549">    if (def_regmatch.regprog == NULL)</a>
<a name="ln4550">      goto fpip_end;</a>
<a name="ln4551">    def_regmatch.rm_ic = FALSE;         /* don't ignore case in define pat. */</a>
<a name="ln4552">  }</a>
<a name="ln4553">  files = xcalloc(max_path_depth, sizeof(SearchedFile));</a>
<a name="ln4554">  old_files = max_path_depth;</a>
<a name="ln4555">  depth = depth_displayed = -1;</a>
<a name="ln4556"> </a>
<a name="ln4557">  lnum = start_lnum;</a>
<a name="ln4558">  if (end_lnum &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln4559">    end_lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln4560">  if (lnum &gt; end_lnum)                  /* do at least one line */</a>
<a name="ln4561">    lnum = end_lnum;</a>
<a name="ln4562">  line = ml_get(lnum);</a>
<a name="ln4563"> </a>
<a name="ln4564">  for (;; ) {</a>
<a name="ln4565">    if (incl_regmatch.regprog != NULL</a>
<a name="ln4566">        &amp;&amp; vim_regexec(&amp;incl_regmatch, line, (colnr_T)0)) {</a>
<a name="ln4567">      char_u *p_fname = (curr_fname == curbuf-&gt;b_fname)</a>
<a name="ln4568">                        ? curbuf-&gt;b_ffname : curr_fname;</a>
<a name="ln4569"> </a>
<a name="ln4570">      if (inc_opt != NULL &amp;&amp; strstr((char *)inc_opt, &quot;\\zs&quot;) != NULL)</a>
<a name="ln4571">        /* Use text from '\zs' to '\ze' (or end) of 'include'. */</a>
<a name="ln4572">        new_fname = find_file_name_in_path(incl_regmatch.startp[0],</a>
<a name="ln4573">                                           (size_t)(incl_regmatch.endp[0]</a>
<a name="ln4574">                                                    - incl_regmatch.startp[0]),</a>
<a name="ln4575">                                           FNAME_EXP|FNAME_INCL|FNAME_REL,</a>
<a name="ln4576">                                           1L, p_fname);</a>
<a name="ln4577">      else</a>
<a name="ln4578">        /* Use text after match with 'include'. */</a>
<a name="ln4579">        new_fname = file_name_in_line(incl_regmatch.endp[0], 0,</a>
<a name="ln4580">            FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);</a>
<a name="ln4581">      already_searched = FALSE;</a>
<a name="ln4582">      if (new_fname != NULL) {</a>
<a name="ln4583">        // Check whether we have already searched in this file</a>
<a name="ln4584">        for (i = 0;; i++) {</a>
<a name="ln4585">          if (i == depth + 1) {</a>
<a name="ln4586">            i = old_files;</a>
<a name="ln4587">          }</a>
<a name="ln4588">          if (i == max_path_depth) {</a>
<a name="ln4589">            break;</a>
<a name="ln4590">          }</a>
<a name="ln4591">          if (path_full_compare(new_fname, files[i].name,</a>
<a name="ln4592">                                true, true) &amp; kEqualFiles) {</a>
<a name="ln4593">            if (type != CHECK_PATH</a>
<a name="ln4594">                &amp;&amp; action == ACTION_SHOW_ALL &amp;&amp; files[i].matched) {</a>
<a name="ln4595">              msg_putchar('\n');  // cursor below last one */</a>
<a name="ln4596">              if (!got_int) {  // don't display if 'q' typed at &quot;--more--&quot;</a>
<a name="ln4597">                               // message</a>
<a name="ln4598">                msg_home_replace_hl(new_fname);</a>
<a name="ln4599">                MSG_PUTS(_(&quot; (includes previously listed match)&quot;));</a>
<a name="ln4600">                prev_fname = NULL;</a>
<a name="ln4601">              }</a>
<a name="ln4602">            }</a>
<a name="ln4603">            XFREE_CLEAR(new_fname);</a>
<a name="ln4604">            already_searched = true;</a>
<a name="ln4605">            break;</a>
<a name="ln4606">          }</a>
<a name="ln4607">        }</a>
<a name="ln4608">      }</a>
<a name="ln4609"> </a>
<a name="ln4610">      if (type == CHECK_PATH &amp;&amp; (action == ACTION_SHOW_ALL</a>
<a name="ln4611">                                 || (new_fname == NULL &amp;&amp; !already_searched))) {</a>
<a name="ln4612">        if (did_show) {</a>
<a name="ln4613">          msg_putchar('\n');  // cursor below last one</a>
<a name="ln4614">        } else {</a>
<a name="ln4615">          gotocmdline(true);  // cursor at status line</a>
<a name="ln4616">          MSG_PUTS_TITLE(_(&quot;--- Included files &quot;));</a>
<a name="ln4617">          if (action != ACTION_SHOW_ALL) {</a>
<a name="ln4618">            MSG_PUTS_TITLE(_(&quot;not found &quot;));</a>
<a name="ln4619">          }</a>
<a name="ln4620">          MSG_PUTS_TITLE(_(&quot;in path ---\n&quot;));</a>
<a name="ln4621">        }</a>
<a name="ln4622">        did_show = true;</a>
<a name="ln4623">        while (depth_displayed &lt; depth &amp;&amp; !got_int) {</a>
<a name="ln4624">          ++depth_displayed;</a>
<a name="ln4625">          for (i = 0; i &lt; depth_displayed; i++)</a>
<a name="ln4626">            MSG_PUTS(&quot;  &quot;);</a>
<a name="ln4627">          msg_home_replace(files[depth_displayed].name);</a>
<a name="ln4628">          MSG_PUTS(&quot; --&gt;\n&quot;);</a>
<a name="ln4629">        }</a>
<a name="ln4630">        if (!got_int) {                     /* don't display if 'q' typed</a>
<a name="ln4631">                                               for &quot;--more--&quot; message */</a>
<a name="ln4632">          for (i = 0; i &lt;= depth_displayed; i++)</a>
<a name="ln4633">            MSG_PUTS(&quot;  &quot;);</a>
<a name="ln4634">          if (new_fname != NULL) {</a>
<a name="ln4635">            /* using &quot;new_fname&quot; is more reliable, e.g., when</a>
<a name="ln4636">             * 'includeexpr' is set. */</a>
<a name="ln4637">            msg_outtrans_attr(new_fname, HL_ATTR(HLF_D));</a>
<a name="ln4638">          } else {</a>
<a name="ln4639">            /*</a>
<a name="ln4640">             * Isolate the file name.</a>
<a name="ln4641">             * Include the surrounding &quot;&quot; or &lt;&gt; if present.</a>
<a name="ln4642">             */</a>
<a name="ln4643">            if (inc_opt != NULL</a>
<a name="ln4644">                &amp;&amp; strstr((char *)inc_opt, &quot;\\zs&quot;) != NULL) {</a>
<a name="ln4645">              /* pattern contains \zs, use the match */</a>
<a name="ln4646">              p = incl_regmatch.startp[0];</a>
<a name="ln4647">              i = (int)(incl_regmatch.endp[0]</a>
<a name="ln4648">                        - incl_regmatch.startp[0]);</a>
<a name="ln4649">            } else {</a>
<a name="ln4650">              /* find the file name after the end of the match */</a>
<a name="ln4651">              for (p = incl_regmatch.endp[0];</a>
<a name="ln4652">                   *p &amp;&amp; !vim_isfilec(*p); p++)</a>
<a name="ln4653">                ;</a>
<a name="ln4654">              for (i = 0; vim_isfilec(p[i]); i++)</a>
<a name="ln4655">                ;</a>
<a name="ln4656">            }</a>
<a name="ln4657"> </a>
<a name="ln4658">            if (i == 0) {</a>
<a name="ln4659">              /* Nothing found, use the rest of the line. */</a>
<a name="ln4660">              p = incl_regmatch.endp[0];</a>
<a name="ln4661">              i = (int)STRLEN(p);</a>
<a name="ln4662">            }</a>
<a name="ln4663">            /* Avoid checking before the start of the line, can</a>
<a name="ln4664">             * happen if \zs appears in the regexp. */</a>
<a name="ln4665">            else if (p &gt; line) {</a>
<a name="ln4666">              if (p[-1] == '&quot;' || p[-1] == '&lt;') {</a>
<a name="ln4667">                --p;</a>
<a name="ln4668">                ++i;</a>
<a name="ln4669">              }</a>
<a name="ln4670">              if (p[i] == '&quot;' || p[i] == '&gt;')</a>
<a name="ln4671">                ++i;</a>
<a name="ln4672">            }</a>
<a name="ln4673">            save_char = p[i];</a>
<a name="ln4674">            p[i] = NUL;</a>
<a name="ln4675">            msg_outtrans_attr(p, HL_ATTR(HLF_D));</a>
<a name="ln4676">            p[i] = save_char;</a>
<a name="ln4677">          }</a>
<a name="ln4678"> </a>
<a name="ln4679">          if (new_fname == NULL &amp;&amp; action == ACTION_SHOW_ALL) {</a>
<a name="ln4680">            if (already_searched)</a>
<a name="ln4681">              MSG_PUTS(_(&quot;  (Already listed)&quot;));</a>
<a name="ln4682">            else</a>
<a name="ln4683">              MSG_PUTS(_(&quot;  NOT FOUND&quot;));</a>
<a name="ln4684">          }</a>
<a name="ln4685">        }</a>
<a name="ln4686">        ui_flush();                /* output each line directly */</a>
<a name="ln4687">      }</a>
<a name="ln4688"> </a>
<a name="ln4689">      if (new_fname != NULL) {</a>
<a name="ln4690">        /* Push the new file onto the file stack */</a>
<a name="ln4691">        if (depth + 1 == old_files) {</a>
<a name="ln4692">          bigger = xmalloc(max_path_depth * 2 * sizeof(SearchedFile));</a>
<a name="ln4693">          for (i = 0; i &lt;= depth; i++)</a>
<a name="ln4694">            bigger[i] = files[i];</a>
<a name="ln4695">          for (i = depth + 1; i &lt; old_files + max_path_depth; i++) {</a>
<a name="ln4696">            bigger[i].fp = NULL;</a>
<a name="ln4697">            bigger[i].name = NULL;</a>
<a name="ln4698">            bigger[i].lnum = 0;</a>
<a name="ln4699">            bigger[i].matched = FALSE;</a>
<a name="ln4700">          }</a>
<a name="ln4701">          for (i = old_files; i &lt; max_path_depth; i++)</a>
<a name="ln4702">            bigger[i + max_path_depth] = files[i];</a>
<a name="ln4703">          old_files += max_path_depth;</a>
<a name="ln4704">          max_path_depth *= 2;</a>
<a name="ln4705">          xfree(files);</a>
<a name="ln4706">          files = bigger;</a>
<a name="ln4707">        }</a>
<a name="ln4708">        if ((files[depth + 1].fp = os_fopen((char *)new_fname, &quot;r&quot;)) == NULL) {</a>
<a name="ln4709">          xfree(new_fname);</a>
<a name="ln4710">        } else {</a>
<a name="ln4711">          if (++depth == old_files) {</a>
<a name="ln4712">            // Something wrong. We will forget one of our already visited files</a>
<a name="ln4713">            // now.</a>
<a name="ln4714">            xfree(files[old_files].name);</a>
<a name="ln4715">            ++old_files;</a>
<a name="ln4716">          }</a>
<a name="ln4717">          files[depth].name = curr_fname = new_fname;</a>
<a name="ln4718">          files[depth].lnum = 0;</a>
<a name="ln4719">          files[depth].matched = FALSE;</a>
<a name="ln4720">          if (action == ACTION_EXPAND) {</a>
<a name="ln4721">            msg_hist_off = true;                // reset in msg_trunc_attr()</a>
<a name="ln4722">            vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln4723">                         _(&quot;Scanning included file: %s&quot;),</a>
<a name="ln4724">                         (char *)new_fname);</a>
<a name="ln4725">            msg_trunc_attr(IObuff, true, HL_ATTR(HLF_R));</a>
<a name="ln4726">          } else if (p_verbose &gt;= 5) {</a>
<a name="ln4727">            verbose_enter();</a>
<a name="ln4728">            smsg(_(&quot;Searching included file %s&quot;),</a>
<a name="ln4729">                (char *)new_fname);</a>
<a name="ln4730">            verbose_leave();</a>
<a name="ln4731">          }</a>
<a name="ln4732"> </a>
<a name="ln4733">        }</a>
<a name="ln4734">      }</a>
<a name="ln4735">    } else {</a>
<a name="ln4736">      /*</a>
<a name="ln4737">       * Check if the line is a define (type == FIND_DEFINE)</a>
<a name="ln4738">       */</a>
<a name="ln4739">      p = line;</a>
<a name="ln4740">search_line:</a>
<a name="ln4741">      define_matched = FALSE;</a>
<a name="ln4742">      if (def_regmatch.regprog != NULL</a>
<a name="ln4743">          &amp;&amp; vim_regexec(&amp;def_regmatch, line, (colnr_T)0)) {</a>
<a name="ln4744">        /*</a>
<a name="ln4745">         * Pattern must be first identifier after 'define', so skip</a>
<a name="ln4746">         * to that position before checking for match of pattern.  Also</a>
<a name="ln4747">         * don't let it match beyond the end of this identifier.</a>
<a name="ln4748">         */</a>
<a name="ln4749">        p = def_regmatch.endp[0];</a>
<a name="ln4750">        while (*p &amp;&amp; !vim_iswordc(*p))</a>
<a name="ln4751">          p++;</a>
<a name="ln4752">        define_matched = TRUE;</a>
<a name="ln4753">      }</a>
<a name="ln4754"> </a>
<a name="ln4755">      /*</a>
<a name="ln4756">       * Look for a match.  Don't do this if we are looking for a</a>
<a name="ln4757">       * define and this line didn't match define_prog above.</a>
<a name="ln4758">       */</a>
<a name="ln4759">      if (def_regmatch.regprog == NULL || define_matched) {</a>
<a name="ln4760">        if (define_matched</a>
<a name="ln4761">            || (compl_cont_status &amp; CONT_SOL)</a>
<a name="ln4762">            ) {</a>
<a name="ln4763">          /* compare the first &quot;len&quot; chars from &quot;ptr&quot; */</a>
<a name="ln4764">          startp = skipwhite(p);</a>
<a name="ln4765">          if (p_ic) {</a>
<a name="ln4766">            matched = !mb_strnicmp(startp, ptr, len);</a>
<a name="ln4767">          }</a>
<a name="ln4768">          else</a>
<a name="ln4769">            matched = !STRNCMP(startp, ptr, len);</a>
<a name="ln4770">          if (matched &amp;&amp; define_matched &amp;&amp; whole</a>
<a name="ln4771">              &amp;&amp; vim_iswordc(startp[len]))</a>
<a name="ln4772">            matched = false;</a>
<a name="ln4773">        } else if (regmatch.regprog != NULL</a>
<a name="ln4774">                   &amp;&amp; vim_regexec(&amp;regmatch, line, (colnr_T)(p - line))) {</a>
<a name="ln4775">          matched = true;</a>
<a name="ln4776">          startp = regmatch.startp[0];</a>
<a name="ln4777">          // Check if the line is not a comment line (unless we are</a>
<a name="ln4778">          // looking for a define).  A line starting with &quot;# define&quot;</a>
<a name="ln4779">          // is not considered to be a comment line.</a>
<a name="ln4780">          if (skip_comments) {</a>
<a name="ln4781">            if ((*line != '#'</a>
<a name="ln4782">                 || STRNCMP(skipwhite(line + 1), &quot;define&quot;, 6) != 0)</a>
<a name="ln4783">                &amp;&amp; get_leader_len(line, NULL, false, true)) {</a>
<a name="ln4784">              matched = false;</a>
<a name="ln4785">            }</a>
<a name="ln4786"> </a>
<a name="ln4787">            /*</a>
<a name="ln4788">             * Also check for a &quot;/ *&quot; or &quot;/ /&quot; before the match.</a>
<a name="ln4789">             * Skips lines like &quot;int backwards;  / * normal index</a>
<a name="ln4790">             * * /&quot; when looking for &quot;normal&quot;.</a>
<a name="ln4791">             * Note: Doesn't skip &quot;/ *&quot; in comments.</a>
<a name="ln4792">             */</a>
<a name="ln4793">            p = skipwhite(line);</a>
<a name="ln4794">            if (matched</a>
<a name="ln4795">                || (p[0] == '/' &amp;&amp; p[1] == '*') || p[0] == '*')</a>
<a name="ln4796">              for (p = line; *p &amp;&amp; p &lt; startp; ++p) {</a>
<a name="ln4797">                if (matched</a>
<a name="ln4798">                    &amp;&amp; p[0] == '/'</a>
<a name="ln4799">                    &amp;&amp; (p[1] == '*' || p[1] == '/')) {</a>
<a name="ln4800">                  matched = false;</a>
<a name="ln4801">                  // After &quot;//&quot; all text is comment</a>
<a name="ln4802">                  if (p[1] == '/') {</a>
<a name="ln4803">                    break;</a>
<a name="ln4804">                  }</a>
<a name="ln4805">                  p++;</a>
<a name="ln4806">                } else if (!matched &amp;&amp; p[0] == '*' &amp;&amp; p[1] == '/') {</a>
<a name="ln4807">                  // Can find match after &quot;* /&quot;.</a>
<a name="ln4808">                  matched = true;</a>
<a name="ln4809">                  p++;</a>
<a name="ln4810">                }</a>
<a name="ln4811">              }</a>
<a name="ln4812">          }</a>
<a name="ln4813">        }</a>
<a name="ln4814">      }</a>
<a name="ln4815">    }</a>
<a name="ln4816">    if (matched) {</a>
<a name="ln4817">      if (action == ACTION_EXPAND) {</a>
<a name="ln4818">        bool cont_s_ipos = false;</a>
<a name="ln4819">        char_u  *aux;</a>
<a name="ln4820"> </a>
<a name="ln4821">        if (depth == -1 &amp;&amp; lnum == curwin-&gt;w_cursor.lnum)</a>
<a name="ln4822">          break;</a>
<a name="ln4823">        found = true;</a>
<a name="ln4824">        aux = p = startp;</a>
<a name="ln4825">        if (compl_cont_status &amp; CONT_ADDING) {</a>
<a name="ln4826">          p += compl_length;</a>
<a name="ln4827">          if (vim_iswordp(p))</a>
<a name="ln4828">            goto exit_matched;</a>
<a name="ln4829">          p = find_word_start(p);</a>
<a name="ln4830">        }</a>
<a name="ln4831">        p = find_word_end(p);</a>
<a name="ln4832">        i = (int)(p - aux);</a>
<a name="ln4833"> </a>
<a name="ln4834">        if ((compl_cont_status &amp; CONT_ADDING) &amp;&amp; i == compl_length) {</a>
<a name="ln4835">          /* IOSIZE &gt; compl_length, so the STRNCPY works */</a>
<a name="ln4836">          STRNCPY(IObuff, aux, i);</a>
<a name="ln4837"> </a>
<a name="ln4838">          /* Get the next line: when &quot;depth&quot; &lt; 0  from the current</a>
<a name="ln4839">           * buffer, otherwise from the included file.  Jump to</a>
<a name="ln4840">           * exit_matched when past the last line. */</a>
<a name="ln4841">          if (depth &lt; 0) {</a>
<a name="ln4842">            if (lnum &gt;= end_lnum)</a>
<a name="ln4843">              goto exit_matched;</a>
<a name="ln4844">            line = ml_get(++lnum);</a>
<a name="ln4845">          } else if (vim_fgets(line = file_line,</a>
<a name="ln4846">                         LSIZE, files[depth].fp))</a>
<a name="ln4847">            goto exit_matched;</a>
<a name="ln4848"> </a>
<a name="ln4849">          /* we read a line, set &quot;already&quot; to check this &quot;line&quot; later</a>
<a name="ln4850">           * if depth &gt;= 0 we'll increase files[depth].lnum far</a>
<a name="ln4851">           * bellow  -- Acevedo */</a>
<a name="ln4852">          already = aux = p = skipwhite(line);</a>
<a name="ln4853">          p = find_word_start(p);</a>
<a name="ln4854">          p = find_word_end(p);</a>
<a name="ln4855">          if (p &gt; aux) {</a>
<a name="ln4856">            if (*aux != ')' &amp;&amp; IObuff[i-1] != TAB) {</a>
<a name="ln4857">              if (IObuff[i-1] != ' ')</a>
<a name="ln4858">                IObuff[i++] = ' ';</a>
<a name="ln4859">              /* IObuf =~ &quot;\(\k\|\i\).* &quot;, thus i &gt;= 2*/</a>
<a name="ln4860">              if (p_js</a>
<a name="ln4861">                  &amp;&amp; (IObuff[i-2] == '.'</a>
<a name="ln4862">                      || IObuff[i-2] == '?'</a>
<a name="ln4863">                      || IObuff[i-2] == '!')) {</a>
<a name="ln4864">                IObuff[i++] = ' ';</a>
<a name="ln4865">              }</a>
<a name="ln4866">            }</a>
<a name="ln4867">            /* copy as much as possible of the new word */</a>
<a name="ln4868">            if (p - aux &gt;= IOSIZE - i)</a>
<a name="ln4869">              p = aux + IOSIZE - i - 1;</a>
<a name="ln4870">            STRNCPY(IObuff + i, aux, p - aux);</a>
<a name="ln4871">            i += (int)(p - aux);</a>
<a name="ln4872">            cont_s_ipos = true;</a>
<a name="ln4873">          }</a>
<a name="ln4874">          IObuff[i] = NUL;</a>
<a name="ln4875">          aux = IObuff;</a>
<a name="ln4876"> </a>
<a name="ln4877">          if (i == compl_length)</a>
<a name="ln4878">            goto exit_matched;</a>
<a name="ln4879">        }</a>
<a name="ln4880"> </a>
<a name="ln4881">        const int add_r = ins_compl_add_infercase(</a>
<a name="ln4882">            aux, i, p_ic, curr_fname == curbuf-&gt;b_fname ? NULL : curr_fname,</a>
<a name="ln4883">            dir, cont_s_ipos);</a>
<a name="ln4884">        if (add_r == OK) {</a>
<a name="ln4885">          // if dir was BACKWARD then honor it just once</a>
<a name="ln4886">          dir = FORWARD;</a>
<a name="ln4887">        } else if (add_r == FAIL) {</a>
<a name="ln4888">          break;</a>
<a name="ln4889">        }</a>
<a name="ln4890">      } else if (action == ACTION_SHOW_ALL) {</a>
<a name="ln4891">        found = true;</a>
<a name="ln4892">        if (!did_show) {</a>
<a name="ln4893">          gotocmdline(true);                    // cursor at status line</a>
<a name="ln4894">        }</a>
<a name="ln4895">        if (curr_fname != prev_fname) {</a>
<a name="ln4896">          if (did_show)</a>
<a name="ln4897">            msg_putchar('\n');                  /* cursor below last one */</a>
<a name="ln4898">          if (!got_int)                         /* don't display if 'q' typed</a>
<a name="ln4899">                                                    at &quot;--more--&quot; message */</a>
<a name="ln4900">            msg_home_replace_hl(curr_fname);</a>
<a name="ln4901">          prev_fname = curr_fname;</a>
<a name="ln4902">        }</a>
<a name="ln4903">        did_show = true;</a>
<a name="ln4904">        if (!got_int) {</a>
<a name="ln4905">          show_pat_in_path(line, type, true, action,</a>
<a name="ln4906">                           (depth == -1) ? NULL : files[depth].fp,</a>
<a name="ln4907">                           (depth == -1) ? &amp;lnum : &amp;files[depth].lnum,</a>
<a name="ln4908">                           match_count++);</a>
<a name="ln4909">        }</a>
<a name="ln4910"> </a>
<a name="ln4911">        /* Set matched flag for this file and all the ones that</a>
<a name="ln4912">         * include it */</a>
<a name="ln4913">        for (i = 0; i &lt;= depth; ++i)</a>
<a name="ln4914">          files[i].matched = TRUE;</a>
<a name="ln4915">      } else if (--count &lt;= 0) {</a>
<a name="ln4916">        found = true;</a>
<a name="ln4917">        if (depth == -1 &amp;&amp; lnum == curwin-&gt;w_cursor.lnum</a>
<a name="ln4918">            &amp;&amp; l_g_do_tagpreview == 0) {</a>
<a name="ln4919">          EMSG(_(&quot;E387: Match is on current line&quot;));</a>
<a name="ln4920">        } else if (action == ACTION_SHOW) {</a>
<a name="ln4921">          show_pat_in_path(line, type, did_show, action,</a>
<a name="ln4922">                           (depth == -1) ? NULL : files[depth].fp,</a>
<a name="ln4923">                           (depth == -1) ? &amp;lnum : &amp;files[depth].lnum, 1L);</a>
<a name="ln4924">          did_show = true;</a>
<a name="ln4925">        } else {</a>
<a name="ln4926">          /* &quot;:psearch&quot; uses the preview window */</a>
<a name="ln4927">          if (l_g_do_tagpreview != 0) {</a>
<a name="ln4928">            curwin_save = curwin;</a>
<a name="ln4929">            prepare_tagpreview(true);</a>
<a name="ln4930">          }</a>
<a name="ln4931">          if (action == ACTION_SPLIT) {</a>
<a name="ln4932">            if (win_split(0, 0) == FAIL)</a>
<a name="ln4933">              break;</a>
<a name="ln4934">            RESET_BINDING(curwin);</a>
<a name="ln4935">          }</a>
<a name="ln4936">          if (depth == -1) {</a>
<a name="ln4937">            // match in current file</a>
<a name="ln4938">            if (l_g_do_tagpreview != 0) {</a>
<a name="ln4939">              if (!GETFILE_SUCCESS(getfile(curwin_save-&gt;w_buffer-&gt;b_fnum, NULL,</a>
<a name="ln4940">                                           NULL, true, lnum, false))) {</a>
<a name="ln4941">                break;    // failed to jump to file</a>
<a name="ln4942">              }</a>
<a name="ln4943">            } else {</a>
<a name="ln4944">              setpcmark();</a>
<a name="ln4945">            }</a>
<a name="ln4946">            curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln4947">            check_cursor();</a>
<a name="ln4948">          } else {</a>
<a name="ln4949">            if (!GETFILE_SUCCESS(getfile(0, files[depth].name, NULL, true,</a>
<a name="ln4950">                                         files[depth].lnum, false))) {</a>
<a name="ln4951">              break;    // failed to jump to file</a>
<a name="ln4952">            }</a>
<a name="ln4953">            // autocommands may have changed the lnum, we don't</a>
<a name="ln4954">            // want that here</a>
<a name="ln4955">            curwin-&gt;w_cursor.lnum = files[depth].lnum;</a>
<a name="ln4956">          }</a>
<a name="ln4957">        }</a>
<a name="ln4958">        if (action != ACTION_SHOW) {</a>
<a name="ln4959">          curwin-&gt;w_cursor.col = (colnr_T)(startp - line);</a>
<a name="ln4960">          curwin-&gt;w_set_curswant = TRUE;</a>
<a name="ln4961">        }</a>
<a name="ln4962"> </a>
<a name="ln4963">        if (l_g_do_tagpreview != 0</a>
<a name="ln4964">            &amp;&amp; curwin != curwin_save &amp;&amp; win_valid(curwin_save)) {</a>
<a name="ln4965">          /* Return cursor to where we were */</a>
<a name="ln4966">          validate_cursor();</a>
<a name="ln4967">          redraw_later(curwin, VALID);</a>
<a name="ln4968">          win_enter(curwin_save, true);</a>
<a name="ln4969">        }</a>
<a name="ln4970">        break;</a>
<a name="ln4971">      }</a>
<a name="ln4972">exit_matched:</a>
<a name="ln4973">      matched = false;</a>
<a name="ln4974">      // look for other matches in the rest of the line if we</a>
<a name="ln4975">      // are not at the end of it already</a>
<a name="ln4976">      if (def_regmatch.regprog == NULL</a>
<a name="ln4977">          &amp;&amp; action == ACTION_EXPAND</a>
<a name="ln4978">          &amp;&amp; !(compl_cont_status &amp; CONT_SOL)</a>
<a name="ln4979">          &amp;&amp; *startp != NUL</a>
<a name="ln4980">          &amp;&amp; *(p = startp + utfc_ptr2len(startp)) != NUL) {</a>
<a name="ln4981">        goto search_line;</a>
<a name="ln4982">      }</a>
<a name="ln4983">    }</a>
<a name="ln4984">    line_breakcheck();</a>
<a name="ln4985">    if (action == ACTION_EXPAND)</a>
<a name="ln4986">      ins_compl_check_keys(30, false);</a>
<a name="ln4987">    if (got_int || compl_interrupted)</a>
<a name="ln4988">      break;</a>
<a name="ln4989"> </a>
<a name="ln4990">    /*</a>
<a name="ln4991">     * Read the next line.  When reading an included file and encountering</a>
<a name="ln4992">     * end-of-file, close the file and continue in the file that included</a>
<a name="ln4993">     * it.</a>
<a name="ln4994">     */</a>
<a name="ln4995">    while (depth &gt;= 0 &amp;&amp; !already</a>
<a name="ln4996">           &amp;&amp; vim_fgets(line = file_line, LSIZE, files[depth].fp)) {</a>
<a name="ln4997">      fclose(files[depth].fp);</a>
<a name="ln4998">      --old_files;</a>
<a name="ln4999">      files[old_files].name = files[depth].name;</a>
<a name="ln5000">      files[old_files].matched = files[depth].matched;</a>
<a name="ln5001">      --depth;</a>
<a name="ln5002">      curr_fname = (depth == -1) ? curbuf-&gt;b_fname</a>
<a name="ln5003">                   : files[depth].name;</a>
<a name="ln5004">      if (depth &lt; depth_displayed)</a>
<a name="ln5005">        depth_displayed = depth;</a>
<a name="ln5006">    }</a>
<a name="ln5007">    if (depth &gt;= 0) {           /* we could read the line */</a>
<a name="ln5008">      files[depth].lnum++;</a>
<a name="ln5009">      /* Remove any CR and LF from the line. */</a>
<a name="ln5010">      i = (int)STRLEN(line);</a>
<a name="ln5011">      if (i &gt; 0 &amp;&amp; line[i - 1] == '\n')</a>
<a name="ln5012">        line[--i] = NUL;</a>
<a name="ln5013">      if (i &gt; 0 &amp;&amp; line[i - 1] == '\r')</a>
<a name="ln5014">        line[--i] = NUL;</a>
<a name="ln5015">    } else if (!already) {</a>
<a name="ln5016">      if (++lnum &gt; end_lnum)</a>
<a name="ln5017">        break;</a>
<a name="ln5018">      line = ml_get(lnum);</a>
<a name="ln5019">    }</a>
<a name="ln5020">    already = NULL;</a>
<a name="ln5021">  }</a>
<a name="ln5022">  /* End of big for (;;) loop. */</a>
<a name="ln5023"> </a>
<a name="ln5024">  /* Close any files that are still open. */</a>
<a name="ln5025">  for (i = 0; i &lt;= depth; i++) {</a>
<a name="ln5026">    fclose(files[i].fp);</a>
<a name="ln5027">    xfree(files[i].name);</a>
<a name="ln5028">  }</a>
<a name="ln5029">  for (i = old_files; i &lt; max_path_depth; i++)</a>
<a name="ln5030">    xfree(files[i].name);</a>
<a name="ln5031">  xfree(files);</a>
<a name="ln5032"> </a>
<a name="ln5033">  if (type == CHECK_PATH) {</a>
<a name="ln5034">    if (!did_show) {</a>
<a name="ln5035">      if (action != ACTION_SHOW_ALL)</a>
<a name="ln5036">        MSG(_(&quot;All included files were found&quot;));</a>
<a name="ln5037">      else</a>
<a name="ln5038">        MSG(_(&quot;No included files&quot;));</a>
<a name="ln5039">    }</a>
<a name="ln5040">  } else if (!found</a>
<a name="ln5041">             &amp;&amp; action != ACTION_EXPAND</a>
<a name="ln5042">             ) {</a>
<a name="ln5043">    if (got_int || compl_interrupted)</a>
<a name="ln5044">      EMSG(_(e_interr));</a>
<a name="ln5045">    else if (type == FIND_DEFINE)</a>
<a name="ln5046">      EMSG(_(&quot;E388: Couldn't find definition&quot;));</a>
<a name="ln5047">    else</a>
<a name="ln5048">      EMSG(_(&quot;E389: Couldn't find pattern&quot;));</a>
<a name="ln5049">  }</a>
<a name="ln5050">  if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)</a>
<a name="ln5051">    msg_end();</a>
<a name="ln5052"> </a>
<a name="ln5053">fpip_end:</a>
<a name="ln5054">  xfree(file_line);</a>
<a name="ln5055">  vim_regfree(regmatch.regprog);</a>
<a name="ln5056">  vim_regfree(incl_regmatch.regprog);</a>
<a name="ln5057">  vim_regfree(def_regmatch.regprog);</a>
<a name="ln5058">}</a>
<a name="ln5059"> </a>
<a name="ln5060">static void show_pat_in_path(char_u *line, int type, bool did_show, int action,</a>
<a name="ln5061">                             FILE *fp, linenr_T *lnum, long count)</a>
<a name="ln5062">  FUNC_ATTR_NONNULL_ARG(1, 6)</a>
<a name="ln5063">{</a>
<a name="ln5064">  char_u  *p;</a>
<a name="ln5065"> </a>
<a name="ln5066">  if (did_show) {</a>
<a name="ln5067">    msg_putchar('\n');          // cursor below last one</a>
<a name="ln5068">  } else if (!msg_silent) {</a>
<a name="ln5069">    gotocmdline(true);          // cursor at status line</a>
<a name="ln5070">  }</a>
<a name="ln5071">  if (got_int) {                // 'q' typed at &quot;--more--&quot; message</a>
<a name="ln5072">    return;</a>
<a name="ln5073">  }</a>
<a name="ln5074">  for (;; ) {</a>
<a name="ln5075">    p = line + STRLEN(line) - 1;</a>
<a name="ln5076">    if (fp != NULL) {</a>
<a name="ln5077">      /* We used fgets(), so get rid of newline at end */</a>
<a name="ln5078">      if (p &gt;= line &amp;&amp; *p == '\n')</a>
<a name="ln5079">        --p;</a>
<a name="ln5080">      if (p &gt;= line &amp;&amp; *p == '\r')</a>
<a name="ln5081">        --p;</a>
<a name="ln5082">      *(p + 1) = NUL;</a>
<a name="ln5083">    }</a>
<a name="ln5084">    if (action == ACTION_SHOW_ALL) {</a>
<a name="ln5085">      snprintf((char *)IObuff, IOSIZE, &quot;%3ld: &quot;, count);  // Show match nr.</a>
<a name="ln5086">      msg_puts((const char *)IObuff);</a>
<a name="ln5087">      snprintf((char *)IObuff, IOSIZE, &quot;%4ld&quot;, *lnum);  // Show line nr.</a>
<a name="ln5088">      // Highlight line numbers.</a>
<a name="ln5089">      msg_puts_attr((const char *)IObuff, HL_ATTR(HLF_N));</a>
<a name="ln5090">      msg_puts(&quot; &quot;);</a>
<a name="ln5091">    }</a>
<a name="ln5092">    msg_prt_line(line, FALSE);</a>
<a name="ln5093">    ui_flush();                        /* show one line at a time */</a>
<a name="ln5094"> </a>
<a name="ln5095">    /* Definition continues until line that doesn't end with '\' */</a>
<a name="ln5096">    if (got_int || type != FIND_DEFINE || p &lt; line || *p != '\\')</a>
<a name="ln5097">      break;</a>
<a name="ln5098"> </a>
<a name="ln5099">    if (fp != NULL) {</a>
<a name="ln5100">      if (vim_fgets(line, LSIZE, fp))       /* end of file */</a>
<a name="ln5101">        break;</a>
<a name="ln5102">      ++*lnum;</a>
<a name="ln5103">    } else {</a>
<a name="ln5104">      if (++*lnum &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln5105">        break;</a>
<a name="ln5106">      line = ml_get(*lnum);</a>
<a name="ln5107">    }</a>
<a name="ln5108">    msg_putchar('\n');</a>
<a name="ln5109">  }</a>
<a name="ln5110">}</a>
<a name="ln5111"> </a>
<a name="ln5112">/// Get last search pattern</a>
<a name="ln5113">void get_search_pattern(SearchPattern *const pat)</a>
<a name="ln5114">{</a>
<a name="ln5115">  memcpy(pat, &amp;(spats[0]), sizeof(spats[0]));</a>
<a name="ln5116">}</a>
<a name="ln5117"> </a>
<a name="ln5118">/// Get last substitute pattern</a>
<a name="ln5119">void get_substitute_pattern(SearchPattern *const pat)</a>
<a name="ln5120">{</a>
<a name="ln5121">  memcpy(pat, &amp;(spats[1]), sizeof(spats[1]));</a>
<a name="ln5122">  memset(&amp;(pat-&gt;off), 0, sizeof(pat-&gt;off));</a>
<a name="ln5123">}</a>
<a name="ln5124"> </a>
<a name="ln5125">/// Set last search pattern</a>
<a name="ln5126">void set_search_pattern(const SearchPattern pat)</a>
<a name="ln5127">{</a>
<a name="ln5128">  free_spat(&amp;spats[0]);</a>
<a name="ln5129">  memcpy(&amp;(spats[0]), &amp;pat, sizeof(spats[0]));</a>
<a name="ln5130">  set_vv_searchforward();</a>
<a name="ln5131">}</a>
<a name="ln5132"> </a>
<a name="ln5133">/// Set last substitute pattern</a>
<a name="ln5134">void set_substitute_pattern(const SearchPattern pat)</a>
<a name="ln5135">{</a>
<a name="ln5136">  free_spat(&amp;spats[1]);</a>
<a name="ln5137">  memcpy(&amp;(spats[1]), &amp;pat, sizeof(spats[1]));</a>
<a name="ln5138">  memset(&amp;(spats[1].off), 0, sizeof(spats[1].off));</a>
<a name="ln5139">}</a>
<a name="ln5140"> </a>
<a name="ln5141">/// Set last used search pattern</a>
<a name="ln5142">///</a>
<a name="ln5143">/// @param[in]  is_substitute_pattern  If true set substitute pattern as last</a>
<a name="ln5144">///                                    used. Otherwise sets search pattern.</a>
<a name="ln5145">void set_last_used_pattern(const bool is_substitute_pattern)</a>
<a name="ln5146">{</a>
<a name="ln5147">  last_idx = (is_substitute_pattern ? 1 : 0);</a>
<a name="ln5148">}</a>
<a name="ln5149"> </a>
<a name="ln5150">/// Returns true if search pattern was the last used one</a>
<a name="ln5151">bool search_was_last_used(void)</a>
<a name="ln5152">{</a>
<a name="ln5153">  return last_idx == 0;</a>
<a name="ln5154">}</a>

</code></pre>
<div class="balloon" rel="1530"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The variable 'dir' is of enum type. It is odd that it is used as a variable of a Boolean-type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
