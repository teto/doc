
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>normal.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">//</a>
<a name="ln5">// normal.c:    Contains the main routine for processing characters in command</a>
<a name="ln6">//              mode.  Communicates closely with the code in ops.c to handle</a>
<a name="ln7">//              the operators.</a>
<a name="ln8">//</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;assert.h&gt;</a>
<a name="ln11">#include &lt;inttypes.h&gt;</a>
<a name="ln12">#include &lt;string.h&gt;</a>
<a name="ln13">#include &lt;stdbool.h&gt;</a>
<a name="ln14">#include &lt;stdlib.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;nvim/log.h&quot;</a>
<a name="ln17">#include &quot;nvim/vim.h&quot;</a>
<a name="ln18">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln19">#include &quot;nvim/normal.h&quot;</a>
<a name="ln20">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln21">#include &quot;nvim/change.h&quot;</a>
<a name="ln22">#include &quot;nvim/charset.h&quot;</a>
<a name="ln23">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln24">#include &quot;nvim/diff.h&quot;</a>
<a name="ln25">#include &quot;nvim/digraph.h&quot;</a>
<a name="ln26">#include &quot;nvim/edit.h&quot;</a>
<a name="ln27">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln28">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln29">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln30">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln31">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln32">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln33">#include &quot;nvim/fold.h&quot;</a>
<a name="ln34">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln35">#include &quot;nvim/indent.h&quot;</a>
<a name="ln36">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln37">#include &quot;nvim/main.h&quot;</a>
<a name="ln38">#include &quot;nvim/mark.h&quot;</a>
<a name="ln39">#include &quot;nvim/memline.h&quot;</a>
<a name="ln40">#include &quot;nvim/memory.h&quot;</a>
<a name="ln41">#include &quot;nvim/message.h&quot;</a>
<a name="ln42">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln43">#include &quot;nvim/keymap.h&quot;</a>
<a name="ln44">#include &quot;nvim/move.h&quot;</a>
<a name="ln45">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln46">#include &quot;nvim/ops.h&quot;</a>
<a name="ln47">#include &quot;nvim/option.h&quot;</a>
<a name="ln48">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln49">#include &quot;nvim/screen.h&quot;</a>
<a name="ln50">#include &quot;nvim/search.h&quot;</a>
<a name="ln51">#include &quot;nvim/spell.h&quot;</a>
<a name="ln52">#include &quot;nvim/spellfile.h&quot;</a>
<a name="ln53">#include &quot;nvim/strings.h&quot;</a>
<a name="ln54">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln55">#include &quot;nvim/tag.h&quot;</a>
<a name="ln56">#include &quot;nvim/ui.h&quot;</a>
<a name="ln57">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln58">#include &quot;nvim/undo.h&quot;</a>
<a name="ln59">#include &quot;nvim/window.h&quot;</a>
<a name="ln60">#include &quot;nvim/state.h&quot;</a>
<a name="ln61">#include &quot;nvim/event/loop.h&quot;</a>
<a name="ln62">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln63">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln64">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66">typedef struct normal_state {</a>
<a name="ln67">  VimState state;</a>
<a name="ln68">  bool command_finished;</a>
<a name="ln69">  bool ctrl_w;</a>
<a name="ln70">  bool need_flushbuf;</a>
<a name="ln71">  bool set_prevcount;</a>
<a name="ln72">  bool previous_got_int;             // `got_int` was true</a>
<a name="ln73">  bool cmdwin;                       // command-line window normal mode</a>
<a name="ln74">  bool noexmode;                     // true if the normal mode was pushed from</a>
<a name="ln75">                                     // ex mode(:global or :visual for example)</a>
<a name="ln76">  bool toplevel;                     // top-level normal mode</a>
<a name="ln77">  oparg_T oa;                        // operator arguments</a>
<a name="ln78">  cmdarg_T ca;                       // command arguments</a>
<a name="ln79">  int mapped_len;</a>
<a name="ln80">  int old_mapped_len;</a>
<a name="ln81">  int idx;</a>
<a name="ln82">  int c;</a>
<a name="ln83">  int old_col;</a>
<a name="ln84">  pos_T old_pos;</a>
<a name="ln85">} NormalState;</a>
<a name="ln86"> </a>
<a name="ln87">/*</a>
<a name="ln88"> * The Visual area is remembered for reselection.</a>
<a name="ln89"> */</a>
<a name="ln90">static int resel_VIsual_mode = NUL;             /* 'v', 'V', or Ctrl-V */</a>
<a name="ln91">static linenr_T resel_VIsual_line_count;        /* number of lines */</a>
<a name="ln92">static colnr_T resel_VIsual_vcol;               /* nr of cols or end col */</a>
<a name="ln93">static int VIsual_mode_orig = NUL;              /* saved Visual mode */</a>
<a name="ln94"> </a>
<a name="ln95">static int restart_VIsual_select = 0;</a>
<a name="ln96"> </a>
<a name="ln97"> </a>
<a name="ln98">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln99"># include &quot;normal.c.generated.h&quot;</a>
<a name="ln100">#endif</a>
<a name="ln101"> </a>
<a name="ln102">static inline void normal_state_init(NormalState *s)</a>
<a name="ln103">{</a>
<a name="ln104">  memset(s, 0, sizeof(NormalState));</a>
<a name="ln105">  s-&gt;state.check = normal_check;</a>
<a name="ln106">  s-&gt;state.execute = normal_execute;</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">/*</a>
<a name="ln110"> * nv_*(): functions called to handle Normal and Visual mode commands.</a>
<a name="ln111"> * n_*(): functions called to handle Normal mode commands.</a>
<a name="ln112"> * v_*(): functions called to handle Visual mode commands.</a>
<a name="ln113"> */</a>
<a name="ln114"> </a>
<a name="ln115">static char *e_noident = N_(&quot;E349: No identifier under cursor&quot;);</a>
<a name="ln116"> </a>
<a name="ln117">/*</a>
<a name="ln118"> * Function to be called for a Normal or Visual mode command.</a>
<a name="ln119"> * The argument is a cmdarg_T.</a>
<a name="ln120"> */</a>
<a name="ln121">typedef void (*nv_func_T)(cmdarg_T *cap);</a>
<a name="ln122"> </a>
<a name="ln123">/* Values for cmd_flags. */</a>
<a name="ln124">#define NV_NCH      0x01          /* may need to get a second char */</a>
<a name="ln125">#define NV_NCH_NOP  (0x02|NV_NCH) /* get second char when no operator pending */</a>
<a name="ln126">#define NV_NCH_ALW  (0x04|NV_NCH) /* always get a second char */</a>
<a name="ln127">#define NV_LANG     0x08        /* second char needs language adjustment */</a>
<a name="ln128"> </a>
<a name="ln129">#define NV_SS       0x10        /* may start selection */</a>
<a name="ln130">#define NV_SSS      0x20        /* may start selection with shift modifier */</a>
<a name="ln131">#define NV_STS      0x40        /* may stop selection without shift modif. */</a>
<a name="ln132">#define NV_RL       0x80        /* 'rightleft' modifies command */</a>
<a name="ln133">#define NV_KEEPREG  0x100       /* don't clear regname */</a>
<a name="ln134">#define NV_NCW      0x200       /* not allowed in command-line window */</a>
<a name="ln135"> </a>
<a name="ln136">/*</a>
<a name="ln137"> * Generally speaking, every Normal mode command should either clear any</a>
<a name="ln138"> * pending operator (with *clearop*()), or set the motion type variable</a>
<a name="ln139"> * oap-&gt;motion_type.</a>
<a name="ln140"> *</a>
<a name="ln141"> * When a cursor motion command is made, it is marked as being a character or</a>
<a name="ln142"> * line oriented motion.  Then, if an operator is in effect, the operation</a>
<a name="ln143"> * becomes character or line oriented accordingly.</a>
<a name="ln144"> */</a>
<a name="ln145"> </a>
<a name="ln146">/*</a>
<a name="ln147"> * This table contains one entry for every Normal or Visual mode command.</a>
<a name="ln148"> * The order doesn't matter, init_normal_cmds() will create a sorted index.</a>
<a name="ln149"> * It is faster when all keys from zero to '~' are present.</a>
<a name="ln150"> */</a>
<a name="ln151">static const struct nv_cmd {</a>
<a name="ln152">  int cmd_char;                 /* (first) command character */</a>
<a name="ln153">  nv_func_T cmd_func;           /* function for this command */</a>
<a name="ln154">  uint16_t cmd_flags;           /* NV_ flags */</a>
<a name="ln155">  short cmd_arg;                /* value for ca.arg */</a>
<a name="ln156">} nv_cmds[] =</a>
<a name="ln157">{</a>
<a name="ln158">  { NUL,       nv_error,       0,                      0 },</a>
<a name="ln159">  { Ctrl_A,    nv_addsub,      0,                      0 },</a>
<a name="ln160">  { Ctrl_B,    nv_page,        NV_STS,                 BACKWARD },</a>
<a name="ln161">  { Ctrl_C,    nv_esc,         0,                      true },</a>
<a name="ln162">  { Ctrl_D,    nv_halfpage,    0,                      0 },</a>
<a name="ln163">  { Ctrl_E,    nv_scroll_line, 0,                      true },</a>
<a name="ln164">  { Ctrl_F,    nv_page,        NV_STS,                 FORWARD },</a>
<a name="ln165">  { Ctrl_G,    nv_ctrlg,       0,                      0 },</a>
<a name="ln166">  { Ctrl_H,    nv_ctrlh,       0,                      0 },</a>
<a name="ln167">  { Ctrl_I,    nv_pcmark,      0,                      0 },</a>
<a name="ln168">  { NL,        nv_down,        0,                      false },</a>
<a name="ln169">  { Ctrl_K,    nv_error,       0,                      0 },</a>
<a name="ln170">  { Ctrl_L,    nv_clear,       0,                      0 },</a>
<a name="ln171">  { CAR,       nv_down,        0,                      true },</a>
<a name="ln172">  { Ctrl_N,    nv_down,        NV_STS,                 false },</a>
<a name="ln173">  { Ctrl_O,    nv_ctrlo,       0,                      0 },</a>
<a name="ln174">  { Ctrl_P,    nv_up,          NV_STS,                 false },</a>
<a name="ln175">  { Ctrl_Q,    nv_visual,      0,                      false },</a>
<a name="ln176">  { Ctrl_R,    nv_redo,        0,                      0 },</a>
<a name="ln177">  { Ctrl_S,    nv_ignore,      0,                      0 },</a>
<a name="ln178">  { Ctrl_T,    nv_tagpop,      NV_NCW,                 0 },</a>
<a name="ln179">  { Ctrl_U,    nv_halfpage,    0,                      0 },</a>
<a name="ln180">  { Ctrl_V,    nv_visual,      0,                      false },</a>
<a name="ln181">  { 'V',       nv_visual,      0,                      false },</a>
<a name="ln182">  { 'v',       nv_visual,      0,                      false },</a>
<a name="ln183">  { Ctrl_W,    nv_window,      0,                      0 },</a>
<a name="ln184">  { Ctrl_X,    nv_addsub,      0,                      0 },</a>
<a name="ln185">  { Ctrl_Y,    nv_scroll_line, 0,                      false },</a>
<a name="ln186">  { Ctrl_Z,    nv_suspend,     0,                      0 },</a>
<a name="ln187">  { ESC,       nv_esc,         0,                      false },</a>
<a name="ln188">  { Ctrl_BSL,  nv_normal,      NV_NCH_ALW,             0 },</a>
<a name="ln189">  { Ctrl_RSB,  nv_ident,       NV_NCW,                 0 },</a>
<a name="ln190">  { Ctrl_HAT,  nv_hat,         NV_NCW,                 0 },</a>
<a name="ln191">  { Ctrl__,    nv_error,       0,                      0 },</a>
<a name="ln192">  { ' ',       nv_right,       0,                      0 },</a>
<a name="ln193">  { '!',       nv_operator,    0,                      0 },</a>
<a name="ln194">  { '&quot;',       nv_regname,     NV_NCH_NOP|NV_KEEPREG,  0 },</a>
<a name="ln195">  { '#',       nv_ident,       0,                      0 },</a>
<a name="ln196">  { '$',       nv_dollar,      0,                      0 },</a>
<a name="ln197">  { '%',       nv_percent,     0,                      0 },</a>
<a name="ln198">  { '&amp;',       nv_optrans,     0,                      0 },</a>
<a name="ln199">  { '\'',      nv_gomark,      NV_NCH_ALW,             true },</a>
<a name="ln200">  { '(',       nv_brace,       0,                      BACKWARD },</a>
<a name="ln201">  { ')',       nv_brace,       0,                      FORWARD },</a>
<a name="ln202">  { '*',       nv_ident,       0,                      0 },</a>
<a name="ln203">  { '+',       nv_down,        0,                      true },</a>
<a name="ln204">  { ',',       nv_csearch,     0,                      true },</a>
<a name="ln205">  { '-',       nv_up,          0,                      true },</a>
<a name="ln206">  { '.',       nv_dot,         NV_KEEPREG,             0 },</a>
<a name="ln207">  { '/',       nv_search,      0,                      false },</a>
<a name="ln208">  { '0',       nv_beginline,   0,                      0 },</a>
<a name="ln209">  { '1',       nv_ignore,      0,                      0 },</a>
<a name="ln210">  { '2',       nv_ignore,      0,                      0 },</a>
<a name="ln211">  { '3',       nv_ignore,      0,                      0 },</a>
<a name="ln212">  { '4',       nv_ignore,      0,                      0 },</a>
<a name="ln213">  { '5',       nv_ignore,      0,                      0 },</a>
<a name="ln214">  { '6',       nv_ignore,      0,                      0 },</a>
<a name="ln215">  { '7',       nv_ignore,      0,                      0 },</a>
<a name="ln216">  { '8',       nv_ignore,      0,                      0 },</a>
<a name="ln217">  { '9',       nv_ignore,      0,                      0 },</a>
<a name="ln218">  { ':',       nv_colon,       0,                      0 },</a>
<a name="ln219">  { ';',       nv_csearch,     0,                      false },</a>
<a name="ln220">  { '&lt;',       nv_operator,    NV_RL,                  0 },</a>
<a name="ln221">  { '=',       nv_operator,    0,                      0 },</a>
<a name="ln222">  { '&gt;',       nv_operator,    NV_RL,                  0 },</a>
<a name="ln223">  { '?',       nv_search,      0,                      false },</a>
<a name="ln224">  { '@',       nv_at,          NV_NCH_NOP,             false },</a>
<a name="ln225">  { 'A',       nv_edit,        0,                      0 },</a>
<a name="ln226">  { 'B',       nv_bck_word,    0,                      1 },</a>
<a name="ln227">  { 'C',       nv_abbrev,      NV_KEEPREG,             0 },</a>
<a name="ln228">  { 'D',       nv_abbrev,      NV_KEEPREG,             0 },</a>
<a name="ln229">  { 'E',       nv_wordcmd,     0,                      true },</a>
<a name="ln230">  { 'F',       nv_csearch,     NV_NCH_ALW|NV_LANG,     BACKWARD },</a>
<a name="ln231">  { 'G',       nv_goto,        0,                      true },</a>
<a name="ln232">  { 'H',       nv_scroll,      0,                      0 },</a>
<a name="ln233">  { 'I',       nv_edit,        0,                      0 },</a>
<a name="ln234">  { 'J',       nv_join,        0,                      0 },</a>
<a name="ln235">  { 'K',       nv_ident,       0,                      0 },</a>
<a name="ln236">  { 'L',       nv_scroll,      0,                      0 },</a>
<a name="ln237">  { 'M',       nv_scroll,      0,                      0 },</a>
<a name="ln238">  { 'N',       nv_next,        0,                      SEARCH_REV },</a>
<a name="ln239">  { 'O',       nv_open,        0,                      0 },</a>
<a name="ln240">  { 'P',       nv_put,         0,                      0 },</a>
<a name="ln241">  { 'Q',       nv_exmode,      NV_NCW,                 0 },</a>
<a name="ln242">  { 'R',       nv_Replace,     0,                      false },</a>
<a name="ln243">  { 'S',       nv_subst,       NV_KEEPREG,             0 },</a>
<a name="ln244">  { 'T',       nv_csearch,     NV_NCH_ALW|NV_LANG,     BACKWARD },</a>
<a name="ln245">  { 'U',       nv_Undo,        0,                      0 },</a>
<a name="ln246">  { 'W',       nv_wordcmd,     0,                      true },</a>
<a name="ln247">  { 'X',       nv_abbrev,      NV_KEEPREG,             0 },</a>
<a name="ln248">  { 'Y',       nv_abbrev,      NV_KEEPREG,             0 },</a>
<a name="ln249">  { 'Z',       nv_Zet,         NV_NCH_NOP|NV_NCW,      0 },</a>
<a name="ln250">  { '[',       nv_brackets,    NV_NCH_ALW,             BACKWARD },</a>
<a name="ln251">  { '\\',      nv_error,       0,                      0 },</a>
<a name="ln252">  { ']',       nv_brackets,    NV_NCH_ALW,             FORWARD },</a>
<a name="ln253">  { '^',       nv_beginline,   0,                      BL_WHITE | BL_FIX },</a>
<a name="ln254">  { '_',       nv_lineop,      0,                      0 },</a>
<a name="ln255">  { '`',       nv_gomark,      NV_NCH_ALW,             false },</a>
<a name="ln256">  { 'a',       nv_edit,        NV_NCH,                 0 },</a>
<a name="ln257">  { 'b',       nv_bck_word,    0,                      0 },</a>
<a name="ln258">  { 'c',       nv_operator,    0,                      0 },</a>
<a name="ln259">  { 'd',       nv_operator,    0,                      0 },</a>
<a name="ln260">  { 'e',       nv_wordcmd,     0,                      false },</a>
<a name="ln261">  { 'f',       nv_csearch,     NV_NCH_ALW|NV_LANG,     FORWARD },</a>
<a name="ln262">  { 'g',       nv_g_cmd,       NV_NCH_ALW,             false },</a>
<a name="ln263">  { 'h',       nv_left,        NV_RL,                  0 },</a>
<a name="ln264">  { 'i',       nv_edit,        NV_NCH,                 0 },</a>
<a name="ln265">  { 'j',       nv_down,        0,                      false },</a>
<a name="ln266">  { 'k',       nv_up,          0,                      false },</a>
<a name="ln267">  { 'l',       nv_right,       NV_RL,                  0 },</a>
<a name="ln268">  { 'm',       nv_mark,        NV_NCH_NOP,             0 },</a>
<a name="ln269">  { 'n',       nv_next,        0,                      0 },</a>
<a name="ln270">  { 'o',       nv_open,        0,                      0 },</a>
<a name="ln271">  { 'p',       nv_put,         0,                      0 },</a>
<a name="ln272">  { 'q',       nv_record,      NV_NCH,                 0 },</a>
<a name="ln273">  { 'r',       nv_replace,     NV_NCH_NOP|NV_LANG,     0 },</a>
<a name="ln274">  { 's',       nv_subst,       NV_KEEPREG,             0 },</a>
<a name="ln275">  { 't',       nv_csearch,     NV_NCH_ALW|NV_LANG,     FORWARD },</a>
<a name="ln276">  { 'u',       nv_undo,        0,                      0 },</a>
<a name="ln277">  { 'w',       nv_wordcmd,     0,                      false },</a>
<a name="ln278">  { 'x',       nv_abbrev,      NV_KEEPREG,             0 },</a>
<a name="ln279">  { 'y',       nv_operator,    0,                      0 },</a>
<a name="ln280">  { 'z',       nv_zet,         NV_NCH_ALW,             0 },</a>
<a name="ln281">  { '{',       nv_findpar,     0,                      BACKWARD },</a>
<a name="ln282">  { '|',       nv_pipe,        0,                      0 },</a>
<a name="ln283">  { '}',       nv_findpar,     0,                      FORWARD },</a>
<a name="ln284">  { '~',       nv_tilde,       0,                      0 },</a>
<a name="ln285"> </a>
<a name="ln286">  // pound sign</a>
<a name="ln287">  { POUND,     nv_ident,       0,                      0 },</a>
<a name="ln288">  { K_MOUSEUP, nv_mousescroll, 0,                      MSCR_UP },</a>
<a name="ln289">  { K_MOUSEDOWN, nv_mousescroll, 0,                    MSCR_DOWN },</a>
<a name="ln290">  { K_MOUSELEFT, nv_mousescroll, 0,                    MSCR_LEFT },</a>
<a name="ln291">  { K_MOUSERIGHT, nv_mousescroll, 0,                   MSCR_RIGHT },</a>
<a name="ln292">  { K_LEFTMOUSE, nv_mouse,     0,                      0 },</a>
<a name="ln293">  { K_LEFTMOUSE_NM, nv_mouse,  0,                      0 },</a>
<a name="ln294">  { K_LEFTDRAG, nv_mouse,      0,                      0 },</a>
<a name="ln295">  { K_LEFTRELEASE, nv_mouse,   0,                      0 },</a>
<a name="ln296">  { K_LEFTRELEASE_NM, nv_mouse, 0,                     0 },</a>
<a name="ln297">  { K_MIDDLEMOUSE, nv_mouse,   0,                      0 },</a>
<a name="ln298">  { K_MIDDLEDRAG, nv_mouse,    0,                      0 },</a>
<a name="ln299">  { K_MIDDLERELEASE, nv_mouse, 0,                      0 },</a>
<a name="ln300">  { K_RIGHTMOUSE, nv_mouse,    0,                      0 },</a>
<a name="ln301">  { K_RIGHTDRAG, nv_mouse,     0,                      0 },</a>
<a name="ln302">  { K_RIGHTRELEASE, nv_mouse,  0,                      0 },</a>
<a name="ln303">  { K_X1MOUSE, nv_mouse,       0,                      0 },</a>
<a name="ln304">  { K_X1DRAG, nv_mouse,        0,                      0 },</a>
<a name="ln305">  { K_X1RELEASE, nv_mouse,     0,                      0 },</a>
<a name="ln306">  { K_X2MOUSE, nv_mouse,       0,                      0 },</a>
<a name="ln307">  { K_X2DRAG, nv_mouse,        0,                      0 },</a>
<a name="ln308">  { K_X2RELEASE, nv_mouse,     0,                      0 },</a>
<a name="ln309">  { K_IGNORE,  nv_ignore,      NV_KEEPREG,             0 },</a>
<a name="ln310">  { K_NOP,     nv_nop,         0,                      0 },</a>
<a name="ln311">  { K_INS,     nv_edit,        0,                      0 },</a>
<a name="ln312">  { K_KINS,    nv_edit,        0,                      0 },</a>
<a name="ln313">  { K_BS,      nv_ctrlh,       0,                      0 },</a>
<a name="ln314">  { K_UP,      nv_up,          NV_SSS|NV_STS,          false },</a>
<a name="ln315">  { K_S_UP,    nv_page,        NV_SS,                  BACKWARD },</a>
<a name="ln316">  { K_DOWN,    nv_down,        NV_SSS|NV_STS,          false },</a>
<a name="ln317">  { K_S_DOWN,  nv_page,        NV_SS,                  FORWARD },</a>
<a name="ln318">  { K_LEFT,    nv_left,        NV_SSS|NV_STS|NV_RL,    0 },</a>
<a name="ln319">  { K_S_LEFT,  nv_bck_word,    NV_SS|NV_RL,            0 },</a>
<a name="ln320">  { K_C_LEFT,  nv_bck_word,    NV_SSS|NV_RL|NV_STS,    1 },</a>
<a name="ln321">  { K_RIGHT,   nv_right,       NV_SSS|NV_STS|NV_RL,    0 },</a>
<a name="ln322">  { K_S_RIGHT, nv_wordcmd,     NV_SS|NV_RL,            false },</a>
<a name="ln323">  { K_C_RIGHT, nv_wordcmd,     NV_SSS|NV_RL|NV_STS,    true },</a>
<a name="ln324">  { K_PAGEUP,  nv_page,        NV_SSS|NV_STS,          BACKWARD },</a>
<a name="ln325">  { K_KPAGEUP, nv_page,        NV_SSS|NV_STS,          BACKWARD },</a>
<a name="ln326">  { K_PAGEDOWN, nv_page,       NV_SSS|NV_STS,          FORWARD },</a>
<a name="ln327">  { K_KPAGEDOWN, nv_page,      NV_SSS|NV_STS,          FORWARD },</a>
<a name="ln328">  { K_END,     nv_end,         NV_SSS|NV_STS,          false },</a>
<a name="ln329">  { K_KEND,    nv_end,         NV_SSS|NV_STS,          false },</a>
<a name="ln330">  { K_S_END,   nv_end,         NV_SS,                  false },</a>
<a name="ln331">  { K_C_END,   nv_end,         NV_SSS|NV_STS,          true },</a>
<a name="ln332">  { K_HOME,    nv_home,        NV_SSS|NV_STS,          0 },</a>
<a name="ln333">  { K_KHOME,   nv_home,        NV_SSS|NV_STS,          0 },</a>
<a name="ln334">  { K_S_HOME,  nv_home,        NV_SS,                  0 },</a>
<a name="ln335">  { K_C_HOME,  nv_goto,        NV_SSS|NV_STS,          false },</a>
<a name="ln336">  { K_DEL,     nv_abbrev,      0,                      0 },</a>
<a name="ln337">  { K_KDEL,    nv_abbrev,      0,                      0 },</a>
<a name="ln338">  { K_UNDO,    nv_kundo,       0,                      0 },</a>
<a name="ln339">  { K_HELP,    nv_help,        NV_NCW,                 0 },</a>
<a name="ln340">  { K_F1,      nv_help,        NV_NCW,                 0 },</a>
<a name="ln341">  { K_XF1,     nv_help,        NV_NCW,                 0 },</a>
<a name="ln342">  { K_SELECT,  nv_select,      0,                      0 },</a>
<a name="ln343">  { K_EVENT,   nv_event,       NV_KEEPREG,             0 },</a>
<a name="ln344">  { K_COMMAND, nv_colon,       0,                      0 },</a>
<a name="ln345">};</a>
<a name="ln346"> </a>
<a name="ln347">/* Number of commands in nv_cmds[]. */</a>
<a name="ln348">#define NV_CMDS_SIZE ARRAY_SIZE(nv_cmds)</a>
<a name="ln349"> </a>
<a name="ln350">/* Sorted index of commands in nv_cmds[]. */</a>
<a name="ln351">static short nv_cmd_idx[NV_CMDS_SIZE];</a>
<a name="ln352"> </a>
<a name="ln353">/* The highest index for which</a>
<a name="ln354"> * nv_cmds[idx].cmd_char == nv_cmd_idx[nv_cmds[idx].cmd_char] */</a>
<a name="ln355">static int nv_max_linear;</a>
<a name="ln356"> </a>
<a name="ln357">/*</a>
<a name="ln358"> * Compare functions for qsort() below, that checks the command character</a>
<a name="ln359"> * through the index in nv_cmd_idx[].</a>
<a name="ln360"> */</a>
<a name="ln361">static int nv_compare(const void *s1, const void *s2)</a>
<a name="ln362">{</a>
<a name="ln363">  int c1, c2;</a>
<a name="ln364"> </a>
<a name="ln365">  /* The commands are sorted on absolute value. */</a>
<a name="ln366">  c1 = nv_cmds[*(const short *)s1].cmd_char;</a>
<a name="ln367">  c2 = nv_cmds[*(const short *)s2].cmd_char;</a>
<a name="ln368">  if (c1 &lt; 0)</a>
<a name="ln369">    c1 = -c1;</a>
<a name="ln370">  if (c2 &lt; 0)</a>
<a name="ln371">    c2 = -c2;</a>
<a name="ln372">  return c1 - c2;</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375">/*</a>
<a name="ln376"> * Initialize the nv_cmd_idx[] table.</a>
<a name="ln377"> */</a>
<a name="ln378">void init_normal_cmds(void)</a>
<a name="ln379">{</a>
<a name="ln380">  assert(NV_CMDS_SIZE &lt;= SHRT_MAX);</a>
<a name="ln381"> </a>
<a name="ln382">  /* Fill the index table with a one to one relation. */</a>
<a name="ln383">  for (short int i = 0; i &lt; (short int)NV_CMDS_SIZE; ++i) {</a>
<a name="ln384">    nv_cmd_idx[i] = i;</a>
<a name="ln385">  }</a>
<a name="ln386"> </a>
<a name="ln387">  /* Sort the commands by the command character.  */</a>
<a name="ln388">  qsort(&amp;nv_cmd_idx, NV_CMDS_SIZE, sizeof(short), nv_compare);</a>
<a name="ln389"> </a>
<a name="ln390">  /* Find the first entry that can't be indexed by the command character. */</a>
<a name="ln391">  short int i;</a>
<a name="ln392">  for (i = 0; i &lt; (short int)NV_CMDS_SIZE; ++i) {</a>
<a name="ln393">    if (i != nv_cmds[nv_cmd_idx[i]].cmd_char) {</a>
<a name="ln394">      break;</a>
<a name="ln395">    }</a>
<a name="ln396">  }</a>
<a name="ln397">  nv_max_linear = i - 1;</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">/*</a>
<a name="ln401"> * Search for a command in the commands table.</a>
<a name="ln402"> * Returns -1 for invalid command.</a>
<a name="ln403"> */</a>
<a name="ln404">static int find_command(int cmdchar)</a>
<a name="ln405">{</a>
<a name="ln406">  int i;</a>
<a name="ln407">  int idx;</a>
<a name="ln408">  int top, bot;</a>
<a name="ln409">  int c;</a>
<a name="ln410"> </a>
<a name="ln411">  /* A multi-byte character is never a command. */</a>
<a name="ln412">  if (cmdchar &gt;= 0x100)</a>
<a name="ln413">    return -1;</a>
<a name="ln414"> </a>
<a name="ln415">  /* We use the absolute value of the character.  Special keys have a</a>
<a name="ln416">   * negative value, but are sorted on their absolute value. */</a>
<a name="ln417">  if (cmdchar &lt; 0)</a>
<a name="ln418">    cmdchar = -cmdchar;</a>
<a name="ln419"> </a>
<a name="ln420">  /* If the character is in the first part: The character is the index into</a>
<a name="ln421">   * nv_cmd_idx[]. */</a>
<a name="ln422">  assert(nv_max_linear &lt; (int)NV_CMDS_SIZE);</a>
<a name="ln423">  if (cmdchar &lt;= nv_max_linear)</a>
<a name="ln424">    return nv_cmd_idx[cmdchar];</a>
<a name="ln425"> </a>
<a name="ln426">  /* Perform a binary search. */</a>
<a name="ln427">  bot = nv_max_linear + 1;</a>
<a name="ln428">  top = NV_CMDS_SIZE - 1;</a>
<a name="ln429">  idx = -1;</a>
<a name="ln430">  while (bot &lt;= top) {</a>
<a name="ln431">    i = (top + bot) / 2;</a>
<a name="ln432">    c = nv_cmds[nv_cmd_idx[i]].cmd_char;</a>
<a name="ln433">    if (c &lt; 0)</a>
<a name="ln434">      c = -c;</a>
<a name="ln435">    if (cmdchar == c) {</a>
<a name="ln436">      idx = nv_cmd_idx[i];</a>
<a name="ln437">      break;</a>
<a name="ln438">    }</a>
<a name="ln439">    if (cmdchar &gt; c)</a>
<a name="ln440">      bot = i + 1;</a>
<a name="ln441">    else</a>
<a name="ln442">      top = i - 1;</a>
<a name="ln443">  }</a>
<a name="ln444">  return idx;</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447">// Normal state entry point. This is called on:</a>
<a name="ln448">//</a>
<a name="ln449">// - Startup, In this case the function never returns.</a>
<a name="ln450">// - The command-line window is opened(`q:`). Returns when `cmdwin_result` != 0.</a>
<a name="ln451">// - The :visual command is called from :global in ex mode, `:global/PAT/visual`</a>
<a name="ln452">//   for example. Returns when re-entering ex mode(because ex mode recursion is</a>
<a name="ln453">//   not allowed)</a>
<a name="ln454">//</a>
<a name="ln455">// This used to be called main_loop on main.c</a>
<a name="ln456">void normal_enter(bool cmdwin, bool noexmode)</a>
<a name="ln457">{</a>
<a name="ln458">  NormalState state;</a>
<a name="ln459">  normal_state_init(&amp;state);</a>
<a name="ln460">  state.cmdwin = cmdwin;</a>
<a name="ln461">  state.noexmode = noexmode;</a>
<a name="ln462">  state.toplevel = (!cmdwin || cmdwin_result == 0) &amp;&amp; !noexmode;</a>
<a name="ln463">  state_enter(&amp;state.state);</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466">static void normal_prepare(NormalState *s)</a>
<a name="ln467">{</a>
<a name="ln468">  memset(&amp;s-&gt;ca, 0, sizeof(s-&gt;ca));  // also resets ca.retval</a>
<a name="ln469">  s-&gt;ca.oap = &amp;s-&gt;oa;</a>
<a name="ln470"> </a>
<a name="ln471">  // Use a count remembered from before entering an operator. After typing &quot;3d&quot;</a>
<a name="ln472">  // we return from normal_cmd() and come back here, the &quot;3&quot; is remembered in</a>
<a name="ln473">  // &quot;opcount&quot;.</a>
<a name="ln474">  s-&gt;ca.opcount = opcount;</a>
<a name="ln475"> </a>
<a name="ln476">  // If there is an operator pending, then the command we take this time will</a>
<a name="ln477">  // terminate it. Finish_op tells us to finish the operation before returning</a>
<a name="ln478">  // this time (unless the operation was cancelled).</a>
<a name="ln479">  int c = finish_op;</a>
<a name="ln480">  finish_op = (s-&gt;oa.op_type != OP_NOP);</a>
<a name="ln481">  if (finish_op != c) {</a>
<a name="ln482">    ui_cursor_shape();  // may show different cursor shape</a>
<a name="ln483">  }</a>
<a name="ln484"> </a>
<a name="ln485">  // When not finishing an operator and no register name typed, reset the count.</a>
<a name="ln486">  if (!finish_op &amp;&amp; !s-&gt;oa.regname) {</a>
<a name="ln487">    s-&gt;ca.opcount = 0;</a>
<a name="ln488">    s-&gt;set_prevcount = true;</a>
<a name="ln489">  }</a>
<a name="ln490"> </a>
<a name="ln491">  // Restore counts from before receiving K_EVENT.  This means after</a>
<a name="ln492">  // typing &quot;3&quot;, handling K_EVENT and then typing &quot;2&quot; we get &quot;32&quot;, not</a>
<a name="ln493">  // &quot;3 * 2&quot;.</a>
<a name="ln494">  if (s-&gt;oa.prev_opcount &gt; 0 || s-&gt;oa.prev_count0 &gt; 0) {</a>
<a name="ln495">    s-&gt;ca.opcount = s-&gt;oa.prev_opcount;</a>
<a name="ln496">    s-&gt;ca.count0 = s-&gt;oa.prev_count0;</a>
<a name="ln497">    s-&gt;oa.prev_opcount = 0;</a>
<a name="ln498">    s-&gt;oa.prev_count0 = 0;</a>
<a name="ln499">  }</a>
<a name="ln500"> </a>
<a name="ln501">  s-&gt;mapped_len = typebuf_maplen();</a>
<a name="ln502">  State = NORMAL_BUSY;</a>
<a name="ln503"> </a>
<a name="ln504">  // Set v:count here, when called from main() and not a stuffed command, so</a>
<a name="ln505">  // that v:count can be used in an expression mapping when there is no count.</a>
<a name="ln506">  // Do set it for redo</a>
<a name="ln507">  if (s-&gt;toplevel &amp;&amp; readbuf1_empty()) {</a>
<a name="ln508">    set_vcount_ca(&amp;s-&gt;ca, &amp;s-&gt;set_prevcount);</a>
<a name="ln509">  }</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">static bool normal_handle_special_visual_command(NormalState *s)</a>
<a name="ln513">{</a>
<a name="ln514">  // when 'keymodel' contains &quot;stopsel&quot; may stop Select/Visual mode</a>
<a name="ln515">  if (km_stopsel</a>
<a name="ln516">      &amp;&amp; (nv_cmds[s-&gt;idx].cmd_flags &amp; NV_STS)</a>
<a name="ln517">      &amp;&amp; !(mod_mask &amp; MOD_MASK_SHIFT)) {</a>
<a name="ln518">    end_visual_mode();</a>
<a name="ln519">    redraw_curbuf_later(INVERTED);</a>
<a name="ln520">  }</a>
<a name="ln521"> </a>
<a name="ln522">  // Keys that work different when 'keymodel' contains &quot;startsel&quot;</a>
<a name="ln523">  if (km_startsel) {</a>
<a name="ln524">    if (nv_cmds[s-&gt;idx].cmd_flags &amp; NV_SS) {</a>
<a name="ln525">      unshift_special(&amp;s-&gt;ca);</a>
<a name="ln526">      s-&gt;idx = find_command(s-&gt;ca.cmdchar);</a>
<a name="ln527">      if (s-&gt;idx &lt; 0) {</a>
<a name="ln528">        // Just in case</a>
<a name="ln529">        clearopbeep(&amp;s-&gt;oa);</a>
<a name="ln530">        return true;</a>
<a name="ln531">      }</a>
<a name="ln532">    } else if ((nv_cmds[s-&gt;idx].cmd_flags &amp; NV_SSS)</a>
<a name="ln533">               &amp;&amp; (mod_mask &amp; MOD_MASK_SHIFT)) {</a>
<a name="ln534">      mod_mask &amp;= ~MOD_MASK_SHIFT;</a>
<a name="ln535">    }</a>
<a name="ln536">  }</a>
<a name="ln537">  return false;</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540">static bool normal_need_additional_char(NormalState *s)</a>
<a name="ln541">{</a>
<a name="ln542">  int flags = nv_cmds[s-&gt;idx].cmd_flags;</a>
<a name="ln543">  bool pending_op = s-&gt;oa.op_type != OP_NOP;</a>
<a name="ln544">  int cmdchar = s-&gt;ca.cmdchar;</a>
<a name="ln545">  // without NV_NCH we never need to check for an additional char</a>
<a name="ln546">  return flags &amp; NV_NCH &amp;&amp; (</a>
<a name="ln547">      // NV_NCH_NOP is set and no operator is pending, get a second char</a>
<a name="ln548">      ((flags &amp; NV_NCH_NOP) == NV_NCH_NOP &amp;&amp; !pending_op)</a>
<a name="ln549">      // NV_NCH_ALW is set, always get a second char</a>
<a name="ln550">      || (flags &amp; NV_NCH_ALW) == NV_NCH_ALW</a>
<a name="ln551">      // 'q' without a pending operator, recording or executing a register,</a>
<a name="ln552">      // needs to be followed by a second char, examples:</a>
<a name="ln553">      // - qc =&gt; record using register c</a>
<a name="ln554">      // - q: =&gt; open command-line window</a>
<a name="ln555">      || (cmdchar == 'q'</a>
<a name="ln556">          &amp;&amp; !pending_op</a>
<a name="ln557">          &amp;&amp; reg_recording == 0</a>
<a name="ln558">          &amp;&amp; reg_executing == 0)</a>
<a name="ln559">      // 'a' or 'i' after an operator is a text object, examples:</a>
<a name="ln560">      // - ciw =&gt; change inside word</a>
<a name="ln561">      // - da( =&gt; delete parenthesis and everything inside.</a>
<a name="ln562">      // Also, don't do anything when these keys are received in visual mode</a>
<a name="ln563">      // so just get another char.</a>
<a name="ln564">      //</a>
<a name="ln565">      // TODO(tarruda): Visual state needs to be refactored into a</a>
<a name="ln566">      // separate state that &quot;inherits&quot; from normal state.</a>
<a name="ln567">      || ((cmdchar == 'a' || cmdchar == 'i') &amp;&amp; (pending_op || VIsual_active)));</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570">static bool normal_need_redraw_mode_message(NormalState *s)</a>
<a name="ln571">{</a>
<a name="ln572">  return (</a>
<a name="ln573">      // 'showmode' is set and messages can be printed</a>
<a name="ln574">      ((p_smd &amp;&amp; msg_silent == 0</a>
<a name="ln575">        // must restart insert mode(ctrl+o or ctrl+l) or we just entered visual</a>
<a name="ln576">        // mode</a>
<a name="ln577">        &amp;&amp; (restart_edit != 0 || (VIsual_active</a>
<a name="ln578">                                  &amp;&amp; s-&gt;old_pos.lnum == curwin-&gt;w_cursor.lnum</a>
<a name="ln579">                                  &amp;&amp; s-&gt;old_pos.col == curwin-&gt;w_cursor.col))</a>
<a name="ln580">        // command-line must be cleared or redrawn</a>
<a name="ln581">        &amp;&amp; (clear_cmdline || redraw_cmdline)</a>
<a name="ln582">        // some message was printed or scrolled</a>
<a name="ln583">        &amp;&amp; (msg_didout || (msg_didany &amp;&amp; msg_scroll))</a>
<a name="ln584">        // it is fine to remove the current message</a>
<a name="ln585">        &amp;&amp; !msg_nowait</a>
<a name="ln586">        // the command was the result of direct user input and not a mapping</a>
<a name="ln587">        &amp;&amp; KeyTyped)</a>
<a name="ln588">       // must restart insert mode, not in visual mode and error message is</a>
<a name="ln589">       // being shown</a>
<a name="ln590">       || (restart_edit != 0 &amp;&amp; !VIsual_active &amp;&amp; msg_scroll</a>
<a name="ln591">           &amp;&amp; emsg_on_display))</a>
<a name="ln592">      // no register was used</a>
<a name="ln593">      &amp;&amp; s-&gt;oa.regname == 0</a>
<a name="ln594">      &amp;&amp; !(s-&gt;ca.retval &amp; CA_COMMAND_BUSY)</a>
<a name="ln595">      &amp;&amp; stuff_empty()</a>
<a name="ln596">      &amp;&amp; typebuf_typed()</a>
<a name="ln597">      &amp;&amp; emsg_silent == 0</a>
<a name="ln598">      &amp;&amp; !did_wait_return</a>
<a name="ln599">      &amp;&amp; s-&gt;oa.op_type == OP_NOP);</a>
<a name="ln600">}</a>
<a name="ln601"> </a>
<a name="ln602">static void normal_redraw_mode_message(NormalState *s)</a>
<a name="ln603">{</a>
<a name="ln604">  int save_State = State;</a>
<a name="ln605"> </a>
<a name="ln606">  // Draw the cursor with the right shape here</a>
<a name="ln607">  if (restart_edit != 0) {</a>
<a name="ln608">    State = INSERT;</a>
<a name="ln609">  }</a>
<a name="ln610"> </a>
<a name="ln611">  // If need to redraw, and there is a &quot;keep_msg&quot;, redraw before the</a>
<a name="ln612">  // delay</a>
<a name="ln613">  if (must_redraw &amp;&amp; keep_msg != NULL &amp;&amp; !emsg_on_display) {</a>
<a name="ln614">    char_u      *kmsg;</a>
<a name="ln615"> </a>
<a name="ln616">    kmsg = keep_msg;</a>
<a name="ln617">    keep_msg = NULL;</a>
<a name="ln618">    // Showmode() will clear keep_msg, but we want to use it anyway.</a>
<a name="ln619">    // First update w_topline.</a>
<a name="ln620">    setcursor();</a>
<a name="ln621">    update_screen(0);</a>
<a name="ln622">    // now reset it, otherwise it's put in the history again</a>
<a name="ln623">    keep_msg = kmsg;</a>
<a name="ln624"> </a>
<a name="ln625">    kmsg = vim_strsave(keep_msg);</a>
<a name="ln626">    msg_attr((const char *)kmsg, keep_msg_attr);</a>
<a name="ln627">    xfree(kmsg);</a>
<a name="ln628">  }</a>
<a name="ln629">  setcursor();</a>
<a name="ln630">  ui_cursor_shape();                  // show different cursor shape</a>
<a name="ln631">  ui_flush();</a>
<a name="ln632">  if (msg_scroll || emsg_on_display) {</a>
<a name="ln633">    os_delay(1003L, true);            // wait at least one second</a>
<a name="ln634">  }</a>
<a name="ln635">  os_delay(3003L, false);             // wait up to three seconds</a>
<a name="ln636">  State = save_State;</a>
<a name="ln637"> </a>
<a name="ln638">  msg_scroll = false;</a>
<a name="ln639">  emsg_on_display = false;</a>
<a name="ln640">}</a>
<a name="ln641"> </a>
<a name="ln642">// TODO(tarruda): Split into a &quot;normal pending&quot; state that can handle K_EVENT</a>
<a name="ln643">static void normal_get_additional_char(NormalState *s)</a>
<a name="ln644">{</a>
<a name="ln645">  int *cp;</a>
<a name="ln646">  bool repl = false;            // get character for replace mode</a>
<a name="ln647">  bool lit = false;             // get extra character literally</a>
<a name="ln648">  bool langmap_active = false;  // using :lmap mappings</a>
<a name="ln649">  int lang;                     // getting a text character</a>
<a name="ln650"> </a>
<a name="ln651">  no_mapping++;</a>
<a name="ln652">  // Don't generate a CursorHold event here, most commands can't handle</a>
<a name="ln653">  // it, e.g., nv_replace(), nv_csearch().</a>
<a name="ln654">  did_cursorhold = true;</a>
<a name="ln655">  if (s-&gt;ca.cmdchar == 'g') {</a>
<a name="ln656">    // For 'g' get the next character now, so that we can check for</a>
<a name="ln657">    // &quot;gr&quot;, &quot;g'&quot; and &quot;g`&quot;.</a>
<a name="ln658">    s-&gt;ca.nchar = plain_vgetc();</a>
<a name="ln659">    LANGMAP_ADJUST(s-&gt;ca.nchar, true);</a>
<a name="ln660">    s-&gt;need_flushbuf |= add_to_showcmd(s-&gt;ca.nchar);</a>
<a name="ln661">    if (s-&gt;ca.nchar == 'r' || s-&gt;ca.nchar == '\'' || s-&gt;ca.nchar == '`'</a>
<a name="ln662">        || s-&gt;ca.nchar == Ctrl_BSL) {</a>
<a name="ln663">      cp = &amp;s-&gt;ca.extra_char;            // need to get a third character</a>
<a name="ln664">      if (s-&gt;ca.nchar != 'r') {</a>
<a name="ln665">        lit = true;                           // get it literally</a>
<a name="ln666">      } else {</a>
<a name="ln667">        repl = true;                          // get it in replace mode</a>
<a name="ln668">      }</a>
<a name="ln669">    } else {</a>
<a name="ln670">      cp = NULL;                      // no third character needed</a>
<a name="ln671">    }</a>
<a name="ln672">  } else {</a>
<a name="ln673">    if (s-&gt;ca.cmdchar == 'r') {</a>
<a name="ln674">      // get it in replace mode</a>
<a name="ln675">      repl = true;</a>
<a name="ln676">    }</a>
<a name="ln677">    cp = &amp;s-&gt;ca.nchar;</a>
<a name="ln678">  }</a>
<a name="ln679">  lang = (repl || (nv_cmds[s-&gt;idx].cmd_flags &amp; NV_LANG));</a>
<a name="ln680"> </a>
<a name="ln681">  // Get a second or third character.</a>
<a name="ln682">  if (cp != NULL) {</a>
<a name="ln683">    if (repl) {</a>
<a name="ln684">      State = REPLACE;                // pretend Replace mode</a>
<a name="ln685">      ui_cursor_shape();              // show different cursor shape</a>
<a name="ln686">    }</a>
<a name="ln687">    if (lang &amp;&amp; curbuf-&gt;b_p_iminsert == B_IMODE_LMAP) {</a>
<a name="ln688">      // Allow mappings defined with &quot;:lmap&quot;.</a>
<a name="ln689">      no_mapping--;</a>
<a name="ln690">      if (repl) {</a>
<a name="ln691">        State = LREPLACE;</a>
<a name="ln692">      } else {</a>
<a name="ln693">        State = LANGMAP;</a>
<a name="ln694">      }</a>
<a name="ln695">      langmap_active = true;</a>
<a name="ln696">    }</a>
<a name="ln697"> </a>
<a name="ln698">    *cp = plain_vgetc();</a>
<a name="ln699"> </a>
<a name="ln700">    if (langmap_active) {</a>
<a name="ln701">      // Undo the decrement done above</a>
<a name="ln702">      no_mapping++;</a>
<a name="ln703">    }</a>
<a name="ln704">    State = NORMAL_BUSY;</a>
<a name="ln705">    s-&gt;need_flushbuf |= add_to_showcmd(*cp);</a>
<a name="ln706"> </a>
<a name="ln707">    if (!lit) {</a>
<a name="ln708">      // Typing CTRL-K gets a digraph.</a>
<a name="ln709">      if (*cp == Ctrl_K &amp;&amp; ((nv_cmds[s-&gt;idx].cmd_flags &amp; NV_LANG)</a>
<a name="ln710">              || cp == &amp;s-&gt;ca.extra_char)</a>
<a name="ln711">          &amp;&amp; vim_strchr(p_cpo, CPO_DIGRAPH) == NULL) {</a>
<a name="ln712">        s-&gt;c = get_digraph(false);</a>
<a name="ln713">        if (s-&gt;c &gt; 0) {</a>
<a name="ln714">          *cp = s-&gt;c;</a>
<a name="ln715">          // Guessing how to update showcmd here...</a>
<a name="ln716">          del_from_showcmd(3);</a>
<a name="ln717">          s-&gt;need_flushbuf |= add_to_showcmd(*cp);</a>
<a name="ln718">        }</a>
<a name="ln719">      }</a>
<a name="ln720"> </a>
<a name="ln721">      // adjust chars &gt; 127, except after &quot;tTfFr&quot; commands</a>
<a name="ln722">      LANGMAP_ADJUST(*cp, !lang);</a>
<a name="ln723">      // adjust Hebrew mapped char</a>
<a name="ln724">      if (p_hkmap &amp;&amp; lang &amp;&amp; KeyTyped) {</a>
<a name="ln725">        *cp = hkmap(*cp);</a>
<a name="ln726">      }</a>
<a name="ln727">    }</a>
<a name="ln728"> </a>
<a name="ln729">    // When the next character is CTRL-\ a following CTRL-N means the</a>
<a name="ln730">    // command is aborted and we go to Normal mode.</a>
<a name="ln731">    if (cp == &amp;s-&gt;ca.extra_char</a>
<a name="ln732">        &amp;&amp; s-&gt;ca.nchar == Ctrl_BSL</a>
<a name="ln733">        &amp;&amp; (s-&gt;ca.extra_char == Ctrl_N || s-&gt;ca.extra_char == Ctrl_G)) {</a>
<a name="ln734">      s-&gt;ca.cmdchar = Ctrl_BSL;</a>
<a name="ln735">      s-&gt;ca.nchar = s-&gt;ca.extra_char;</a>
<a name="ln736">      s-&gt;idx = find_command(s-&gt;ca.cmdchar);</a>
<a name="ln737">    } else if ((s-&gt;ca.nchar == 'n' || s-&gt;ca.nchar == 'N')</a>
<a name="ln738">        &amp;&amp; s-&gt;ca.cmdchar == 'g') {</a>
<a name="ln739">      s-&gt;ca.oap-&gt;op_type = get_op_type(*cp, NUL);</a>
<a name="ln740">    } else if (*cp == Ctrl_BSL) {</a>
<a name="ln741">      long towait = (p_ttm &gt;= 0 ? p_ttm : p_tm);</a>
<a name="ln742"> </a>
<a name="ln743">      // There is a busy wait here when typing &quot;f&lt;C-\&gt;&quot; and then</a>
<a name="ln744">      // something different from CTRL-N.  Can't be avoided.</a>
<a name="ln745">      while ((s-&gt;c = vpeekc()) &lt;= 0 &amp;&amp; towait &gt; 0L) {</a>
<a name="ln746">        do_sleep(towait &gt; 50L ? 50L : towait);</a>
<a name="ln747">        towait -= 50L;</a>
<a name="ln748">      }</a>
<a name="ln749">      if (s-&gt;c &gt; 0) {</a>
<a name="ln750">        s-&gt;c = plain_vgetc();</a>
<a name="ln751">        if (s-&gt;c != Ctrl_N &amp;&amp; s-&gt;c != Ctrl_G) {</a>
<a name="ln752">          vungetc(s-&gt;c);</a>
<a name="ln753">        } else {</a>
<a name="ln754">          s-&gt;ca.cmdchar = Ctrl_BSL;</a>
<a name="ln755">          s-&gt;ca.nchar = s-&gt;c;</a>
<a name="ln756">          s-&gt;idx = find_command(s-&gt;ca.cmdchar);</a>
<a name="ln757">          assert(s-&gt;idx &gt;= 0);</a>
<a name="ln758">        }</a>
<a name="ln759">      }</a>
<a name="ln760">    }</a>
<a name="ln761"> </a>
<a name="ln762">    // When getting a text character and the next character is a</a>
<a name="ln763">    // multi-byte character, it could be a composing character.</a>
<a name="ln764">    // However, don't wait for it to arrive. Also, do enable mapping,</a>
<a name="ln765">    // because if it's put back with vungetc() it's too late to apply</a>
<a name="ln766">    // mapping.</a>
<a name="ln767">    no_mapping--;</a>
<a name="ln768">    while (lang &amp;&amp; (s-&gt;c = vpeekc()) &gt; 0</a>
<a name="ln769">           &amp;&amp; (s-&gt;c &gt;= 0x100 || MB_BYTE2LEN(vpeekc()) &gt; 1)) {</a>
<a name="ln770">      s-&gt;c = plain_vgetc();</a>
<a name="ln771">      if (!utf_iscomposing(s-&gt;c)) {</a>
<a name="ln772">        vungetc(s-&gt;c);                   /* it wasn't, put it back */</a>
<a name="ln773">        break;</a>
<a name="ln774">      } else if (s-&gt;ca.ncharC1 == 0) {</a>
<a name="ln775">        s-&gt;ca.ncharC1 = s-&gt;c;</a>
<a name="ln776">      } else {</a>
<a name="ln777">        s-&gt;ca.ncharC2 = s-&gt;c;</a>
<a name="ln778">      }</a>
<a name="ln779">    }</a>
<a name="ln780">    no_mapping++;</a>
<a name="ln781">  }</a>
<a name="ln782">  no_mapping--;</a>
<a name="ln783">}</a>
<a name="ln784"> </a>
<a name="ln785">static void normal_invert_horizontal(NormalState *s)</a>
<a name="ln786">{</a>
<a name="ln787">  switch (s-&gt;ca.cmdchar) {</a>
<a name="ln788">    case 'l':       s-&gt;ca.cmdchar = 'h'; break;</a>
<a name="ln789">    case K_RIGHT:   s-&gt;ca.cmdchar = K_LEFT; break;</a>
<a name="ln790">    case K_S_RIGHT: s-&gt;ca.cmdchar = K_S_LEFT; break;</a>
<a name="ln791">    case K_C_RIGHT: s-&gt;ca.cmdchar = K_C_LEFT; break;</a>
<a name="ln792">    case 'h':       s-&gt;ca.cmdchar = 'l'; break;</a>
<a name="ln793">    case K_LEFT:    s-&gt;ca.cmdchar = K_RIGHT; break;</a>
<a name="ln794">    case K_S_LEFT:  s-&gt;ca.cmdchar = K_S_RIGHT; break;</a>
<a name="ln795">    case K_C_LEFT:  s-&gt;ca.cmdchar = K_C_RIGHT; break;</a>
<a name="ln796">    case '&gt;':       s-&gt;ca.cmdchar = '&lt;'; break;</a>
<a name="ln797">    case '&lt;':       s-&gt;ca.cmdchar = '&gt;'; break;</a>
<a name="ln798">  }</a>
<a name="ln799">  s-&gt;idx = find_command(s-&gt;ca.cmdchar);</a>
<a name="ln800">}</a>
<a name="ln801"> </a>
<a name="ln802">static bool normal_get_command_count(NormalState *s)</a>
<a name="ln803">{</a>
<a name="ln804">  if (VIsual_active &amp;&amp; VIsual_select) {</a>
<a name="ln805">    return false;</a>
<a name="ln806">  }</a>
<a name="ln807">  // Handle a count before a command and compute ca.count0.</a>
<a name="ln808">  // Note that '0' is a command and not the start of a count, but it's</a>
<a name="ln809">  // part of a count after other digits.</a>
<a name="ln810">  while ((s-&gt;c &gt;= '1' &amp;&amp; s-&gt;c &lt;= '9') || (s-&gt;ca.count0 != 0</a>
<a name="ln811">        &amp;&amp; (s-&gt;c == K_DEL || s-&gt;c == K_KDEL || s-&gt;c == '0'))) {</a>
<a name="ln812">    if (s-&gt;c == K_DEL || s-&gt;c == K_KDEL) {</a>
<a name="ln813">      s-&gt;ca.count0 /= 10;</a>
<a name="ln814">      del_from_showcmd(4);            // delete the digit and ~@%</a>
<a name="ln815">    } else {</a>
<a name="ln816">      s-&gt;ca.count0 = s-&gt;ca.count0 * 10 + (s-&gt;c - '0');</a>
<a name="ln817">    }</a>
<a name="ln818"> </a>
<a name="ln819">    if (s-&gt;ca.count0 &lt; 0) {</a>
<a name="ln820">      // got too large!</a>
<a name="ln821">      s-&gt;ca.count0 = 999999999L;</a>
<a name="ln822">    }</a>
<a name="ln823"> </a>
<a name="ln824">    // Set v:count here, when called from main() and not a stuffed</a>
<a name="ln825">    // command, so that v:count can be used in an expression mapping</a>
<a name="ln826">    // right after the count. Do set it for redo.</a>
<a name="ln827">    if (s-&gt;toplevel &amp;&amp; readbuf1_empty()) {</a>
<a name="ln828">      set_vcount_ca(&amp;s-&gt;ca, &amp;s-&gt;set_prevcount);</a>
<a name="ln829">    }</a>
<a name="ln830"> </a>
<a name="ln831">    if (s-&gt;ctrl_w) {</a>
<a name="ln832">      no_mapping++;</a>
<a name="ln833">    }</a>
<a name="ln834"> </a>
<a name="ln835">    ++no_zero_mapping;                // don't map zero here</a>
<a name="ln836">    s-&gt;c = plain_vgetc();</a>
<a name="ln837">    LANGMAP_ADJUST(s-&gt;c, true);</a>
<a name="ln838">    --no_zero_mapping;</a>
<a name="ln839">    if (s-&gt;ctrl_w) {</a>
<a name="ln840">      no_mapping--;</a>
<a name="ln841">    }</a>
<a name="ln842">    s-&gt;need_flushbuf |= add_to_showcmd(s-&gt;c);</a>
<a name="ln843">  }</a>
<a name="ln844"> </a>
<a name="ln845">  // If we got CTRL-W there may be a/another count</a>
<a name="ln846">  if (s-&gt;c == Ctrl_W &amp;&amp; !s-&gt;ctrl_w &amp;&amp; s-&gt;oa.op_type == OP_NOP) {</a>
<a name="ln847">    s-&gt;ctrl_w = true;</a>
<a name="ln848">    s-&gt;ca.opcount = s-&gt;ca.count0;           // remember first count</a>
<a name="ln849">    s-&gt;ca.count0 = 0;</a>
<a name="ln850">    no_mapping++;</a>
<a name="ln851">    s-&gt;c = plain_vgetc();                // get next character</a>
<a name="ln852">    LANGMAP_ADJUST(s-&gt;c, true);</a>
<a name="ln853">    no_mapping--;</a>
<a name="ln854">    s-&gt;need_flushbuf |= add_to_showcmd(s-&gt;c);</a>
<a name="ln855">    return true;</a>
<a name="ln856">  }</a>
<a name="ln857"> </a>
<a name="ln858">  return false;</a>
<a name="ln859">}</a>
<a name="ln860"> </a>
<a name="ln861">static void normal_finish_command(NormalState *s)</a>
<a name="ln862">{</a>
<a name="ln863">  if (s-&gt;command_finished) {</a>
<a name="ln864">    goto normal_end;</a>
<a name="ln865">  }</a>
<a name="ln866"> </a>
<a name="ln867">  // If we didn't start or finish an operator, reset oap-&gt;regname, unless we</a>
<a name="ln868">  // need it later.</a>
<a name="ln869">  if (!finish_op</a>
<a name="ln870">      &amp;&amp; !s-&gt;oa.op_type</a>
<a name="ln871">      &amp;&amp; (s-&gt;idx &lt; 0 || !(nv_cmds[s-&gt;idx].cmd_flags &amp; NV_KEEPREG))) {</a>
<a name="ln872">    clearop(&amp;s-&gt;oa);</a>
<a name="ln873">    set_reg_var(get_default_register_name());</a>
<a name="ln874">  }</a>
<a name="ln875"> </a>
<a name="ln876">  // Get the length of mapped chars again after typing a count, second</a>
<a name="ln877">  // character or &quot;z333&lt;cr&gt;&quot;.</a>
<a name="ln878">  if (s-&gt;old_mapped_len &gt; 0) {</a>
<a name="ln879">    s-&gt;old_mapped_len = typebuf_maplen();</a>
<a name="ln880">  }</a>
<a name="ln881"> </a>
<a name="ln882">  // If an operation is pending, handle it.  But not for K_IGNORE.</a>
<a name="ln883">  if (s-&gt;ca.cmdchar != K_IGNORE) {</a>
<a name="ln884">    do_pending_operator(&amp;s-&gt;ca, s-&gt;old_col, false);</a>
<a name="ln885">  }</a>
<a name="ln886"> </a>
<a name="ln887">  // Wait for a moment when a message is displayed that will be overwritten</a>
<a name="ln888">  // by the mode message.</a>
<a name="ln889">  // In Visual mode and with &quot;^O&quot; in Insert mode, a short message will be</a>
<a name="ln890">  // overwritten by the mode message.  Wait a bit, until a key is hit.</a>
<a name="ln891">  // In Visual mode, it's more important to keep the Visual area updated</a>
<a name="ln892">  // than keeping a message (e.g. from a /pat search).</a>
<a name="ln893">  // Only do this if the command was typed, not from a mapping.</a>
<a name="ln894">  // Don't wait when emsg_silent is non-zero.</a>
<a name="ln895">  // Also wait a bit after an error message, e.g. for &quot;^O:&quot;.</a>
<a name="ln896">  // Don't redraw the screen, it would remove the message.</a>
<a name="ln897">  if (normal_need_redraw_mode_message(s)) {</a>
<a name="ln898">    normal_redraw_mode_message(s);</a>
<a name="ln899">  }</a>
<a name="ln900"> </a>
<a name="ln901">  // Finish up after executing a Normal mode command.</a>
<a name="ln902">normal_end:</a>
<a name="ln903"> </a>
<a name="ln904">  msg_nowait = false;</a>
<a name="ln905"> </a>
<a name="ln906">  if (finish_op) {</a>
<a name="ln907">    set_reg_var(get_default_register_name());</a>
<a name="ln908">  }</a>
<a name="ln909"> </a>
<a name="ln910">  // Reset finish_op, in case it was set</a>
<a name="ln911">  s-&gt;c = finish_op;</a>
<a name="ln912">  finish_op = false;</a>
<a name="ln913">  // Redraw the cursor with another shape, if we were in Operator-pending</a>
<a name="ln914">  // mode or did a replace command.</a>
<a name="ln915">  if (s-&gt;c || s-&gt;ca.cmdchar == 'r') {</a>
<a name="ln916">    ui_cursor_shape();                  // may show different cursor shape</a>
<a name="ln917">  }</a>
<a name="ln918"> </a>
<a name="ln919">  if (s-&gt;oa.op_type == OP_NOP &amp;&amp; s-&gt;oa.regname == 0</a>
<a name="ln920">      &amp;&amp; s-&gt;ca.cmdchar != K_EVENT) {</a>
<a name="ln921">    clear_showcmd();</a>
<a name="ln922">  }</a>
<a name="ln923"> </a>
<a name="ln924">  checkpcmark();                // check if we moved since setting pcmark</a>
<a name="ln925">  xfree(s-&gt;ca.searchbuf);</a>
<a name="ln926"> </a>
<a name="ln927">  mb_check_adjust_col(curwin);  // #6203</a>
<a name="ln928"> </a>
<a name="ln929">  if (curwin-&gt;w_p_scb &amp;&amp; s-&gt;toplevel) {</a>
<a name="ln930">    validate_cursor();          // may need to update w_leftcol</a>
<a name="ln931">    do_check_scrollbind(true);</a>
<a name="ln932">  }</a>
<a name="ln933"> </a>
<a name="ln934">  if (curwin-&gt;w_p_crb &amp;&amp; s-&gt;toplevel) {</a>
<a name="ln935">    validate_cursor();          // may need to update w_leftcol</a>
<a name="ln936">    do_check_cursorbind();</a>
<a name="ln937">  }</a>
<a name="ln938"> </a>
<a name="ln939">  // May restart edit(), if we got here with CTRL-O in Insert mode (but not</a>
<a name="ln940">  // if still inside a mapping that started in Visual mode).</a>
<a name="ln941">  // May switch from Visual to Select mode after CTRL-O command.</a>
<a name="ln942">  if (s-&gt;oa.op_type == OP_NOP</a>
<a name="ln943">             &amp;&amp; ((restart_edit != 0 &amp;&amp; !VIsual_active &amp;&amp; s-&gt;old_mapped_len == 0)</a>
<a name="ln944">                 || restart_VIsual_select == 1)</a>
<a name="ln945">             &amp;&amp; !(s-&gt;ca.retval &amp; CA_COMMAND_BUSY)</a>
<a name="ln946">             &amp;&amp; stuff_empty()</a>
<a name="ln947">             &amp;&amp; s-&gt;oa.regname == 0) {</a>
<a name="ln948">    if (restart_VIsual_select == 1) {</a>
<a name="ln949">      VIsual_select = true;</a>
<a name="ln950">      showmode();</a>
<a name="ln951">      restart_VIsual_select = 0;</a>
<a name="ln952">    }</a>
<a name="ln953">    if (restart_edit != 0 &amp;&amp; !VIsual_active &amp;&amp; s-&gt;old_mapped_len == 0) {</a>
<a name="ln954">      (void)edit(restart_edit, false, 1L);</a>
<a name="ln955">    }</a>
<a name="ln956">  }</a>
<a name="ln957"> </a>
<a name="ln958">  if (restart_VIsual_select == 2) {</a>
<a name="ln959">    restart_VIsual_select = 1;</a>
<a name="ln960">  }</a>
<a name="ln961"> </a>
<a name="ln962">  // Save count before an operator for next time</a>
<a name="ln963">  opcount = s-&gt;ca.opcount;</a>
<a name="ln964">}</a>
<a name="ln965"> </a>
<a name="ln966">static int normal_execute(VimState *state, int key)</a>
<a name="ln967">{</a>
<a name="ln968">  NormalState *s = (NormalState *)state;</a>
<a name="ln969">  s-&gt;command_finished = false;</a>
<a name="ln970">  s-&gt;ctrl_w = false;                  /* got CTRL-W command */</a>
<a name="ln971">  s-&gt;old_col = curwin-&gt;w_curswant;</a>
<a name="ln972">  s-&gt;c = key;</a>
<a name="ln973"> </a>
<a name="ln974">  LANGMAP_ADJUST(s-&gt;c, get_real_state() != SELECTMODE);</a>
<a name="ln975"> </a>
<a name="ln976">  // If a mapping was started in Visual or Select mode, remember the length</a>
<a name="ln977">  // of the mapping.  This is used below to not return to Insert mode for as</a>
<a name="ln978">  // long as the mapping is being executed.</a>
<a name="ln979">  if (restart_edit == 0) {</a>
<a name="ln980">    s-&gt;old_mapped_len = 0;</a>
<a name="ln981">  } else if (s-&gt;old_mapped_len || (VIsual_active &amp;&amp; s-&gt;mapped_len == 0</a>
<a name="ln982">        &amp;&amp; typebuf_maplen() &gt; 0)) {</a>
<a name="ln983">    s-&gt;old_mapped_len = typebuf_maplen();</a>
<a name="ln984">  }</a>
<a name="ln985"> </a>
<a name="ln986">  if (s-&gt;c == NUL) {</a>
<a name="ln987">    s-&gt;c = K_ZERO;</a>
<a name="ln988">  }</a>
<a name="ln989"> </a>
<a name="ln990">  // In Select mode, typed text replaces the selection.</a>
<a name="ln991">  if (VIsual_active &amp;&amp; VIsual_select &amp;&amp; (vim_isprintc(s-&gt;c)</a>
<a name="ln992">        || s-&gt;c == NL || s-&gt;c == CAR || s-&gt;c == K_KENTER)) {</a>
<a name="ln993">    // Fake a &quot;c&quot;hange command.  When &quot;restart_edit&quot; is set (e.g., because</a>
<a name="ln994">    // 'insertmode' is set) fake a &quot;d&quot;elete command, Insert mode will</a>
<a name="ln995">    // restart automatically.</a>
<a name="ln996">    // Insert the typed character in the typeahead buffer, so that it can</a>
<a name="ln997">    // be mapped in Insert mode.  Required for &quot;:lmap&quot; to work.</a>
<a name="ln998">    ins_char_typebuf(s-&gt;c);</a>
<a name="ln999">    if (restart_edit != 0) {</a>
<a name="ln1000">      s-&gt;c = 'd';</a>
<a name="ln1001">    } else {</a>
<a name="ln1002">      s-&gt;c = 'c';</a>
<a name="ln1003">    }</a>
<a name="ln1004">    msg_nowait = true;          // don't delay going to insert mode</a>
<a name="ln1005">    s-&gt;old_mapped_len = 0;      // do go to Insert mode</a>
<a name="ln1006">  }</a>
<a name="ln1007"> </a>
<a name="ln1008">  s-&gt;need_flushbuf = add_to_showcmd(s-&gt;c);</a>
<a name="ln1009"> </a>
<a name="ln1010">  while (normal_get_command_count(s)) continue;</a>
<a name="ln1011"> </a>
<a name="ln1012">  if (s-&gt;c == K_EVENT) {</a>
<a name="ln1013">    // Save the count values so that ca.opcount and ca.count0 are exactly</a>
<a name="ln1014">    // the same when coming back here after handling K_EVENT.</a>
<a name="ln1015">    s-&gt;oa.prev_opcount = s-&gt;ca.opcount;</a>
<a name="ln1016">    s-&gt;oa.prev_count0 = s-&gt;ca.count0;</a>
<a name="ln1017">  } else if (s-&gt;ca.opcount != 0)  {</a>
<a name="ln1018">    // If we're in the middle of an operator (including after entering a</a>
<a name="ln1019">    // yank buffer with '&quot;') AND we had a count before the operator, then</a>
<a name="ln1020">    // that count overrides the current value of ca.count0.</a>
<a name="ln1021">    // What this means effectively, is that commands like &quot;3dw&quot; get turned</a>
<a name="ln1022">    // into &quot;d3w&quot; which makes things fall into place pretty neatly.</a>
<a name="ln1023">    // If you give a count before AND after the operator, they are</a>
<a name="ln1024">    // multiplied.</a>
<a name="ln1025">    if (s-&gt;ca.count0) {</a>
<a name="ln1026">      s-&gt;ca.count0 *= s-&gt;ca.opcount;</a>
<a name="ln1027">    } else {</a>
<a name="ln1028">      s-&gt;ca.count0 = s-&gt;ca.opcount;</a>
<a name="ln1029">    }</a>
<a name="ln1030">  }</a>
<a name="ln1031"> </a>
<a name="ln1032">  // Always remember the count.  It will be set to zero (on the next call,</a>
<a name="ln1033">  // above) when there is no pending operator.</a>
<a name="ln1034">  // When called from main(), save the count for use by the &quot;count&quot; built-in</a>
<a name="ln1035">  // variable.</a>
<a name="ln1036">  s-&gt;ca.opcount = s-&gt;ca.count0;</a>
<a name="ln1037">  s-&gt;ca.count1 = (s-&gt;ca.count0 == 0 ? 1 : s-&gt;ca.count0);</a>
<a name="ln1038"> </a>
<a name="ln1039">  // Only set v:count when called from main() and not a stuffed command.</a>
<a name="ln1040">  // Do set it for redo.</a>
<a name="ln1041">  if (s-&gt;toplevel &amp;&amp; readbuf1_empty()) {</a>
<a name="ln1042">    set_vcount(s-&gt;ca.count0, s-&gt;ca.count1, s-&gt;set_prevcount);</a>
<a name="ln1043">  }</a>
<a name="ln1044"> </a>
<a name="ln1045">  // Find the command character in the table of commands.</a>
<a name="ln1046">  // For CTRL-W we already got nchar when looking for a count.</a>
<a name="ln1047">  if (s-&gt;ctrl_w) {</a>
<a name="ln1048">    s-&gt;ca.nchar = s-&gt;c;</a>
<a name="ln1049">    s-&gt;ca.cmdchar = Ctrl_W;</a>
<a name="ln1050">  } else {</a>
<a name="ln1051">    s-&gt;ca.cmdchar = s-&gt;c;</a>
<a name="ln1052">  }</a>
<a name="ln1053"> </a>
<a name="ln1054">  s-&gt;idx = find_command(s-&gt;ca.cmdchar);</a>
<a name="ln1055"> </a>
<a name="ln1056">  if (s-&gt;idx &lt; 0) {</a>
<a name="ln1057">    // Not a known command: beep.</a>
<a name="ln1058">    clearopbeep(&amp;s-&gt;oa);</a>
<a name="ln1059">    s-&gt;command_finished = true;</a>
<a name="ln1060">    goto finish;</a>
<a name="ln1061">  }</a>
<a name="ln1062"> </a>
<a name="ln1063">  if (text_locked() &amp;&amp; (nv_cmds[s-&gt;idx].cmd_flags &amp; NV_NCW)) {</a>
<a name="ln1064">    // This command is not allowed while editing a cmdline: beep.</a>
<a name="ln1065">    clearopbeep(&amp;s-&gt;oa);</a>
<a name="ln1066">    text_locked_msg();</a>
<a name="ln1067">    s-&gt;command_finished = true;</a>
<a name="ln1068">    goto finish;</a>
<a name="ln1069">  }</a>
<a name="ln1070"> </a>
<a name="ln1071">  if ((nv_cmds[s-&gt;idx].cmd_flags &amp; NV_NCW) &amp;&amp; curbuf_locked()) {</a>
<a name="ln1072">    s-&gt;command_finished = true;</a>
<a name="ln1073">    goto finish;</a>
<a name="ln1074">  }</a>
<a name="ln1075"> </a>
<a name="ln1076">  // In Visual/Select mode, a few keys are handled in a special way.</a>
<a name="ln1077">  if (VIsual_active &amp;&amp; normal_handle_special_visual_command(s)) {</a>
<a name="ln1078">    s-&gt;command_finished = true;</a>
<a name="ln1079">    goto finish;</a>
<a name="ln1080">  }</a>
<a name="ln1081"> </a>
<a name="ln1082">  if (curwin-&gt;w_p_rl &amp;&amp; KeyTyped &amp;&amp; !KeyStuffed</a>
<a name="ln1083">      &amp;&amp; (nv_cmds[s-&gt;idx].cmd_flags &amp; NV_RL)) {</a>
<a name="ln1084">    // Invert horizontal movements and operations.  Only when typed by the</a>
<a name="ln1085">    // user directly, not when the result of a mapping or &quot;x&quot; translated</a>
<a name="ln1086">    // to &quot;dl&quot;.</a>
<a name="ln1087">    normal_invert_horizontal(s);</a>
<a name="ln1088">  }</a>
<a name="ln1089"> </a>
<a name="ln1090">  // Get an additional character if we need one.</a>
<a name="ln1091">  if (normal_need_additional_char(s)) {</a>
<a name="ln1092">    normal_get_additional_char(s);</a>
<a name="ln1093">  }</a>
<a name="ln1094"> </a>
<a name="ln1095">  // Flush the showcmd characters onto the screen so we can see them while</a>
<a name="ln1096">  // the command is being executed.  Only do this when the shown command was</a>
<a name="ln1097">  // actually displayed, otherwise this will slow down a lot when executing</a>
<a name="ln1098">  // mappings.</a>
<a name="ln1099">  if (s-&gt;need_flushbuf) {</a>
<a name="ln1100">    ui_flush();</a>
<a name="ln1101">  }</a>
<a name="ln1102">  if (s-&gt;ca.cmdchar != K_IGNORE &amp;&amp; s-&gt;ca.cmdchar != K_EVENT) {</a>
<a name="ln1103">    did_cursorhold = false;</a>
<a name="ln1104">  }</a>
<a name="ln1105"> </a>
<a name="ln1106">  State = NORMAL;</a>
<a name="ln1107"> </a>
<a name="ln1108">  if (s-&gt;ca.nchar == ESC) {</a>
<a name="ln1109">    clearop(&amp;s-&gt;oa);</a>
<a name="ln1110">    if (restart_edit == 0 &amp;&amp; goto_im()) {</a>
<a name="ln1111">      restart_edit = 'a';</a>
<a name="ln1112">    }</a>
<a name="ln1113">    s-&gt;command_finished = true;</a>
<a name="ln1114">    goto finish;</a>
<a name="ln1115">  }</a>
<a name="ln1116"> </a>
<a name="ln1117">  if (s-&gt;ca.cmdchar != K_IGNORE) {</a>
<a name="ln1118">    msg_didout = false;        // don't scroll screen up for normal command</a>
<a name="ln1119">    msg_col = 0;</a>
<a name="ln1120">  }</a>
<a name="ln1121"> </a>
<a name="ln1122">  s-&gt;old_pos = curwin-&gt;w_cursor;           // remember where cursor was</a>
<a name="ln1123"> </a>
<a name="ln1124">  // When 'keymodel' contains &quot;startsel&quot; some keys start Select/Visual</a>
<a name="ln1125">  // mode.</a>
<a name="ln1126">  if (!VIsual_active &amp;&amp; km_startsel) {</a>
<a name="ln1127">    if (nv_cmds[s-&gt;idx].cmd_flags &amp; NV_SS) {</a>
<a name="ln1128">      start_selection();</a>
<a name="ln1129">      unshift_special(&amp;s-&gt;ca);</a>
<a name="ln1130">      s-&gt;idx = find_command(s-&gt;ca.cmdchar);</a>
<a name="ln1131">      assert(s-&gt;idx &gt;= 0);</a>
<a name="ln1132">    } else if ((nv_cmds[s-&gt;idx].cmd_flags &amp; NV_SSS)</a>
<a name="ln1133">               &amp;&amp; (mod_mask &amp; MOD_MASK_SHIFT)) {</a>
<a name="ln1134">      start_selection();</a>
<a name="ln1135">      mod_mask &amp;= ~MOD_MASK_SHIFT;</a>
<a name="ln1136">    }</a>
<a name="ln1137">  }</a>
<a name="ln1138"> </a>
<a name="ln1139">  // Execute the command!</a>
<a name="ln1140">  // Call the command function found in the commands table.</a>
<a name="ln1141">  s-&gt;ca.arg = nv_cmds[s-&gt;idx].cmd_arg;</a>
<a name="ln1142">  (nv_cmds[s-&gt;idx].cmd_func)(&amp;s-&gt;ca);</a>
<a name="ln1143"> </a>
<a name="ln1144">finish:</a>
<a name="ln1145">  normal_finish_command(s);</a>
<a name="ln1146">  return 1;</a>
<a name="ln1147">}</a>
<a name="ln1148"> </a>
<a name="ln1149">static void normal_check_stuff_buffer(NormalState *s)</a>
<a name="ln1150">{</a>
<a name="ln1151">  if (stuff_empty()) {</a>
<a name="ln1152">    did_check_timestamps = false;</a>
<a name="ln1153"> </a>
<a name="ln1154">    if (need_check_timestamps) {</a>
<a name="ln1155">      check_timestamps(false);</a>
<a name="ln1156">    }</a>
<a name="ln1157"> </a>
<a name="ln1158">    if (need_wait_return) {</a>
<a name="ln1159">      // if wait_return still needed call it now</a>
<a name="ln1160">      wait_return(false);</a>
<a name="ln1161">    }</a>
<a name="ln1162"> </a>
<a name="ln1163">    if (need_start_insertmode &amp;&amp; goto_im() &amp;&amp; !VIsual_active) {</a>
<a name="ln1164">      need_start_insertmode = false;</a>
<a name="ln1165">      stuffReadbuff(&quot;i&quot;);  // start insert mode next</a>
<a name="ln1166">      // skip the fileinfo message now, because it would be shown</a>
<a name="ln1167">      // after insert mode finishes!</a>
<a name="ln1168">      need_fileinfo = false;</a>
<a name="ln1169">    }</a>
<a name="ln1170">  }</a>
<a name="ln1171">}</a>
<a name="ln1172"> </a>
<a name="ln1173">static void normal_check_interrupt(NormalState *s)</a>
<a name="ln1174">{</a>
<a name="ln1175">  // Reset &quot;got_int&quot; now that we got back to the main loop.  Except when</a>
<a name="ln1176">  // inside a &quot;:g/pat/cmd&quot; command, then the &quot;got_int&quot; needs to abort</a>
<a name="ln1177">  // the &quot;:g&quot; command.</a>
<a name="ln1178">  // For &quot;:g/pat/vi&quot; we reset &quot;got_int&quot; when used once.  When used</a>
<a name="ln1179">  // a second time we go back to Ex mode and abort the &quot;:g&quot; command.</a>
<a name="ln1180">  if (got_int) {</a>
<a name="ln1181">    if (s-&gt;noexmode &amp;&amp; global_busy &amp;&amp; !exmode_active</a>
<a name="ln1182">        &amp;&amp; s-&gt;previous_got_int) {</a>
<a name="ln1183">      // Typed two CTRL-C in a row: go back to ex mode as if &quot;Q&quot; was</a>
<a name="ln1184">      // used and keep &quot;got_int&quot; set, so that it aborts &quot;:g&quot;.</a>
<a name="ln1185">      exmode_active = EXMODE_NORMAL;</a>
<a name="ln1186">      State = NORMAL;</a>
<a name="ln1187">    } else if (!global_busy || !exmode_active) {</a>
<a name="ln1188">      if (!quit_more) {</a>
<a name="ln1189">        // flush all buffers</a>
<a name="ln1190">        (void)vgetc();</a>
<a name="ln1191">      }</a>
<a name="ln1192">      got_int = false;</a>
<a name="ln1193">    }</a>
<a name="ln1194">    s-&gt;previous_got_int = true;</a>
<a name="ln1195">  } else {</a>
<a name="ln1196">    s-&gt;previous_got_int = false;</a>
<a name="ln1197">  }</a>
<a name="ln1198">}</a>
<a name="ln1199"> </a>
<a name="ln1200">static void normal_check_window_scrolled(NormalState *s)</a>
<a name="ln1201">{</a>
<a name="ln1202">  // Trigger Scroll if the viewport changed.</a>
<a name="ln1203">  if (!finish_op &amp;&amp; has_event(EVENT_WINSCROLLED)</a>
<a name="ln1204">      &amp;&amp; win_did_scroll(curwin)) {</a>
<a name="ln1205">    do_autocmd_winscrolled(curwin);</a>
<a name="ln1206">  }</a>
<a name="ln1207">}</a>
<a name="ln1208"> </a>
<a name="ln1209">static void normal_check_cursor_moved(NormalState *s)</a>
<a name="ln1210">{</a>
<a name="ln1211">  // Trigger CursorMoved if the cursor moved.</a>
<a name="ln1212">  if (!finish_op &amp;&amp; (has_event(EVENT_CURSORMOVED) || curwin-&gt;w_p_cole &gt; 0)</a>
<a name="ln1213">      &amp;&amp; !equalpos(curwin-&gt;w_last_cursormoved, curwin-&gt;w_cursor)) {</a>
<a name="ln1214">    if (has_event(EVENT_CURSORMOVED)) {</a>
<a name="ln1215">      apply_autocmds(EVENT_CURSORMOVED, NULL, NULL, false, curbuf);</a>
<a name="ln1216">    }</a>
<a name="ln1217"> </a>
<a name="ln1218">    curwin-&gt;w_last_cursormoved = curwin-&gt;w_cursor;</a>
<a name="ln1219">  }</a>
<a name="ln1220">}</a>
<a name="ln1221"> </a>
<a name="ln1222">static void normal_check_text_changed(NormalState *s)</a>
<a name="ln1223">{</a>
<a name="ln1224">  // Trigger TextChanged if changedtick differs.</a>
<a name="ln1225">  if (!finish_op &amp;&amp; has_event(EVENT_TEXTCHANGED)</a>
<a name="ln1226">      &amp;&amp; curbuf-&gt;b_last_changedtick != buf_get_changedtick(curbuf)) {</a>
<a name="ln1227">    apply_autocmds(EVENT_TEXTCHANGED, NULL, NULL, false, curbuf);</a>
<a name="ln1228">    curbuf-&gt;b_last_changedtick = buf_get_changedtick(curbuf);</a>
<a name="ln1229">  }</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232">static void normal_check_buffer_modified(NormalState *s)</a>
<a name="ln1233">{</a>
<a name="ln1234">  // Trigger BufModified if b_modified changed</a>
<a name="ln1235">  if (!finish_op &amp;&amp; has_event(EVENT_BUFMODIFIEDSET)</a>
<a name="ln1236">      &amp;&amp; curbuf-&gt;b_changed_invalid == true) {</a>
<a name="ln1237">    apply_autocmds(EVENT_BUFMODIFIEDSET, NULL, NULL, false, curbuf);</a>
<a name="ln1238">    curbuf-&gt;b_changed_invalid = false;</a>
<a name="ln1239">  }</a>
<a name="ln1240">}</a>
<a name="ln1241"> </a>
<a name="ln1242">static void normal_check_folds(NormalState *s)</a>
<a name="ln1243">{</a>
<a name="ln1244">  // Include a closed fold completely in the Visual area.</a>
<a name="ln1245">  foldAdjustVisual();</a>
<a name="ln1246"> </a>
<a name="ln1247">  // When 'foldclose' is set, apply 'foldlevel' to folds that don't</a>
<a name="ln1248">  // contain the cursor.</a>
<a name="ln1249">  // When 'foldopen' is &quot;all&quot;, open the fold(s) under the cursor.</a>
<a name="ln1250">  // This may mark the window for redrawing.</a>
<a name="ln1251">  if (hasAnyFolding(curwin) &amp;&amp; !char_avail()) {</a>
<a name="ln1252">    foldCheckClose();</a>
<a name="ln1253"> </a>
<a name="ln1254">    if (fdo_flags &amp; FDO_ALL) {</a>
<a name="ln1255">      foldOpenCursor();</a>
<a name="ln1256">    }</a>
<a name="ln1257">  }</a>
<a name="ln1258">}</a>
<a name="ln1259"> </a>
<a name="ln1260">static void normal_redraw(NormalState *s)</a>
<a name="ln1261">{</a>
<a name="ln1262">  // Before redrawing, make sure w_topline is correct, and w_leftcol</a>
<a name="ln1263">  // if lines don't wrap, and w_skipcol if lines wrap.</a>
<a name="ln1264">  update_topline(curwin);</a>
<a name="ln1265">  validate_cursor();</a>
<a name="ln1266"> </a>
<a name="ln1267">  // If the cursor moves horizontally when 'concealcursor' is active, then the</a>
<a name="ln1268">  // current line needs to be redrawn in order to calculate the correct</a>
<a name="ln1269">  // cursor position.</a>
<a name="ln1270">  if (curwin-&gt;w_p_cole &gt; 0 &amp;&amp; conceal_cursor_line(curwin)) {</a>
<a name="ln1271">    redrawWinline(curwin, curwin-&gt;w_cursor.lnum);</a>
<a name="ln1272">  }</a>
<a name="ln1273"> </a>
<a name="ln1274">  if (VIsual_active) {</a>
<a name="ln1275">    update_curbuf(INVERTED);  // update inverted part</a>
<a name="ln1276">  } else if (must_redraw) {</a>
<a name="ln1277">    update_screen(0);</a>
<a name="ln1278">  } else if (redraw_cmdline || clear_cmdline) {</a>
<a name="ln1279">    showmode();</a>
<a name="ln1280">  }</a>
<a name="ln1281"> </a>
<a name="ln1282">  redraw_statuslines();</a>
<a name="ln1283"> </a>
<a name="ln1284">  if (need_maketitle) {</a>
<a name="ln1285">    maketitle();</a>
<a name="ln1286">  }</a>
<a name="ln1287"> </a>
<a name="ln1288">  curbuf-&gt;b_last_used = time(NULL);</a>
<a name="ln1289"> </a>
<a name="ln1290">  // Display message after redraw. If an external message is still visible,</a>
<a name="ln1291">  // it contains the kept message already.</a>
<a name="ln1292">  if (keep_msg != NULL &amp;&amp; !msg_ext_is_visible()) {</a>
<a name="ln1293">    char_u *const p = vim_strsave(keep_msg);</a>
<a name="ln1294"> </a>
<a name="ln1295">    // msg_start() will set keep_msg to NULL, make a copy</a>
<a name="ln1296">    // first.  Don't reset keep_msg, msg_attr_keep() uses it to</a>
<a name="ln1297">    // check for duplicates.  Never put this message in</a>
<a name="ln1298">    // history.</a>
<a name="ln1299">    msg_hist_off = true;</a>
<a name="ln1300">    msg_attr((const char *)p, keep_msg_attr);</a>
<a name="ln1301">    msg_hist_off = false;</a>
<a name="ln1302">    xfree(p);</a>
<a name="ln1303">  }</a>
<a name="ln1304"> </a>
<a name="ln1305">  // show fileinfo after redraw</a>
<a name="ln1306">  if (need_fileinfo &amp;&amp; !shortmess(SHM_FILEINFO)) {</a>
<a name="ln1307">    fileinfo(false, true, false);</a>
<a name="ln1308">    need_fileinfo = false;</a>
<a name="ln1309">  }</a>
<a name="ln1310"> </a>
<a name="ln1311">  emsg_on_display = false;  // can delete error message now</a>
<a name="ln1312">  did_emsg = false;</a>
<a name="ln1313">  msg_didany = false;  // reset lines_left in msg_start()</a>
<a name="ln1314">  may_clear_sb_text();  // clear scroll-back text on next msg</a>
<a name="ln1315">  showruler(false);</a>
<a name="ln1316"> </a>
<a name="ln1317">  setcursor();</a>
<a name="ln1318">}</a>
<a name="ln1319"> </a>
<a name="ln1320">// Function executed before each iteration of normal mode.</a>
<a name="ln1321">// Return:</a>
<a name="ln1322">//   1 if the iteration should continue normally</a>
<a name="ln1323">//   -1 if the iteration should be skipped</a>
<a name="ln1324">//   0 if the main loop must exit</a>
<a name="ln1325">static int normal_check(VimState *state)</a>
<a name="ln1326">{</a>
<a name="ln1327">  NormalState *s = (NormalState *)state;</a>
<a name="ln1328">  normal_check_stuff_buffer(s);</a>
<a name="ln1329">  normal_check_interrupt(s);</a>
<a name="ln1330"> </a>
<a name="ln1331">  if (!exmode_active) {</a>
<a name="ln1332">    msg_scroll = false;</a>
<a name="ln1333">  }</a>
<a name="ln1334">  quit_more = false;</a>
<a name="ln1335"> </a>
<a name="ln1336">  // If skip redraw is set (for &quot;:&quot; in wait_return()), don't redraw now.</a>
<a name="ln1337">  // If there is nothing in the stuff_buffer or do_redraw is TRUE,</a>
<a name="ln1338">  // update cursor and redraw.</a>
<a name="ln1339">  if (skip_redraw || exmode_active) {</a>
<a name="ln1340">    skip_redraw = false;</a>
<a name="ln1341">  } else if (do_redraw || stuff_empty()) {</a>
<a name="ln1342">    // Need to make sure w_topline and w_leftcol are correct before</a>
<a name="ln1343">    // normal_check_window_scrolled() is called.</a>
<a name="ln1344">    update_topline(curwin);</a>
<a name="ln1345"> </a>
<a name="ln1346">    normal_check_cursor_moved(s);</a>
<a name="ln1347">    normal_check_text_changed(s);</a>
<a name="ln1348">    normal_check_window_scrolled(s);</a>
<a name="ln1349">    normal_check_buffer_modified(s);</a>
<a name="ln1350"> </a>
<a name="ln1351">    // Updating diffs from changed() does not always work properly,</a>
<a name="ln1352">    // esp. updating folds.  Do an update just before redrawing if</a>
<a name="ln1353">    // needed.</a>
<a name="ln1354">    if (curtab-&gt;tp_diff_update || curtab-&gt;tp_diff_invalid) {</a>
<a name="ln1355">      ex_diffupdate(NULL);</a>
<a name="ln1356">      curtab-&gt;tp_diff_update = false;</a>
<a name="ln1357">    }</a>
<a name="ln1358"> </a>
<a name="ln1359">    // Scroll-binding for diff mode may have been postponed until</a>
<a name="ln1360">    // here.  Avoids doing it for every change.</a>
<a name="ln1361">    if (diff_need_scrollbind) {</a>
<a name="ln1362">      check_scrollbind((linenr_T)0, 0L);</a>
<a name="ln1363">      diff_need_scrollbind = false;</a>
<a name="ln1364">    }</a>
<a name="ln1365"> </a>
<a name="ln1366">    normal_check_folds(s);</a>
<a name="ln1367">    normal_redraw(s);</a>
<a name="ln1368">    do_redraw = false;</a>
<a name="ln1369"> </a>
<a name="ln1370">    // Now that we have drawn the first screen all the startup stuff</a>
<a name="ln1371">    // has been done, close any file for startup messages.</a>
<a name="ln1372">    if (time_fd != NULL) {</a>
<a name="ln1373">      TIME_MSG(&quot;first screen update&quot;);</a>
<a name="ln1374">      TIME_MSG(&quot;--- NVIM STARTED ---&quot;);</a>
<a name="ln1375">      fclose(time_fd);</a>
<a name="ln1376">      time_fd = NULL;</a>
<a name="ln1377">    }</a>
<a name="ln1378">  }</a>
<a name="ln1379"> </a>
<a name="ln1380">  // May perform garbage collection when waiting for a character, but</a>
<a name="ln1381">  // only at the very toplevel.  Otherwise we may be using a List or</a>
<a name="ln1382">  // Dict internally somewhere.</a>
<a name="ln1383">  // &quot;may_garbage_collect&quot; is reset in vgetc() which is invoked through</a>
<a name="ln1384">  // do_exmode() and normal_cmd().</a>
<a name="ln1385">  may_garbage_collect = !s-&gt;cmdwin &amp;&amp; !s-&gt;noexmode;</a>
<a name="ln1386"> </a>
<a name="ln1387">  // Update w_curswant if w_set_curswant has been set.</a>
<a name="ln1388">  // Postponed until here to avoid computing w_virtcol too often.</a>
<a name="ln1389">  update_curswant();</a>
<a name="ln1390"> </a>
<a name="ln1391">  if (exmode_active) {</a>
<a name="ln1392">    if (s-&gt;noexmode) {</a>
<a name="ln1393">      return 0;</a>
<a name="ln1394">    }</a>
<a name="ln1395">    do_exmode(exmode_active == EXMODE_VIM);</a>
<a name="ln1396">    return -1;</a>
<a name="ln1397">  }</a>
<a name="ln1398"> </a>
<a name="ln1399">  if (s-&gt;cmdwin &amp;&amp; cmdwin_result != 0) {</a>
<a name="ln1400">    // command-line window and cmdwin_result is set</a>
<a name="ln1401">    return 0;</a>
<a name="ln1402">  }</a>
<a name="ln1403"> </a>
<a name="ln1404">  normal_prepare(s);</a>
<a name="ln1405">  return 1;</a>
<a name="ln1406">}</a>
<a name="ln1407"> </a>
<a name="ln1408">/*</a>
<a name="ln1409"> * Set v:count and v:count1 according to &quot;cap&quot;.</a>
<a name="ln1410"> * Set v:prevcount only when &quot;set_prevcount&quot; is true.</a>
<a name="ln1411"> */</a>
<a name="ln1412">static void set_vcount_ca(cmdarg_T *cap, bool *set_prevcount)</a>
<a name="ln1413">{</a>
<a name="ln1414">  long count = cap-&gt;count0;</a>
<a name="ln1415"> </a>
<a name="ln1416">  /* multiply with cap-&gt;opcount the same way as above */</a>
<a name="ln1417">  if (cap-&gt;opcount != 0)</a>
<a name="ln1418">    count = cap-&gt;opcount * (count == 0 ? 1 : count);</a>
<a name="ln1419">  set_vcount(count, count == 0 ? 1 : count, *set_prevcount);</a>
<a name="ln1420">  *set_prevcount = false;    /* only set v:prevcount once */</a>
<a name="ln1421">}</a>
<a name="ln1422"> </a>
<a name="ln1423">// Handle an operator after Visual mode or when the movement is finished.</a>
<a name="ln1424">// &quot;gui_yank&quot; is true when yanking text for the clipboard.</a>
<a name="ln1425">void do_pending_operator(cmdarg_T *cap, int old_col, bool gui_yank)</a>
<a name="ln1426">{</a>
<a name="ln1427">  oparg_T     *oap = cap-&gt;oap;</a>
<a name="ln1428">  pos_T old_cursor;</a>
<a name="ln1429">  bool empty_region_error;</a>
<a name="ln1430">  int restart_edit_save;</a>
<a name="ln1431">  int lbr_saved = curwin-&gt;w_p_lbr;</a>
<a name="ln1432"> </a>
<a name="ln1433"> </a>
<a name="ln1434">  // The visual area is remembered for redo</a>
<a name="ln1435">  static int redo_VIsual_mode = NUL;        // 'v', 'V', or Ctrl-V</a>
<a name="ln1436">  static linenr_T redo_VIsual_line_count;   // number of lines</a>
<a name="ln1437">  static colnr_T redo_VIsual_vcol;          // number of cols or end column</a>
<a name="ln1438">  static long redo_VIsual_count;            // count for Visual operator</a>
<a name="ln1439">  static int redo_VIsual_arg;               // extra argument</a>
<a name="ln1440">  bool include_line_break = false;</a>
<a name="ln1441"> </a>
<a name="ln1442">  old_cursor = curwin-&gt;w_cursor;</a>
<a name="ln1443"> </a>
<a name="ln1444">  /*</a>
<a name="ln1445">   * If an operation is pending, handle it...</a>
<a name="ln1446">   */</a>
<a name="ln1447">  if ((finish_op</a>
<a name="ln1448">       || VIsual_active)</a>
<a name="ln1449">      &amp;&amp; oap-&gt;op_type != OP_NOP) {</a>
<a name="ln1450">    // Yank can be redone when 'y' is in 'cpoptions', but not when yanking</a>
<a name="ln1451">    // for the clipboard.</a>
<a name="ln1452">    const bool redo_yank = vim_strchr(p_cpo, CPO_YANK) != NULL &amp;&amp; !gui_yank;</a>
<a name="ln1453"> </a>
<a name="ln1454">    // Avoid a problem with unwanted linebreaks in block mode</a>
<a name="ln1455">    if (curwin-&gt;w_p_lbr) {</a>
<a name="ln1456">      curwin-&gt;w_valid &amp;= ~VALID_VIRTCOL;</a>
<a name="ln1457">    }</a>
<a name="ln1458">    curwin-&gt;w_p_lbr = false;</a>
<a name="ln1459">    oap-&gt;is_VIsual = VIsual_active;</a>
<a name="ln1460">    if (oap-&gt;motion_force == 'V') {</a>
<a name="ln1461">      oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln1462">    } else if (oap-&gt;motion_force == 'v') {</a>
<a name="ln1463">      // If the motion was linewise, &quot;inclusive&quot; will not have been set.</a>
<a name="ln1464">      // Use &quot;exclusive&quot; to be consistent.  Makes &quot;dvj&quot; work nice.</a>
<a name="ln1465">      if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln1466">        oap-&gt;inclusive = false;</a>
<a name="ln1467">      } else if (oap-&gt;motion_type == kMTCharWise) {</a>
<a name="ln1468">        // If the motion already was charwise, toggle &quot;inclusive&quot;</a>
<a name="ln1469">        oap-&gt;inclusive = !oap-&gt;inclusive;</a>
<a name="ln1470">      }</a>
<a name="ln1471">      oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln1472">    } else if (oap-&gt;motion_force == Ctrl_V) {</a>
<a name="ln1473">      // Change line- or charwise motion into Visual block mode.</a>
<a name="ln1474">      if (!VIsual_active) {</a>
<a name="ln1475">        VIsual_active = true;</a>
<a name="ln1476">        VIsual = oap-&gt;start;</a>
<a name="ln1477">      }</a>
<a name="ln1478">      VIsual_mode = Ctrl_V;</a>
<a name="ln1479">      VIsual_select = false;</a>
<a name="ln1480">      VIsual_reselect = false;</a>
<a name="ln1481">    }</a>
<a name="ln1482"> </a>
<a name="ln1483">    // Only redo yank when 'y' flag is in 'cpoptions'.</a>
<a name="ln1484">    // Never redo &quot;zf&quot; (define fold).</a>
<a name="ln1485">    if ((redo_yank || oap-&gt;op_type != OP_YANK)</a>
<a name="ln1486">        &amp;&amp; ((!VIsual_active || oap-&gt;motion_force)</a>
<a name="ln1487">            // Also redo Operator-pending Visual mode mappings.</a>
<a name="ln1488">            || ((cap-&gt;cmdchar == ':' || cap-&gt;cmdchar == K_COMMAND)</a>
<a name="ln1489">                &amp;&amp; oap-&gt;op_type != OP_COLON))</a>
<a name="ln1490">        &amp;&amp; cap-&gt;cmdchar != 'D'</a>
<a name="ln1491">        &amp;&amp; oap-&gt;op_type != OP_FOLD</a>
<a name="ln1492">        &amp;&amp; oap-&gt;op_type != OP_FOLDOPEN</a>
<a name="ln1493">        &amp;&amp; oap-&gt;op_type != OP_FOLDOPENREC</a>
<a name="ln1494">        &amp;&amp; oap-&gt;op_type != OP_FOLDCLOSE</a>
<a name="ln1495">        &amp;&amp; oap-&gt;op_type != OP_FOLDCLOSEREC</a>
<a name="ln1496">        &amp;&amp; oap-&gt;op_type != OP_FOLDDEL</a>
<a name="ln1497">        &amp;&amp; oap-&gt;op_type != OP_FOLDDELREC</a>
<a name="ln1498">        ) {</a>
<a name="ln1499">      prep_redo(oap-&gt;regname, cap-&gt;count0,</a>
<a name="ln1500">          get_op_char(oap-&gt;op_type), get_extra_op_char(oap-&gt;op_type),</a>
<a name="ln1501">          oap-&gt;motion_force, cap-&gt;cmdchar, cap-&gt;nchar);</a>
<a name="ln1502">      if (cap-&gt;cmdchar == '/' || cap-&gt;cmdchar == '?') {     /* was a search */</a>
<a name="ln1503">        /*</a>
<a name="ln1504">         * If 'cpoptions' does not contain 'r', insert the search</a>
<a name="ln1505">         * pattern to really repeat the same command.</a>
<a name="ln1506">         */</a>
<a name="ln1507">        if (vim_strchr(p_cpo, CPO_REDO) == NULL) {</a>
<a name="ln1508">          AppendToRedobuffLit(cap-&gt;searchbuf, -1);</a>
<a name="ln1509">        }</a>
<a name="ln1510">        AppendToRedobuff(NL_STR);</a>
<a name="ln1511">      } else if (cap-&gt;cmdchar == ':' || cap-&gt;cmdchar == K_COMMAND) {</a>
<a name="ln1512">        // do_cmdline() has stored the first typed line in</a>
<a name="ln1513">        // &quot;repeat_cmdline&quot;.  When several lines are typed repeating</a>
<a name="ln1514">        // won't be possible.</a>
<a name="ln1515">        if (repeat_cmdline == NULL) {</a>
<a name="ln1516">          ResetRedobuff();</a>
<a name="ln1517">        } else {</a>
<a name="ln1518">          AppendToRedobuffLit(repeat_cmdline, -1);</a>
<a name="ln1519">          AppendToRedobuff(NL_STR);</a>
<a name="ln1520">          XFREE_CLEAR(repeat_cmdline);</a>
<a name="ln1521">        }</a>
<a name="ln1522">      }</a>
<a name="ln1523">    }</a>
<a name="ln1524"> </a>
<a name="ln1525">    if (redo_VIsual_busy) {</a>
<a name="ln1526">      /* Redo of an operation on a Visual area. Use the same size from</a>
<a name="ln1527">       * redo_VIsual_line_count and redo_VIsual_vcol. */</a>
<a name="ln1528">      oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln1529">      curwin-&gt;w_cursor.lnum += redo_VIsual_line_count - 1;</a>
<a name="ln1530">      if (curwin-&gt;w_cursor.lnum &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln1531">        curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1532">      VIsual_mode = redo_VIsual_mode;</a>
<a name="ln1533">      if (redo_VIsual_vcol == MAXCOL || VIsual_mode == 'v') {</a>
<a name="ln1534">        if (VIsual_mode == 'v') {</a>
<a name="ln1535">          if (redo_VIsual_line_count &lt;= 1) {</a>
<a name="ln1536">            validate_virtcol();</a>
<a name="ln1537">            curwin-&gt;w_curswant =</a>
<a name="ln1538">              curwin-&gt;w_virtcol + redo_VIsual_vcol - 1;</a>
<a name="ln1539">          } else</a>
<a name="ln1540">            curwin-&gt;w_curswant = redo_VIsual_vcol;</a>
<a name="ln1541">        } else {</a>
<a name="ln1542">          curwin-&gt;w_curswant = MAXCOL;</a>
<a name="ln1543">        }</a>
<a name="ln1544">        coladvance(curwin-&gt;w_curswant);</a>
<a name="ln1545">      }</a>
<a name="ln1546">      cap-&gt;count0 = redo_VIsual_count;</a>
<a name="ln1547">      cap-&gt;count1 = (cap-&gt;count0 == 0 ? 1 : cap-&gt;count0);</a>
<a name="ln1548">    } else if (VIsual_active) {</a>
<a name="ln1549">      if (!gui_yank) {</a>
<a name="ln1550">        /* Save the current VIsual area for '&lt; and '&gt; marks, and &quot;gv&quot; */</a>
<a name="ln1551">        curbuf-&gt;b_visual.vi_start = VIsual;</a>
<a name="ln1552">        curbuf-&gt;b_visual.vi_end = curwin-&gt;w_cursor;</a>
<a name="ln1553">        curbuf-&gt;b_visual.vi_mode = VIsual_mode;</a>
<a name="ln1554">        if (VIsual_mode_orig != NUL) {</a>
<a name="ln1555">          curbuf-&gt;b_visual.vi_mode = VIsual_mode_orig;</a>
<a name="ln1556">          VIsual_mode_orig = NUL;</a>
<a name="ln1557">        }</a>
<a name="ln1558">        curbuf-&gt;b_visual.vi_curswant = curwin-&gt;w_curswant;</a>
<a name="ln1559">        curbuf-&gt;b_visual_mode_eval = VIsual_mode;</a>
<a name="ln1560">      }</a>
<a name="ln1561"> </a>
<a name="ln1562">      // In Select mode, a linewise selection is operated upon like a</a>
<a name="ln1563">      // charwise selection.</a>
<a name="ln1564">      // Special case: gH&lt;Del&gt; deletes the last line.</a>
<a name="ln1565">      if (VIsual_select &amp;&amp; VIsual_mode == 'V'</a>
<a name="ln1566">          &amp;&amp; cap-&gt;oap-&gt;op_type != OP_DELETE) {</a>
<a name="ln1567">        if (lt(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln1568">          VIsual.col = 0;</a>
<a name="ln1569">          curwin-&gt;w_cursor.col =</a>
<a name="ln1570">            (colnr_T)STRLEN(ml_get(curwin-&gt;w_cursor.lnum));</a>
<a name="ln1571">        } else {</a>
<a name="ln1572">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln1573">          VIsual.col = (colnr_T)STRLEN(ml_get(VIsual.lnum));</a>
<a name="ln1574">        }</a>
<a name="ln1575">        VIsual_mode = 'v';</a>
<a name="ln1576">      }</a>
<a name="ln1577">      /* If 'selection' is &quot;exclusive&quot;, backup one character for</a>
<a name="ln1578">       * charwise selections. */</a>
<a name="ln1579">      else if (VIsual_mode == 'v') {</a>
<a name="ln1580">        include_line_break =</a>
<a name="ln1581">          unadjust_for_sel();</a>
<a name="ln1582">      }</a>
<a name="ln1583"> </a>
<a name="ln1584">      oap-&gt;start = VIsual;</a>
<a name="ln1585">      if (VIsual_mode == 'V') {</a>
<a name="ln1586">        oap-&gt;start.col = 0;</a>
<a name="ln1587">        oap-&gt;start.coladd = 0;</a>
<a name="ln1588">      }</a>
<a name="ln1589">    }</a>
<a name="ln1590"> </a>
<a name="ln1591">    /*</a>
<a name="ln1592">     * Set oap-&gt;start to the first position of the operated text, oap-&gt;end</a>
<a name="ln1593">     * to the end of the operated text.  w_cursor is equal to oap-&gt;start.</a>
<a name="ln1594">     */</a>
<a name="ln1595">    if (lt(oap-&gt;start, curwin-&gt;w_cursor)) {</a>
<a name="ln1596">      /* Include folded lines completely. */</a>
<a name="ln1597">      if (!VIsual_active) {</a>
<a name="ln1598">        if (hasFolding(oap-&gt;start.lnum, &amp;oap-&gt;start.lnum, NULL))</a>
<a name="ln1599">          oap-&gt;start.col = 0;</a>
<a name="ln1600">        if ((curwin-&gt;w_cursor.col &gt; 0</a>
<a name="ln1601">             || oap-&gt;inclusive</a>
<a name="ln1602">             || oap-&gt;motion_type == kMTLineWise)</a>
<a name="ln1603">            &amp;&amp; hasFolding(curwin-&gt;w_cursor.lnum, NULL,</a>
<a name="ln1604">                          &amp;curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln1605">          curwin-&gt;w_cursor.col = (colnr_T)STRLEN(get_cursor_line_ptr());</a>
<a name="ln1606">        }</a>
<a name="ln1607">      }</a>
<a name="ln1608">      oap-&gt;end = curwin-&gt;w_cursor;</a>
<a name="ln1609">      curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln1610"> </a>
<a name="ln1611">      /* w_virtcol may have been updated; if the cursor goes back to its</a>
<a name="ln1612">       * previous position w_virtcol becomes invalid and isn't updated</a>
<a name="ln1613">       * automatically. */</a>
<a name="ln1614">      curwin-&gt;w_valid &amp;= ~VALID_VIRTCOL;</a>
<a name="ln1615">    } else {</a>
<a name="ln1616">      // Include folded lines completely.</a>
<a name="ln1617">      if (!VIsual_active &amp;&amp; oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln1618">        if (hasFolding(curwin-&gt;w_cursor.lnum, &amp;curwin-&gt;w_cursor.lnum,</a>
<a name="ln1619">                       NULL)) {</a>
<a name="ln1620">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln1621">        }</a>
<a name="ln1622">        if (hasFolding(oap-&gt;start.lnum, NULL, &amp;oap-&gt;start.lnum)) {</a>
<a name="ln1623">          oap-&gt;start.col = (colnr_T)STRLEN(ml_get(oap-&gt;start.lnum));</a>
<a name="ln1624">        }</a>
<a name="ln1625">      }</a>
<a name="ln1626">      oap-&gt;end = oap-&gt;start;</a>
<a name="ln1627">      oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln1628">    }</a>
<a name="ln1629"> </a>
<a name="ln1630">    // Just in case lines were deleted that make the position invalid.</a>
<a name="ln1631">    check_pos(curwin-&gt;w_buffer, &amp;oap-&gt;end);</a>
<a name="ln1632">    oap-&gt;line_count = oap-&gt;end.lnum - oap-&gt;start.lnum + 1;</a>
<a name="ln1633"> </a>
<a name="ln1634">    /* Set &quot;virtual_op&quot; before resetting VIsual_active. */</a>
<a name="ln1635">    virtual_op = virtual_active();</a>
<a name="ln1636"> </a>
<a name="ln1637">    if (VIsual_active || redo_VIsual_busy) {</a>
<a name="ln1638">      get_op_vcol(oap, redo_VIsual_vcol, true);</a>
<a name="ln1639"> </a>
<a name="ln1640">      if (!redo_VIsual_busy &amp;&amp; !gui_yank) {</a>
<a name="ln1641">        /*</a>
<a name="ln1642">         * Prepare to reselect and redo Visual: this is based on the</a>
<a name="ln1643">         * size of the Visual text</a>
<a name="ln1644">         */</a>
<a name="ln1645">        resel_VIsual_mode = VIsual_mode;</a>
<a name="ln1646">        if (curwin-&gt;w_curswant == MAXCOL)</a>
<a name="ln1647">          resel_VIsual_vcol = MAXCOL;</a>
<a name="ln1648">        else {</a>
<a name="ln1649">          if (VIsual_mode != Ctrl_V)</a>
<a name="ln1650">            getvvcol(curwin, &amp;(oap-&gt;end),</a>
<a name="ln1651">                NULL, NULL, &amp;oap-&gt;end_vcol);</a>
<a name="ln1652">          if (VIsual_mode == Ctrl_V || oap-&gt;line_count &lt;= 1) {</a>
<a name="ln1653">            if (VIsual_mode != Ctrl_V)</a>
<a name="ln1654">              getvvcol(curwin, &amp;(oap-&gt;start),</a>
<a name="ln1655">                  &amp;oap-&gt;start_vcol, NULL, NULL);</a>
<a name="ln1656">            resel_VIsual_vcol = oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln1657">          } else</a>
<a name="ln1658">            resel_VIsual_vcol = oap-&gt;end_vcol;</a>
<a name="ln1659">        }</a>
<a name="ln1660">        resel_VIsual_line_count = oap-&gt;line_count;</a>
<a name="ln1661">      }</a>
<a name="ln1662"> </a>
<a name="ln1663">      // can't redo yank (unless 'y' is in 'cpoptions') and &quot;:&quot;</a>
<a name="ln1664">      if ((redo_yank || oap-&gt;op_type != OP_YANK)</a>
<a name="ln1665">          &amp;&amp; oap-&gt;op_type != OP_COLON</a>
<a name="ln1666">          &amp;&amp; oap-&gt;op_type != OP_FOLD</a>
<a name="ln1667">          &amp;&amp; oap-&gt;op_type != OP_FOLDOPEN</a>
<a name="ln1668">          &amp;&amp; oap-&gt;op_type != OP_FOLDOPENREC</a>
<a name="ln1669">          &amp;&amp; oap-&gt;op_type != OP_FOLDCLOSE</a>
<a name="ln1670">          &amp;&amp; oap-&gt;op_type != OP_FOLDCLOSEREC</a>
<a name="ln1671">          &amp;&amp; oap-&gt;op_type != OP_FOLDDEL</a>
<a name="ln1672">          &amp;&amp; oap-&gt;op_type != OP_FOLDDELREC</a>
<a name="ln1673">          &amp;&amp; oap-&gt;motion_force == NUL</a>
<a name="ln1674">          ) {</a>
<a name="ln1675">        /* Prepare for redoing.  Only use the nchar field for &quot;r&quot;,</a>
<a name="ln1676">         * otherwise it might be the second char of the operator. */</a>
<a name="ln1677">        if (cap-&gt;cmdchar == 'g' &amp;&amp; (cap-&gt;nchar == 'n'</a>
<a name="ln1678">                                    || cap-&gt;nchar == 'N')) {</a>
<a name="ln1679">          prep_redo(oap-&gt;regname, cap-&gt;count0,</a>
<a name="ln1680">                    get_op_char(oap-&gt;op_type), get_extra_op_char(oap-&gt;op_type),</a>
<a name="ln1681">                    oap-&gt;motion_force, cap-&gt;cmdchar, cap-&gt;nchar);</a>
<a name="ln1682">        } else if (cap-&gt;cmdchar != ':' &amp;&amp; cap-&gt;cmdchar != K_COMMAND) {</a>
<a name="ln1683">          int nchar = oap-&gt;op_type == OP_REPLACE ? cap-&gt;nchar : NUL;</a>
<a name="ln1684"> </a>
<a name="ln1685">          // reverse what nv_replace() did</a>
<a name="ln1686">          if (nchar == REPLACE_CR_NCHAR) {</a>
<a name="ln1687">            nchar = CAR;</a>
<a name="ln1688">          } else if (nchar == REPLACE_NL_NCHAR) {</a>
<a name="ln1689">            nchar = NL;</a>
<a name="ln1690">          }</a>
<a name="ln1691">          prep_redo(oap-&gt;regname, 0L, NUL, 'v', get_op_char(oap-&gt;op_type),</a>
<a name="ln1692">                    get_extra_op_char(oap-&gt;op_type), nchar);</a>
<a name="ln1693">        }</a>
<a name="ln1694">        if (!redo_VIsual_busy) {</a>
<a name="ln1695">          redo_VIsual_mode = resel_VIsual_mode;</a>
<a name="ln1696">          redo_VIsual_vcol = resel_VIsual_vcol;</a>
<a name="ln1697">          redo_VIsual_line_count = resel_VIsual_line_count;</a>
<a name="ln1698">          redo_VIsual_count = cap-&gt;count0;</a>
<a name="ln1699">          redo_VIsual_arg = cap-&gt;arg;</a>
<a name="ln1700">        }</a>
<a name="ln1701">      }</a>
<a name="ln1702"> </a>
<a name="ln1703">      // oap-&gt;inclusive defaults to true.</a>
<a name="ln1704">      // If oap-&gt;end is on a NUL (empty line) oap-&gt;inclusive becomes</a>
<a name="ln1705">      // false.  This makes &quot;d}P&quot; and &quot;v}dP&quot; work the same.</a>
<a name="ln1706">      if (oap-&gt;motion_force == NUL || oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln1707">        oap-&gt;inclusive = true;</a>
<a name="ln1708">      }</a>
<a name="ln1709">      if (VIsual_mode == 'V') {</a>
<a name="ln1710">        oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln1711">      } else if (VIsual_mode == 'v') {</a>
<a name="ln1712">        oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln1713">        if (*ml_get_pos(&amp;(oap-&gt;end)) == NUL</a>
<a name="ln1714">            &amp;&amp; (include_line_break || !virtual_op)</a>
<a name="ln1715">            ) {</a>
<a name="ln1716">          oap-&gt;inclusive = false;</a>
<a name="ln1717">          // Try to include the newline, unless it's an operator</a>
<a name="ln1718">          // that works on lines only.</a>
<a name="ln1719">          if (*p_sel != 'o'</a>
<a name="ln1720">              &amp;&amp; !op_on_lines(oap-&gt;op_type)</a>
<a name="ln1721">              &amp;&amp; oap-&gt;end.lnum &lt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1722">            oap-&gt;end.lnum++;</a>
<a name="ln1723">            oap-&gt;end.col = 0;</a>
<a name="ln1724">            oap-&gt;end.coladd = 0;</a>
<a name="ln1725">            oap-&gt;line_count++;</a>
<a name="ln1726">          }</a>
<a name="ln1727">        }</a>
<a name="ln1728">      }</a>
<a name="ln1729"> </a>
<a name="ln1730">      redo_VIsual_busy = false;</a>
<a name="ln1731"> </a>
<a name="ln1732">      /*</a>
<a name="ln1733">       * Switch Visual off now, so screen updating does</a>
<a name="ln1734">       * not show inverted text when the screen is redrawn.</a>
<a name="ln1735">       * With OP_YANK and sometimes with OP_COLON and OP_FILTER there is</a>
<a name="ln1736">       * no screen redraw, so it is done here to remove the inverted</a>
<a name="ln1737">       * part.</a>
<a name="ln1738">       */</a>
<a name="ln1739">      if (!gui_yank) {</a>
<a name="ln1740">        VIsual_active = false;</a>
<a name="ln1741">        setmouse();</a>
<a name="ln1742">        mouse_dragging = 0;</a>
<a name="ln1743">        may_clear_cmdline();</a>
<a name="ln1744">        if ((oap-&gt;op_type == OP_YANK</a>
<a name="ln1745">             || oap-&gt;op_type == OP_COLON</a>
<a name="ln1746">             || oap-&gt;op_type == OP_FUNCTION</a>
<a name="ln1747">             || oap-&gt;op_type == OP_FILTER)</a>
<a name="ln1748">            &amp;&amp; oap-&gt;motion_force == NUL) {</a>
<a name="ln1749">          // Make sure redrawing is correct.</a>
<a name="ln1750">          curwin-&gt;w_p_lbr = lbr_saved;</a>
<a name="ln1751">          redraw_curbuf_later(INVERTED);</a>
<a name="ln1752">        }</a>
<a name="ln1753">      }</a>
<a name="ln1754">    }</a>
<a name="ln1755"> </a>
<a name="ln1756">    // Include the trailing byte of a multi-byte char.</a>
<a name="ln1757">    if (oap-&gt;inclusive) {</a>
<a name="ln1758">      const int l = utfc_ptr2len(ml_get_pos(&amp;oap-&gt;end));</a>
<a name="ln1759">      if (l &gt; 1) {</a>
<a name="ln1760">        oap-&gt;end.col += l - 1;</a>
<a name="ln1761">      }</a>
<a name="ln1762">    }</a>
<a name="ln1763">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln1764"> </a>
<a name="ln1765">    /*</a>
<a name="ln1766">     * oap-&gt;empty is set when start and end are the same.  The inclusive</a>
<a name="ln1767">     * flag affects this too, unless yanking and the end is on a NUL.</a>
<a name="ln1768">     */</a>
<a name="ln1769">    oap-&gt;empty = (oap-&gt;motion_type != kMTLineWise</a>
<a name="ln1770">                  &amp;&amp; (!oap-&gt;inclusive</a>
<a name="ln1771">                      || (oap-&gt;op_type == OP_YANK</a>
<a name="ln1772">                          &amp;&amp; gchar_pos(&amp;oap-&gt;end) == NUL))</a>
<a name="ln1773">                  &amp;&amp; equalpos(oap-&gt;start, oap-&gt;end)</a>
<a name="ln1774">                  &amp;&amp; !(virtual_op &amp;&amp; oap-&gt;start.coladd != oap-&gt;end.coladd)</a>
<a name="ln1775">                  );</a>
<a name="ln1776">    /*</a>
<a name="ln1777">     * For delete, change and yank, it's an error to operate on an</a>
<a name="ln1778">     * empty region, when 'E' included in 'cpoptions' (Vi compatible).</a>
<a name="ln1779">     */</a>
<a name="ln1780">    empty_region_error = (oap-&gt;empty</a>
<a name="ln1781">                          &amp;&amp; vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL);</a>
<a name="ln1782"> </a>
<a name="ln1783">    /* Force a redraw when operating on an empty Visual region, when</a>
<a name="ln1784">     * 'modifiable is off or creating a fold. */</a>
<a name="ln1785">    if (oap-&gt;is_VIsual &amp;&amp; (oap-&gt;empty || !MODIFIABLE(curbuf)</a>
<a name="ln1786">                           || oap-&gt;op_type == OP_FOLD</a>
<a name="ln1787">                           )) {</a>
<a name="ln1788">      curwin-&gt;w_p_lbr = lbr_saved;</a>
<a name="ln1789">      redraw_curbuf_later(INVERTED);</a>
<a name="ln1790">    }</a>
<a name="ln1791"> </a>
<a name="ln1792">    /*</a>
<a name="ln1793">     * If the end of an operator is in column one while oap-&gt;motion_type</a>
<a name="ln1794">     * is kMTCharWise and oap-&gt;inclusive is false, we put op_end after the last</a>
<a name="ln1795">     * character in the previous line. If op_start is on or before the</a>
<a name="ln1796">     * first non-blank in the line, the operator becomes linewise</a>
<a name="ln1797">     * (strange, but that's the way vi does it).</a>
<a name="ln1798">     */</a>
<a name="ln1799">    if (oap-&gt;motion_type == kMTCharWise</a>
<a name="ln1800">        &amp;&amp; oap-&gt;inclusive == false</a>
<a name="ln1801">        &amp;&amp; !(cap-&gt;retval &amp; CA_NO_ADJ_OP_END)</a>
<a name="ln1802">        &amp;&amp; oap-&gt;end.col == 0</a>
<a name="ln1803">        &amp;&amp; (!oap-&gt;is_VIsual || *p_sel == 'o')</a>
<a name="ln1804">        &amp;&amp; oap-&gt;line_count &gt; 1) {</a>
<a name="ln1805">      oap-&gt;end_adjusted = true;  // remember that we did this</a>
<a name="ln1806">      oap-&gt;line_count--;</a>
<a name="ln1807">      oap-&gt;end.lnum--;</a>
<a name="ln1808">      if (inindent(0)) {</a>
<a name="ln1809">        oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln1810">      } else {</a>
<a name="ln1811">        oap-&gt;end.col = (colnr_T)STRLEN(ml_get(oap-&gt;end.lnum));</a>
<a name="ln1812">        if (oap-&gt;end.col) {</a>
<a name="ln1813">          --oap-&gt;end.col;</a>
<a name="ln1814">          oap-&gt;inclusive = true;</a>
<a name="ln1815">        }</a>
<a name="ln1816">      }</a>
<a name="ln1817">    } else</a>
<a name="ln1818">      oap-&gt;end_adjusted = false;</a>
<a name="ln1819"> </a>
<a name="ln1820">    switch (oap-&gt;op_type) {</a>
<a name="ln1821">    case OP_LSHIFT:</a>
<a name="ln1822">    case OP_RSHIFT:</a>
<a name="ln1823">      op_shift(oap, true,</a>
<a name="ln1824">          oap-&gt;is_VIsual ? (int)cap-&gt;count1 :</a>
<a name="ln1825">          1);</a>
<a name="ln1826">      auto_format(false, true);</a>
<a name="ln1827">      break;</a>
<a name="ln1828"> </a>
<a name="ln1829">    case OP_JOIN_NS:</a>
<a name="ln1830">    case OP_JOIN:</a>
<a name="ln1831">      if (oap-&gt;line_count &lt; 2)</a>
<a name="ln1832">        oap-&gt;line_count = 2;</a>
<a name="ln1833">      if (curwin-&gt;w_cursor.lnum + oap-&gt;line_count - 1 &gt;</a>
<a name="ln1834">          curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1835">        beep_flush();</a>
<a name="ln1836">      } else {</a>
<a name="ln1837">        do_join((size_t)oap-&gt;line_count, oap-&gt;op_type == OP_JOIN,</a>
<a name="ln1838">                true, true, true);</a>
<a name="ln1839">        auto_format(false, true);</a>
<a name="ln1840">      }</a>
<a name="ln1841">      break;</a>
<a name="ln1842"> </a>
<a name="ln1843">    case OP_DELETE:</a>
<a name="ln1844">      VIsual_reselect = false;              /* don't reselect now */</a>
<a name="ln1845">      if (empty_region_error) {</a>
<a name="ln1846">        vim_beep(BO_OPER);</a>
<a name="ln1847">        CancelRedo();</a>
<a name="ln1848">      } else {</a>
<a name="ln1849">        (void)op_delete(oap);</a>
<a name="ln1850">        // save cursor line for undo if it wasn't saved yet</a>
<a name="ln1851">        if (oap-&gt;motion_type == kMTLineWise</a>
<a name="ln1852">            &amp;&amp; has_format_option(FO_AUTO)</a>
<a name="ln1853">            &amp;&amp; u_save_cursor() == OK) {</a>
<a name="ln1854">          auto_format(false, true);</a>
<a name="ln1855">        }</a>
<a name="ln1856">      }</a>
<a name="ln1857">      break;</a>
<a name="ln1858"> </a>
<a name="ln1859">    case OP_YANK:</a>
<a name="ln1860">      if (empty_region_error) {</a>
<a name="ln1861">        if (!gui_yank) {</a>
<a name="ln1862">          vim_beep(BO_OPER);</a>
<a name="ln1863">          CancelRedo();</a>
<a name="ln1864">        }</a>
<a name="ln1865">      } else {</a>
<a name="ln1866">        curwin-&gt;w_p_lbr = lbr_saved;</a>
<a name="ln1867">        (void)op_yank(oap, !gui_yank, false);</a>
<a name="ln1868">      }</a>
<a name="ln1869">      check_cursor_col();</a>
<a name="ln1870">      break;</a>
<a name="ln1871"> </a>
<a name="ln1872">    case OP_CHANGE:</a>
<a name="ln1873">      VIsual_reselect = false;              /* don't reselect now */</a>
<a name="ln1874">      if (empty_region_error) {</a>
<a name="ln1875">        vim_beep(BO_OPER);</a>
<a name="ln1876">        CancelRedo();</a>
<a name="ln1877">      } else {</a>
<a name="ln1878">        /* This is a new edit command, not a restart.  Need to</a>
<a name="ln1879">         * remember it to make 'insertmode' work with mappings for</a>
<a name="ln1880">         * Visual mode.  But do this only once and not when typed and</a>
<a name="ln1881">         * 'insertmode' isn't set. */</a>
<a name="ln1882">        if (p_im || !KeyTyped)</a>
<a name="ln1883">          restart_edit_save = restart_edit;</a>
<a name="ln1884">        else</a>
<a name="ln1885">          restart_edit_save = 0;</a>
<a name="ln1886">        restart_edit = 0;</a>
<a name="ln1887"> </a>
<a name="ln1888">        // Restore linebreak, so that when the user edits it looks as before.</a>
<a name="ln1889">        curwin-&gt;w_p_lbr = lbr_saved;</a>
<a name="ln1890"> </a>
<a name="ln1891">        // Reset finish_op now, don't want it set inside edit().</a>
<a name="ln1892">        finish_op = false;</a>
<a name="ln1893">        if (op_change(oap))             /* will call edit() */</a>
<a name="ln1894">          cap-&gt;retval |= CA_COMMAND_BUSY;</a>
<a name="ln1895">        if (restart_edit == 0)</a>
<a name="ln1896">          restart_edit = restart_edit_save;</a>
<a name="ln1897">      }</a>
<a name="ln1898">      break;</a>
<a name="ln1899"> </a>
<a name="ln1900">    case OP_FILTER:</a>
<a name="ln1901">      if (vim_strchr(p_cpo, CPO_FILTER) != NULL) {</a>
<a name="ln1902">        AppendToRedobuff(&quot;!\r&quot;);  // Use any last used !cmd.</a>
<a name="ln1903">      } else {</a>
<a name="ln1904">        bangredo = true;  // do_bang() will put cmd in redo buffer.</a>
<a name="ln1905">      }</a>
<a name="ln1906">      FALLTHROUGH;</a>
<a name="ln1907"> </a>
<a name="ln1908">    case OP_INDENT:</a>
<a name="ln1909">    case OP_COLON:</a>
<a name="ln1910"> </a>
<a name="ln1911">      /*</a>
<a name="ln1912">       * If 'equalprg' is empty, do the indenting internally.</a>
<a name="ln1913">       */</a>
<a name="ln1914">      if (oap-&gt;op_type == OP_INDENT &amp;&amp; *get_equalprg() == NUL) {</a>
<a name="ln1915">        if (curbuf-&gt;b_p_lisp) {</a>
<a name="ln1916">          op_reindent(oap, get_lisp_indent);</a>
<a name="ln1917">          break;</a>
<a name="ln1918">        }</a>
<a name="ln1919">        op_reindent(oap,</a>
<a name="ln1920">            *curbuf-&gt;b_p_inde != NUL ? get_expr_indent :</a>
<a name="ln1921">            get_c_indent);</a>
<a name="ln1922">        break;</a>
<a name="ln1923">      }</a>
<a name="ln1924"> </a>
<a name="ln1925">      op_colon(oap);</a>
<a name="ln1926">      break;</a>
<a name="ln1927"> </a>
<a name="ln1928">    case OP_TILDE:</a>
<a name="ln1929">    case OP_UPPER:</a>
<a name="ln1930">    case OP_LOWER:</a>
<a name="ln1931">    case OP_ROT13:</a>
<a name="ln1932">      if (empty_region_error) {</a>
<a name="ln1933">        vim_beep(BO_OPER);</a>
<a name="ln1934">        CancelRedo();</a>
<a name="ln1935">      } else</a>
<a name="ln1936">        op_tilde(oap);</a>
<a name="ln1937">      check_cursor_col();</a>
<a name="ln1938">      break;</a>
<a name="ln1939"> </a>
<a name="ln1940">    case OP_FORMAT:</a>
<a name="ln1941">      if (*curbuf-&gt;b_p_fex != NUL) {</a>
<a name="ln1942">        op_formatexpr(oap);             // use expression</a>
<a name="ln1943">      } else if (*p_fp != NUL || *curbuf-&gt;b_p_fp != NUL) {</a>
<a name="ln1944">        op_colon(oap);                  // use external command</a>
<a name="ln1945">      } else {</a>
<a name="ln1946">        op_format(oap, false);          // use internal function</a>
<a name="ln1947">      }</a>
<a name="ln1948">      break;</a>
<a name="ln1949"> </a>
<a name="ln1950">    case OP_FORMAT2:</a>
<a name="ln1951">      op_format(oap, true);             /* use internal function */</a>
<a name="ln1952">      break;</a>
<a name="ln1953"> </a>
<a name="ln1954">    case OP_FUNCTION:</a>
<a name="ln1955">      // Restore linebreak, so that when the user edits it looks as</a>
<a name="ln1956">      // before.</a>
<a name="ln1957">      curwin-&gt;w_p_lbr = lbr_saved;</a>
<a name="ln1958">      op_function(oap);                 // call 'operatorfunc'</a>
<a name="ln1959">      break;</a>
<a name="ln1960"> </a>
<a name="ln1961">    case OP_INSERT:</a>
<a name="ln1962">    case OP_APPEND:</a>
<a name="ln1963">      VIsual_reselect = false;          /* don't reselect now */</a>
<a name="ln1964">      if (empty_region_error) {</a>
<a name="ln1965">        vim_beep(BO_OPER);</a>
<a name="ln1966">        CancelRedo();</a>
<a name="ln1967">      } else {</a>
<a name="ln1968">        /* This is a new edit command, not a restart.  Need to</a>
<a name="ln1969">         * remember it to make 'insertmode' work with mappings for</a>
<a name="ln1970">         * Visual mode.  But do this only once. */</a>
<a name="ln1971">        restart_edit_save = restart_edit;</a>
<a name="ln1972">        restart_edit = 0;</a>
<a name="ln1973"> </a>
<a name="ln1974">        // Restore linebreak, so that when the user edits it looks as before.</a>
<a name="ln1975">        curwin-&gt;w_p_lbr = lbr_saved;</a>
<a name="ln1976"> </a>
<a name="ln1977">        op_insert(oap, cap-&gt;count1);</a>
<a name="ln1978"> </a>
<a name="ln1979">        // Reset linebreak, so that formatting works correctly.</a>
<a name="ln1980">        curwin-&gt;w_p_lbr = false;</a>
<a name="ln1981"> </a>
<a name="ln1982">        /* TODO: when inserting in several lines, should format all</a>
<a name="ln1983">         * the lines. */</a>
<a name="ln1984">        auto_format(false, true);</a>
<a name="ln1985"> </a>
<a name="ln1986">        if (restart_edit == 0) {</a>
<a name="ln1987">          restart_edit = restart_edit_save;</a>
<a name="ln1988">        } else {</a>
<a name="ln1989">          cap-&gt;retval |= CA_COMMAND_BUSY;</a>
<a name="ln1990">        }</a>
<a name="ln1991">      }</a>
<a name="ln1992">      break;</a>
<a name="ln1993"> </a>
<a name="ln1994">    case OP_REPLACE:</a>
<a name="ln1995">      VIsual_reselect = false;          /* don't reselect now */</a>
<a name="ln1996">      if (empty_region_error) {</a>
<a name="ln1997">        vim_beep(BO_OPER);</a>
<a name="ln1998">        CancelRedo();</a>
<a name="ln1999">      } else {</a>
<a name="ln2000">        // Restore linebreak, so that when the user edits it looks as before.</a>
<a name="ln2001">        curwin-&gt;w_p_lbr = lbr_saved;</a>
<a name="ln2002"> </a>
<a name="ln2003">        op_replace(oap, cap-&gt;nchar);</a>
<a name="ln2004">      }</a>
<a name="ln2005">      break;</a>
<a name="ln2006"> </a>
<a name="ln2007">    case OP_FOLD:</a>
<a name="ln2008">      VIsual_reselect = false;          // don't reselect now</a>
<a name="ln2009">      foldCreate(curwin, oap-&gt;start, oap-&gt;end);</a>
<a name="ln2010">      break;</a>
<a name="ln2011"> </a>
<a name="ln2012">    case OP_FOLDOPEN:</a>
<a name="ln2013">    case OP_FOLDOPENREC:</a>
<a name="ln2014">    case OP_FOLDCLOSE:</a>
<a name="ln2015">    case OP_FOLDCLOSEREC:</a>
<a name="ln2016">      VIsual_reselect = false;          // don't reselect now</a>
<a name="ln2017">      opFoldRange(oap-&gt;start, oap-&gt;end,</a>
<a name="ln2018">                  oap-&gt;op_type == OP_FOLDOPEN</a>
<a name="ln2019">                  || oap-&gt;op_type == OP_FOLDOPENREC,</a>
<a name="ln2020">                  oap-&gt;op_type == OP_FOLDOPENREC</a>
<a name="ln2021">                  || oap-&gt;op_type == OP_FOLDCLOSEREC,</a>
<a name="ln2022">                  oap-&gt;is_VIsual);</a>
<a name="ln2023">      break;</a>
<a name="ln2024"> </a>
<a name="ln2025">    case OP_FOLDDEL:</a>
<a name="ln2026">    case OP_FOLDDELREC:</a>
<a name="ln2027">      VIsual_reselect = false;          // don't reselect now</a>
<a name="ln2028">      deleteFold(curwin, oap-&gt;start.lnum, oap-&gt;end.lnum,</a>
<a name="ln2029">                 oap-&gt;op_type == OP_FOLDDELREC, oap-&gt;is_VIsual);</a>
<a name="ln2030">      break;</a>
<a name="ln2031"> </a>
<a name="ln2032">    case OP_NR_ADD:</a>
<a name="ln2033">    case OP_NR_SUB:</a>
<a name="ln2034">      if (empty_region_error) {</a>
<a name="ln2035">        vim_beep(BO_OPER);</a>
<a name="ln2036">        CancelRedo();</a>
<a name="ln2037">      } else {</a>
<a name="ln2038">        VIsual_active = true;</a>
<a name="ln2039">        curwin-&gt;w_p_lbr = lbr_saved;</a>
<a name="ln2040">        op_addsub(oap, cap-&gt;count1, redo_VIsual_arg);</a>
<a name="ln2041">        VIsual_active = false;</a>
<a name="ln2042">      }</a>
<a name="ln2043">      check_cursor_col();</a>
<a name="ln2044">      break;</a>
<a name="ln2045">    default:</a>
<a name="ln2046">      clearopbeep(oap);</a>
<a name="ln2047">    }</a>
<a name="ln2048">    virtual_op = kNone;</a>
<a name="ln2049">    if (!gui_yank) {</a>
<a name="ln2050">      /*</a>
<a name="ln2051">       * if 'sol' not set, go back to old column for some commands</a>
<a name="ln2052">       */</a>
<a name="ln2053">      if (!p_sol &amp;&amp; oap-&gt;motion_type == kMTLineWise &amp;&amp; !oap-&gt;end_adjusted</a>
<a name="ln2054">          &amp;&amp; (oap-&gt;op_type == OP_LSHIFT || oap-&gt;op_type == OP_RSHIFT</a>
<a name="ln2055">              || oap-&gt;op_type == OP_DELETE)) {</a>
<a name="ln2056">        curwin-&gt;w_p_lbr = false;</a>
<a name="ln2057">        coladvance(curwin-&gt;w_curswant = old_col);</a>
<a name="ln2058">      }</a>
<a name="ln2059">    } else {</a>
<a name="ln2060">      curwin-&gt;w_cursor = old_cursor;</a>
<a name="ln2061">    }</a>
<a name="ln2062">    clearop(oap);</a>
<a name="ln2063">    motion_force = NUL;</a>
<a name="ln2064">  }</a>
<a name="ln2065">  curwin-&gt;w_p_lbr = lbr_saved;</a>
<a name="ln2066">}</a>
<a name="ln2067"> </a>
<a name="ln2068">/*</a>
<a name="ln2069"> * Handle indent and format operators and visual mode &quot;:&quot;.</a>
<a name="ln2070"> */</a>
<a name="ln2071">static void op_colon(oparg_T *oap)</a>
<a name="ln2072">{</a>
<a name="ln2073">  stuffcharReadbuff(':');</a>
<a name="ln2074">  if (oap-&gt;is_VIsual) {</a>
<a name="ln2075">    stuffReadbuff(&quot;'&lt;,'&gt;&quot;);</a>
<a name="ln2076">  } else {</a>
<a name="ln2077">    // Make the range look nice, so it can be repeated.</a>
<a name="ln2078">    if (oap-&gt;start.lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln2079">      stuffcharReadbuff('.');</a>
<a name="ln2080">    } else {</a>
<a name="ln2081">      stuffnumReadbuff((long)oap-&gt;start.lnum);</a>
<a name="ln2082">    }</a>
<a name="ln2083">    if (oap-&gt;end.lnum != oap-&gt;start.lnum) {</a>
<a name="ln2084">      stuffcharReadbuff(',');</a>
<a name="ln2085">      if (oap-&gt;end.lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln2086">        stuffcharReadbuff('.');</a>
<a name="ln2087">      } else if (oap-&gt;end.lnum == curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2088">        stuffcharReadbuff('$');</a>
<a name="ln2089">      } else if (oap-&gt;start.lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln2090">        stuffReadbuff(&quot;.+&quot;);</a>
<a name="ln2091">        stuffnumReadbuff(oap-&gt;line_count - 1);</a>
<a name="ln2092">      } else {</a>
<a name="ln2093">        stuffnumReadbuff((long)oap-&gt;end.lnum);</a>
<a name="ln2094">      }</a>
<a name="ln2095">    }</a>
<a name="ln2096">  }</a>
<a name="ln2097">  if (oap-&gt;op_type != OP_COLON) {</a>
<a name="ln2098">    stuffReadbuff(&quot;!&quot;);</a>
<a name="ln2099">  }</a>
<a name="ln2100">  if (oap-&gt;op_type == OP_INDENT) {</a>
<a name="ln2101">    stuffReadbuff((const char *)get_equalprg());</a>
<a name="ln2102">    stuffReadbuff(&quot;\n&quot;);</a>
<a name="ln2103">  } else if (oap-&gt;op_type == OP_FORMAT) {</a>
<a name="ln2104">    if (*curbuf-&gt;b_p_fp != NUL) {</a>
<a name="ln2105">      stuffReadbuff((const char *)curbuf-&gt;b_p_fp);</a>
<a name="ln2106">    } else if (*p_fp != NUL) {</a>
<a name="ln2107">      stuffReadbuff((const char *)p_fp);</a>
<a name="ln2108">    } else {</a>
<a name="ln2109">      stuffReadbuff(&quot;fmt&quot;);</a>
<a name="ln2110">    }</a>
<a name="ln2111">    stuffReadbuff(&quot;\n']&quot;);</a>
<a name="ln2112">  }</a>
<a name="ln2113"> </a>
<a name="ln2114">  /*</a>
<a name="ln2115">   * do_cmdline() does the rest</a>
<a name="ln2116">   */</a>
<a name="ln2117">}</a>
<a name="ln2118"> </a>
<a name="ln2119">/*</a>
<a name="ln2120"> * Handle the &quot;g@&quot; operator: call 'operatorfunc'.</a>
<a name="ln2121"> */</a>
<a name="ln2122">static void op_function(const oparg_T *oap)</a>
<a name="ln2123">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2124">{</a>
<a name="ln2125">  const TriState save_virtual_op = virtual_op;</a>
<a name="ln2126"> </a>
<a name="ln2127">  if (*p_opfunc == NUL)</a>
<a name="ln2128">    EMSG(_(&quot;E774: 'operatorfunc' is empty&quot;));</a>
<a name="ln2129">  else {</a>
<a name="ln2130">    /* Set '[ and '] marks to text to be operated on. */</a>
<a name="ln2131">    curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln2132">    curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln2133">    if (oap-&gt;motion_type != kMTLineWise &amp;&amp; !oap-&gt;inclusive) {</a>
<a name="ln2134">      // Exclude the end position.</a>
<a name="ln2135">      decl(&amp;curbuf-&gt;b_op_end);</a>
<a name="ln2136">    }</a>
<a name="ln2137"> </a>
<a name="ln2138">    typval_T argv[2];</a>
<a name="ln2139">    argv[0].v_type = VAR_STRING;</a>
<a name="ln2140">    argv[1].v_type = VAR_UNKNOWN;</a>
<a name="ln2141">    argv[0].vval.v_string =</a>
<a name="ln2142">      (char_u *)(((const char *const[]) {</a>
<a name="ln2143">        [kMTBlockWise] = &quot;block&quot;,</a>
<a name="ln2144">        [kMTLineWise] = &quot;line&quot;,</a>
<a name="ln2145">        [kMTCharWise] = &quot;char&quot;,</a>
<a name="ln2146">      })[oap-&gt;motion_type]);</a>
<a name="ln2147"> </a>
<a name="ln2148">    // Reset virtual_op so that 'virtualedit' can be changed in the</a>
<a name="ln2149">    // function.</a>
<a name="ln2150">    virtual_op = kNone;</a>
<a name="ln2151"> </a>
<a name="ln2152">    (void)call_func_retnr(p_opfunc, 1, argv);</a>
<a name="ln2153"> </a>
<a name="ln2154">    virtual_op = save_virtual_op;</a>
<a name="ln2155">  }</a>
<a name="ln2156">}</a>
<a name="ln2157"> </a>
<a name="ln2158">// Move the current tab to tab in same column as mouse or to end of the</a>
<a name="ln2159">// tabline if there is no tab there.</a>
<a name="ln2160">static void move_tab_to_mouse(void)</a>
<a name="ln2161">{</a>
<a name="ln2162">  int tabnr = tab_page_click_defs[mouse_col].tabnr;</a>
<a name="ln2163">  if (tabnr &lt;= 0) {</a>
<a name="ln2164">      tabpage_move(9999);</a>
<a name="ln2165">  } else if (tabnr &lt; tabpage_index(curtab)) {</a>
<a name="ln2166">      tabpage_move(tabnr - 1);</a>
<a name="ln2167">  } else {</a>
<a name="ln2168">      tabpage_move(tabnr);</a>
<a name="ln2169">  }</a>
<a name="ln2170">}</a>
<a name="ln2171"> </a>
<a name="ln2172">/*</a>
<a name="ln2173"> * Do the appropriate action for the current mouse click in the current mode.</a>
<a name="ln2174"> * Not used for Command-line mode.</a>
<a name="ln2175"> *</a>
<a name="ln2176"> * Normal Mode:</a>
<a name="ln2177"> * event	 modi-	position      visual	   change   action</a>
<a name="ln2178"> *		 fier	cursor			   window</a>
<a name="ln2179"> * left press	  -	yes	    end		    yes</a>
<a name="ln2180"> * left press	  C	yes	    end		    yes	    &quot;^]&quot; (2)</a>
<a name="ln2181"> * left press	  S	yes	    end		    yes	    &quot;*&quot; (2)</a>
<a name="ln2182"> * left drag	  -	yes	start if moved	    no</a>
<a name="ln2183"> * left relse	  -	yes	start if moved	    no</a>
<a name="ln2184"> * middle press	  -	yes	 if not active	    no	    put register</a>
<a name="ln2185"> * middle press	  -	yes	 if active	    no	    yank and put</a>
<a name="ln2186"> * right press	  -	yes	start or extend	    yes</a>
<a name="ln2187"> * right press	  S	yes	no change	    yes	    &quot;#&quot; (2)</a>
<a name="ln2188"> * right drag	  -	yes	extend		    no</a>
<a name="ln2189"> * right relse	  -	yes	extend		    no</a>
<a name="ln2190"> *</a>
<a name="ln2191"> * Insert or Replace Mode:</a>
<a name="ln2192"> * event	 modi-	position      visual	   change   action</a>
<a name="ln2193"> *		 fier	cursor			   window</a>
<a name="ln2194"> * left press	  -	yes	(cannot be active)  yes</a>
<a name="ln2195"> * left press	  C	yes	(cannot be active)  yes	    &quot;CTRL-O^]&quot; (2)</a>
<a name="ln2196"> * left press	  S	yes	(cannot be active)  yes	    &quot;CTRL-O*&quot; (2)</a>
<a name="ln2197"> * left drag	  -	yes	start or extend (1) no	    CTRL-O (1)</a>
<a name="ln2198"> * left relse	  -	yes	start or extend (1) no	    CTRL-O (1)</a>
<a name="ln2199"> * middle press	  -	no	(cannot be active)  no	    put register</a>
<a name="ln2200"> * right press	  -	yes	start or extend	    yes	    CTRL-O</a>
<a name="ln2201"> * right press	  S	yes	(cannot be active)  yes	    &quot;CTRL-O#&quot; (2)</a>
<a name="ln2202"> *</a>
<a name="ln2203"> * (1) only if mouse pointer moved since press</a>
<a name="ln2204"> * (2) only if click is in same buffer</a>
<a name="ln2205"> *</a>
<a name="ln2206"> * Return true if start_arrow() should be called for edit mode.</a>
<a name="ln2207"> */</a>
<a name="ln2208">bool</a>
<a name="ln2209">do_mouse (</a>
<a name="ln2210">    oparg_T *oap,               /* operator argument, can be NULL */</a>
<a name="ln2211">    int c,                          /* K_LEFTMOUSE, etc */</a>
<a name="ln2212">    int dir,                        /* Direction to 'put' if necessary */</a>
<a name="ln2213">    long count,</a>
<a name="ln2214">    bool fixindent                  /* PUT_FIXINDENT if fixing indent necessary */</a>
<a name="ln2215">)</a>
<a name="ln2216">{</a>
<a name="ln2217">  static bool got_click = false;        /* got a click some time back */</a>
<a name="ln2218"> </a>
<a name="ln2219">  int which_button;             /* MOUSE_LEFT, _MIDDLE or _RIGHT */</a>
<a name="ln2220">  bool is_click;                /* If false it's a drag or release event */</a>
<a name="ln2221">  bool is_drag;                 /* If true it's a drag event */</a>
<a name="ln2222">  int jump_flags = 0;           /* flags for jump_to_mouse() */</a>
<a name="ln2223">  pos_T start_visual;</a>
<a name="ln2224">  bool moved;                   /* Has cursor moved? */</a>
<a name="ln2225">  bool in_status_line;          /* mouse in status line */</a>
<a name="ln2226">  static bool in_tab_line = false;   /* mouse clicked in tab line */</a>
<a name="ln2227">  bool in_sep_line;             /* mouse in vertical separator line */</a>
<a name="ln2228">  int c1, c2;</a>
<a name="ln2229">  pos_T save_cursor;</a>
<a name="ln2230">  win_T       *old_curwin = curwin;</a>
<a name="ln2231">  static pos_T orig_cursor;</a>
<a name="ln2232">  colnr_T leftcol, rightcol;</a>
<a name="ln2233">  pos_T end_visual;</a>
<a name="ln2234">  long diff;</a>
<a name="ln2235">  int old_active = VIsual_active;</a>
<a name="ln2236">  int old_mode = VIsual_mode;</a>
<a name="ln2237">  int regname;</a>
<a name="ln2238"> </a>
<a name="ln2239">  save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln2240"> </a>
<a name="ln2241">  for (;; ) {</a>
<a name="ln2242">    which_button = get_mouse_button(KEY2TERMCAP1(c), &amp;is_click, &amp;is_drag);</a>
<a name="ln2243">    if (is_drag) {</a>
<a name="ln2244">      /* If the next character is the same mouse event then use that</a>
<a name="ln2245">       * one. Speeds up dragging the status line. */</a>
<a name="ln2246">      if (vpeekc() != NUL) {</a>
<a name="ln2247">        int nc;</a>
<a name="ln2248">        int save_mouse_grid = mouse_grid;</a>
<a name="ln2249">        int save_mouse_row = mouse_row;</a>
<a name="ln2250">        int save_mouse_col = mouse_col;</a>
<a name="ln2251"> </a>
<a name="ln2252">        /* Need to get the character, peeking doesn't get the actual</a>
<a name="ln2253">         * one. */</a>
<a name="ln2254">        nc = safe_vgetc();</a>
<a name="ln2255">        if (c == nc)</a>
<a name="ln2256">          continue;</a>
<a name="ln2257">        vungetc(nc);</a>
<a name="ln2258">        mouse_grid = save_mouse_grid;</a>
<a name="ln2259">        mouse_row = save_mouse_row;</a>
<a name="ln2260">        mouse_col = save_mouse_col;</a>
<a name="ln2261">      }</a>
<a name="ln2262">    }</a>
<a name="ln2263">    break;</a>
<a name="ln2264">  }</a>
<a name="ln2265"> </a>
<a name="ln2266"> </a>
<a name="ln2267">  /*</a>
<a name="ln2268">   * Ignore drag and release events if we didn't get a click.</a>
<a name="ln2269">   */</a>
<a name="ln2270">  if (is_click)</a>
<a name="ln2271">    got_click = true;</a>
<a name="ln2272">  else {</a>
<a name="ln2273">    if (!got_click)                     /* didn't get click, ignore */</a>
<a name="ln2274">      return false;</a>
<a name="ln2275">    if (!is_drag) {                     /* release, reset got_click */</a>
<a name="ln2276">      got_click = false;</a>
<a name="ln2277">      if (in_tab_line) {</a>
<a name="ln2278">        in_tab_line = false;</a>
<a name="ln2279">        return false;</a>
<a name="ln2280">      }</a>
<a name="ln2281">    }</a>
<a name="ln2282">  }</a>
<a name="ln2283"> </a>
<a name="ln2284"> </a>
<a name="ln2285">  /*</a>
<a name="ln2286">   * CTRL right mouse button does CTRL-T</a>
<a name="ln2287">   */</a>
<a name="ln2288">  if (is_click &amp;&amp; (mod_mask &amp; MOD_MASK_CTRL) &amp;&amp; which_button == MOUSE_RIGHT) {</a>
<a name="ln2289">    if (State &amp; INSERT)</a>
<a name="ln2290">      stuffcharReadbuff(Ctrl_O);</a>
<a name="ln2291">    if (count &gt; 1)</a>
<a name="ln2292">      stuffnumReadbuff(count);</a>
<a name="ln2293">    stuffcharReadbuff(Ctrl_T);</a>
<a name="ln2294">    got_click = false;                  /* ignore drag&amp;release now */</a>
<a name="ln2295">    return false;</a>
<a name="ln2296">  }</a>
<a name="ln2297"> </a>
<a name="ln2298">  /*</a>
<a name="ln2299">   * CTRL only works with left mouse button</a>
<a name="ln2300">   */</a>
<a name="ln2301">  if ((mod_mask &amp; MOD_MASK_CTRL) &amp;&amp; which_button != MOUSE_LEFT)</a>
<a name="ln2302">    return false;</a>
<a name="ln2303"> </a>
<a name="ln2304">  /*</a>
<a name="ln2305">   * When a modifier is down, ignore drag and release events, as well as</a>
<a name="ln2306">   * multiple clicks and the middle mouse button.</a>
<a name="ln2307">   * Accept shift-leftmouse drags when 'mousemodel' is &quot;popup.*&quot;.</a>
<a name="ln2308">   */</a>
<a name="ln2309">  if ((mod_mask &amp; (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT</a>
<a name="ln2310">                   | MOD_MASK_META))</a>
<a name="ln2311">      &amp;&amp; (!is_click</a>
<a name="ln2312">          || (mod_mask &amp; MOD_MASK_MULTI_CLICK)</a>
<a name="ln2313">          || which_button == MOUSE_MIDDLE)</a>
<a name="ln2314">      &amp;&amp; !((mod_mask &amp; (MOD_MASK_SHIFT|MOD_MASK_ALT))</a>
<a name="ln2315">           &amp;&amp; mouse_model_popup()</a>
<a name="ln2316">           &amp;&amp; which_button == MOUSE_LEFT)</a>
<a name="ln2317">      &amp;&amp; !((mod_mask &amp; MOD_MASK_ALT)</a>
<a name="ln2318">           &amp;&amp; !mouse_model_popup()</a>
<a name="ln2319">           &amp;&amp; which_button == MOUSE_RIGHT)</a>
<a name="ln2320">      )</a>
<a name="ln2321">    return false;</a>
<a name="ln2322"> </a>
<a name="ln2323">  /*</a>
<a name="ln2324">   * If the button press was used as the movement command for an operator</a>
<a name="ln2325">   * (eg &quot;d&lt;MOUSE&gt;&quot;), or it is the middle button that is held down, ignore</a>
<a name="ln2326">   * drag/release events.</a>
<a name="ln2327">   */</a>
<a name="ln2328">  if (!is_click &amp;&amp; which_button == MOUSE_MIDDLE)</a>
<a name="ln2329">    return false;</a>
<a name="ln2330"> </a>
<a name="ln2331">  if (oap != NULL)</a>
<a name="ln2332">    regname = oap-&gt;regname;</a>
<a name="ln2333">  else</a>
<a name="ln2334">    regname = 0;</a>
<a name="ln2335"> </a>
<a name="ln2336">  /*</a>
<a name="ln2337">   * Middle mouse button does a 'put' of the selected text</a>
<a name="ln2338">   */</a>
<a name="ln2339">  if (which_button == MOUSE_MIDDLE) {</a>
<a name="ln2340">    if (State == NORMAL) {</a>
<a name="ln2341">      /*</a>
<a name="ln2342">       * If an operator was pending, we don't know what the user wanted</a>
<a name="ln2343">       * to do. Go back to normal mode: Clear the operator and beep().</a>
<a name="ln2344">       */</a>
<a name="ln2345">      if (oap != NULL &amp;&amp; oap-&gt;op_type != OP_NOP) {</a>
<a name="ln2346">        clearopbeep(oap);</a>
<a name="ln2347">        return false;</a>
<a name="ln2348">      }</a>
<a name="ln2349"> </a>
<a name="ln2350">      /*</a>
<a name="ln2351">       * If visual was active, yank the highlighted text and put it</a>
<a name="ln2352">       * before the mouse pointer position.</a>
<a name="ln2353">       * In Select mode replace the highlighted text with the clipboard.</a>
<a name="ln2354">       */</a>
<a name="ln2355">      if (VIsual_active) {</a>
<a name="ln2356">        if (VIsual_select) {</a>
<a name="ln2357">          stuffcharReadbuff(Ctrl_G);</a>
<a name="ln2358">          stuffReadbuff(&quot;\&quot;+p&quot;);</a>
<a name="ln2359">        } else {</a>
<a name="ln2360">          stuffcharReadbuff('y');</a>
<a name="ln2361">          stuffcharReadbuff(K_MIDDLEMOUSE);</a>
<a name="ln2362">        }</a>
<a name="ln2363">        return false;</a>
<a name="ln2364">      }</a>
<a name="ln2365">      /*</a>
<a name="ln2366">       * The rest is below jump_to_mouse()</a>
<a name="ln2367">       */</a>
<a name="ln2368">    } else if ((State &amp; INSERT) == 0)</a>
<a name="ln2369">      return false;</a>
<a name="ln2370"> </a>
<a name="ln2371">    /*</a>
<a name="ln2372">     * Middle click in insert mode doesn't move the mouse, just insert the</a>
<a name="ln2373">     * contents of a register.  '.' register is special, can't insert that</a>
<a name="ln2374">     * with do_put().</a>
<a name="ln2375">     * Also paste at the cursor if the current mode isn't in 'mouse' (only</a>
<a name="ln2376">     * happens for the GUI).</a>
<a name="ln2377">     */</a>
<a name="ln2378">    if ((State &amp; INSERT)) {</a>
<a name="ln2379">      if (regname == '.') {</a>
<a name="ln2380">        insert_reg(regname, true);</a>
<a name="ln2381">      } else {</a>
<a name="ln2382">        if (regname == 0 &amp;&amp; eval_has_provider(&quot;clipboard&quot;)) {</a>
<a name="ln2383">          regname = '*';</a>
<a name="ln2384">        }</a>
<a name="ln2385">        if ((State &amp; REPLACE_FLAG) &amp;&amp; !yank_register_mline(regname)) {</a>
<a name="ln2386">          insert_reg(regname, true);</a>
<a name="ln2387">        } else {</a>
<a name="ln2388">          do_put(regname, NULL, BACKWARD, 1L,</a>
<a name="ln2389">                 (fixindent ? PUT_FIXINDENT : 0) | PUT_CURSEND);</a>
<a name="ln2390"> </a>
<a name="ln2391">          /* Repeat it with CTRL-R CTRL-O r or CTRL-R CTRL-P r */</a>
<a name="ln2392">          AppendCharToRedobuff(Ctrl_R);</a>
<a name="ln2393">          AppendCharToRedobuff(fixindent ? Ctrl_P : Ctrl_O);</a>
<a name="ln2394">          AppendCharToRedobuff(regname == 0 ? '&quot;' : regname);</a>
<a name="ln2395">        }</a>
<a name="ln2396">      }</a>
<a name="ln2397">      return false;</a>
<a name="ln2398">    }</a>
<a name="ln2399">  }</a>
<a name="ln2400"> </a>
<a name="ln2401">  /* When dragging or button-up stay in the same window. */</a>
<a name="ln2402">  if (!is_click)</a>
<a name="ln2403">    jump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;</a>
<a name="ln2404"> </a>
<a name="ln2405">  start_visual.lnum = 0;</a>
<a name="ln2406"> </a>
<a name="ln2407">  // Check for clicking in the tab page line.</a>
<a name="ln2408">  if (mouse_grid &lt;= 1 &amp;&amp; mouse_row == 0 &amp;&amp; firstwin-&gt;w_winrow &gt; 0) {</a>
<a name="ln2409">    if (is_drag) {</a>
<a name="ln2410">      if (in_tab_line) {</a>
<a name="ln2411">        move_tab_to_mouse();</a>
<a name="ln2412">      }</a>
<a name="ln2413">      return false;</a>
<a name="ln2414">    }</a>
<a name="ln2415"> </a>
<a name="ln2416">    /* click in a tab selects that tab page */</a>
<a name="ln2417">    if (is_click</a>
<a name="ln2418">        &amp;&amp; cmdwin_type == 0</a>
<a name="ln2419">        &amp;&amp; mouse_col &lt; Columns) {</a>
<a name="ln2420">      in_tab_line = true;</a>
<a name="ln2421">      c1 = tab_page_click_defs[mouse_col].tabnr;</a>
<a name="ln2422">      switch (tab_page_click_defs[mouse_col].type) {</a>
<a name="ln2423">        case kStlClickDisabled: {</a>
<a name="ln2424">          break;</a>
<a name="ln2425">        }</a>
<a name="ln2426">        case kStlClickTabClose: {</a>
<a name="ln2427">          tabpage_T *tp;</a>
<a name="ln2428"> </a>
<a name="ln2429">          // Close the current or specified tab page.</a>
<a name="ln2430">          if (c1 == 999) {</a>
<a name="ln2431">            tp = curtab;</a>
<a name="ln2432">          } else {</a>
<a name="ln2433">            tp = find_tabpage(c1);</a>
<a name="ln2434">          }</a>
<a name="ln2435">          if (tp == curtab) {</a>
<a name="ln2436">            if (first_tabpage-&gt;tp_next != NULL) {</a>
<a name="ln2437">              tabpage_close(false);</a>
<a name="ln2438">            }</a>
<a name="ln2439">          } else if (tp != NULL) {</a>
<a name="ln2440">            tabpage_close_other(tp, false);</a>
<a name="ln2441">          }</a>
<a name="ln2442">          break;</a>
<a name="ln2443">        }</a>
<a name="ln2444">        case kStlClickTabSwitch: {</a>
<a name="ln2445">          if ((mod_mask &amp; MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK) {</a>
<a name="ln2446">            // double click opens new page</a>
<a name="ln2447">            end_visual_mode();</a>
<a name="ln2448">            tabpage_new();</a>
<a name="ln2449">            tabpage_move(c1 == 0 ? 9999 : c1 - 1);</a>
<a name="ln2450">          } else {</a>
<a name="ln2451">            // Go to specified tab page, or next one if not clicking</a>
<a name="ln2452">            // on a label.</a>
<a name="ln2453">            goto_tabpage(c1);</a>
<a name="ln2454"> </a>
<a name="ln2455">            // It's like clicking on the status line of a window.</a>
<a name="ln2456">            if (curwin != old_curwin) {</a>
<a name="ln2457">              end_visual_mode();</a>
<a name="ln2458">            }</a>
<a name="ln2459">          }</a>
<a name="ln2460">          break;</a>
<a name="ln2461">        }</a>
<a name="ln2462">        case kStlClickFuncRun: {</a>
<a name="ln2463">          typval_T argv[] = {</a>
<a name="ln2464">            {</a>
<a name="ln2465">              .v_lock = VAR_FIXED,</a>
<a name="ln2466">              .v_type = VAR_NUMBER,</a>
<a name="ln2467">              .vval = {</a>
<a name="ln2468">                .v_number = (varnumber_T) tab_page_click_defs[mouse_col].tabnr</a>
<a name="ln2469">              },</a>
<a name="ln2470">            },</a>
<a name="ln2471">            {</a>
<a name="ln2472">              .v_lock = VAR_FIXED,</a>
<a name="ln2473">              .v_type = VAR_NUMBER,</a>
<a name="ln2474">              .vval = {</a>
<a name="ln2475">                .v_number = (((mod_mask &amp; MOD_MASK_MULTI_CLICK)</a>
<a name="ln2476">                              == MOD_MASK_4CLICK)</a>
<a name="ln2477">                             ? 4</a>
<a name="ln2478">                             : ((mod_mask &amp; MOD_MASK_MULTI_CLICK)</a>
<a name="ln2479">                                == MOD_MASK_3CLICK)</a>
<a name="ln2480">                             ? 3</a>
<a name="ln2481">                             : ((mod_mask &amp; MOD_MASK_MULTI_CLICK)</a>
<a name="ln2482">                                == MOD_MASK_2CLICK)</a>
<a name="ln2483">                             ? 2</a>
<a name="ln2484">                             : 1)</a>
<a name="ln2485">              },</a>
<a name="ln2486">            },</a>
<a name="ln2487">            {</a>
<a name="ln2488">              .v_lock = VAR_FIXED,</a>
<a name="ln2489">              .v_type = VAR_STRING,</a>
<a name="ln2490">              .vval = { .v_string = (char_u *) (which_button == MOUSE_LEFT</a>
<a name="ln2491">                                                ? &quot;l&quot;</a>
<a name="ln2492">                                                : which_button == MOUSE_RIGHT</a>
<a name="ln2493">                                                ? &quot;r&quot;</a>
<a name="ln2494">                                                : which_button == MOUSE_MIDDLE</a>
<a name="ln2495">                                                ? &quot;m&quot;</a>
<a name="ln2496">                                                : &quot;?&quot;) },</a>
<a name="ln2497">            },</a>
<a name="ln2498">            {</a>
<a name="ln2499">              .v_lock = VAR_FIXED,</a>
<a name="ln2500">              .v_type = VAR_STRING,</a>
<a name="ln2501">              .vval = {</a>
<a name="ln2502">                .v_string = (char_u[]) {</a>
<a name="ln2503">                  (char_u) (mod_mask &amp; MOD_MASK_SHIFT ? 's' : ' '),</a>
<a name="ln2504">                  (char_u) (mod_mask &amp; MOD_MASK_CTRL ? 'c' : ' '),</a>
<a name="ln2505">                  (char_u) (mod_mask &amp; MOD_MASK_ALT ? 'a' : ' '),</a>
<a name="ln2506">                  (char_u) (mod_mask &amp; MOD_MASK_META ? 'm' : ' '),</a>
<a name="ln2507">                  NUL</a>
<a name="ln2508">                }</a>
<a name="ln2509">              },</a>
<a name="ln2510">            }</a>
<a name="ln2511">          };</a>
<a name="ln2512">          typval_T rettv;</a>
<a name="ln2513">          int doesrange;</a>
<a name="ln2514">          (void)call_func((char_u *)tab_page_click_defs[mouse_col].func,</a>
<a name="ln2515">                          -1,</a>
<a name="ln2516">                          &amp;rettv, ARRAY_SIZE(argv), argv, NULL,</a>
<a name="ln2517">                          curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.lnum,</a>
<a name="ln2518">                          &amp;doesrange, true, NULL, NULL);</a>
<a name="ln2519">          tv_clear(&amp;rettv);</a>
<a name="ln2520">          break;</a>
<a name="ln2521">        }</a>
<a name="ln2522">      }</a>
<a name="ln2523">    }</a>
<a name="ln2524">    return true;</a>
<a name="ln2525">  } else if (is_drag &amp;&amp; in_tab_line) {</a>
<a name="ln2526">    move_tab_to_mouse();</a>
<a name="ln2527">    return false;</a>
<a name="ln2528">  }</a>
<a name="ln2529"> </a>
<a name="ln2530"> </a>
<a name="ln2531">  /*</a>
<a name="ln2532">   * When 'mousemodel' is &quot;popup&quot; or &quot;popup_setpos&quot;, translate mouse events:</a>
<a name="ln2533">   * right button up   -&gt; pop-up menu</a>
<a name="ln2534">   * shift-left button -&gt; right button</a>
<a name="ln2535">   * alt-left button   -&gt; alt-right button</a>
<a name="ln2536">   */</a>
<a name="ln2537">  if (mouse_model_popup()) {</a>
<a name="ln2538">    if (which_button == MOUSE_RIGHT</a>
<a name="ln2539">        &amp;&amp; !(mod_mask &amp; (MOD_MASK_SHIFT | MOD_MASK_CTRL))) {</a>
<a name="ln2540">      /*</a>
<a name="ln2541">       * NOTE: Ignore right button down and drag mouse events.</a>
<a name="ln2542">       * Windows only shows the popup menu on the button up event.</a>
<a name="ln2543">       */</a>
<a name="ln2544">      return false;</a>
<a name="ln2545">    }</a>
<a name="ln2546">    if (which_button == MOUSE_LEFT</a>
<a name="ln2547">        &amp;&amp; (mod_mask &amp; (MOD_MASK_SHIFT|MOD_MASK_ALT))) {</a>
<a name="ln2548">      which_button = MOUSE_RIGHT;</a>
<a name="ln2549">      mod_mask &amp;= ~MOD_MASK_SHIFT;</a>
<a name="ln2550">    }</a>
<a name="ln2551">  }</a>
<a name="ln2552"> </a>
<a name="ln2553">  if ((State &amp; (NORMAL | INSERT))</a>
<a name="ln2554">      &amp;&amp; !(mod_mask &amp; (MOD_MASK_SHIFT | MOD_MASK_CTRL))) {</a>
<a name="ln2555">    if (which_button == MOUSE_LEFT) {</a>
<a name="ln2556">      if (is_click) {</a>
<a name="ln2557">        /* stop Visual mode for a left click in a window, but not when</a>
<a name="ln2558">         * on a status line */</a>
<a name="ln2559">        if (VIsual_active)</a>
<a name="ln2560">          jump_flags |= MOUSE_MAY_STOP_VIS;</a>
<a name="ln2561">      } else {</a>
<a name="ln2562">        jump_flags |= MOUSE_MAY_VIS;</a>
<a name="ln2563">      }</a>
<a name="ln2564">    } else if (which_button == MOUSE_RIGHT) {</a>
<a name="ln2565">      if (is_click &amp;&amp; VIsual_active) {</a>
<a name="ln2566">        /*</a>
<a name="ln2567">         * Remember the start and end of visual before moving the</a>
<a name="ln2568">         * cursor.</a>
<a name="ln2569">         */</a>
<a name="ln2570">        if (lt(curwin-&gt;w_cursor, VIsual)) {</a>
<a name="ln2571">          start_visual = curwin-&gt;w_cursor;</a>
<a name="ln2572">          end_visual = VIsual;</a>
<a name="ln2573">        } else {</a>
<a name="ln2574">          start_visual = VIsual;</a>
<a name="ln2575">          end_visual = curwin-&gt;w_cursor;</a>
<a name="ln2576">        }</a>
<a name="ln2577">      }</a>
<a name="ln2578">      jump_flags |= MOUSE_FOCUS;</a>
<a name="ln2579">      jump_flags |= MOUSE_MAY_VIS;</a>
<a name="ln2580">    }</a>
<a name="ln2581">  }</a>
<a name="ln2582"> </a>
<a name="ln2583">  /*</a>
<a name="ln2584">   * If an operator is pending, ignore all drags and releases until the</a>
<a name="ln2585">   * next mouse click.</a>
<a name="ln2586">   */</a>
<a name="ln2587">  if (!is_drag &amp;&amp; oap != NULL &amp;&amp; oap-&gt;op_type != OP_NOP) {</a>
<a name="ln2588">    got_click = false;</a>
<a name="ln2589">    oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln2590">  }</a>
<a name="ln2591"> </a>
<a name="ln2592">  /* When releasing the button let jump_to_mouse() know. */</a>
<a name="ln2593">  if (!is_click &amp;&amp; !is_drag)</a>
<a name="ln2594">    jump_flags |= MOUSE_RELEASED;</a>
<a name="ln2595"> </a>
<a name="ln2596">  /*</a>
<a name="ln2597">   * JUMP!</a>
<a name="ln2598">   */</a>
<a name="ln2599">  jump_flags = jump_to_mouse(jump_flags,</a>
<a name="ln2600">                             oap == NULL ? NULL : &amp;(oap-&gt;inclusive),</a>
<a name="ln2601">                             which_button);</a>
<a name="ln2602"> </a>
<a name="ln2603">  moved = (jump_flags &amp; CURSOR_MOVED);</a>
<a name="ln2604">  in_status_line = (jump_flags &amp; IN_STATUS_LINE);</a>
<a name="ln2605">  in_sep_line = (jump_flags &amp; IN_SEP_LINE);</a>
<a name="ln2606"> </a>
<a name="ln2607"> </a>
<a name="ln2608">  /* When jumping to another window, clear a pending operator.  That's a bit</a>
<a name="ln2609">   * friendlier than beeping and not jumping to that window. */</a>
<a name="ln2610">  if (curwin != old_curwin &amp;&amp; oap != NULL &amp;&amp; oap-&gt;op_type != OP_NOP)</a>
<a name="ln2611">    clearop(oap);</a>
<a name="ln2612"> </a>
<a name="ln2613">  if (mod_mask == 0</a>
<a name="ln2614">      &amp;&amp; !is_drag</a>
<a name="ln2615">      &amp;&amp; (jump_flags &amp; (MOUSE_FOLD_CLOSE | MOUSE_FOLD_OPEN))</a>
<a name="ln2616">      &amp;&amp; which_button == MOUSE_LEFT) {</a>
<a name="ln2617">    // open or close a fold at this line</a>
<a name="ln2618">    if (jump_flags &amp; MOUSE_FOLD_OPEN) {</a>
<a name="ln2619">      openFold(curwin-&gt;w_cursor, 1L);</a>
<a name="ln2620">    } else {</a>
<a name="ln2621">      closeFold(curwin-&gt;w_cursor, 1L);</a>
<a name="ln2622">    }</a>
<a name="ln2623">    // don't move the cursor if still in the same window</a>
<a name="ln2624">    if (curwin == old_curwin) {</a>
<a name="ln2625">      curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln2626">    }</a>
<a name="ln2627">  }</a>
<a name="ln2628"> </a>
<a name="ln2629"> </a>
<a name="ln2630">  /* Set global flag that we are extending the Visual area with mouse</a>
<a name="ln2631">   * dragging; temporarily minimize 'scrolloff'. */</a>
<a name="ln2632">  if (VIsual_active &amp;&amp; is_drag &amp;&amp; get_scrolloff_value(curwin)) {</a>
<a name="ln2633">    // In the very first line, allow scrolling one line</a>
<a name="ln2634">    if (mouse_row == 0) {</a>
<a name="ln2635">      mouse_dragging = 2;</a>
<a name="ln2636">    } else {</a>
<a name="ln2637">      mouse_dragging = 1;</a>
<a name="ln2638">    }</a>
<a name="ln2639">  }</a>
<a name="ln2640"> </a>
<a name="ln2641">  /* When dragging the mouse above the window, scroll down. */</a>
<a name="ln2642">  if (is_drag &amp;&amp; mouse_row &lt; 0 &amp;&amp; !in_status_line) {</a>
<a name="ln2643">    scroll_redraw(false, 1L);</a>
<a name="ln2644">    mouse_row = 0;</a>
<a name="ln2645">  }</a>
<a name="ln2646"> </a>
<a name="ln2647">  if (start_visual.lnum) {              /* right click in visual mode */</a>
<a name="ln2648">    /* When ALT is pressed make Visual mode blockwise. */</a>
<a name="ln2649">    if (mod_mask &amp; MOD_MASK_ALT)</a>
<a name="ln2650">      VIsual_mode = Ctrl_V;</a>
<a name="ln2651"> </a>
<a name="ln2652">    /*</a>
<a name="ln2653">     * In Visual-block mode, divide the area in four, pick up the corner</a>
<a name="ln2654">     * that is in the quarter that the cursor is in.</a>
<a name="ln2655">     */</a>
<a name="ln2656">    if (VIsual_mode == Ctrl_V) {</a>
<a name="ln2657">      getvcols(curwin, &amp;start_visual, &amp;end_visual, &amp;leftcol, &amp;rightcol);</a>
<a name="ln2658">      if (curwin-&gt;w_curswant &gt; (leftcol + rightcol) / 2)</a>
<a name="ln2659">        end_visual.col = leftcol;</a>
<a name="ln2660">      else</a>
<a name="ln2661">        end_visual.col = rightcol;</a>
<a name="ln2662">      if (curwin-&gt;w_cursor.lnum &gt;=</a>
<a name="ln2663">          (start_visual.lnum + end_visual.lnum) / 2) {</a>
<a name="ln2664">        end_visual.lnum = start_visual.lnum;</a>
<a name="ln2665">      }</a>
<a name="ln2666"> </a>
<a name="ln2667">      /* move VIsual to the right column */</a>
<a name="ln2668">      start_visual = curwin-&gt;w_cursor;              /* save the cursor pos */</a>
<a name="ln2669">      curwin-&gt;w_cursor = end_visual;</a>
<a name="ln2670">      coladvance(end_visual.col);</a>
<a name="ln2671">      VIsual = curwin-&gt;w_cursor;</a>
<a name="ln2672">      curwin-&gt;w_cursor = start_visual;              /* restore the cursor */</a>
<a name="ln2673">    } else {</a>
<a name="ln2674">      /*</a>
<a name="ln2675">       * If the click is before the start of visual, change the start.</a>
<a name="ln2676">       * If the click is after the end of visual, change the end.  If</a>
<a name="ln2677">       * the click is inside the visual, change the closest side.</a>
<a name="ln2678">       */</a>
<a name="ln2679">      if (lt(curwin-&gt;w_cursor, start_visual))</a>
<a name="ln2680">        VIsual = end_visual;</a>
<a name="ln2681">      else if (lt(end_visual, curwin-&gt;w_cursor))</a>
<a name="ln2682">        VIsual = start_visual;</a>
<a name="ln2683">      else {</a>
<a name="ln2684">        /* In the same line, compare column number */</a>
<a name="ln2685">        if (end_visual.lnum == start_visual.lnum) {</a>
<a name="ln2686">          if (curwin-&gt;w_cursor.col - start_visual.col &gt;</a>
<a name="ln2687">              end_visual.col - curwin-&gt;w_cursor.col)</a>
<a name="ln2688">            VIsual = start_visual;</a>
<a name="ln2689">          else</a>
<a name="ln2690">            VIsual = end_visual;</a>
<a name="ln2691">        }</a>
<a name="ln2692">        /* In different lines, compare line number */</a>
<a name="ln2693">        else {</a>
<a name="ln2694">          diff = (curwin-&gt;w_cursor.lnum - start_visual.lnum) -</a>
<a name="ln2695">                 (end_visual.lnum - curwin-&gt;w_cursor.lnum);</a>
<a name="ln2696"> </a>
<a name="ln2697">          if (diff &gt; 0)                         /* closest to end */</a>
<a name="ln2698">            VIsual = start_visual;</a>
<a name="ln2699">          else if (diff &lt; 0)            /* closest to start */</a>
<a name="ln2700">            VIsual = end_visual;</a>
<a name="ln2701">          else {                                /* in the middle line */</a>
<a name="ln2702">            if (curwin-&gt;w_cursor.col &lt;</a>
<a name="ln2703">                (start_visual.col + end_visual.col) / 2)</a>
<a name="ln2704">              VIsual = end_visual;</a>
<a name="ln2705">            else</a>
<a name="ln2706">              VIsual = start_visual;</a>
<a name="ln2707">          }</a>
<a name="ln2708">        }</a>
<a name="ln2709">      }</a>
<a name="ln2710">    }</a>
<a name="ln2711">  }</a>
<a name="ln2712">  /*</a>
<a name="ln2713">   * If Visual mode started in insert mode, execute &quot;CTRL-O&quot;</a>
<a name="ln2714">   */</a>
<a name="ln2715">  else if ((State &amp; INSERT) &amp;&amp; VIsual_active)</a>
<a name="ln2716">    stuffcharReadbuff(Ctrl_O);</a>
<a name="ln2717"> </a>
<a name="ln2718">  /*</a>
<a name="ln2719">   * Middle mouse click: Put text before cursor.</a>
<a name="ln2720">   */</a>
<a name="ln2721">  if (which_button == MOUSE_MIDDLE) {</a>
<a name="ln2722">    if (regname == 0 &amp;&amp; eval_has_provider(&quot;clipboard&quot;)) {</a>
<a name="ln2723">      regname = '*';</a>
<a name="ln2724">    }</a>
<a name="ln2725">    if (yank_register_mline(regname)) {</a>
<a name="ln2726">      if (mouse_past_bottom)</a>
<a name="ln2727">        dir = FORWARD;</a>
<a name="ln2728">    } else if (mouse_past_eol)</a>
<a name="ln2729">      dir = FORWARD;</a>
<a name="ln2730"> </a>
<a name="ln2731">    if (fixindent) {</a>
<a name="ln2732">      c1 = (dir == BACKWARD) ? '[' : ']';</a>
<a name="ln2733">      c2 = 'p';</a>
<a name="ln2734">    } else {</a>
<a name="ln2735">      c1 = (dir == FORWARD) ? 'p' : 'P';</a>
<a name="ln2736">      c2 = NUL;</a>
<a name="ln2737">    }</a>
<a name="ln2738">    prep_redo(regname, count, NUL, c1, NUL, c2, NUL);</a>
<a name="ln2739"> </a>
<a name="ln2740">    /*</a>
<a name="ln2741">     * Remember where the paste started, so in edit() Insstart can be set</a>
<a name="ln2742">     * to this position</a>
<a name="ln2743">     */</a>
<a name="ln2744">    if (restart_edit != 0)</a>
<a name="ln2745">      where_paste_started = curwin-&gt;w_cursor;</a>
<a name="ln2746">    do_put(regname, NULL, dir, count,</a>
<a name="ln2747">           (fixindent ? PUT_FIXINDENT : 0)| PUT_CURSEND);</a>
<a name="ln2748">  }</a>
<a name="ln2749">  /*</a>
<a name="ln2750">   * Ctrl-Mouse click or double click in a quickfix window jumps to the</a>
<a name="ln2751">   * error under the mouse pointer.</a>
<a name="ln2752">   */</a>
<a name="ln2753">  else if (((mod_mask &amp; MOD_MASK_CTRL)</a>
<a name="ln2754">            || (mod_mask &amp; MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)</a>
<a name="ln2755">           &amp;&amp; bt_quickfix(curbuf)) {</a>
<a name="ln2756">    if (curwin-&gt;w_llist_ref == NULL) {          // quickfix window</a>
<a name="ln2757">      do_cmdline_cmd(&quot;.cc&quot;);</a>
<a name="ln2758">    } else {                                    // location list window</a>
<a name="ln2759">      do_cmdline_cmd(&quot;.ll&quot;);</a>
<a name="ln2760">    }</a>
<a name="ln2761">    got_click = false;                  // ignore drag&amp;release now</a>
<a name="ln2762">  }</a>
<a name="ln2763">  /*</a>
<a name="ln2764">   * Ctrl-Mouse click (or double click in a help window) jumps to the tag</a>
<a name="ln2765">   * under the mouse pointer.</a>
<a name="ln2766">   */</a>
<a name="ln2767">  else if ((mod_mask &amp; MOD_MASK_CTRL) || (curbuf-&gt;b_help</a>
<a name="ln2768">                                          &amp;&amp; (mod_mask &amp;</a>
<a name="ln2769">                                              MOD_MASK_MULTI_CLICK) ==</a>
<a name="ln2770">                                          MOD_MASK_2CLICK)) {</a>
<a name="ln2771">    if (State &amp; INSERT)</a>
<a name="ln2772">      stuffcharReadbuff(Ctrl_O);</a>
<a name="ln2773">    stuffcharReadbuff(Ctrl_RSB);</a>
<a name="ln2774">    got_click = false;                  /* ignore drag&amp;release now */</a>
<a name="ln2775">  }</a>
<a name="ln2776">  /*</a>
<a name="ln2777">   * Shift-Mouse click searches for the next occurrence of the word under</a>
<a name="ln2778">   * the mouse pointer</a>
<a name="ln2779">   */</a>
<a name="ln2780">  else if ((mod_mask &amp; MOD_MASK_SHIFT)) {</a>
<a name="ln2781">    if (State &amp; INSERT</a>
<a name="ln2782">        || (VIsual_active &amp;&amp; VIsual_select)</a>
<a name="ln2783">        )</a>
<a name="ln2784">      stuffcharReadbuff(Ctrl_O);</a>
<a name="ln2785">    if (which_button == MOUSE_LEFT)</a>
<a name="ln2786">      stuffcharReadbuff('*');</a>
<a name="ln2787">    else        /* MOUSE_RIGHT */</a>
<a name="ln2788">      stuffcharReadbuff('#');</a>
<a name="ln2789">  }</a>
<a name="ln2790">  /* Handle double clicks, unless on status line */</a>
<a name="ln2791">  else if (in_status_line) {</a>
<a name="ln2792">  } else if (in_sep_line) {</a>
<a name="ln2793">  } else if ((mod_mask &amp; MOD_MASK_MULTI_CLICK) &amp;&amp; (State &amp; (NORMAL | INSERT))) {</a>
<a name="ln2794">    if (is_click || !VIsual_active) {</a>
<a name="ln2795">      if (VIsual_active) {</a>
<a name="ln2796">        orig_cursor = VIsual;</a>
<a name="ln2797">      } else {</a>
<a name="ln2798">        VIsual = curwin-&gt;w_cursor;</a>
<a name="ln2799">        orig_cursor = VIsual;</a>
<a name="ln2800">        VIsual_active = true;</a>
<a name="ln2801">        VIsual_reselect = true;</a>
<a name="ln2802">        /* start Select mode if 'selectmode' contains &quot;mouse&quot; */</a>
<a name="ln2803">        may_start_select('o');</a>
<a name="ln2804">        setmouse();</a>
<a name="ln2805">      }</a>
<a name="ln2806">      if ((mod_mask &amp; MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK) {</a>
<a name="ln2807">        /* Double click with ALT pressed makes it blockwise. */</a>
<a name="ln2808">        if (mod_mask &amp; MOD_MASK_ALT)</a>
<a name="ln2809">          VIsual_mode = Ctrl_V;</a>
<a name="ln2810">        else</a>
<a name="ln2811">          VIsual_mode = 'v';</a>
<a name="ln2812">      } else if ((mod_mask &amp; MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)</a>
<a name="ln2813">        VIsual_mode = 'V';</a>
<a name="ln2814">      else if ((mod_mask &amp; MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)</a>
<a name="ln2815">        VIsual_mode = Ctrl_V;</a>
<a name="ln2816">    }</a>
<a name="ln2817">    /*</a>
<a name="ln2818">     * A double click selects a word or a block.</a>
<a name="ln2819">     */</a>
<a name="ln2820">    if ((mod_mask &amp; MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK) {</a>
<a name="ln2821">      pos_T       *pos = NULL;</a>
<a name="ln2822">      int gc;</a>
<a name="ln2823"> </a>
<a name="ln2824">      if (is_click) {</a>
<a name="ln2825">        /* If the character under the cursor (skipping white space) is</a>
<a name="ln2826">         * not a word character, try finding a match and select a (),</a>
<a name="ln2827">         * {}, [], #if/#endif, etc. block. */</a>
<a name="ln2828">        end_visual = curwin-&gt;w_cursor;</a>
<a name="ln2829">        while (gc = gchar_pos(&amp;end_visual), ascii_iswhite(gc))</a>
<a name="ln2830">          inc(&amp;end_visual);</a>
<a name="ln2831">        if (oap != NULL) {</a>
<a name="ln2832">          oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln2833">        }</a>
<a name="ln2834">        if (oap != NULL</a>
<a name="ln2835">            &amp;&amp; VIsual_mode == 'v'</a>
<a name="ln2836">            &amp;&amp; !vim_iswordc(gchar_pos(&amp;end_visual))</a>
<a name="ln2837">            &amp;&amp; equalpos(curwin-&gt;w_cursor, VIsual)</a>
<a name="ln2838">            &amp;&amp; (pos = findmatch(oap, NUL)) != NULL) {</a>
<a name="ln2839">          curwin-&gt;w_cursor = *pos;</a>
<a name="ln2840">          if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln2841">            VIsual_mode = 'V';</a>
<a name="ln2842">          } else if (*p_sel == 'e') {</a>
<a name="ln2843">            if (lt(curwin-&gt;w_cursor, VIsual)) {</a>
<a name="ln2844">              VIsual.col++;</a>
<a name="ln2845">            } else {</a>
<a name="ln2846">              curwin-&gt;w_cursor.col++;</a>
<a name="ln2847">            }</a>
<a name="ln2848">          }</a>
<a name="ln2849">        }</a>
<a name="ln2850">      }</a>
<a name="ln2851"> </a>
<a name="ln2852">      if (pos == NULL &amp;&amp; (is_click || is_drag)) {</a>
<a name="ln2853">        /* When not found a match or when dragging: extend to include</a>
<a name="ln2854">         * a word. */</a>
<a name="ln2855">        if (lt(curwin-&gt;w_cursor, orig_cursor)) {</a>
<a name="ln2856">          find_start_of_word(&amp;curwin-&gt;w_cursor);</a>
<a name="ln2857">          find_end_of_word(&amp;VIsual);</a>
<a name="ln2858">        } else {</a>
<a name="ln2859">          find_start_of_word(&amp;VIsual);</a>
<a name="ln2860">          if (*p_sel == 'e' &amp;&amp; *get_cursor_pos_ptr() != NUL)</a>
<a name="ln2861">            curwin-&gt;w_cursor.col +=</a>
<a name="ln2862">              (*mb_ptr2len)(get_cursor_pos_ptr());</a>
<a name="ln2863">          find_end_of_word(&amp;curwin-&gt;w_cursor);</a>
<a name="ln2864">        }</a>
<a name="ln2865">      }</a>
<a name="ln2866">      curwin-&gt;w_set_curswant = true;</a>
<a name="ln2867">    }</a>
<a name="ln2868">    if (is_click)</a>
<a name="ln2869">      redraw_curbuf_later(INVERTED);            /* update the inversion */</a>
<a name="ln2870">  } else if (VIsual_active &amp;&amp; !old_active) {</a>
<a name="ln2871">    if (mod_mask &amp; MOD_MASK_ALT)</a>
<a name="ln2872">      VIsual_mode = Ctrl_V;</a>
<a name="ln2873">    else</a>
<a name="ln2874">      VIsual_mode = 'v';</a>
<a name="ln2875">  }</a>
<a name="ln2876"> </a>
<a name="ln2877">  /* If Visual mode changed show it later. */</a>
<a name="ln2878">  if ((!VIsual_active &amp;&amp; old_active &amp;&amp; mode_displayed)</a>
<a name="ln2879">      || (VIsual_active &amp;&amp; p_smd &amp;&amp; msg_silent == 0</a>
<a name="ln2880">          &amp;&amp; (!old_active || VIsual_mode != old_mode)))</a>
<a name="ln2881">    redraw_cmdline = true;</a>
<a name="ln2882"> </a>
<a name="ln2883">  return moved;</a>
<a name="ln2884">}</a>
<a name="ln2885"> </a>
<a name="ln2886">/*</a>
<a name="ln2887"> * Move &quot;pos&quot; back to the start of the word it's in.</a>
<a name="ln2888"> */</a>
<a name="ln2889">static void find_start_of_word(pos_T *pos)</a>
<a name="ln2890">{</a>
<a name="ln2891">  char_u      *line;</a>
<a name="ln2892">  int cclass;</a>
<a name="ln2893">  int col;</a>
<a name="ln2894"> </a>
<a name="ln2895">  line = ml_get(pos-&gt;lnum);</a>
<a name="ln2896">  cclass = get_mouse_class(line + pos-&gt;col);</a>
<a name="ln2897"> </a>
<a name="ln2898">  while (pos-&gt;col &gt; 0) {</a>
<a name="ln2899">    col = pos-&gt;col - 1;</a>
<a name="ln2900">    col -= utf_head_off(line, line + col);</a>
<a name="ln2901">    if (get_mouse_class(line + col) != cclass) {</a>
<a name="ln2902">      break;</a>
<a name="ln2903">    }</a>
<a name="ln2904">    pos-&gt;col = col;</a>
<a name="ln2905">  }</a>
<a name="ln2906">}</a>
<a name="ln2907"> </a>
<a name="ln2908">/*</a>
<a name="ln2909"> * Move &quot;pos&quot; forward to the end of the word it's in.</a>
<a name="ln2910"> * When 'selection' is &quot;exclusive&quot;, the position is just after the word.</a>
<a name="ln2911"> */</a>
<a name="ln2912">static void find_end_of_word(pos_T *pos)</a>
<a name="ln2913">{</a>
<a name="ln2914">  char_u      *line;</a>
<a name="ln2915">  int cclass;</a>
<a name="ln2916">  int col;</a>
<a name="ln2917"> </a>
<a name="ln2918">  line = ml_get(pos-&gt;lnum);</a>
<a name="ln2919">  if (*p_sel == 'e' &amp;&amp; pos-&gt;col &gt; 0) {</a>
<a name="ln2920">    pos-&gt;col--;</a>
<a name="ln2921">    pos-&gt;col -= utf_head_off(line, line + pos-&gt;col);</a>
<a name="ln2922">  }</a>
<a name="ln2923">  cclass = get_mouse_class(line + pos-&gt;col);</a>
<a name="ln2924">  while (line[pos-&gt;col] != NUL) {</a>
<a name="ln2925">    col = pos-&gt;col + (*mb_ptr2len)(line + pos-&gt;col);</a>
<a name="ln2926">    if (get_mouse_class(line + col) != cclass) {</a>
<a name="ln2927">      if (*p_sel == 'e')</a>
<a name="ln2928">        pos-&gt;col = col;</a>
<a name="ln2929">      break;</a>
<a name="ln2930">    }</a>
<a name="ln2931">    pos-&gt;col = col;</a>
<a name="ln2932">  }</a>
<a name="ln2933">}</a>
<a name="ln2934"> </a>
<a name="ln2935">/*</a>
<a name="ln2936"> * Get class of a character for selection: same class means same word.</a>
<a name="ln2937"> * 0: blank</a>
<a name="ln2938"> * 1: punctuation groups</a>
<a name="ln2939"> * 2: normal word character</a>
<a name="ln2940"> * &gt;2: multi-byte word character.</a>
<a name="ln2941"> */</a>
<a name="ln2942">static int get_mouse_class(char_u *p)</a>
<a name="ln2943">{</a>
<a name="ln2944">  if (MB_BYTE2LEN(p[0]) &gt; 1) {</a>
<a name="ln2945">    return mb_get_class(p);</a>
<a name="ln2946">  }</a>
<a name="ln2947"> </a>
<a name="ln2948">  const int c = *p;</a>
<a name="ln2949">  if (c == ' ' || c == '\t') {</a>
<a name="ln2950">    return 0;</a>
<a name="ln2951">  }</a>
<a name="ln2952">  if (vim_iswordc(c)) {</a>
<a name="ln2953">    return 2;</a>
<a name="ln2954">  }</a>
<a name="ln2955"> </a>
<a name="ln2956">  /*</a>
<a name="ln2957">   * There are a few special cases where we want certain combinations of</a>
<a name="ln2958">   * characters to be considered as a single word.  These are things like</a>
<a name="ln2959">   * &quot;-&gt;&quot;, &quot;/ *&quot;, &quot;*=&quot;, &quot;+=&quot;, &quot;&amp;=&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot;, &quot;!=&quot; etc.  Otherwise, each</a>
<a name="ln2960">   * character is in its own class.</a>
<a name="ln2961">   */</a>
<a name="ln2962">  if (c != NUL &amp;&amp; vim_strchr((char_u *)&quot;-+*/%&lt;&gt;&amp;|^!=&quot;, c) != NULL)</a>
<a name="ln2963">    return 1;</a>
<a name="ln2964">  return c;</a>
<a name="ln2965">}</a>
<a name="ln2966"> </a>
<a name="ln2967">/*</a>
<a name="ln2968"> * End Visual mode.</a>
<a name="ln2969"> * This function should ALWAYS be called to end Visual mode, except from</a>
<a name="ln2970"> * do_pending_operator().</a>
<a name="ln2971"> */</a>
<a name="ln2972">void end_visual_mode(void)</a>
<a name="ln2973">{</a>
<a name="ln2974"> </a>
<a name="ln2975">  VIsual_active = false;</a>
<a name="ln2976">  setmouse();</a>
<a name="ln2977">  mouse_dragging = 0;</a>
<a name="ln2978"> </a>
<a name="ln2979">  /* Save the current VIsual area for '&lt; and '&gt; marks, and &quot;gv&quot; */</a>
<a name="ln2980">  curbuf-&gt;b_visual.vi_mode = VIsual_mode;</a>
<a name="ln2981">  curbuf-&gt;b_visual.vi_start = VIsual;</a>
<a name="ln2982">  curbuf-&gt;b_visual.vi_end = curwin-&gt;w_cursor;</a>
<a name="ln2983">  curbuf-&gt;b_visual.vi_curswant = curwin-&gt;w_curswant;</a>
<a name="ln2984">  curbuf-&gt;b_visual_mode_eval = VIsual_mode;</a>
<a name="ln2985">  if (!virtual_active())</a>
<a name="ln2986">    curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2987"> </a>
<a name="ln2988">  may_clear_cmdline();</a>
<a name="ln2989"> </a>
<a name="ln2990">  adjust_cursor_eol();</a>
<a name="ln2991">}</a>
<a name="ln2992"> </a>
<a name="ln2993">/*</a>
<a name="ln2994"> * Reset VIsual_active and VIsual_reselect.</a>
<a name="ln2995"> */</a>
<a name="ln2996">void reset_VIsual_and_resel(void)</a>
<a name="ln2997">{</a>
<a name="ln2998">  if (VIsual_active) {</a>
<a name="ln2999">    end_visual_mode();</a>
<a name="ln3000">    redraw_curbuf_later(INVERTED);      /* delete the inversion later */</a>
<a name="ln3001">  }</a>
<a name="ln3002">  VIsual_reselect = false;</a>
<a name="ln3003">}</a>
<a name="ln3004"> </a>
<a name="ln3005">/*</a>
<a name="ln3006"> * Reset VIsual_active and VIsual_reselect if it's set.</a>
<a name="ln3007"> */</a>
<a name="ln3008">void reset_VIsual(void)</a>
<a name="ln3009">{</a>
<a name="ln3010">  if (VIsual_active) {</a>
<a name="ln3011">    end_visual_mode();</a>
<a name="ln3012">    redraw_curbuf_later(INVERTED);      /* delete the inversion later */</a>
<a name="ln3013">    VIsual_reselect = false;</a>
<a name="ln3014">  }</a>
<a name="ln3015">}</a>
<a name="ln3016"> </a>
<a name="ln3017">// Check for a balloon-eval special item to include when searching for an</a>
<a name="ln3018">// identifier.  When &quot;dir&quot; is BACKWARD &quot;ptr[-1]&quot; must be valid!</a>
<a name="ln3019">// Returns true if the character at &quot;*ptr&quot; should be included.</a>
<a name="ln3020">// &quot;dir&quot; is FORWARD or BACKWARD, the direction of searching.</a>
<a name="ln3021">// &quot;*colp&quot; is in/decremented if &quot;ptr[-dir]&quot; should also be included.</a>
<a name="ln3022">// &quot;bnp&quot; points to a counter for square brackets.</a>
<a name="ln3023">static bool find_is_eval_item(</a>
<a name="ln3024">    const char_u *const ptr,</a>
<a name="ln3025">    int *const colp,</a>
<a name="ln3026">    int *const bnp,</a>
<a name="ln3027">    const int dir)</a>
<a name="ln3028">{</a>
<a name="ln3029">  // Accept everything inside [].</a>
<a name="ln3030">  if ((*ptr == ']' &amp;&amp; dir == BACKWARD) || (*ptr == '[' &amp;&amp; dir == FORWARD)) {</a>
<a name="ln3031">    *bnp += 1;</a>
<a name="ln3032">  }</a>
<a name="ln3033">  if (*bnp &gt; 0) {</a>
<a name="ln3034">    if ((*ptr == '[' &amp;&amp; dir == BACKWARD) || (*ptr == ']' &amp;&amp; dir == FORWARD)) {</a>
<a name="ln3035">      *bnp -= 1;</a>
<a name="ln3036">    }</a>
<a name="ln3037">    return true;</a>
<a name="ln3038">  }</a>
<a name="ln3039"> </a>
<a name="ln3040">  // skip over &quot;s.var&quot;</a>
<a name="ln3041">  if (*ptr == '.') {</a>
<a name="ln3042">    return true;</a>
<a name="ln3043">  }</a>
<a name="ln3044"> </a>
<a name="ln3045">  // two-character item: s-&gt;var</a>
<a name="ln3046">  if (ptr[dir == BACKWARD ? 0 : 1] == '&gt;'</a>
<a name="ln3047">      &amp;&amp; ptr[dir == BACKWARD ? -1 : 0] == '-') {</a>
<a name="ln3048">    *colp += dir;</a>
<a name="ln3049">    return true;</a>
<a name="ln3050">  }</a>
<a name="ln3051">  return false;</a>
<a name="ln3052">}</a>
<a name="ln3053"> </a>
<a name="ln3054">// Find the identifier under or to the right of the cursor.</a>
<a name="ln3055">// &quot;find_type&quot; can have one of three values:</a>
<a name="ln3056">// FIND_IDENT:   find an identifier (keyword)</a>
<a name="ln3057">// FIND_STRING:  find any non-white text</a>
<a name="ln3058">// FIND_IDENT + FIND_STRING: find any non-white text, identifier preferred.</a>
<a name="ln3059">// FIND_EVAL:  find text useful for C program debugging</a>
<a name="ln3060">//</a>
<a name="ln3061">// There are three steps:</a>
<a name="ln3062">// 1. Search forward for the start of an identifier/text.  Doesn't move if</a>
<a name="ln3063">//    already on one.</a>
<a name="ln3064">// 2. Search backward for the start of this identifier/text.</a>
<a name="ln3065">//    This doesn't match the real Vi but I like it a little better and it</a>
<a name="ln3066">//    shouldn't bother anyone.</a>
<a name="ln3067">// 3. Search forward to the end of this identifier/text.</a>
<a name="ln3068">//    When FIND_IDENT isn't defined, we backup until a blank.</a>
<a name="ln3069">//</a>
<a name="ln3070">// Returns the length of the text, or zero if no text is found.</a>
<a name="ln3071">// If text is found, a pointer to the text is put in &quot;*text&quot;.  This</a>
<a name="ln3072">// points into the current buffer line and is not always NUL terminated.</a>
<a name="ln3073">size_t find_ident_under_cursor(char_u **text, int find_type)</a>
<a name="ln3074">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3075">{</a>
<a name="ln3076">  return find_ident_at_pos(curwin, curwin-&gt;w_cursor.lnum,</a>
<a name="ln3077">                           curwin-&gt;w_cursor.col, text, NULL, find_type);</a>
<a name="ln3078">}</a>
<a name="ln3079"> </a>
<a name="ln3080">/*</a>
<a name="ln3081"> * Like find_ident_under_cursor(), but for any window and any position.</a>
<a name="ln3082"> * However: Uses 'iskeyword' from the current window!.</a>
<a name="ln3083"> */</a>
<a name="ln3084">size_t find_ident_at_pos(</a>
<a name="ln3085">    win_T *wp,</a>
<a name="ln3086">    linenr_T lnum,</a>
<a name="ln3087">    colnr_T startcol,</a>
<a name="ln3088">    char_u **text,</a>
<a name="ln3089">    int *textcol,      // column where &quot;text&quot; starts, can be NULL</a>
<a name="ln3090">    int find_type)</a>
<a name="ln3091">  FUNC_ATTR_NONNULL_ARG(1, 4)</a>
<a name="ln3092">{</a>
<a name="ln3093">  int col = 0;         // init to shut up GCC</a>
<a name="ln3094">  int i;</a>
<a name="ln3095">  int this_class = 0;</a>
<a name="ln3096">  int prev_class;</a>
<a name="ln3097">  int prevcol;</a>
<a name="ln3098">  int bn = 0;                       // bracket nesting</a>
<a name="ln3099"> </a>
<a name="ln3100">  // if i == 0: try to find an identifier</a>
<a name="ln3101">  // if i == 1: try to find any non-white text</a>
<a name="ln3102">  char_u *ptr = ml_get_buf(wp-&gt;w_buffer, lnum, false);</a>
<a name="ln3103">  for (i = (find_type &amp; FIND_IDENT) ? 0 : 1; i &lt; 2; i++) {</a>
<a name="ln3104">    // 1. skip to start of identifier/text</a>
<a name="ln3105">    col = startcol;</a>
<a name="ln3106">    while (ptr[col] != NUL) {</a>
<a name="ln3107">      // Stop at a ']' to evaluate &quot;a[x]&quot;.</a>
<a name="ln3108">      if ((find_type &amp; FIND_EVAL) &amp;&amp; ptr[col] == ']') {</a>
<a name="ln3109">        break;</a>
<a name="ln3110">      }</a>
<a name="ln3111">      this_class = mb_get_class(ptr + col);</a>
<a name="ln3112">      if (this_class != 0 &amp;&amp; (i == 1 || this_class != 1)) {</a>
<a name="ln3113">        break;</a>
<a name="ln3114">      }</a>
<a name="ln3115">      col += utfc_ptr2len(ptr + col);</a>
<a name="ln3116">    }</a>
<a name="ln3117"> </a>
<a name="ln3118">    // When starting on a ']' count it, so that we include the '['.</a>
<a name="ln3119">    bn = ptr[col] == ']';</a>
<a name="ln3120"> </a>
<a name="ln3121">    //</a>
<a name="ln3122">    // 2. Back up to start of identifier/text.</a>
<a name="ln3123">    //</a>
<a name="ln3124">    // Remember class of character under cursor.</a>
<a name="ln3125">    if ((find_type &amp; FIND_EVAL) &amp;&amp; ptr[col] == ']') {</a>
<a name="ln3126">      this_class = mb_get_class((char_u *)&quot;a&quot;);</a>
<a name="ln3127">    } else {</a>
<a name="ln3128">      this_class = mb_get_class(ptr + col);</a>
<a name="ln3129">    }</a>
<a name="ln3130">    while (col &gt; 0 &amp;&amp; this_class != 0) {</a>
<a name="ln3131">      prevcol = col - 1 - utf_head_off(ptr, ptr + col - 1);</a>
<a name="ln3132">      prev_class = mb_get_class(ptr + prevcol);</a>
<a name="ln3133">      if (this_class != prev_class</a>
<a name="ln3134">          &amp;&amp; (i == 0</a>
<a name="ln3135">              || prev_class == 0</a>
<a name="ln3136">              || (find_type &amp; FIND_IDENT))</a>
<a name="ln3137">          &amp;&amp; (!(find_type &amp; FIND_EVAL)</a>
<a name="ln3138">              || prevcol == 0</a>
<a name="ln3139">              || !find_is_eval_item(ptr + prevcol, &amp;prevcol, &amp;bn, BACKWARD))) {</a>
<a name="ln3140">        break;</a>
<a name="ln3141">      }</a>
<a name="ln3142">      col = prevcol;</a>
<a name="ln3143">    }</a>
<a name="ln3144"> </a>
<a name="ln3145">    // If we don't want just any old text, or we've found an</a>
<a name="ln3146">    // identifier, stop searching.</a>
<a name="ln3147">    if (this_class &gt; 2) {</a>
<a name="ln3148">      this_class = 2;</a>
<a name="ln3149">    }</a>
<a name="ln3150">    if (!(find_type &amp; FIND_STRING) || this_class == 2) {</a>
<a name="ln3151">      break;</a>
<a name="ln3152">    }</a>
<a name="ln3153">  }</a>
<a name="ln3154"> </a>
<a name="ln3155">  if (ptr[col] == NUL || (i == 0 &amp;&amp; this_class != 2)) {</a>
<a name="ln3156">    // Didn't find an identifier or text.</a>
<a name="ln3157">    if (find_type &amp; FIND_STRING) {</a>
<a name="ln3158">      EMSG(_(&quot;E348: No string under cursor&quot;));</a>
<a name="ln3159">    } else {</a>
<a name="ln3160">      EMSG(_(e_noident));</a>
<a name="ln3161">    }</a>
<a name="ln3162">    return 0;</a>
<a name="ln3163">  }</a>
<a name="ln3164">  ptr += col;</a>
<a name="ln3165">  *text = ptr;</a>
<a name="ln3166">  if (textcol != NULL) {</a>
<a name="ln3167">    *textcol = col;</a>
<a name="ln3168">  }</a>
<a name="ln3169"> </a>
<a name="ln3170">  // 3. Find the end if the identifier/text.</a>
<a name="ln3171">  bn = 0;</a>
<a name="ln3172">  startcol -= col;</a>
<a name="ln3173">  col = 0;</a>
<a name="ln3174">  // Search for point of changing multibyte character class.</a>
<a name="ln3175">  this_class = mb_get_class(ptr);</a>
<a name="ln3176">  while (ptr[col] != NUL</a>
<a name="ln3177">         &amp;&amp; ((i == 0</a>
<a name="ln3178">              ? mb_get_class(ptr + col) == this_class</a>
<a name="ln3179">              : mb_get_class(ptr + col) != 0)</a>
<a name="ln3180">             || ((find_type &amp; FIND_EVAL)</a>
<a name="ln3181">                 &amp;&amp; col &lt;= (int)startcol</a>
<a name="ln3182">                 &amp;&amp; find_is_eval_item(ptr + col, &amp;col, &amp;bn, FORWARD)))) {</a>
<a name="ln3183">    col += utfc_ptr2len(ptr + col);</a>
<a name="ln3184">  }</a>
<a name="ln3185"> </a>
<a name="ln3186">  assert(col &gt;= 0);</a>
<a name="ln3187">  return (size_t)col;</a>
<a name="ln3188">}</a>
<a name="ln3189"> </a>
<a name="ln3190">/*</a>
<a name="ln3191"> * Prepare for redo of a normal command.</a>
<a name="ln3192"> */</a>
<a name="ln3193">static void prep_redo_cmd(cmdarg_T *cap)</a>
<a name="ln3194">{</a>
<a name="ln3195">  prep_redo(cap-&gt;oap-&gt;regname, cap-&gt;count0,</a>
<a name="ln3196">      NUL, cap-&gt;cmdchar, NUL, NUL, cap-&gt;nchar);</a>
<a name="ln3197">}</a>
<a name="ln3198"> </a>
<a name="ln3199">/*</a>
<a name="ln3200"> * Prepare for redo of any command.</a>
<a name="ln3201"> * Note that only the last argument can be a multi-byte char.</a>
<a name="ln3202"> */</a>
<a name="ln3203">static void prep_redo(int regname, long num, int cmd1, int cmd2, int cmd3, int cmd4, int cmd5)</a>
<a name="ln3204">{</a>
<a name="ln3205">  ResetRedobuff();</a>
<a name="ln3206">  if (regname != 0) {   /* yank from specified buffer */</a>
<a name="ln3207">    AppendCharToRedobuff('&quot;');</a>
<a name="ln3208">    AppendCharToRedobuff(regname);</a>
<a name="ln3209">  }</a>
<a name="ln3210">  if (num)</a>
<a name="ln3211">    AppendNumberToRedobuff(num);</a>
<a name="ln3212"> </a>
<a name="ln3213">  if (cmd1 != NUL)</a>
<a name="ln3214">    AppendCharToRedobuff(cmd1);</a>
<a name="ln3215">  if (cmd2 != NUL)</a>
<a name="ln3216">    AppendCharToRedobuff(cmd2);</a>
<a name="ln3217">  if (cmd3 != NUL)</a>
<a name="ln3218">    AppendCharToRedobuff(cmd3);</a>
<a name="ln3219">  if (cmd4 != NUL)</a>
<a name="ln3220">    AppendCharToRedobuff(cmd4);</a>
<a name="ln3221">  if (cmd5 != NUL)</a>
<a name="ln3222">    AppendCharToRedobuff(cmd5);</a>
<a name="ln3223">}</a>
<a name="ln3224"> </a>
<a name="ln3225">/*</a>
<a name="ln3226"> * check for operator active and clear it</a>
<a name="ln3227"> *</a>
<a name="ln3228"> * return true if operator was active</a>
<a name="ln3229"> */</a>
<a name="ln3230">static bool checkclearop(oparg_T *oap)</a>
<a name="ln3231">{</a>
<a name="ln3232">  if (oap-&gt;op_type == OP_NOP)</a>
<a name="ln3233">    return false;</a>
<a name="ln3234">  clearopbeep(oap);</a>
<a name="ln3235">  return true;</a>
<a name="ln3236">}</a>
<a name="ln3237"> </a>
<a name="ln3238">/*</a>
<a name="ln3239"> * Check for operator or Visual active.  Clear active operator.</a>
<a name="ln3240"> *</a>
<a name="ln3241"> * Return true if operator or Visual was active.</a>
<a name="ln3242"> */</a>
<a name="ln3243">static bool checkclearopq(oparg_T *oap)</a>
<a name="ln3244">{</a>
<a name="ln3245">  if (oap-&gt;op_type == OP_NOP</a>
<a name="ln3246">      &amp;&amp; !VIsual_active</a>
<a name="ln3247">      )</a>
<a name="ln3248">    return false;</a>
<a name="ln3249">  clearopbeep(oap);</a>
<a name="ln3250">  return true;</a>
<a name="ln3251">}</a>
<a name="ln3252"> </a>
<a name="ln3253">static void clearop(oparg_T *oap)</a>
<a name="ln3254">{</a>
<a name="ln3255">  oap-&gt;op_type = OP_NOP;</a>
<a name="ln3256">  oap-&gt;regname = 0;</a>
<a name="ln3257">  oap-&gt;motion_force = NUL;</a>
<a name="ln3258">  oap-&gt;use_reg_one = false;</a>
<a name="ln3259">}</a>
<a name="ln3260"> </a>
<a name="ln3261">static void clearopbeep(oparg_T *oap)</a>
<a name="ln3262">{</a>
<a name="ln3263">  clearop(oap);</a>
<a name="ln3264">  beep_flush();</a>
<a name="ln3265">}</a>
<a name="ln3266"> </a>
<a name="ln3267">/*</a>
<a name="ln3268"> * Remove the shift modifier from a special key.</a>
<a name="ln3269"> */</a>
<a name="ln3270">static void unshift_special(cmdarg_T *cap)</a>
<a name="ln3271">{</a>
<a name="ln3272">  switch (cap-&gt;cmdchar) {</a>
<a name="ln3273">  case K_S_RIGHT: cap-&gt;cmdchar = K_RIGHT; break;</a>
<a name="ln3274">  case K_S_LEFT:  cap-&gt;cmdchar = K_LEFT; break;</a>
<a name="ln3275">  case K_S_UP:    cap-&gt;cmdchar = K_UP; break;</a>
<a name="ln3276">  case K_S_DOWN:  cap-&gt;cmdchar = K_DOWN; break;</a>
<a name="ln3277">  case K_S_HOME:  cap-&gt;cmdchar = K_HOME; break;</a>
<a name="ln3278">  case K_S_END:   cap-&gt;cmdchar = K_END; break;</a>
<a name="ln3279">  }</a>
<a name="ln3280">  cap-&gt;cmdchar = simplify_key(cap-&gt;cmdchar, &amp;mod_mask);</a>
<a name="ln3281">}</a>
<a name="ln3282"> </a>
<a name="ln3283">/// If the mode is currently displayed clear the command line or update the</a>
<a name="ln3284">/// command displayed.</a>
<a name="ln3285">static void may_clear_cmdline(void)</a>
<a name="ln3286">{</a>
<a name="ln3287">  if (mode_displayed) {</a>
<a name="ln3288">    // unshow visual mode later</a>
<a name="ln3289">    clear_cmdline = true;</a>
<a name="ln3290">  } else {</a>
<a name="ln3291">    clear_showcmd();</a>
<a name="ln3292">  }</a>
<a name="ln3293">}</a>
<a name="ln3294"> </a>
<a name="ln3295">// Routines for displaying a partly typed command</a>
<a name="ln3296"># define SHOWCMD_BUFLEN SHOWCMD_COLS + 1 + 30</a>
<a name="ln3297">static char_u showcmd_buf[SHOWCMD_BUFLEN];</a>
<a name="ln3298">static char_u old_showcmd_buf[SHOWCMD_BUFLEN];    /* For push_showcmd() */</a>
<a name="ln3299">static bool showcmd_is_clear = true;</a>
<a name="ln3300">static bool showcmd_visual = false;</a>
<a name="ln3301"> </a>
<a name="ln3302"> </a>
<a name="ln3303">void clear_showcmd(void)</a>
<a name="ln3304">{</a>
<a name="ln3305">  if (!p_sc)</a>
<a name="ln3306">    return;</a>
<a name="ln3307"> </a>
<a name="ln3308">  if (VIsual_active &amp;&amp; !char_avail()) {</a>
<a name="ln3309">    int cursor_bot = lt(VIsual, curwin-&gt;w_cursor);</a>
<a name="ln3310">    long lines;</a>
<a name="ln3311">    colnr_T leftcol, rightcol;</a>
<a name="ln3312">    linenr_T top, bot;</a>
<a name="ln3313"> </a>
<a name="ln3314">    /* Show the size of the Visual area. */</a>
<a name="ln3315">    if (cursor_bot) {</a>
<a name="ln3316">      top = VIsual.lnum;</a>
<a name="ln3317">      bot = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3318">    } else {</a>
<a name="ln3319">      top = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3320">      bot = VIsual.lnum;</a>
<a name="ln3321">    }</a>
<a name="ln3322">    // Include closed folds as a whole.</a>
<a name="ln3323">    (void)hasFolding(top, &amp;top, NULL);</a>
<a name="ln3324">    (void)hasFolding(bot, NULL, &amp;bot);</a>
<a name="ln3325">    lines = bot - top + 1;</a>
<a name="ln3326"> </a>
<a name="ln3327">    if (VIsual_mode == Ctrl_V) {</a>
<a name="ln3328">      char_u *saved_sbr = p_sbr;</a>
<a name="ln3329"> </a>
<a name="ln3330">      /* Make 'sbr' empty for a moment to get the correct size. */</a>
<a name="ln3331">      p_sbr = empty_option;</a>
<a name="ln3332">      getvcols(curwin, &amp;curwin-&gt;w_cursor, &amp;VIsual, &amp;leftcol, &amp;rightcol);</a>
<a name="ln3333">      p_sbr = saved_sbr;</a>
<a name="ln3334">      snprintf((char *)showcmd_buf, SHOWCMD_BUFLEN, &quot;%&quot; PRId64 &quot;x%&quot; PRId64,</a>
<a name="ln3335">               (int64_t)lines, (int64_t)rightcol - leftcol + 1);</a>
<a name="ln3336">    } else if (VIsual_mode == 'V' || VIsual.lnum != curwin-&gt;w_cursor.lnum) {</a>
<a name="ln3337">      snprintf((char *)showcmd_buf, SHOWCMD_BUFLEN, &quot;%&quot; PRId64, (int64_t)lines);</a>
<a name="ln3338">    } else {</a>
<a name="ln3339">      char_u  *s, *e;</a>
<a name="ln3340">      int l;</a>
<a name="ln3341">      int bytes = 0;</a>
<a name="ln3342">      int chars = 0;</a>
<a name="ln3343"> </a>
<a name="ln3344">      if (cursor_bot) {</a>
<a name="ln3345">        s = ml_get_pos(&amp;VIsual);</a>
<a name="ln3346">        e = get_cursor_pos_ptr();</a>
<a name="ln3347">      } else {</a>
<a name="ln3348">        s = get_cursor_pos_ptr();</a>
<a name="ln3349">        e = ml_get_pos(&amp;VIsual);</a>
<a name="ln3350">      }</a>
<a name="ln3351">      while ((*p_sel != 'e') ? s &lt;= e : s &lt; e) {</a>
<a name="ln3352">        l = (*mb_ptr2len)(s);</a>
<a name="ln3353">        if (l == 0) {</a>
<a name="ln3354">          ++bytes;</a>
<a name="ln3355">          ++chars;</a>
<a name="ln3356">          break;            /* end of line */</a>
<a name="ln3357">        }</a>
<a name="ln3358">        bytes += l;</a>
<a name="ln3359">        ++chars;</a>
<a name="ln3360">        s += l;</a>
<a name="ln3361">      }</a>
<a name="ln3362">      if (bytes == chars)</a>
<a name="ln3363">        sprintf((char *)showcmd_buf, &quot;%d&quot;, chars);</a>
<a name="ln3364">      else</a>
<a name="ln3365">        sprintf((char *)showcmd_buf, &quot;%d-%d&quot;, chars, bytes);</a>
<a name="ln3366">    }</a>
<a name="ln3367">    int limit = ui_has(kUIMessages) ? SHOWCMD_BUFLEN-1 : SHOWCMD_COLS;</a>
<a name="ln3368">    showcmd_buf[limit] = NUL;  // truncate</a>
<a name="ln3369">    showcmd_visual = true;</a>
<a name="ln3370">  } else {</a>
<a name="ln3371">    showcmd_buf[0] = NUL;</a>
<a name="ln3372">    showcmd_visual = false;</a>
<a name="ln3373"> </a>
<a name="ln3374">    /* Don't actually display something if there is nothing to clear. */</a>
<a name="ln3375">    if (showcmd_is_clear)</a>
<a name="ln3376">      return;</a>
<a name="ln3377">  }</a>
<a name="ln3378"> </a>
<a name="ln3379">  display_showcmd();</a>
<a name="ln3380">}</a>
<a name="ln3381"> </a>
<a name="ln3382">/*</a>
<a name="ln3383"> * Add 'c' to string of shown command chars.</a>
<a name="ln3384"> * Return true if output has been written (and setcursor() has been called).</a>
<a name="ln3385"> */</a>
<a name="ln3386">bool add_to_showcmd(int c)</a>
<a name="ln3387">{</a>
<a name="ln3388">  char_u      *p;</a>
<a name="ln3389">  int i;</a>
<a name="ln3390">  static int ignore[] =</a>
<a name="ln3391">  {</a>
<a name="ln3392">    K_IGNORE,</a>
<a name="ln3393">    K_LEFTMOUSE, K_LEFTDRAG, K_LEFTRELEASE,</a>
<a name="ln3394">    K_MIDDLEMOUSE, K_MIDDLEDRAG, K_MIDDLERELEASE,</a>
<a name="ln3395">    K_RIGHTMOUSE, K_RIGHTDRAG, K_RIGHTRELEASE,</a>
<a name="ln3396">    K_MOUSEDOWN, K_MOUSEUP, K_MOUSELEFT, K_MOUSERIGHT,</a>
<a name="ln3397">    K_X1MOUSE, K_X1DRAG, K_X1RELEASE, K_X2MOUSE, K_X2DRAG, K_X2RELEASE,</a>
<a name="ln3398">    K_EVENT,</a>
<a name="ln3399">    0</a>
<a name="ln3400">  };</a>
<a name="ln3401"> </a>
<a name="ln3402">  if (!p_sc || msg_silent != 0)</a>
<a name="ln3403">    return false;</a>
<a name="ln3404"> </a>
<a name="ln3405">  if (showcmd_visual) {</a>
<a name="ln3406">    showcmd_buf[0] = NUL;</a>
<a name="ln3407">    showcmd_visual = false;</a>
<a name="ln3408">  }</a>
<a name="ln3409"> </a>
<a name="ln3410">  /* Ignore keys that are scrollbar updates and mouse clicks */</a>
<a name="ln3411">  if (IS_SPECIAL(c))</a>
<a name="ln3412">    for (i = 0; ignore[i] != 0; ++i)</a>
<a name="ln3413">      if (ignore[i] == c)</a>
<a name="ln3414">        return false;</a>
<a name="ln3415"> </a>
<a name="ln3416">  p = transchar(c);</a>
<a name="ln3417">  if (*p == ' ')</a>
<a name="ln3418">    STRCPY(p, &quot;&lt;20&gt;&quot;);</a>
<a name="ln3419">  size_t old_len = STRLEN(showcmd_buf);</a>
<a name="ln3420">  size_t extra_len = STRLEN(p);</a>
<a name="ln3421">  size_t limit = ui_has(kUIMessages) ? SHOWCMD_BUFLEN-1 : SHOWCMD_COLS;</a>
<a name="ln3422">  if (old_len + extra_len &gt; limit) {</a>
<a name="ln3423">    size_t overflow = old_len + extra_len - limit;</a>
<a name="ln3424">    memmove(showcmd_buf, showcmd_buf + overflow, old_len - overflow + 1);</a>
<a name="ln3425">  }</a>
<a name="ln3426">  STRCAT(showcmd_buf, p);</a>
<a name="ln3427"> </a>
<a name="ln3428">  if (char_avail())</a>
<a name="ln3429">    return false;</a>
<a name="ln3430"> </a>
<a name="ln3431">  display_showcmd();</a>
<a name="ln3432"> </a>
<a name="ln3433">  return true;</a>
<a name="ln3434">}</a>
<a name="ln3435"> </a>
<a name="ln3436">void add_to_showcmd_c(int c)</a>
<a name="ln3437">{</a>
<a name="ln3438">  add_to_showcmd(c);</a>
<a name="ln3439">  setcursor();</a>
<a name="ln3440">}</a>
<a name="ln3441"> </a>
<a name="ln3442">/*</a>
<a name="ln3443"> * Delete 'len' characters from the end of the shown command.</a>
<a name="ln3444"> */</a>
<a name="ln3445">static void del_from_showcmd(int len)</a>
<a name="ln3446">{</a>
<a name="ln3447">  int old_len;</a>
<a name="ln3448"> </a>
<a name="ln3449">  if (!p_sc)</a>
<a name="ln3450">    return;</a>
<a name="ln3451"> </a>
<a name="ln3452">  old_len = (int)STRLEN(showcmd_buf);</a>
<a name="ln3453">  if (len &gt; old_len)</a>
<a name="ln3454">    len = old_len;</a>
<a name="ln3455">  showcmd_buf[old_len - len] = NUL;</a>
<a name="ln3456"> </a>
<a name="ln3457">  if (!char_avail())</a>
<a name="ln3458">    display_showcmd();</a>
<a name="ln3459">}</a>
<a name="ln3460"> </a>
<a name="ln3461">/*</a>
<a name="ln3462"> * push_showcmd() and pop_showcmd() are used when waiting for the user to type</a>
<a name="ln3463"> * something and there is a partial mapping.</a>
<a name="ln3464"> */</a>
<a name="ln3465">void push_showcmd(void)</a>
<a name="ln3466">{</a>
<a name="ln3467">  if (p_sc)</a>
<a name="ln3468">    STRCPY(old_showcmd_buf, showcmd_buf);</a>
<a name="ln3469">}</a>
<a name="ln3470"> </a>
<a name="ln3471">void pop_showcmd(void)</a>
<a name="ln3472">{</a>
<a name="ln3473">  if (!p_sc)</a>
<a name="ln3474">    return;</a>
<a name="ln3475"> </a>
<a name="ln3476">  STRCPY(showcmd_buf, old_showcmd_buf);</a>
<a name="ln3477"> </a>
<a name="ln3478">  display_showcmd();</a>
<a name="ln3479">}</a>
<a name="ln3480"> </a>
<a name="ln3481">static void display_showcmd(void)</a>
<a name="ln3482">{</a>
<a name="ln3483">  int len;</a>
<a name="ln3484">  len = (int)STRLEN(showcmd_buf);</a>
<a name="ln3485">  showcmd_is_clear = (len == 0);</a>
<a name="ln3486"> </a>
<a name="ln3487">  if (ui_has(kUIMessages)) {</a>
<a name="ln3488">    Array content = ARRAY_DICT_INIT;</a>
<a name="ln3489">    if (len &gt; 0) {</a>
<a name="ln3490">      Array chunk = ARRAY_DICT_INIT;</a>
<a name="ln3491">      // placeholder for future highlight support</a>
<a name="ln3492">      ADD(chunk, INTEGER_OBJ(0));</a>
<a name="ln3493">      ADD(chunk, STRING_OBJ(cstr_to_string((char *)showcmd_buf)));</a>
<a name="ln3494">      ADD(content, ARRAY_OBJ(chunk));</a>
<a name="ln3495">    }</a>
<a name="ln3496">    ui_call_msg_showcmd(content);</a>
<a name="ln3497">    return;</a>
<a name="ln3498">  }</a>
<a name="ln3499"> </a>
<a name="ln3500">  msg_grid_validate();</a>
<a name="ln3501">  int showcmd_row = Rows - 1;</a>
<a name="ln3502">  grid_puts_line_start(&amp;msg_grid_adj, showcmd_row);</a>
<a name="ln3503"> </a>
<a name="ln3504">  if (!showcmd_is_clear) {</a>
<a name="ln3505">    grid_puts(&amp;msg_grid_adj, showcmd_buf, showcmd_row, sc_col,</a>
<a name="ln3506">              HL_ATTR(HLF_MSG));</a>
<a name="ln3507">  }</a>
<a name="ln3508"> </a>
<a name="ln3509">  // clear the rest of an old message by outputting up to SHOWCMD_COLS spaces</a>
<a name="ln3510">  grid_puts(&amp;msg_grid_adj, (char_u *)&quot;          &quot; + len, showcmd_row,</a>
<a name="ln3511">            sc_col + len, HL_ATTR(HLF_MSG));</a>
<a name="ln3512"> </a>
<a name="ln3513">  grid_puts_line_flush(false);</a>
<a name="ln3514">}</a>
<a name="ln3515"> </a>
<a name="ln3516">/*</a>
<a name="ln3517"> * When &quot;check&quot; is false, prepare for commands that scroll the window.</a>
<a name="ln3518"> * When &quot;check&quot; is true, take care of scroll-binding after the window has</a>
<a name="ln3519"> * scrolled.  Called from normal_cmd() and edit().</a>
<a name="ln3520"> */</a>
<a name="ln3521">void do_check_scrollbind(bool check)</a>
<a name="ln3522">{</a>
<a name="ln3523">  static win_T        *old_curwin = NULL;</a>
<a name="ln3524">  static linenr_T old_topline = 0;</a>
<a name="ln3525">  static int old_topfill = 0;</a>
<a name="ln3526">  static buf_T        *old_buf = NULL;</a>
<a name="ln3527">  static colnr_T old_leftcol = 0;</a>
<a name="ln3528"> </a>
<a name="ln3529">  if (check &amp;&amp; curwin-&gt;w_p_scb) {</a>
<a name="ln3530">    /* If a &quot;:syncbind&quot; command was just used, don't scroll, only reset</a>
<a name="ln3531">     * the values. */</a>
<a name="ln3532">    if (did_syncbind)</a>
<a name="ln3533">      did_syncbind = false;</a>
<a name="ln3534">    else if (curwin == old_curwin) {</a>
<a name="ln3535">      /*</a>
<a name="ln3536">       * Synchronize other windows, as necessary according to</a>
<a name="ln3537">       * 'scrollbind'.  Don't do this after an &quot;:edit&quot; command, except</a>
<a name="ln3538">       * when 'diff' is set.</a>
<a name="ln3539">       */</a>
<a name="ln3540">      if ((curwin-&gt;w_buffer == old_buf</a>
<a name="ln3541">           || curwin-&gt;w_p_diff</a>
<a name="ln3542">           )</a>
<a name="ln3543">          &amp;&amp; (curwin-&gt;w_topline != old_topline</a>
<a name="ln3544">              || curwin-&gt;w_topfill != old_topfill</a>
<a name="ln3545">              || curwin-&gt;w_leftcol != old_leftcol)) {</a>
<a name="ln3546">        check_scrollbind(curwin-&gt;w_topline - old_topline,</a>
<a name="ln3547">            (long)(curwin-&gt;w_leftcol - old_leftcol));</a>
<a name="ln3548">      }</a>
<a name="ln3549">    } else if (vim_strchr(p_sbo, 'j')) { /* jump flag set in 'scrollopt' */</a>
<a name="ln3550">      /*</a>
<a name="ln3551">       * When switching between windows, make sure that the relative</a>
<a name="ln3552">       * vertical offset is valid for the new window.  The relative</a>
<a name="ln3553">       * offset is invalid whenever another 'scrollbind' window has</a>
<a name="ln3554">       * scrolled to a point that would force the current window to</a>
<a name="ln3555">       * scroll past the beginning or end of its buffer.  When the</a>
<a name="ln3556">       * resync is performed, some of the other 'scrollbind' windows may</a>
<a name="ln3557">       * need to jump so that the current window's relative position is</a>
<a name="ln3558">       * visible on-screen.</a>
<a name="ln3559">       */</a>
<a name="ln3560">      check_scrollbind(curwin-&gt;w_topline - curwin-&gt;w_scbind_pos, 0L);</a>
<a name="ln3561">    }</a>
<a name="ln3562">    curwin-&gt;w_scbind_pos = curwin-&gt;w_topline;</a>
<a name="ln3563">  }</a>
<a name="ln3564"> </a>
<a name="ln3565">  old_curwin = curwin;</a>
<a name="ln3566">  old_topline = curwin-&gt;w_topline;</a>
<a name="ln3567">  old_topfill = curwin-&gt;w_topfill;</a>
<a name="ln3568">  old_buf = curwin-&gt;w_buffer;</a>
<a name="ln3569">  old_leftcol = curwin-&gt;w_leftcol;</a>
<a name="ln3570">}</a>
<a name="ln3571"> </a>
<a name="ln3572">/*</a>
<a name="ln3573"> * Synchronize any windows that have &quot;scrollbind&quot; set, based on the</a>
<a name="ln3574"> * number of rows by which the current window has changed</a>
<a name="ln3575"> * (1998-11-02 16:21:01  R. Edward Ralston &lt;eralston@computer.org&gt;)</a>
<a name="ln3576"> */</a>
<a name="ln3577">void check_scrollbind(linenr_T topline_diff, long leftcol_diff)</a>
<a name="ln3578">{</a>
<a name="ln3579">  bool want_ver;</a>
<a name="ln3580">  bool want_hor;</a>
<a name="ln3581">  win_T       *old_curwin = curwin;</a>
<a name="ln3582">  buf_T       *old_curbuf = curbuf;</a>
<a name="ln3583">  int old_VIsual_select = VIsual_select;</a>
<a name="ln3584">  int old_VIsual_active = VIsual_active;</a>
<a name="ln3585">  colnr_T tgt_leftcol = curwin-&gt;w_leftcol;</a>
<a name="ln3586">  long topline;</a>
<a name="ln3587">  long y;</a>
<a name="ln3588"> </a>
<a name="ln3589">  /*</a>
<a name="ln3590">   * check 'scrollopt' string for vertical and horizontal scroll options</a>
<a name="ln3591">   */</a>
<a name="ln3592">  want_ver = (vim_strchr(p_sbo, 'v') &amp;&amp; topline_diff != 0);</a>
<a name="ln3593">  want_ver |= old_curwin-&gt;w_p_diff;</a>
<a name="ln3594">  want_hor = (vim_strchr(p_sbo, 'h') &amp;&amp; (leftcol_diff || topline_diff != 0));</a>
<a name="ln3595"> </a>
<a name="ln3596">  /*</a>
<a name="ln3597">   * loop through the scrollbound windows and scroll accordingly</a>
<a name="ln3598">   */</a>
<a name="ln3599">  VIsual_select = VIsual_active = 0;</a>
<a name="ln3600">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln3601">    curwin = wp;</a>
<a name="ln3602">    curbuf = curwin-&gt;w_buffer;</a>
<a name="ln3603">    /* skip original window  and windows with 'noscrollbind' */</a>
<a name="ln3604">    if (curwin == old_curwin || !curwin-&gt;w_p_scb) {</a>
<a name="ln3605">      continue;</a>
<a name="ln3606">    }</a>
<a name="ln3607">    /*</a>
<a name="ln3608">     * do the vertical scroll</a>
<a name="ln3609">     */</a>
<a name="ln3610">    if (want_ver) {</a>
<a name="ln3611">      if (old_curwin-&gt;w_p_diff &amp;&amp; curwin-&gt;w_p_diff) {</a>
<a name="ln3612">        diff_set_topline(old_curwin, curwin);</a>
<a name="ln3613">      } else {</a>
<a name="ln3614">        curwin-&gt;w_scbind_pos += topline_diff;</a>
<a name="ln3615">        topline = curwin-&gt;w_scbind_pos;</a>
<a name="ln3616">        if (topline &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln3617">          topline = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3618">        if (topline &lt; 1)</a>
<a name="ln3619">          topline = 1;</a>
<a name="ln3620"> </a>
<a name="ln3621">        y = topline - curwin-&gt;w_topline;</a>
<a name="ln3622">        if (y &gt; 0)</a>
<a name="ln3623">          scrollup(y, false);</a>
<a name="ln3624">        else</a>
<a name="ln3625">          scrolldown(-y, false);</a>
<a name="ln3626">      }</a>
<a name="ln3627"> </a>
<a name="ln3628">      redraw_later(curwin, VALID);</a>
<a name="ln3629">      cursor_correct();</a>
<a name="ln3630">      curwin-&gt;w_redr_status = true;</a>
<a name="ln3631">    }</a>
<a name="ln3632"> </a>
<a name="ln3633">    /*</a>
<a name="ln3634">     * do the horizontal scroll</a>
<a name="ln3635">     */</a>
<a name="ln3636">    if (want_hor &amp;&amp; curwin-&gt;w_leftcol != tgt_leftcol) {</a>
<a name="ln3637">      curwin-&gt;w_leftcol = tgt_leftcol;</a>
<a name="ln3638">      leftcol_changed();</a>
<a name="ln3639">    }</a>
<a name="ln3640">  }</a>
<a name="ln3641"> </a>
<a name="ln3642">  /*</a>
<a name="ln3643">   * reset current-window</a>
<a name="ln3644">   */</a>
<a name="ln3645">  VIsual_select = old_VIsual_select;</a>
<a name="ln3646">  VIsual_active = old_VIsual_active;</a>
<a name="ln3647">  curwin = old_curwin;</a>
<a name="ln3648">  curbuf = old_curbuf;</a>
<a name="ln3649">}</a>
<a name="ln3650"> </a>
<a name="ln3651">/*</a>
<a name="ln3652"> * Command character that's ignored.</a>
<a name="ln3653"> * Used for CTRL-Q and CTRL-S to avoid problems with terminals that use</a>
<a name="ln3654"> * xon/xoff.</a>
<a name="ln3655"> */</a>
<a name="ln3656">static void nv_ignore(cmdarg_T *cap)</a>
<a name="ln3657">{</a>
<a name="ln3658">  cap-&gt;retval |= CA_COMMAND_BUSY;       /* don't call edit() now */</a>
<a name="ln3659">}</a>
<a name="ln3660"> </a>
<a name="ln3661">/*</a>
<a name="ln3662"> * Command character that doesn't do anything, but unlike nv_ignore() does</a>
<a name="ln3663"> * start edit().  Used for &quot;startinsert&quot; executed while starting up.</a>
<a name="ln3664"> */</a>
<a name="ln3665">static void nv_nop(cmdarg_T *cap)</a>
<a name="ln3666">{</a>
<a name="ln3667">}</a>
<a name="ln3668"> </a>
<a name="ln3669">/*</a>
<a name="ln3670"> * Command character doesn't exist.</a>
<a name="ln3671"> */</a>
<a name="ln3672">static void nv_error(cmdarg_T *cap)</a>
<a name="ln3673">{</a>
<a name="ln3674">  clearopbeep(cap-&gt;oap);</a>
<a name="ln3675">}</a>
<a name="ln3676"> </a>
<a name="ln3677">/*</a>
<a name="ln3678"> * &lt;Help&gt; and &lt;F1&gt; commands.</a>
<a name="ln3679"> */</a>
<a name="ln3680">static void nv_help(cmdarg_T *cap)</a>
<a name="ln3681">{</a>
<a name="ln3682">  if (!checkclearopq(cap-&gt;oap))</a>
<a name="ln3683">    ex_help(NULL);</a>
<a name="ln3684">}</a>
<a name="ln3685"> </a>
<a name="ln3686">/*</a>
<a name="ln3687"> * CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.</a>
<a name="ln3688"> */</a>
<a name="ln3689">static void nv_addsub(cmdarg_T *cap)</a>
<a name="ln3690">{</a>
<a name="ln3691">  if (bt_prompt(curbuf) &amp;&amp; !prompt_curpos_editable()) {</a>
<a name="ln3692">    clearopbeep(cap-&gt;oap);</a>
<a name="ln3693">  } else if (!VIsual_active &amp;&amp; cap-&gt;oap-&gt;op_type == OP_NOP) {</a>
<a name="ln3694">    prep_redo_cmd(cap);</a>
<a name="ln3695">    cap-&gt;oap-&gt;op_type = cap-&gt;cmdchar == Ctrl_A ? OP_NR_ADD : OP_NR_SUB;</a>
<a name="ln3696">    op_addsub(cap-&gt;oap, cap-&gt;count1, cap-&gt;arg);</a>
<a name="ln3697">    cap-&gt;oap-&gt;op_type = OP_NOP;</a>
<a name="ln3698">  } else if (VIsual_active) {</a>
<a name="ln3699">    nv_operator(cap);</a>
<a name="ln3700">  } else {</a>
<a name="ln3701">    clearop(cap-&gt;oap);</a>
<a name="ln3702">  }</a>
<a name="ln3703">}</a>
<a name="ln3704"> </a>
<a name="ln3705">/*</a>
<a name="ln3706"> * CTRL-F, CTRL-B, etc: Scroll page up or down.</a>
<a name="ln3707"> */</a>
<a name="ln3708">static void nv_page(cmdarg_T *cap)</a>
<a name="ln3709">{</a>
<a name="ln3710">  if (!checkclearop(cap-&gt;oap)) {</a>
<a name="ln3711">    if (mod_mask &amp; MOD_MASK_CTRL) {</a>
<a name="ln3712">      /* &lt;C-PageUp&gt;: tab page back; &lt;C-PageDown&gt;: tab page forward */</a>
<a name="ln3713">      if (cap-&gt;arg == BACKWARD)</a>
<a name="ln3714">        goto_tabpage(-(int)cap-&gt;count1);</a>
<a name="ln3715">      else</a>
<a name="ln3716">        goto_tabpage((int)cap-&gt;count0);</a>
<a name="ln3717">    } else</a>
<a name="ln3718">      (void)onepage(cap-&gt;arg, cap-&gt;count1);</a>
<a name="ln3719">  }</a>
<a name="ln3720">}</a>
<a name="ln3721"> </a>
<a name="ln3722">/*</a>
<a name="ln3723"> * Implementation of &quot;gd&quot; and &quot;gD&quot; command.</a>
<a name="ln3724"> */</a>
<a name="ln3725">static void</a>
<a name="ln3726">nv_gd (</a>
<a name="ln3727">    oparg_T *oap,</a>
<a name="ln3728">    int nchar,</a>
<a name="ln3729">    int thisblock                  /* 1 for &quot;1gd&quot; and &quot;1gD&quot; */</a>
<a name="ln3730">)</a>
<a name="ln3731">{</a>
<a name="ln3732">  size_t len;</a>
<a name="ln3733">  char_u *ptr;</a>
<a name="ln3734">  if ((len = find_ident_under_cursor(&amp;ptr, FIND_IDENT)) == 0</a>
<a name="ln3735">      || !find_decl(ptr, len, nchar == 'd', thisblock, SEARCH_START)) {</a>
<a name="ln3736">    clearopbeep(oap);</a>
<a name="ln3737">  } else if ((fdo_flags &amp; FDO_SEARCH) &amp;&amp; KeyTyped &amp;&amp; oap-&gt;op_type == OP_NOP) {</a>
<a name="ln3738">    foldOpenCursor();</a>
<a name="ln3739">  }</a>
<a name="ln3740">}</a>
<a name="ln3741"> </a>
<a name="ln3742">// Return true if line[offset] is not inside a C-style comment or string, false</a>
<a name="ln3743">// otherwise.</a>
<a name="ln3744">static bool is_ident(char_u *line, int offset)</a>
<a name="ln3745">{</a>
<a name="ln3746">  bool incomment = false;</a>
<a name="ln3747">  int instring = 0;</a>
<a name="ln3748">  int prev = 0;</a>
<a name="ln3749"> </a>
<a name="ln3750">  for (int i = 0; i &lt; offset &amp;&amp; line[i] != NUL; i++) {</a>
<a name="ln3751">    if (instring != 0) {</a>
<a name="ln3752">      if (prev != '\\' &amp;&amp; line[i] == instring) {</a>
<a name="ln3753">        instring = 0;</a>
<a name="ln3754">      }</a>
<a name="ln3755">    } else if ((line[i] == '&quot;' || line[i] == '\'') &amp;&amp; !incomment) {</a>
<a name="ln3756">      instring = line[i];</a>
<a name="ln3757">    } else {</a>
<a name="ln3758">      if (incomment) {</a>
<a name="ln3759">        if (prev == '*' &amp;&amp; line[i] == '/') {</a>
<a name="ln3760">          incomment = false;</a>
<a name="ln3761">        }</a>
<a name="ln3762">      } else if (prev == '/' &amp;&amp; line[i] == '*') {</a>
<a name="ln3763">        incomment = true;</a>
<a name="ln3764">      } else if (prev == '/' &amp;&amp; line[i] == '/') {</a>
<a name="ln3765">        return false;</a>
<a name="ln3766">      }</a>
<a name="ln3767">    }</a>
<a name="ln3768"> </a>
<a name="ln3769">    prev = line[i];</a>
<a name="ln3770">  }</a>
<a name="ln3771"> </a>
<a name="ln3772">  return incomment == false &amp;&amp; instring == 0;</a>
<a name="ln3773">}</a>
<a name="ln3774"> </a>
<a name="ln3775">/*</a>
<a name="ln3776"> * Search for variable declaration of &quot;ptr[len]&quot;.</a>
<a name="ln3777"> * When &quot;locally&quot; is true in the current function (&quot;gd&quot;), otherwise in the</a>
<a name="ln3778"> * current file (&quot;gD&quot;).</a>
<a name="ln3779"> * When &quot;thisblock&quot; is true check the {} block scope.</a>
<a name="ln3780"> * Return fail when not found.</a>
<a name="ln3781"> */</a>
<a name="ln3782">bool</a>
<a name="ln3783">find_decl (</a>
<a name="ln3784">    char_u *ptr,</a>
<a name="ln3785">    size_t len,</a>
<a name="ln3786">    bool locally,</a>
<a name="ln3787">    bool thisblock,</a>
<a name="ln3788">    int flags_arg                  // flags passed to searchit()</a>
<a name="ln3789">)</a>
<a name="ln3790">{</a>
<a name="ln3791">  char_u      *pat;</a>
<a name="ln3792">  pos_T old_pos;</a>
<a name="ln3793">  pos_T par_pos;</a>
<a name="ln3794">  pos_T found_pos;</a>
<a name="ln3795">  bool t;</a>
<a name="ln3796">  bool save_p_ws;</a>
<a name="ln3797">  bool save_p_scs;</a>
<a name="ln3798">  bool retval = true;</a>
<a name="ln3799">  bool incll;</a>
<a name="ln3800">  int searchflags = flags_arg;</a>
<a name="ln3801"> </a>
<a name="ln3802">  pat = xmalloc(len + 7);</a>
<a name="ln3803"> </a>
<a name="ln3804">  /* Put &quot;\V&quot; before the pattern to avoid that the special meaning of &quot;.&quot;</a>
<a name="ln3805">   * and &quot;~&quot; causes trouble. */</a>
<a name="ln3806">  assert(len &lt;= INT_MAX);</a>
<a name="ln3807">  sprintf((char *)pat, vim_iswordp(ptr) ? &quot;\\V\\&lt;%.*s\\&gt;&quot; : &quot;\\V%.*s&quot;,</a>
<a name="ln3808">          (int)len, ptr);</a>
<a name="ln3809">  old_pos = curwin-&gt;w_cursor;</a>
<a name="ln3810">  save_p_ws = p_ws;</a>
<a name="ln3811">  save_p_scs = p_scs;</a>
<a name="ln3812">  p_ws = false;         /* don't wrap around end of file now */</a>
<a name="ln3813">  p_scs = false;        /* don't switch ignorecase off now */</a>
<a name="ln3814"> </a>
<a name="ln3815">  /*</a>
<a name="ln3816">   * With &quot;gD&quot; go to line 1.</a>
<a name="ln3817">   * With &quot;gd&quot; Search back for the start of the current function, then go</a>
<a name="ln3818">   * back until a blank line.  If this fails go to line 1.</a>
<a name="ln3819">   */</a>
<a name="ln3820">  if (!locally || !findpar(&amp;incll, BACKWARD, 1L, '{', false)) {</a>
<a name="ln3821">    setpcmark();                        /* Set in findpar() otherwise */</a>
<a name="ln3822">    curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln3823">    par_pos = curwin-&gt;w_cursor;</a>
<a name="ln3824">  } else {</a>
<a name="ln3825">    par_pos = curwin-&gt;w_cursor;</a>
<a name="ln3826">    while (curwin-&gt;w_cursor.lnum &gt; 1</a>
<a name="ln3827">           &amp;&amp; *skipwhite(get_cursor_line_ptr()) != NUL)</a>
<a name="ln3828">      --curwin-&gt;w_cursor.lnum;</a>
<a name="ln3829">  }</a>
<a name="ln3830">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3831"> </a>
<a name="ln3832">  /* Search forward for the identifier, ignore comment lines. */</a>
<a name="ln3833">  clearpos(&amp;found_pos);</a>
<a name="ln3834">  for (;; ) {</a>
<a name="ln3835">    t = searchit(curwin, curbuf, &amp;curwin-&gt;w_cursor, NULL, FORWARD,</a>
<a name="ln3836">                 pat, 1L, searchflags, RE_LAST, NULL);</a>
<a name="ln3837">    if (curwin-&gt;w_cursor.lnum &gt;= old_pos.lnum) {</a>
<a name="ln3838">      t = false;         // match after start is failure too</a>
<a name="ln3839">    }</a>
<a name="ln3840"> </a>
<a name="ln3841">    if (thisblock &amp;&amp; t != false) {</a>
<a name="ln3842">      const int64_t maxtravel = old_pos.lnum - curwin-&gt;w_cursor.lnum + 1;</a>
<a name="ln3843">      const pos_T *pos = findmatchlimit(NULL, '}', FM_FORWARD, maxtravel);</a>
<a name="ln3844"> </a>
<a name="ln3845">      // Check that the block the match is in doesn't end before the</a>
<a name="ln3846">      // position where we started the search from.</a>
<a name="ln3847">      if (pos != NULL &amp;&amp; pos-&gt;lnum &lt; old_pos.lnum) {</a>
<a name="ln3848">        // There can't be a useful match before the end of this block.</a>
<a name="ln3849">        // Skip to the end</a>
<a name="ln3850">        curwin-&gt;w_cursor = *pos;</a>
<a name="ln3851">        continue;</a>
<a name="ln3852">      }</a>
<a name="ln3853">    }</a>
<a name="ln3854"> </a>
<a name="ln3855">    if (t == false) {</a>
<a name="ln3856">      /* If we previously found a valid position, use it. */</a>
<a name="ln3857">      if (found_pos.lnum != 0) {</a>
<a name="ln3858">        curwin-&gt;w_cursor = found_pos;</a>
<a name="ln3859">        t = true;</a>
<a name="ln3860">      }</a>
<a name="ln3861">      break;</a>
<a name="ln3862">    }</a>
<a name="ln3863">    if (get_leader_len(get_cursor_line_ptr(), NULL, false, true) &gt; 0) {</a>
<a name="ln3864">      /* Ignore this line, continue at start of next line. */</a>
<a name="ln3865">      ++curwin-&gt;w_cursor.lnum;</a>
<a name="ln3866">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3867">      continue;</a>
<a name="ln3868">    }</a>
<a name="ln3869">    bool valid = is_ident(get_cursor_line_ptr(), curwin-&gt;w_cursor.col);</a>
<a name="ln3870"> </a>
<a name="ln3871">    // If the current position is not a valid identifier and a previous match is</a>
<a name="ln3872">    // present, favor that one instead.</a>
<a name="ln3873">    if (!valid &amp;&amp; found_pos.lnum != 0) {</a>
<a name="ln3874">      curwin-&gt;w_cursor = found_pos;</a>
<a name="ln3875">      break;</a>
<a name="ln3876">    }</a>
<a name="ln3877">    // global search: use first match found</a>
<a name="ln3878">    if (valid &amp;&amp; !locally) {</a>
<a name="ln3879">      break;</a>
<a name="ln3880">    }</a>
<a name="ln3881">    if (valid &amp;&amp; curwin-&gt;w_cursor.lnum &gt;= par_pos.lnum) {</a>
<a name="ln3882">      // If we previously found a valid position, use it.</a>
<a name="ln3883">      if (found_pos.lnum != 0) {</a>
<a name="ln3884">        curwin-&gt;w_cursor = found_pos;</a>
<a name="ln3885">      }</a>
<a name="ln3886">      break;</a>
<a name="ln3887">    }</a>
<a name="ln3888"> </a>
<a name="ln3889">    // For finding a local variable and the match is before the &quot;{&quot; or</a>
<a name="ln3890">    // inside a comment, continue searching.  For K&amp;R style function</a>
<a name="ln3891">    // declarations this skips the function header without types.</a>
<a name="ln3892">    if (!valid) {</a>
<a name="ln3893">      clearpos(&amp;found_pos);</a>
<a name="ln3894">    } else {</a>
<a name="ln3895">      found_pos = curwin-&gt;w_cursor;</a>
<a name="ln3896">    }</a>
<a name="ln3897">    // Remove SEARCH_START from flags to avoid getting stuck at one position.</a>
<a name="ln3898">    searchflags &amp;= ~SEARCH_START;</a>
<a name="ln3899">  }</a>
<a name="ln3900"> </a>
<a name="ln3901">  if (t == false) {</a>
<a name="ln3902">    retval = false;</a>
<a name="ln3903">    curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3904">  } else {</a>
<a name="ln3905">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln3906">    /* &quot;n&quot; searches forward now */</a>
<a name="ln3907">    reset_search_dir();</a>
<a name="ln3908">  }</a>
<a name="ln3909"> </a>
<a name="ln3910">  xfree(pat);</a>
<a name="ln3911">  p_ws = save_p_ws;</a>
<a name="ln3912">  p_scs = save_p_scs;</a>
<a name="ln3913"> </a>
<a name="ln3914">  return retval;</a>
<a name="ln3915">}</a>
<a name="ln3916"> </a>
<a name="ln3917">/*</a>
<a name="ln3918"> * Move 'dist' lines in direction 'dir', counting lines by *screen*</a>
<a name="ln3919"> * lines rather than lines in the file.</a>
<a name="ln3920"> * 'dist' must be positive.</a>
<a name="ln3921"> *</a>
<a name="ln3922"> * Return true if able to move cursor, false otherwise.</a>
<a name="ln3923"> */</a>
<a name="ln3924">static bool nv_screengo(oparg_T *oap, int dir, long dist)</a>
<a name="ln3925">{</a>
<a name="ln3926">  int linelen = linetabsize(get_cursor_line_ptr());</a>
<a name="ln3927">  bool retval = true;</a>
<a name="ln3928">  bool atend = false;</a>
<a name="ln3929">  int n;</a>
<a name="ln3930">  int col_off1;                 /* margin offset for first screen line */</a>
<a name="ln3931">  int col_off2;                 /* margin offset for wrapped screen line */</a>
<a name="ln3932">  int width1;                   /* text width for first screen line */</a>
<a name="ln3933">  int width2;                   /* test width for wrapped screen line */</a>
<a name="ln3934"> </a>
<a name="ln3935">  oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln3936">  oap-&gt;inclusive = (curwin-&gt;w_curswant == MAXCOL);</a>
<a name="ln3937"> </a>
<a name="ln3938">  col_off1 = curwin_col_off();</a>
<a name="ln3939">  col_off2 = col_off1 - curwin_col_off2();</a>
<a name="ln3940">  width1 = curwin-&gt;w_width_inner - col_off1;</a>
<a name="ln3941">  width2 = curwin-&gt;w_width_inner - col_off2;</a>
<a name="ln3942"> </a>
<a name="ln3943">  if (width2 == 0) {</a>
<a name="ln3944">    width2 = 1;  // Avoid divide by zero.</a>
<a name="ln3945">  }</a>
<a name="ln3946"> </a>
<a name="ln3947">  if (curwin-&gt;w_width_inner != 0) {</a>
<a name="ln3948">    // Instead of sticking at the last character of the buffer line we</a>
<a name="ln3949">    // try to stick in the last column of the screen.</a>
<a name="ln3950">    if (curwin-&gt;w_curswant == MAXCOL) {</a>
<a name="ln3951">      atend = true;</a>
<a name="ln3952">      validate_virtcol();</a>
<a name="ln3953">      if (width1 &lt;= 0)</a>
<a name="ln3954">        curwin-&gt;w_curswant = 0;</a>
<a name="ln3955">      else {</a>
<a name="ln3956">        curwin-&gt;w_curswant = width1 - 1;</a>
<a name="ln3957">        if (curwin-&gt;w_virtcol &gt; curwin-&gt;w_curswant)</a>
<a name="ln3958">          curwin-&gt;w_curswant += ((curwin-&gt;w_virtcol</a>
<a name="ln3959">                                  - curwin-&gt;w_curswant -</a>
<a name="ln3960">                                  1) / width2 + 1) * width2;</a>
<a name="ln3961">      }</a>
<a name="ln3962">    } else {</a>
<a name="ln3963">      if (linelen &gt; width1)</a>
<a name="ln3964">        n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;</a>
<a name="ln3965">      else</a>
<a name="ln3966">        n = width1;</a>
<a name="ln3967">      if (curwin-&gt;w_curswant &gt;= n) {</a>
<a name="ln3968">        curwin-&gt;w_curswant = n - 1;</a>
<a name="ln3969">      }</a>
<a name="ln3970">    }</a>
<a name="ln3971"> </a>
<a name="ln3972">    while (dist--) {</a>
<a name="ln3973">      if (dir == BACKWARD) {</a>
<a name="ln3974">        if (curwin-&gt;w_curswant &gt;= width1</a>
<a name="ln3975">            &amp;&amp; !hasFolding(curwin-&gt;w_cursor.lnum, NULL, NULL)) {</a>
<a name="ln3976">          // Move back within the line. This can give a negative value</a>
<a name="ln3977">          // for w_curswant if width1 &lt; width2 (with cpoptions+=n),</a>
<a name="ln3978">          // which will get clipped to column 0.</a>
<a name="ln3979">          curwin-&gt;w_curswant -= width2;</a>
<a name="ln3980">        } else {</a>
<a name="ln3981">          // to previous line</a>
<a name="ln3982"> </a>
<a name="ln3983">          // Move to the start of a closed fold.  Don't do that when</a>
<a name="ln3984">          // 'foldopen' contains &quot;all&quot;: it will open in a moment.</a>
<a name="ln3985">          if (!(fdo_flags &amp; FDO_ALL)) {</a>
<a name="ln3986">            (void)hasFolding(curwin-&gt;w_cursor.lnum,</a>
<a name="ln3987">                             &amp;curwin-&gt;w_cursor.lnum, NULL);</a>
<a name="ln3988">          }</a>
<a name="ln3989">          if (curwin-&gt;w_cursor.lnum == 1) {</a>
<a name="ln3990">            retval = false;</a>
<a name="ln3991">            break;</a>
<a name="ln3992">          }</a>
<a name="ln3993">          curwin-&gt;w_cursor.lnum--;</a>
<a name="ln3994"> </a>
<a name="ln3995">          linelen = linetabsize(get_cursor_line_ptr());</a>
<a name="ln3996">          if (linelen &gt; width1) {</a>
<a name="ln3997">            int w = (((linelen - width1 - 1) / width2) + 1) * width2;</a>
<a name="ln3998">            assert(curwin-&gt;w_curswant &lt;= INT_MAX - w);</a>
<a name="ln3999">            curwin-&gt;w_curswant += w;</a>
<a name="ln4000">          }</a>
<a name="ln4001">        }</a>
<a name="ln4002">      } else { /* dir == FORWARD */</a>
<a name="ln4003">        if (linelen &gt; width1)</a>
<a name="ln4004">          n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;</a>
<a name="ln4005">        else</a>
<a name="ln4006">          n = width1;</a>
<a name="ln4007">        if (curwin-&gt;w_curswant + width2 &lt; (colnr_T)n</a>
<a name="ln4008">            &amp;&amp; !hasFolding(curwin-&gt;w_cursor.lnum, NULL, NULL)) {</a>
<a name="ln4009">          // move forward within line</a>
<a name="ln4010">          curwin-&gt;w_curswant += width2;</a>
<a name="ln4011">        } else {</a>
<a name="ln4012">          // to next line</a>
<a name="ln4013"> </a>
<a name="ln4014">          // Move to the end of a closed fold.</a>
<a name="ln4015">          (void)hasFolding(curwin-&gt;w_cursor.lnum, NULL,</a>
<a name="ln4016">                           &amp;curwin-&gt;w_cursor.lnum);</a>
<a name="ln4017">          if (curwin-&gt;w_cursor.lnum == curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln4018">            retval = false;</a>
<a name="ln4019">            break;</a>
<a name="ln4020">          }</a>
<a name="ln4021">          curwin-&gt;w_cursor.lnum++;</a>
<a name="ln4022">          curwin-&gt;w_curswant %= width2;</a>
<a name="ln4023">          // Check if the cursor has moved below the number display</a>
<a name="ln4024">          // when width1 &lt; width2 (with cpoptions+=n). Subtract width2</a>
<a name="ln4025">          // to get a negative value for w_curswant, which will get</a>
<a name="ln4026">          // clipped to column 0.</a>
<a name="ln4027">          if (curwin-&gt;w_curswant &gt;= width1) {</a>
<a name="ln4028">            curwin-&gt;w_curswant -= width2;</a>
<a name="ln4029">          }</a>
<a name="ln4030">          linelen = linetabsize(get_cursor_line_ptr());</a>
<a name="ln4031">        }</a>
<a name="ln4032">      }</a>
<a name="ln4033">    }</a>
<a name="ln4034">  }</a>
<a name="ln4035"> </a>
<a name="ln4036">  if (virtual_active() &amp;&amp; atend)</a>
<a name="ln4037">    coladvance(MAXCOL);</a>
<a name="ln4038">  else</a>
<a name="ln4039">    coladvance(curwin-&gt;w_curswant);</a>
<a name="ln4040"> </a>
<a name="ln4041">  if (curwin-&gt;w_cursor.col &gt; 0 &amp;&amp; curwin-&gt;w_p_wrap) {</a>
<a name="ln4042">    /*</a>
<a name="ln4043">     * Check for landing on a character that got split at the end of the</a>
<a name="ln4044">     * last line.  We want to advance a screenline, not end up in the same</a>
<a name="ln4045">     * screenline or move two screenlines.</a>
<a name="ln4046">     */</a>
<a name="ln4047">    validate_virtcol();</a>
<a name="ln4048">    colnr_T virtcol = curwin-&gt;w_virtcol;</a>
<a name="ln4049">    if (virtcol &gt; (colnr_T)width1 &amp;&amp; *p_sbr != NUL)</a>
<a name="ln4050">        virtcol -= vim_strsize(p_sbr);</a>
<a name="ln4051"> </a>
<a name="ln4052">    if (virtcol &gt; curwin-&gt;w_curswant</a>
<a name="ln4053">        &amp;&amp; (curwin-&gt;w_curswant &lt; (colnr_T)width1</a>
<a name="ln4054">            ? (curwin-&gt;w_curswant &gt; (colnr_T)width1 / 2)</a>
<a name="ln4055">            : ((curwin-&gt;w_curswant - width1) % width2</a>
<a name="ln4056">               &gt; (colnr_T)width2 / 2)))</a>
<a name="ln4057">      --curwin-&gt;w_cursor.col;</a>
<a name="ln4058">  }</a>
<a name="ln4059"> </a>
<a name="ln4060">  if (atend)</a>
<a name="ln4061">    curwin-&gt;w_curswant = MAXCOL;            /* stick in the last column */</a>
<a name="ln4062"> </a>
<a name="ln4063">  return retval;</a>
<a name="ln4064">}</a>
<a name="ln4065"> </a>
<a name="ln4066">/*</a>
<a name="ln4067"> * Mouse scroll wheel: Default action is to scroll three lines, or one page</a>
<a name="ln4068"> * when Shift or Ctrl is used.</a>
<a name="ln4069"> * K_MOUSEUP (cap-&gt;arg == 1) or K_MOUSEDOWN (cap-&gt;arg == 0) or</a>
<a name="ln4070"> * K_MOUSELEFT (cap-&gt;arg == -1) or K_MOUSERIGHT (cap-&gt;arg == -2)</a>
<a name="ln4071"> */</a>
<a name="ln4072">static void nv_mousescroll(cmdarg_T *cap)</a>
<a name="ln4073">{</a>
<a name="ln4074">  win_T *old_curwin = curwin;</a>
<a name="ln4075"> </a>
<a name="ln4076">  if (mouse_row &gt;= 0 &amp;&amp; mouse_col &gt;= 0) {</a>
<a name="ln4077">    int grid, row, col;</a>
<a name="ln4078"> </a>
<a name="ln4079">    grid = mouse_grid;</a>
<a name="ln4080">    row = mouse_row;</a>
<a name="ln4081">    col = mouse_col;</a>
<a name="ln4082"> </a>
<a name="ln4083">    // find the window at the pointer coordinates</a>
<a name="ln4084">    win_T *wp = mouse_find_win(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln4085">    if (wp == NULL) {</a>
<a name="ln4086">      return;</a>
<a name="ln4087">    }</a>
<a name="ln4088">    curwin = wp;</a>
<a name="ln4089">    curbuf = curwin-&gt;w_buffer;</a>
<a name="ln4090">  }</a>
<a name="ln4091"> </a>
<a name="ln4092">  if (cap-&gt;arg == MSCR_UP || cap-&gt;arg == MSCR_DOWN) {</a>
<a name="ln4093">    if (mod_mask &amp; (MOD_MASK_SHIFT | MOD_MASK_CTRL)) {</a>
<a name="ln4094">      (void)onepage(cap-&gt;arg ? FORWARD : BACKWARD, 1L);</a>
<a name="ln4095">    } else {</a>
<a name="ln4096">      cap-&gt;count1 = 3;</a>
<a name="ln4097">      cap-&gt;count0 = 3;</a>
<a name="ln4098">      nv_scroll_line(cap);</a>
<a name="ln4099">    }</a>
<a name="ln4100">  } else {</a>
<a name="ln4101">    mouse_scroll_horiz(cap-&gt;arg);</a>
<a name="ln4102">  }</a>
<a name="ln4103">  if (curwin != old_curwin &amp;&amp; curwin-&gt;w_p_cul) {</a>
<a name="ln4104">    redraw_for_cursorline(curwin);</a>
<a name="ln4105">  }</a>
<a name="ln4106"> </a>
<a name="ln4107">  curwin-&gt;w_redr_status = true;</a>
<a name="ln4108"> </a>
<a name="ln4109">  curwin = old_curwin;</a>
<a name="ln4110">  curbuf = curwin-&gt;w_buffer;</a>
<a name="ln4111">}</a>
<a name="ln4112"> </a>
<a name="ln4113">/*</a>
<a name="ln4114"> * Mouse clicks and drags.</a>
<a name="ln4115"> */</a>
<a name="ln4116">static void nv_mouse(cmdarg_T *cap)</a>
<a name="ln4117">{</a>
<a name="ln4118">  (void)do_mouse(cap-&gt;oap, cap-&gt;cmdchar, BACKWARD, cap-&gt;count1, 0);</a>
<a name="ln4119">}</a>
<a name="ln4120"> </a>
<a name="ln4121">/*</a>
<a name="ln4122"> * Handle CTRL-E and CTRL-Y commands: scroll a line up or down.</a>
<a name="ln4123"> * cap-&gt;arg must be true for CTRL-E.</a>
<a name="ln4124"> */</a>
<a name="ln4125">static void nv_scroll_line(cmdarg_T *cap)</a>
<a name="ln4126">{</a>
<a name="ln4127">  if (!checkclearop(cap-&gt;oap))</a>
<a name="ln4128">    scroll_redraw(cap-&gt;arg, cap-&gt;count1);</a>
<a name="ln4129">}</a>
<a name="ln4130"> </a>
<a name="ln4131">/*</a>
<a name="ln4132"> * Scroll &quot;count&quot; lines up or down, and redraw.</a>
<a name="ln4133"> */</a>
<a name="ln4134">void scroll_redraw(int up, long count)</a>
<a name="ln4135">{</a>
<a name="ln4136">  linenr_T prev_topline = curwin-&gt;w_topline;</a>
<a name="ln4137">  int prev_topfill = curwin-&gt;w_topfill;</a>
<a name="ln4138">  linenr_T prev_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln4139"> </a>
<a name="ln4140">  bool moved = up ?</a>
<a name="ln4141">    scrollup(count, true) :</a>
<a name="ln4142">    scrolldown(count, true);</a>
<a name="ln4143"> </a>
<a name="ln4144">  if (get_scrolloff_value(curwin)) {</a>
<a name="ln4145">    // Adjust the cursor position for 'scrolloff'.  Mark w_topline as</a>
<a name="ln4146">    // valid, otherwise the screen jumps back at the end of the file.</a>
<a name="ln4147">    cursor_correct();</a>
<a name="ln4148">    check_cursor_moved(curwin);</a>
<a name="ln4149">    curwin-&gt;w_valid |= VALID_TOPLINE;</a>
<a name="ln4150"> </a>
<a name="ln4151">    /* If moved back to where we were, at least move the cursor, otherwise</a>
<a name="ln4152">     * we get stuck at one position.  Don't move the cursor up if the</a>
<a name="ln4153">     * first line of the buffer is already on the screen */</a>
<a name="ln4154">    while (curwin-&gt;w_topline == prev_topline</a>
<a name="ln4155">           &amp;&amp; curwin-&gt;w_topfill == prev_topfill</a>
<a name="ln4156">           ) {</a>
<a name="ln4157">      if (up) {</a>
<a name="ln4158">        if (curwin-&gt;w_cursor.lnum &gt; prev_lnum</a>
<a name="ln4159">            || cursor_down(1L, false) == false)</a>
<a name="ln4160">          break;</a>
<a name="ln4161">      } else {</a>
<a name="ln4162">        if (curwin-&gt;w_cursor.lnum &lt; prev_lnum</a>
<a name="ln4163">            || prev_topline == 1L</a>
<a name="ln4164">            || cursor_up(1L, false) == false)</a>
<a name="ln4165">          break;</a>
<a name="ln4166">      }</a>
<a name="ln4167">      /* Mark w_topline as valid, otherwise the screen jumps back at the</a>
<a name="ln4168">       * end of the file. */</a>
<a name="ln4169">      check_cursor_moved(curwin);</a>
<a name="ln4170">      curwin-&gt;w_valid |= VALID_TOPLINE;</a>
<a name="ln4171">    }</a>
<a name="ln4172">  }</a>
<a name="ln4173">  if (curwin-&gt;w_cursor.lnum != prev_lnum) {</a>
<a name="ln4174">    coladvance(curwin-&gt;w_curswant);</a>
<a name="ln4175">  }</a>
<a name="ln4176">  if (moved) {</a>
<a name="ln4177">    curwin-&gt;w_viewport_invalid = true;</a>
<a name="ln4178">  }</a>
<a name="ln4179">  redraw_later(curwin, VALID);</a>
<a name="ln4180">}</a>
<a name="ln4181"> </a>
<a name="ln4182">/*</a>
<a name="ln4183"> * Commands that start with &quot;z&quot;.</a>
<a name="ln4184"> */</a>
<a name="ln4185">static void nv_zet(cmdarg_T *cap)</a>
<a name="ln4186">{</a>
<a name="ln4187">  int n;</a>
<a name="ln4188">  colnr_T col;</a>
<a name="ln4189">  int nchar = cap-&gt;nchar;</a>
<a name="ln4190">  long old_fdl = curwin-&gt;w_p_fdl;</a>
<a name="ln4191">  int old_fen = curwin-&gt;w_p_fen;</a>
<a name="ln4192">  bool undo = false;</a>
<a name="ln4193"> </a>
<a name="ln4194">  int l_p_siso = (int)get_sidescrolloff_value(curwin);</a>
<a name="ln4195">  assert(l_p_siso &lt;= INT_MAX);</a>
<a name="ln4196"> </a>
<a name="ln4197">  if (ascii_isdigit(nchar)) {</a>
<a name="ln4198">    /*</a>
<a name="ln4199">     * &quot;z123{nchar}&quot;: edit the count before obtaining {nchar}</a>
<a name="ln4200">     */</a>
<a name="ln4201">    if (checkclearop(cap-&gt;oap))</a>
<a name="ln4202">      return;</a>
<a name="ln4203">    n = nchar - '0';</a>
<a name="ln4204">    for (;; ) {</a>
<a name="ln4205">      no_mapping++;</a>
<a name="ln4206">      nchar = plain_vgetc();</a>
<a name="ln4207">      LANGMAP_ADJUST(nchar, true);</a>
<a name="ln4208">      no_mapping--;</a>
<a name="ln4209">      (void)add_to_showcmd(nchar);</a>
<a name="ln4210">      if (nchar == K_DEL || nchar == K_KDEL)</a>
<a name="ln4211">        n /= 10;</a>
<a name="ln4212">      else if (ascii_isdigit(nchar))</a>
<a name="ln4213">        n = n * 10 + (nchar - '0');</a>
<a name="ln4214">      else if (nchar == CAR) {</a>
<a name="ln4215">        win_setheight(n);</a>
<a name="ln4216">        break;</a>
<a name="ln4217">      } else if (nchar == 'l'</a>
<a name="ln4218">                 || nchar == 'h'</a>
<a name="ln4219">                 || nchar == K_LEFT</a>
<a name="ln4220">                 || nchar == K_RIGHT) {</a>
<a name="ln4221">        cap-&gt;count1 = n ? n * cap-&gt;count1 : cap-&gt;count1;</a>
<a name="ln4222">        goto dozet;</a>
<a name="ln4223">      } else {</a>
<a name="ln4224">        clearopbeep(cap-&gt;oap);</a>
<a name="ln4225">        break;</a>
<a name="ln4226">      }</a>
<a name="ln4227">    }</a>
<a name="ln4228">    cap-&gt;oap-&gt;op_type = OP_NOP;</a>
<a name="ln4229">    return;</a>
<a name="ln4230">  }</a>
<a name="ln4231"> </a>
<a name="ln4232">dozet:</a>
<a name="ln4233">  // &quot;zf&quot; and &quot;zF&quot; are always an operator, &quot;zd&quot;, &quot;zo&quot;, &quot;zO&quot;, &quot;zc&quot;</a>
<a name="ln4234">  // and &quot;zC&quot; only in Visual mode.  &quot;zj&quot; and &quot;zk&quot; are motion</a>
<a name="ln4235">  // commands. */</a>
<a name="ln4236">  if (cap-&gt;nchar != 'f' &amp;&amp; cap-&gt;nchar != 'F'</a>
<a name="ln4237">      &amp;&amp; !(VIsual_active &amp;&amp; vim_strchr((char_u *)&quot;dcCoO&quot;, cap-&gt;nchar))</a>
<a name="ln4238">      &amp;&amp; cap-&gt;nchar != 'j' &amp;&amp; cap-&gt;nchar != 'k'</a>
<a name="ln4239">      &amp;&amp; checkclearop(cap-&gt;oap)) {</a>
<a name="ln4240">    return;</a>
<a name="ln4241">  }</a>
<a name="ln4242"> </a>
<a name="ln4243">  /*</a>
<a name="ln4244">   * For &quot;z+&quot;, &quot;z&lt;CR&gt;&quot;, &quot;zt&quot;, &quot;z.&quot;, &quot;zz&quot;, &quot;z^&quot;, &quot;z-&quot;, &quot;zb&quot;:</a>
<a name="ln4245">   * If line number given, set cursor.</a>
<a name="ln4246">   */</a>
<a name="ln4247">  if ((vim_strchr((char_u *)&quot;+\r\nt.z^-b&quot;, nchar) != NULL)</a>
<a name="ln4248">      &amp;&amp; cap-&gt;count0</a>
<a name="ln4249">      &amp;&amp; cap-&gt;count0 != curwin-&gt;w_cursor.lnum) {</a>
<a name="ln4250">    setpcmark();</a>
<a name="ln4251">    if (cap-&gt;count0 &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln4252">      curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln4253">    else</a>
<a name="ln4254">      curwin-&gt;w_cursor.lnum = cap-&gt;count0;</a>
<a name="ln4255">    check_cursor_col();</a>
<a name="ln4256">  }</a>
<a name="ln4257"> </a>
<a name="ln4258">  switch (nchar) {</a>
<a name="ln4259">  /* &quot;z+&quot;, &quot;z&lt;CR&gt;&quot; and &quot;zt&quot;: put cursor at top of screen */</a>
<a name="ln4260">  case '+':</a>
<a name="ln4261">    if (cap-&gt;count0 == 0) {</a>
<a name="ln4262">      // No count given: put cursor at the line below screen</a>
<a name="ln4263">      validate_botline(curwin);               // make sure w_botline is valid</a>
<a name="ln4264">      if (curwin-&gt;w_botline &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln4265">        curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln4266">      } else {</a>
<a name="ln4267">        curwin-&gt;w_cursor.lnum = curwin-&gt;w_botline;</a>
<a name="ln4268">      }</a>
<a name="ln4269">    }</a>
<a name="ln4270">    FALLTHROUGH;</a>
<a name="ln4271">  case NL:</a>
<a name="ln4272">  case CAR:</a>
<a name="ln4273">  case K_KENTER:</a>
<a name="ln4274">    beginline(BL_WHITE | BL_FIX);</a>
<a name="ln4275">    FALLTHROUGH;</a>
<a name="ln4276"> </a>
<a name="ln4277">  case 't':   scroll_cursor_top(0, true);</a>
<a name="ln4278">    redraw_later(curwin, VALID);</a>
<a name="ln4279">    set_fraction(curwin);</a>
<a name="ln4280">    break;</a>
<a name="ln4281"> </a>
<a name="ln4282">  /* &quot;z.&quot; and &quot;zz&quot;: put cursor in middle of screen */</a>
<a name="ln4283">  case '.':   beginline(BL_WHITE | BL_FIX);</a>
<a name="ln4284">  FALLTHROUGH;</a>
<a name="ln4285"> </a>
<a name="ln4286">  case 'z':   scroll_cursor_halfway(true);</a>
<a name="ln4287">    redraw_later(curwin, VALID);</a>
<a name="ln4288">    set_fraction(curwin);</a>
<a name="ln4289">    break;</a>
<a name="ln4290"> </a>
<a name="ln4291">  // &quot;z^&quot;, &quot;z-&quot; and &quot;zb&quot;: put cursor at bottom of screen</a>
<a name="ln4292">  case '^':     // Strange Vi behavior: &lt;count&gt;z^ finds line at top of window</a>
<a name="ln4293">                // when &lt;count&gt; is at bottom of window, and puts that one at</a>
<a name="ln4294">                // bottom of window.</a>
<a name="ln4295">    if (cap-&gt;count0 != 0) {</a>
<a name="ln4296">      scroll_cursor_bot(0, true);</a>
<a name="ln4297">      curwin-&gt;w_cursor.lnum = curwin-&gt;w_topline;</a>
<a name="ln4298">    } else if (curwin-&gt;w_topline == 1)</a>
<a name="ln4299">      curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln4300">    else</a>
<a name="ln4301">      curwin-&gt;w_cursor.lnum = curwin-&gt;w_topline - 1;</a>
<a name="ln4302">    FALLTHROUGH;</a>
<a name="ln4303">  case '-':</a>
<a name="ln4304">    beginline(BL_WHITE | BL_FIX);</a>
<a name="ln4305">    FALLTHROUGH;</a>
<a name="ln4306"> </a>
<a name="ln4307">  case 'b':   scroll_cursor_bot(0, true);</a>
<a name="ln4308">    redraw_later(curwin, VALID);</a>
<a name="ln4309">    set_fraction(curwin);</a>
<a name="ln4310">    break;</a>
<a name="ln4311"> </a>
<a name="ln4312">  /* &quot;zH&quot; - scroll screen right half-page */</a>
<a name="ln4313">  case 'H':</a>
<a name="ln4314">    cap-&gt;count1 *= curwin-&gt;w_width_inner / 2;</a>
<a name="ln4315">    FALLTHROUGH;</a>
<a name="ln4316"> </a>
<a name="ln4317">  /* &quot;zh&quot; - scroll screen to the right */</a>
<a name="ln4318">  case 'h':</a>
<a name="ln4319">  case K_LEFT:</a>
<a name="ln4320">    if (!curwin-&gt;w_p_wrap) {</a>
<a name="ln4321">      if ((colnr_T)cap-&gt;count1 &gt; curwin-&gt;w_leftcol)</a>
<a name="ln4322">        curwin-&gt;w_leftcol = 0;</a>
<a name="ln4323">      else</a>
<a name="ln4324">        curwin-&gt;w_leftcol -= (colnr_T)cap-&gt;count1;</a>
<a name="ln4325">      leftcol_changed();</a>
<a name="ln4326">    }</a>
<a name="ln4327">    break;</a>
<a name="ln4328"> </a>
<a name="ln4329">  // &quot;zL&quot; - scroll screen left half-page</a>
<a name="ln4330">  case 'L':   cap-&gt;count1 *= curwin-&gt;w_width_inner / 2;</a>
<a name="ln4331">    FALLTHROUGH;</a>
<a name="ln4332"> </a>
<a name="ln4333">  /* &quot;zl&quot; - scroll screen to the left */</a>
<a name="ln4334">  case 'l':</a>
<a name="ln4335">  case K_RIGHT:</a>
<a name="ln4336">    if (!curwin-&gt;w_p_wrap) {</a>
<a name="ln4337">      /* scroll the window left */</a>
<a name="ln4338">      curwin-&gt;w_leftcol += (colnr_T)cap-&gt;count1;</a>
<a name="ln4339">      leftcol_changed();</a>
<a name="ln4340">    }</a>
<a name="ln4341">    break;</a>
<a name="ln4342"> </a>
<a name="ln4343">  /* &quot;zs&quot; - scroll screen, cursor at the start */</a>
<a name="ln4344">  case 's':   if (!curwin-&gt;w_p_wrap) {</a>
<a name="ln4345">      if (hasFolding(curwin-&gt;w_cursor.lnum, NULL, NULL))</a>
<a name="ln4346">        col = 0;                        /* like the cursor is in col 0 */</a>
<a name="ln4347">      else</a>
<a name="ln4348">        getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;col, NULL, NULL);</a>
<a name="ln4349">      if (col &gt; l_p_siso)</a>
<a name="ln4350">        col -= l_p_siso;</a>
<a name="ln4351">      else</a>
<a name="ln4352">        col = 0;</a>
<a name="ln4353">      if (curwin-&gt;w_leftcol != col) {</a>
<a name="ln4354">        curwin-&gt;w_leftcol = col;</a>
<a name="ln4355">        redraw_later(curwin, NOT_VALID);</a>
<a name="ln4356">      }</a>
<a name="ln4357">  }</a>
<a name="ln4358">    break;</a>
<a name="ln4359"> </a>
<a name="ln4360">  /* &quot;ze&quot; - scroll screen, cursor at the end */</a>
<a name="ln4361">  case 'e':   if (!curwin-&gt;w_p_wrap) {</a>
<a name="ln4362">      if (hasFolding(curwin-&gt;w_cursor.lnum, NULL, NULL))</a>
<a name="ln4363">        col = 0;                        /* like the cursor is in col 0 */</a>
<a name="ln4364">      else</a>
<a name="ln4365">        getvcol(curwin, &amp;curwin-&gt;w_cursor, NULL, NULL, &amp;col);</a>
<a name="ln4366">      n = curwin-&gt;w_width_inner - curwin_col_off();</a>
<a name="ln4367">      if (col + l_p_siso &lt; n) {</a>
<a name="ln4368">        col = 0;</a>
<a name="ln4369">      } else {</a>
<a name="ln4370">        col = col + l_p_siso - n + 1;</a>
<a name="ln4371">      }</a>
<a name="ln4372">      if (curwin-&gt;w_leftcol != col) {</a>
<a name="ln4373">        curwin-&gt;w_leftcol = col;</a>
<a name="ln4374">        redraw_later(curwin, NOT_VALID);</a>
<a name="ln4375">      }</a>
<a name="ln4376">  }</a>
<a name="ln4377">    break;</a>
<a name="ln4378"> </a>
<a name="ln4379">  /* &quot;zF&quot;: create fold command */</a>
<a name="ln4380">  /* &quot;zf&quot;: create fold operator */</a>
<a name="ln4381">  case 'F':</a>
<a name="ln4382">  case 'f':   if (foldManualAllowed(true)) {</a>
<a name="ln4383">      cap-&gt;nchar = 'f';</a>
<a name="ln4384">      nv_operator(cap);</a>
<a name="ln4385">      curwin-&gt;w_p_fen = true;</a>
<a name="ln4386"> </a>
<a name="ln4387">      /* &quot;zF&quot; is like &quot;zfzf&quot; */</a>
<a name="ln4388">      if (nchar == 'F' &amp;&amp; cap-&gt;oap-&gt;op_type == OP_FOLD) {</a>
<a name="ln4389">        nv_operator(cap);</a>
<a name="ln4390">        finish_op = true;</a>
<a name="ln4391">      }</a>
<a name="ln4392">  } else</a>
<a name="ln4393">      clearopbeep(cap-&gt;oap);</a>
<a name="ln4394">    break;</a>
<a name="ln4395"> </a>
<a name="ln4396">  /* &quot;zd&quot;: delete fold at cursor */</a>
<a name="ln4397">  /* &quot;zD&quot;: delete fold at cursor recursively */</a>
<a name="ln4398">  case 'd':</a>
<a name="ln4399">  case 'D':   if (foldManualAllowed(false)) {</a>
<a name="ln4400">      if (VIsual_active) {</a>
<a name="ln4401">        nv_operator(cap);</a>
<a name="ln4402">      } else {</a>
<a name="ln4403">        deleteFold(curwin, curwin-&gt;w_cursor.lnum,</a>
<a name="ln4404">                   curwin-&gt;w_cursor.lnum, nchar == 'D', false);</a>
<a name="ln4405">      }</a>
<a name="ln4406">  }</a>
<a name="ln4407">    break;</a>
<a name="ln4408"> </a>
<a name="ln4409">  /* &quot;zE&quot;: erase all folds */</a>
<a name="ln4410">  case 'E':   if (foldmethodIsManual(curwin)) {</a>
<a name="ln4411">      clearFolding(curwin);</a>
<a name="ln4412">      changed_window_setting();</a>
<a name="ln4413">    } else if (foldmethodIsMarker(curwin)) {</a>
<a name="ln4414">      deleteFold(curwin, (linenr_T)1, curbuf-&gt;b_ml.ml_line_count, true, false);</a>
<a name="ln4415">    } else {</a>
<a name="ln4416">      EMSG(_(&quot;E352: Cannot erase folds with current 'foldmethod'&quot;));</a>
<a name="ln4417">    }</a>
<a name="ln4418">    break;</a>
<a name="ln4419"> </a>
<a name="ln4420">  /* &quot;zn&quot;: fold none: reset 'foldenable' */</a>
<a name="ln4421">  case 'n':   curwin-&gt;w_p_fen = false;</a>
<a name="ln4422">    break;</a>
<a name="ln4423"> </a>
<a name="ln4424">  /* &quot;zN&quot;: fold Normal: set 'foldenable' */</a>
<a name="ln4425">  case 'N':   curwin-&gt;w_p_fen = true;</a>
<a name="ln4426">    break;</a>
<a name="ln4427"> </a>
<a name="ln4428">  /* &quot;zi&quot;: invert folding: toggle 'foldenable' */</a>
<a name="ln4429">  case 'i':   curwin-&gt;w_p_fen = !curwin-&gt;w_p_fen;</a>
<a name="ln4430">    break;</a>
<a name="ln4431"> </a>
<a name="ln4432">  // &quot;za&quot;: open closed fold or close open fold at cursor</a>
<a name="ln4433">  case 'a':   if (hasFolding(curwin-&gt;w_cursor.lnum, NULL, NULL)) {</a>
<a name="ln4434">      openFold(curwin-&gt;w_cursor, cap-&gt;count1);</a>
<a name="ln4435">    } else {</a>
<a name="ln4436">      closeFold(curwin-&gt;w_cursor, cap-&gt;count1);</a>
<a name="ln4437">      curwin-&gt;w_p_fen = true;</a>
<a name="ln4438">    }</a>
<a name="ln4439">    break;</a>
<a name="ln4440"> </a>
<a name="ln4441">  // &quot;zA&quot;: open fold at cursor recursively</a>
<a name="ln4442">  case 'A':   if (hasFolding(curwin-&gt;w_cursor.lnum, NULL, NULL)) {</a>
<a name="ln4443">      openFoldRecurse(curwin-&gt;w_cursor);</a>
<a name="ln4444">    } else {</a>
<a name="ln4445">      closeFoldRecurse(curwin-&gt;w_cursor);</a>
<a name="ln4446">      curwin-&gt;w_p_fen = true;</a>
<a name="ln4447">    }</a>
<a name="ln4448">    break;</a>
<a name="ln4449"> </a>
<a name="ln4450">  // &quot;zo&quot;: open fold at cursor or Visual area</a>
<a name="ln4451">  case 'o':   if (VIsual_active) {</a>
<a name="ln4452">      nv_operator(cap);</a>
<a name="ln4453">    } else {</a>
<a name="ln4454">      openFold(curwin-&gt;w_cursor, cap-&gt;count1);</a>
<a name="ln4455">    }</a>
<a name="ln4456">    break;</a>
<a name="ln4457"> </a>
<a name="ln4458">  // &quot;zO&quot;: open fold recursively</a>
<a name="ln4459">  case 'O':   if (VIsual_active) {</a>
<a name="ln4460">      nv_operator(cap);</a>
<a name="ln4461">    } else {</a>
<a name="ln4462">      openFoldRecurse(curwin-&gt;w_cursor);</a>
<a name="ln4463">    }</a>
<a name="ln4464">    break;</a>
<a name="ln4465"> </a>
<a name="ln4466">  // &quot;zc&quot;: close fold at cursor or Visual area</a>
<a name="ln4467">  case 'c':   if (VIsual_active) {</a>
<a name="ln4468">      nv_operator(cap);</a>
<a name="ln4469">              } else {</a>
<a name="ln4470">      closeFold(curwin-&gt;w_cursor, cap-&gt;count1);</a>
<a name="ln4471">    }</a>
<a name="ln4472">    curwin-&gt;w_p_fen = true;</a>
<a name="ln4473">    break;</a>
<a name="ln4474"> </a>
<a name="ln4475">  // &quot;zC&quot;: close fold recursively</a>
<a name="ln4476">  case 'C':   if (VIsual_active) {</a>
<a name="ln4477">      nv_operator(cap);</a>
<a name="ln4478">    } else {</a>
<a name="ln4479">      closeFoldRecurse(curwin-&gt;w_cursor);</a>
<a name="ln4480">    }</a>
<a name="ln4481">    curwin-&gt;w_p_fen = true;</a>
<a name="ln4482">    break;</a>
<a name="ln4483"> </a>
<a name="ln4484">  /* &quot;zv&quot;: open folds at the cursor */</a>
<a name="ln4485">  case 'v':   foldOpenCursor();</a>
<a name="ln4486">    break;</a>
<a name="ln4487"> </a>
<a name="ln4488">  /* &quot;zx&quot;: re-apply 'foldlevel' and open folds at the cursor */</a>
<a name="ln4489">  case 'x':   curwin-&gt;w_p_fen = true;</a>
<a name="ln4490">    curwin-&gt;w_foldinvalid = true;               /* recompute folds */</a>
<a name="ln4491">    newFoldLevel();                             /* update right now */</a>
<a name="ln4492">    foldOpenCursor();</a>
<a name="ln4493">    break;</a>
<a name="ln4494"> </a>
<a name="ln4495">  /* &quot;zX&quot;: undo manual opens/closes, re-apply 'foldlevel' */</a>
<a name="ln4496">  case 'X':   curwin-&gt;w_p_fen = true;</a>
<a name="ln4497">    curwin-&gt;w_foldinvalid = true;               /* recompute folds */</a>
<a name="ln4498">    old_fdl = -1;                               /* force an update */</a>
<a name="ln4499">    break;</a>
<a name="ln4500"> </a>
<a name="ln4501">  /* &quot;zm&quot;: fold more */</a>
<a name="ln4502">  case 'm':</a>
<a name="ln4503">    if (curwin-&gt;w_p_fdl &gt; 0) {</a>
<a name="ln4504">      curwin-&gt;w_p_fdl -= cap-&gt;count1;</a>
<a name="ln4505">      if (curwin-&gt;w_p_fdl &lt; 0) {</a>
<a name="ln4506">        curwin-&gt;w_p_fdl = 0;</a>
<a name="ln4507">      }</a>
<a name="ln4508">    }</a>
<a name="ln4509">    old_fdl = -1;                       /* force an update */</a>
<a name="ln4510">    curwin-&gt;w_p_fen = true;</a>
<a name="ln4511">    break;</a>
<a name="ln4512"> </a>
<a name="ln4513">  /* &quot;zM&quot;: close all folds */</a>
<a name="ln4514">  case 'M':   curwin-&gt;w_p_fdl = 0;</a>
<a name="ln4515">    old_fdl = -1;                       /* force an update */</a>
<a name="ln4516">    curwin-&gt;w_p_fen = true;</a>
<a name="ln4517">    break;</a>
<a name="ln4518"> </a>
<a name="ln4519">  /* &quot;zr&quot;: reduce folding */</a>
<a name="ln4520">  case 'r':</a>
<a name="ln4521">    curwin-&gt;w_p_fdl += cap-&gt;count1;</a>
<a name="ln4522">    {</a>
<a name="ln4523">      int d = getDeepestNesting(curwin);</a>
<a name="ln4524">      if (curwin-&gt;w_p_fdl &gt;= d) {</a>
<a name="ln4525">        curwin-&gt;w_p_fdl = d;</a>
<a name="ln4526">      }</a>
<a name="ln4527">    }</a>
<a name="ln4528">    break;</a>
<a name="ln4529"> </a>
<a name="ln4530">  case 'R':     //  &quot;zR&quot;: open all folds</a>
<a name="ln4531">    curwin-&gt;w_p_fdl = getDeepestNesting(curwin);</a>
<a name="ln4532">    old_fdl = -1;                       // force an update</a>
<a name="ln4533">    break;</a>
<a name="ln4534"> </a>
<a name="ln4535">  case 'j':     /* &quot;zj&quot; move to next fold downwards */</a>
<a name="ln4536">  case 'k':     /* &quot;zk&quot; move to next fold upwards */</a>
<a name="ln4537">    if (foldMoveTo(true, nchar == 'j' ? FORWARD : BACKWARD,</a>
<a name="ln4538">            cap-&gt;count1) == false)</a>
<a name="ln4539">      clearopbeep(cap-&gt;oap);</a>
<a name="ln4540">    break;</a>
<a name="ln4541"> </a>
<a name="ln4542"> </a>
<a name="ln4543">  case 'u':     // &quot;zug&quot; and &quot;zuw&quot;: undo &quot;zg&quot; and &quot;zw&quot;</a>
<a name="ln4544">    no_mapping++;</a>
<a name="ln4545">    nchar = plain_vgetc();</a>
<a name="ln4546">    LANGMAP_ADJUST(nchar, true);</a>
<a name="ln4547">    no_mapping--;</a>
<a name="ln4548">    (void)add_to_showcmd(nchar);</a>
<a name="ln4549">    if (vim_strchr((char_u *)&quot;gGwW&quot;, nchar) == NULL) {</a>
<a name="ln4550">      clearopbeep(cap-&gt;oap);</a>
<a name="ln4551">      break;</a>
<a name="ln4552">    }</a>
<a name="ln4553">    undo = true;</a>
<a name="ln4554">    FALLTHROUGH;</a>
<a name="ln4555"> </a>
<a name="ln4556">  case 'g':     /* &quot;zg&quot;: add good word to word list */</a>
<a name="ln4557">  case 'w':     /* &quot;zw&quot;: add wrong word to word list */</a>
<a name="ln4558">  case 'G':     /* &quot;zG&quot;: add good word to temp word list */</a>
<a name="ln4559">  case 'W':     /* &quot;zW&quot;: add wrong word to temp word list */</a>
<a name="ln4560">  {</a>
<a name="ln4561">    char_u  *ptr = NULL;</a>
<a name="ln4562">    size_t len;</a>
<a name="ln4563"> </a>
<a name="ln4564">    if (checkclearop(cap-&gt;oap))</a>
<a name="ln4565">      break;</a>
<a name="ln4566">    if (VIsual_active &amp;&amp; !get_visual_text(cap, &amp;ptr, &amp;len))</a>
<a name="ln4567">      return;</a>
<a name="ln4568">    if (ptr == NULL) {</a>
<a name="ln4569">      pos_T pos = curwin-&gt;w_cursor;</a>
<a name="ln4570"> </a>
<a name="ln4571">      /* Find bad word under the cursor.  When 'spell' is</a>
<a name="ln4572">       * off this fails and find_ident_under_cursor() is</a>
<a name="ln4573">       * used below. */</a>
<a name="ln4574">      emsg_off++;</a>
<a name="ln4575">      len = spell_move_to(curwin, FORWARD, true, true, NULL);</a>
<a name="ln4576">      emsg_off--;</a>
<a name="ln4577">      if (len != 0 &amp;&amp; curwin-&gt;w_cursor.col &lt;= pos.col)</a>
<a name="ln4578">        ptr = ml_get_pos(&amp;curwin-&gt;w_cursor);</a>
<a name="ln4579">      curwin-&gt;w_cursor = pos;</a>
<a name="ln4580">    }</a>
<a name="ln4581"> </a>
<a name="ln4582">    if (ptr == NULL &amp;&amp; (len = find_ident_under_cursor(&amp;ptr, FIND_IDENT)) == 0)</a>
<a name="ln4583">      return;</a>
<a name="ln4584">    assert(len &lt;= INT_MAX);</a>
<a name="ln4585">    spell_add_word(ptr, (int)len, nchar == 'w' || nchar == 'W',</a>
<a name="ln4586">                   (nchar == 'G' || nchar == 'W') ? 0 : (int)cap-&gt;count1,</a>
<a name="ln4587">                   undo);</a>
<a name="ln4588">  }</a>
<a name="ln4589">  break;</a>
<a name="ln4590"> </a>
<a name="ln4591">  case '=':     /* &quot;z=&quot;: suggestions for a badly spelled word  */</a>
<a name="ln4592">    if (!checkclearop(cap-&gt;oap))</a>
<a name="ln4593">      spell_suggest((int)cap-&gt;count0);</a>
<a name="ln4594">    break;</a>
<a name="ln4595"> </a>
<a name="ln4596">  default:    clearopbeep(cap-&gt;oap);</a>
<a name="ln4597">  }</a>
<a name="ln4598"> </a>
<a name="ln4599">  /* Redraw when 'foldenable' changed */</a>
<a name="ln4600">  if (old_fen != curwin-&gt;w_p_fen) {</a>
<a name="ln4601">    if (foldmethodIsDiff(curwin) &amp;&amp; curwin-&gt;w_p_scb) {</a>
<a name="ln4602">      /* Adjust 'foldenable' in diff-synced windows. */</a>
<a name="ln4603">      FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln4604">        if (wp != curwin &amp;&amp; foldmethodIsDiff(wp) &amp;&amp; wp-&gt;w_p_scb) {</a>
<a name="ln4605">          wp-&gt;w_p_fen = curwin-&gt;w_p_fen;</a>
<a name="ln4606">          changed_window_setting_win(wp);</a>
<a name="ln4607">        }</a>
<a name="ln4608">      }</a>
<a name="ln4609">    }</a>
<a name="ln4610">    changed_window_setting();</a>
<a name="ln4611">  }</a>
<a name="ln4612"> </a>
<a name="ln4613">  /* Redraw when 'foldlevel' changed. */</a>
<a name="ln4614">  if (old_fdl != curwin-&gt;w_p_fdl)</a>
<a name="ln4615">    newFoldLevel();</a>
<a name="ln4616">}</a>
<a name="ln4617"> </a>
<a name="ln4618"> </a>
<a name="ln4619"> </a>
<a name="ln4620">/*</a>
<a name="ln4621"> * &quot;Q&quot; command.</a>
<a name="ln4622"> */</a>
<a name="ln4623">static void nv_exmode(cmdarg_T *cap)</a>
<a name="ln4624">{</a>
<a name="ln4625">  /*</a>
<a name="ln4626">   * Ignore 'Q' in Visual mode, just give a beep.</a>
<a name="ln4627">   */</a>
<a name="ln4628">  if (VIsual_active) {</a>
<a name="ln4629">    vim_beep(BO_EX);</a>
<a name="ln4630">  } else if (!checkclearop(cap-&gt;oap)) {</a>
<a name="ln4631">    do_exmode(false);</a>
<a name="ln4632">  }</a>
<a name="ln4633">}</a>
<a name="ln4634"> </a>
<a name="ln4635">/// Handle a &quot;:&quot; command and &lt;Cmd&gt;.</a>
<a name="ln4636">static void nv_colon(cmdarg_T *cap)</a>
<a name="ln4637">{</a>
<a name="ln4638">  int old_p_im;</a>
<a name="ln4639">  bool cmd_result;</a>
<a name="ln4640">  bool is_cmdkey = cap-&gt;cmdchar == K_COMMAND;</a>
<a name="ln4641"> </a>
<a name="ln4642">  if (VIsual_active &amp;&amp; !is_cmdkey) {</a>
<a name="ln4643">    nv_operator(cap);</a>
<a name="ln4644">  } else {</a>
<a name="ln4645">    if (cap-&gt;oap-&gt;op_type != OP_NOP) {</a>
<a name="ln4646">      // Using &quot;:&quot; as a movement is charwise exclusive.</a>
<a name="ln4647">      cap-&gt;oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln4648">      cap-&gt;oap-&gt;inclusive = false;</a>
<a name="ln4649">    } else if (cap-&gt;count0 &amp;&amp; !is_cmdkey) {</a>
<a name="ln4650">      // translate &quot;count:&quot; into &quot;:.,.+(count - 1)&quot;</a>
<a name="ln4651">      stuffcharReadbuff('.');</a>
<a name="ln4652">      if (cap-&gt;count0 &gt; 1) {</a>
<a name="ln4653">        stuffReadbuff(&quot;,.+&quot;);</a>
<a name="ln4654">        stuffnumReadbuff(cap-&gt;count0 - 1L);</a>
<a name="ln4655">      }</a>
<a name="ln4656">    }</a>
<a name="ln4657"> </a>
<a name="ln4658">    /* When typing, don't type below an old message */</a>
<a name="ln4659">    if (KeyTyped)</a>
<a name="ln4660">      compute_cmdrow();</a>
<a name="ln4661"> </a>
<a name="ln4662">    old_p_im = p_im;</a>
<a name="ln4663"> </a>
<a name="ln4664">    // get a command line and execute it</a>
<a name="ln4665">    cmd_result = do_cmdline(NULL, is_cmdkey ? getcmdkeycmd : getexline, NULL,</a>
<a name="ln4666">                            cap-&gt;oap-&gt;op_type != OP_NOP ? DOCMD_KEEPLINE : 0);</a>
<a name="ln4667"> </a>
<a name="ln4668">    /* If 'insertmode' changed, enter or exit Insert mode */</a>
<a name="ln4669">    if (p_im != old_p_im) {</a>
<a name="ln4670">      if (p_im)</a>
<a name="ln4671">        restart_edit = 'i';</a>
<a name="ln4672">      else</a>
<a name="ln4673">        restart_edit = 0;</a>
<a name="ln4674">    }</a>
<a name="ln4675"> </a>
<a name="ln4676">    if (cmd_result == false)</a>
<a name="ln4677">      /* The Ex command failed, do not execute the operator. */</a>
<a name="ln4678">      clearop(cap-&gt;oap);</a>
<a name="ln4679">    else if (cap-&gt;oap-&gt;op_type != OP_NOP</a>
<a name="ln4680">             &amp;&amp; (cap-&gt;oap-&gt;start.lnum &gt; curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln4681">                 || cap-&gt;oap-&gt;start.col &gt;</a>
<a name="ln4682">                 (colnr_T)STRLEN(ml_get(cap-&gt;oap-&gt;start.lnum))</a>
<a name="ln4683">                 || did_emsg</a>
<a name="ln4684">                 ))</a>
<a name="ln4685">      /* The start of the operator has become invalid by the Ex command.</a>
<a name="ln4686">       */</a>
<a name="ln4687">      clearopbeep(cap-&gt;oap);</a>
<a name="ln4688">  }</a>
<a name="ln4689">}</a>
<a name="ln4690"> </a>
<a name="ln4691">/*</a>
<a name="ln4692"> * Handle CTRL-G command.</a>
<a name="ln4693"> */</a>
<a name="ln4694">static void nv_ctrlg(cmdarg_T *cap)</a>
<a name="ln4695">{</a>
<a name="ln4696">  if (VIsual_active) {  /* toggle Selection/Visual mode */</a>
<a name="ln4697">    VIsual_select = !VIsual_select;</a>
<a name="ln4698">    showmode();</a>
<a name="ln4699">  } else if (!checkclearop(cap-&gt;oap))</a>
<a name="ln4700">    /* print full name if count given or :cd used */</a>
<a name="ln4701">    fileinfo((int)cap-&gt;count0, false, true);</a>
<a name="ln4702">}</a>
<a name="ln4703"> </a>
<a name="ln4704">/*</a>
<a name="ln4705"> * Handle CTRL-H &lt;Backspace&gt; command.</a>
<a name="ln4706"> */</a>
<a name="ln4707">static void nv_ctrlh(cmdarg_T *cap)</a>
<a name="ln4708">{</a>
<a name="ln4709">  if (VIsual_active &amp;&amp; VIsual_select) {</a>
<a name="ln4710">    cap-&gt;cmdchar = 'x';         /* BS key behaves like 'x' in Select mode */</a>
<a name="ln4711">    v_visop(cap);</a>
<a name="ln4712">  } else</a>
<a name="ln4713">    nv_left(cap);</a>
<a name="ln4714">}</a>
<a name="ln4715"> </a>
<a name="ln4716">/*</a>
<a name="ln4717"> * CTRL-L: clear screen and redraw.</a>
<a name="ln4718"> */</a>
<a name="ln4719">static void nv_clear(cmdarg_T *cap)</a>
<a name="ln4720">{</a>
<a name="ln4721">  if (!checkclearop(cap-&gt;oap)) {</a>
<a name="ln4722">    /* Clear all syntax states to force resyncing. */</a>
<a name="ln4723">    syn_stack_free_all(curwin-&gt;w_s);</a>
<a name="ln4724">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln4725">      wp-&gt;w_s-&gt;b_syn_slow = false;</a>
<a name="ln4726">    }</a>
<a name="ln4727">    redraw_later(curwin, CLEAR);</a>
<a name="ln4728">  }</a>
<a name="ln4729">}</a>
<a name="ln4730"> </a>
<a name="ln4731">/*</a>
<a name="ln4732"> * CTRL-O: In Select mode: switch to Visual mode for one command.</a>
<a name="ln4733"> * Otherwise: Go to older pcmark.</a>
<a name="ln4734"> */</a>
<a name="ln4735">static void nv_ctrlo(cmdarg_T *cap)</a>
<a name="ln4736">{</a>
<a name="ln4737">  if (VIsual_active &amp;&amp; VIsual_select) {</a>
<a name="ln4738">    VIsual_select = false;</a>
<a name="ln4739">    showmode();</a>
<a name="ln4740">    restart_VIsual_select = 2;          /* restart Select mode later */</a>
<a name="ln4741">  } else {</a>
<a name="ln4742">    cap-&gt;count1 = -cap-&gt;count1;</a>
<a name="ln4743">    nv_pcmark(cap);</a>
<a name="ln4744">  }</a>
<a name="ln4745">}</a>
<a name="ln4746"> </a>
<a name="ln4747">// CTRL-^ command, short for &quot;:e #&quot;.  Works even when the alternate buffer is</a>
<a name="ln4748">// not named.</a>
<a name="ln4749">static void nv_hat(cmdarg_T *cap)</a>
<a name="ln4750">{</a>
<a name="ln4751">  if (!checkclearopq(cap-&gt;oap))</a>
<a name="ln4752">    (void)buflist_getfile((int)cap-&gt;count0, (linenr_T)0,</a>
<a name="ln4753">        GETF_SETMARK|GETF_ALT, false);</a>
<a name="ln4754">}</a>
<a name="ln4755"> </a>
<a name="ln4756">/*</a>
<a name="ln4757"> * &quot;Z&quot; commands.</a>
<a name="ln4758"> */</a>
<a name="ln4759">static void nv_Zet(cmdarg_T *cap)</a>
<a name="ln4760">{</a>
<a name="ln4761">  if (!checkclearopq(cap-&gt;oap)) {</a>
<a name="ln4762">    switch (cap-&gt;nchar) {</a>
<a name="ln4763">    /* &quot;ZZ&quot;: equivalent to &quot;:x&quot;. */</a>
<a name="ln4764">    case 'Z':   do_cmdline_cmd(&quot;x&quot;);</a>
<a name="ln4765">      break;</a>
<a name="ln4766"> </a>
<a name="ln4767">    /* &quot;ZQ&quot;: equivalent to &quot;:q!&quot; (Elvis compatible). */</a>
<a name="ln4768">    case 'Q':   do_cmdline_cmd(&quot;q!&quot;);</a>
<a name="ln4769">      break;</a>
<a name="ln4770"> </a>
<a name="ln4771">    default:    clearopbeep(cap-&gt;oap);</a>
<a name="ln4772">    }</a>
<a name="ln4773">  }</a>
<a name="ln4774">}</a>
<a name="ln4775"> </a>
<a name="ln4776">/*</a>
<a name="ln4777"> * Call nv_ident() as if &quot;c1&quot; was used, with &quot;c2&quot; as next character.</a>
<a name="ln4778"> */</a>
<a name="ln4779">void do_nv_ident(int c1, int c2)</a>
<a name="ln4780">{</a>
<a name="ln4781">  oparg_T oa;</a>
<a name="ln4782">  cmdarg_T ca;</a>
<a name="ln4783"> </a>
<a name="ln4784">  clear_oparg(&amp;oa);</a>
<a name="ln4785">  memset(&amp;ca, 0, sizeof(ca));</a>
<a name="ln4786">  ca.oap = &amp;oa;</a>
<a name="ln4787">  ca.cmdchar = c1;</a>
<a name="ln4788">  ca.nchar = c2;</a>
<a name="ln4789">  nv_ident(&amp;ca);</a>
<a name="ln4790">}</a>
<a name="ln4791"> </a>
<a name="ln4792">/*</a>
<a name="ln4793"> * Handle the commands that use the word under the cursor.</a>
<a name="ln4794"> * [g] CTRL-]	:ta to current identifier</a>
<a name="ln4795"> * [g] 'K'	run program for current identifier</a>
<a name="ln4796"> * [g] '*'	/ to current identifier or string</a>
<a name="ln4797"> * [g] '#'	? to current identifier or string</a>
<a name="ln4798"> *  g  ']'	:tselect for current identifier</a>
<a name="ln4799"> */</a>
<a name="ln4800">static void nv_ident(cmdarg_T *cap)</a>
<a name="ln4801">{</a>
<a name="ln4802">  char_u      *ptr = NULL;</a>
<a name="ln4803">  char_u      *p;</a>
<a name="ln4804">  size_t n = 0;                 /* init for GCC */</a>
<a name="ln4805">  int cmdchar;</a>
<a name="ln4806">  bool g_cmd;                   /* &quot;g&quot; command */</a>
<a name="ln4807">  bool tag_cmd = false;</a>
<a name="ln4808">  char_u      *aux_ptr;</a>
<a name="ln4809"> </a>
<a name="ln4810">  if (cap-&gt;cmdchar == 'g') {    /* &quot;g*&quot;, &quot;g#&quot;, &quot;g]&quot; and &quot;gCTRL-]&quot; */</a>
<a name="ln4811">    cmdchar = cap-&gt;nchar;</a>
<a name="ln4812">    g_cmd = true;</a>
<a name="ln4813">  } else {</a>
<a name="ln4814">    cmdchar = cap-&gt;cmdchar;</a>
<a name="ln4815">    g_cmd = false;</a>
<a name="ln4816">  }</a>
<a name="ln4817"> </a>
<a name="ln4818">  if (cmdchar == POUND)         /* the pound sign, '#' for English keyboards */</a>
<a name="ln4819">    cmdchar = '#';</a>
<a name="ln4820"> </a>
<a name="ln4821">  /*</a>
<a name="ln4822">   * The &quot;]&quot;, &quot;CTRL-]&quot; and &quot;K&quot; commands accept an argument in Visual mode.</a>
<a name="ln4823">   */</a>
<a name="ln4824">  if (cmdchar == ']' || cmdchar == Ctrl_RSB || cmdchar == 'K') {</a>
<a name="ln4825">    if (VIsual_active &amp;&amp; get_visual_text(cap, &amp;ptr, &amp;n) == false)</a>
<a name="ln4826">      return;</a>
<a name="ln4827">    if (checkclearopq(cap-&gt;oap))</a>
<a name="ln4828">      return;</a>
<a name="ln4829">  }</a>
<a name="ln4830"> </a>
<a name="ln4831">  if (ptr == NULL &amp;&amp; (n = find_ident_under_cursor(&amp;ptr,</a>
<a name="ln4832">                                                  ((cmdchar == '*'</a>
<a name="ln4833">                                                    || cmdchar == '#')</a>
<a name="ln4834">                                                   ? FIND_IDENT|FIND_STRING</a>
<a name="ln4835">                                                   : FIND_IDENT))) == 0) {</a>
<a name="ln4836">    clearop(cap-&gt;oap);</a>
<a name="ln4837">    return;</a>
<a name="ln4838">  }</a>
<a name="ln4839"> </a>
<a name="ln4840">  /* Allocate buffer to put the command in.  Inserting backslashes can</a>
<a name="ln4841">   * double the length of the word.  p_kp / curbuf-&gt;b_p_kp could be added</a>
<a name="ln4842">   * and some numbers. */</a>
<a name="ln4843">  char_u *kp = *curbuf-&gt;b_p_kp == NUL ? p_kp : curbuf-&gt;b_p_kp;  // 'keywordprg'</a>
<a name="ln4844">  assert(*kp != NUL);  // option.c:do_set() should default to &quot;:help&quot; if empty.</a>
<a name="ln4845">  bool kp_ex = (*kp == ':');  // 'keywordprg' is an ex command</a>
<a name="ln4846">  bool kp_help = (STRCMP(kp, &quot;:he&quot;) == 0 || STRCMP(kp, &quot;:help&quot;) == 0);</a>
<a name="ln4847">  if (kp_help &amp;&amp; *skipwhite(ptr) == NUL) {</a>
<a name="ln4848">    EMSG(_(e_noident));   // found white space only</a>
<a name="ln4849">    return;</a>
<a name="ln4850">  }</a>
<a name="ln4851">  size_t buf_size = n * 2 + 30 + STRLEN(kp);</a>
<a name="ln4852">  char *buf = xmalloc(buf_size);</a>
<a name="ln4853">  buf[0] = NUL;</a>
<a name="ln4854"> </a>
<a name="ln4855">  switch (cmdchar) {</a>
<a name="ln4856">  case '*':</a>
<a name="ln4857">  case '#':</a>
<a name="ln4858">    /*</a>
<a name="ln4859">     * Put cursor at start of word, makes search skip the word</a>
<a name="ln4860">     * under the cursor.</a>
<a name="ln4861">     * Call setpcmark() first, so &quot;*``&quot; puts the cursor back where</a>
<a name="ln4862">     * it was.</a>
<a name="ln4863">     */</a>
<a name="ln4864">    setpcmark();</a>
<a name="ln4865">    curwin-&gt;w_cursor.col = (colnr_T) (ptr - get_cursor_line_ptr());</a>
<a name="ln4866"> </a>
<a name="ln4867">    if (!g_cmd &amp;&amp; vim_iswordp(ptr))</a>
<a name="ln4868">      STRCPY(buf, &quot;\\&lt;&quot;);</a>
<a name="ln4869">    no_smartcase = true;                /* don't use 'smartcase' now */</a>
<a name="ln4870">    break;</a>
<a name="ln4871"> </a>
<a name="ln4872">  case 'K':</a>
<a name="ln4873">    if (kp_help) {</a>
<a name="ln4874">      STRCPY(buf, &quot;he! &quot;);</a>
<a name="ln4875">    } else if (kp_ex) {</a>
<a name="ln4876">      if (cap-&gt;count0 != 0) {  // Send the count to the ex command.</a>
<a name="ln4877">        snprintf(buf, buf_size, &quot;%&quot; PRId64, (int64_t)(cap-&gt;count0));</a>
<a name="ln4878">      }</a>
<a name="ln4879">      STRCAT(buf, kp);</a>
<a name="ln4880">      STRCAT(buf, &quot; &quot;);</a>
<a name="ln4881">    } else {</a>
<a name="ln4882">      /* An external command will probably use an argument starting</a>
<a name="ln4883">       * with &quot;-&quot; as an option.  To avoid trouble we skip the &quot;-&quot;. */</a>
<a name="ln4884">      while (*ptr == '-' &amp;&amp; n &gt; 0) {</a>
<a name="ln4885">        ++ptr;</a>
<a name="ln4886">        --n;</a>
<a name="ln4887">      }</a>
<a name="ln4888">      if (n == 0) {</a>
<a name="ln4889">        EMSG(_(e_noident));              /* found dashes only */</a>
<a name="ln4890">        xfree(buf);</a>
<a name="ln4891">        return;</a>
<a name="ln4892">      }</a>
<a name="ln4893"> </a>
<a name="ln4894">      /* When a count is given, turn it into a range.  Is this</a>
<a name="ln4895">       * really what we want? */</a>
<a name="ln4896">      bool isman = (STRCMP(kp, &quot;man&quot;) == 0);</a>
<a name="ln4897">      bool isman_s = (STRCMP(kp, &quot;man -s&quot;) == 0);</a>
<a name="ln4898">      if (cap-&gt;count0 != 0 &amp;&amp; !(isman || isman_s)) {</a>
<a name="ln4899">        snprintf(buf, buf_size, &quot;.,.+%&quot; PRId64, (int64_t)(cap-&gt;count0 - 1));</a>
<a name="ln4900">      }</a>
<a name="ln4901"> </a>
<a name="ln4902">      STRCAT(buf, &quot;! &quot;);</a>
<a name="ln4903">      if (cap-&gt;count0 == 0 &amp;&amp; isman_s) {</a>
<a name="ln4904">        STRCAT(buf, &quot;man&quot;);</a>
<a name="ln4905">      } else {</a>
<a name="ln4906">        STRCAT(buf, kp);</a>
<a name="ln4907">      }</a>
<a name="ln4908">      STRCAT(buf, &quot; &quot;);</a>
<a name="ln4909">      if (cap-&gt;count0 != 0 &amp;&amp; (isman || isman_s)) {</a>
<a name="ln4910">        snprintf(buf + STRLEN(buf), buf_size - STRLEN(buf), &quot;%&quot; PRId64,</a>
<a name="ln4911">            (int64_t)cap-&gt;count0);</a>
<a name="ln4912">        STRCAT(buf, &quot; &quot;);</a>
<a name="ln4913">      }</a>
<a name="ln4914">    }</a>
<a name="ln4915">    break;</a>
<a name="ln4916"> </a>
<a name="ln4917">  case ']':</a>
<a name="ln4918">    tag_cmd = true;</a>
<a name="ln4919">    if (p_cst)</a>
<a name="ln4920">      STRCPY(buf, &quot;cstag &quot;);</a>
<a name="ln4921">    else</a>
<a name="ln4922">      STRCPY(buf, &quot;ts &quot;);</a>
<a name="ln4923">    break;</a>
<a name="ln4924"> </a>
<a name="ln4925">  default:</a>
<a name="ln4926">    tag_cmd = true;</a>
<a name="ln4927">    if (curbuf-&gt;b_help)</a>
<a name="ln4928">      STRCPY(buf, &quot;he! &quot;);</a>
<a name="ln4929">    else {</a>
<a name="ln4930">      if (g_cmd)</a>
<a name="ln4931">        STRCPY(buf, &quot;tj &quot;);</a>
<a name="ln4932">      else</a>
<a name="ln4933">        snprintf(buf, buf_size, &quot;%&quot; PRId64 &quot;ta &quot;, (int64_t)cap-&gt;count0);</a>
<a name="ln4934">    }</a>
<a name="ln4935">  }</a>
<a name="ln4936"> </a>
<a name="ln4937">  // Now grab the chars in the identifier</a>
<a name="ln4938">  if (cmdchar == 'K' &amp;&amp; !kp_help) {</a>
<a name="ln4939">    ptr = vim_strnsave(ptr, n);</a>
<a name="ln4940">    if (kp_ex) {</a>
<a name="ln4941">      // Escape the argument properly for an Ex command</a>
<a name="ln4942">      p = (char_u *)vim_strsave_fnameescape((const char *)ptr, false);</a>
<a name="ln4943">    } else {</a>
<a name="ln4944">      // Escape the argument properly for a shell command</a>
<a name="ln4945">      p = vim_strsave_shellescape(ptr, true, true);</a>
<a name="ln4946">    }</a>
<a name="ln4947">    xfree(ptr);</a>
<a name="ln4948">    char *newbuf = xrealloc(buf, STRLEN(buf) + STRLEN(p) + 1);</a>
<a name="ln4949">    buf = newbuf;</a>
<a name="ln4950">    STRCAT(buf, p);</a>
<a name="ln4951">    xfree(p);</a>
<a name="ln4952">  } else {</a>
<a name="ln4953">    if (cmdchar == '*')</a>
<a name="ln4954">      aux_ptr = (char_u *)(p_magic ? &quot;/.*~[^$\\&quot; : &quot;/^$\\&quot;);</a>
<a name="ln4955">    else if (cmdchar == '#')</a>
<a name="ln4956">      aux_ptr = (char_u *)(p_magic ? &quot;/?.*~[^$\\&quot; : &quot;/?^$\\&quot;);</a>
<a name="ln4957">    else if (tag_cmd) {</a>
<a name="ln4958">      if (curbuf-&gt;b_help)</a>
<a name="ln4959">        /* &quot;:help&quot; handles unescaped argument */</a>
<a name="ln4960">        aux_ptr = (char_u *)&quot;&quot;;</a>
<a name="ln4961">      else</a>
<a name="ln4962">        aux_ptr = (char_u *)&quot;\\|\&quot;\n[&quot;;</a>
<a name="ln4963">    } else</a>
<a name="ln4964">      aux_ptr = (char_u *)&quot;\\|\&quot;\n*?[&quot;;</a>
<a name="ln4965"> </a>
<a name="ln4966">    p = (char_u *)buf + STRLEN(buf);</a>
<a name="ln4967">    while (n-- &gt; 0) {</a>
<a name="ln4968">      /* put a backslash before \ and some others */</a>
<a name="ln4969">      if (vim_strchr(aux_ptr, *ptr) != NULL)</a>
<a name="ln4970">        *p++ = '\\';</a>
<a name="ln4971">      /* When current byte is a part of multibyte character, copy all</a>
<a name="ln4972">       * bytes of that character. */</a>
<a name="ln4973">      const size_t len = (size_t)(utfc_ptr2len(ptr) - 1);</a>
<a name="ln4974">      for (size_t i = 0; i &lt; len &amp;&amp; n &gt; 0; i++, n--) {</a>
<a name="ln4975">        *p++ = *ptr++;</a>
<a name="ln4976">      }</a>
<a name="ln4977">      *p++ = *ptr++;</a>
<a name="ln4978">    }</a>
<a name="ln4979">    *p = NUL;</a>
<a name="ln4980">  }</a>
<a name="ln4981"> </a>
<a name="ln4982">  /*</a>
<a name="ln4983">   * Execute the command.</a>
<a name="ln4984">   */</a>
<a name="ln4985">  if (cmdchar == '*' || cmdchar == '#') {</a>
<a name="ln4986">    if (!g_cmd</a>
<a name="ln4987">        &amp;&amp; vim_iswordp(mb_prevptr(get_cursor_line_ptr(), ptr))) {</a>
<a name="ln4988">      STRCAT(buf, &quot;\\&gt;&quot;);</a>
<a name="ln4989">    }</a>
<a name="ln4990">    // put pattern in search history</a>
<a name="ln4991">    init_history();</a>
<a name="ln4992">    add_to_history(HIST_SEARCH, (char_u *)buf, true, NUL);</a>
<a name="ln4993">    (void)normal_search(cap, cmdchar == '*' ? '/' : '?', (char_u *)buf, 0,</a>
<a name="ln4994">                        NULL);</a>
<a name="ln4995">  } else {</a>
<a name="ln4996">    g_tag_at_cursor = true;</a>
<a name="ln4997">    do_cmdline_cmd(buf);</a>
<a name="ln4998">    g_tag_at_cursor = false;</a>
<a name="ln4999">  }</a>
<a name="ln5000"> </a>
<a name="ln5001">  xfree(buf);</a>
<a name="ln5002">}</a>
<a name="ln5003"> </a>
<a name="ln5004">/*</a>
<a name="ln5005"> * Get visually selected text, within one line only.</a>
<a name="ln5006"> * Returns false if more than one line selected.</a>
<a name="ln5007"> */</a>
<a name="ln5008">bool</a>
<a name="ln5009">get_visual_text (</a>
<a name="ln5010">    cmdarg_T *cap,</a>
<a name="ln5011">    char_u **pp,           /* return: start of selected text */</a>
<a name="ln5012">    size_t *lenp           /* return: length of selected text */</a>
<a name="ln5013">)</a>
<a name="ln5014">{</a>
<a name="ln5015">  if (VIsual_mode != 'V')</a>
<a name="ln5016">    unadjust_for_sel();</a>
<a name="ln5017">  if (VIsual.lnum != curwin-&gt;w_cursor.lnum) {</a>
<a name="ln5018">    if (cap != NULL)</a>
<a name="ln5019">      clearopbeep(cap-&gt;oap);</a>
<a name="ln5020">    return false;</a>
<a name="ln5021">  }</a>
<a name="ln5022">  if (VIsual_mode == 'V') {</a>
<a name="ln5023">    *pp = get_cursor_line_ptr();</a>
<a name="ln5024">    *lenp = STRLEN(*pp);</a>
<a name="ln5025">  } else {</a>
<a name="ln5026">    if (lt(curwin-&gt;w_cursor, VIsual)) {</a>
<a name="ln5027">      *pp = ml_get_pos(&amp;curwin-&gt;w_cursor);</a>
<a name="ln5028">      *lenp = (size_t)VIsual.col - (size_t)curwin-&gt;w_cursor.col + 1;</a>
<a name="ln5029">    } else {</a>
<a name="ln5030">      *pp = ml_get_pos(&amp;VIsual);</a>
<a name="ln5031">      *lenp = (size_t)curwin-&gt;w_cursor.col - (size_t)VIsual.col + 1;</a>
<a name="ln5032">    }</a>
<a name="ln5033">    // Correct the length to include the whole last character.</a>
<a name="ln5034">    *lenp += (size_t)(utfc_ptr2len(*pp + (*lenp - 1)) - 1);</a>
<a name="ln5035">  }</a>
<a name="ln5036">  reset_VIsual_and_resel();</a>
<a name="ln5037">  return true;</a>
<a name="ln5038">}</a>
<a name="ln5039"> </a>
<a name="ln5040">/*</a>
<a name="ln5041"> * CTRL-T: backwards in tag stack</a>
<a name="ln5042"> */</a>
<a name="ln5043">static void nv_tagpop(cmdarg_T *cap)</a>
<a name="ln5044">{</a>
<a name="ln5045">  if (!checkclearopq(cap-&gt;oap))</a>
<a name="ln5046">    do_tag((char_u *)&quot;&quot;, DT_POP, (int)cap-&gt;count1, false, true);</a>
<a name="ln5047">}</a>
<a name="ln5048"> </a>
<a name="ln5049">/*</a>
<a name="ln5050"> * Handle scrolling command 'H', 'L' and 'M'.</a>
<a name="ln5051"> */</a>
<a name="ln5052">static void nv_scroll(cmdarg_T *cap)</a>
<a name="ln5053">{</a>
<a name="ln5054">  int used = 0;</a>
<a name="ln5055">  long n;</a>
<a name="ln5056">  linenr_T lnum;</a>
<a name="ln5057">  int half;</a>
<a name="ln5058"> </a>
<a name="ln5059">  cap-&gt;oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln5060">  setpcmark();</a>
<a name="ln5061"> </a>
<a name="ln5062">  if (cap-&gt;cmdchar == 'L') {</a>
<a name="ln5063">    validate_botline(curwin);          // make sure curwin-&gt;w_botline is valid</a>
<a name="ln5064">    curwin-&gt;w_cursor.lnum = curwin-&gt;w_botline - 1;</a>
<a name="ln5065">    if (cap-&gt;count1 - 1 &gt;= curwin-&gt;w_cursor.lnum)</a>
<a name="ln5066">      curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln5067">    else {</a>
<a name="ln5068">      if (hasAnyFolding(curwin)) {</a>
<a name="ln5069">        /* Count a fold for one screen line. */</a>
<a name="ln5070">        for (n = cap-&gt;count1 - 1; n &gt; 0</a>
<a name="ln5071">             &amp;&amp; curwin-&gt;w_cursor.lnum &gt; curwin-&gt;w_topline; --n) {</a>
<a name="ln5072">          (void)hasFolding(curwin-&gt;w_cursor.lnum,</a>
<a name="ln5073">              &amp;curwin-&gt;w_cursor.lnum, NULL);</a>
<a name="ln5074">          --curwin-&gt;w_cursor.lnum;</a>
<a name="ln5075">        }</a>
<a name="ln5076">      } else</a>
<a name="ln5077">        curwin-&gt;w_cursor.lnum -= cap-&gt;count1 - 1;</a>
<a name="ln5078">    }</a>
<a name="ln5079">  } else {</a>
<a name="ln5080">    if (cap-&gt;cmdchar == 'M') {</a>
<a name="ln5081">      /* Don't count filler lines above the window. */</a>
<a name="ln5082">      used -= diff_check_fill(curwin, curwin-&gt;w_topline)</a>
<a name="ln5083">              - curwin-&gt;w_topfill;</a>
<a name="ln5084">      validate_botline(curwin);  // make sure w_empty_rows is valid</a>
<a name="ln5085">      half = (curwin-&gt;w_height_inner - curwin-&gt;w_empty_rows + 1) / 2;</a>
<a name="ln5086">      for (n = 0; curwin-&gt;w_topline + n &lt; curbuf-&gt;b_ml.ml_line_count; n++) {</a>
<a name="ln5087">        // Count half he number of filler lines to be &quot;below this</a>
<a name="ln5088">        // line&quot; and half to be &quot;above the next line&quot;.</a>
<a name="ln5089">        if (n &gt; 0 &amp;&amp; used + diff_check_fill(curwin, curwin-&gt;w_topline</a>
<a name="ln5090">                + n) / 2 &gt;= half) {</a>
<a name="ln5091">          --n;</a>
<a name="ln5092">          break;</a>
<a name="ln5093">        }</a>
<a name="ln5094">        used += plines(curwin-&gt;w_topline + n);</a>
<a name="ln5095">        if (used &gt;= half)</a>
<a name="ln5096">          break;</a>
<a name="ln5097">        if (hasFolding(curwin-&gt;w_topline + n, NULL, &amp;lnum))</a>
<a name="ln5098">          n = lnum - curwin-&gt;w_topline;</a>
<a name="ln5099">      }</a>
<a name="ln5100">      if (n &gt; 0 &amp;&amp; used &gt; curwin-&gt;w_height_inner) {</a>
<a name="ln5101">        n--;</a>
<a name="ln5102">      }</a>
<a name="ln5103">    } else {  // (cap-&gt;cmdchar == 'H')</a>
<a name="ln5104">      n = cap-&gt;count1 - 1;</a>
<a name="ln5105">      if (hasAnyFolding(curwin)) {</a>
<a name="ln5106">        /* Count a fold for one screen line. */</a>
<a name="ln5107">        lnum = curwin-&gt;w_topline;</a>
<a name="ln5108">        while (n-- &gt; 0 &amp;&amp; lnum &lt; curwin-&gt;w_botline - 1) {</a>
<a name="ln5109">          hasFolding(lnum, NULL, &amp;lnum);</a>
<a name="ln5110">          ++lnum;</a>
<a name="ln5111">        }</a>
<a name="ln5112">        n = lnum - curwin-&gt;w_topline;</a>
<a name="ln5113">      }</a>
<a name="ln5114">    }</a>
<a name="ln5115">    curwin-&gt;w_cursor.lnum = curwin-&gt;w_topline + n;</a>
<a name="ln5116">    if (curwin-&gt;w_cursor.lnum &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln5117">      curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln5118">  }</a>
<a name="ln5119"> </a>
<a name="ln5120">  // Correct for 'so', except when an operator is pending.</a>
<a name="ln5121">  if (cap-&gt;oap-&gt;op_type == OP_NOP) {</a>
<a name="ln5122">    cursor_correct();</a>
<a name="ln5123">  }</a>
<a name="ln5124">  beginline(BL_SOL | BL_FIX);</a>
<a name="ln5125">}</a>
<a name="ln5126"> </a>
<a name="ln5127">/*</a>
<a name="ln5128"> * Cursor right commands.</a>
<a name="ln5129"> */</a>
<a name="ln5130">static void nv_right(cmdarg_T *cap)</a>
<a name="ln5131">{</a>
<a name="ln5132">  long n;</a>
<a name="ln5133">  int PAST_LINE;</a>
<a name="ln5134"> </a>
<a name="ln5135">  if (mod_mask &amp; (MOD_MASK_SHIFT | MOD_MASK_CTRL)) {</a>
<a name="ln5136">    /* &lt;C-Right&gt; and &lt;S-Right&gt; move a word or WORD right */</a>
<a name="ln5137">    if (mod_mask &amp; MOD_MASK_CTRL)</a>
<a name="ln5138">      cap-&gt;arg = true;</a>
<a name="ln5139">    nv_wordcmd(cap);</a>
<a name="ln5140">    return;</a>
<a name="ln5141">  }</a>
<a name="ln5142"> </a>
<a name="ln5143">  cap-&gt;oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln5144">  cap-&gt;oap-&gt;inclusive = false;</a>
<a name="ln5145">  PAST_LINE = (VIsual_active &amp;&amp; *p_sel != 'o');</a>
<a name="ln5146"> </a>
<a name="ln5147">  /*</a>
<a name="ln5148">   * In virtual mode, there's no such thing as &quot;PAST_LINE&quot;, as lines are</a>
<a name="ln5149">   * (theoretically) infinitely long.</a>
<a name="ln5150">   */</a>
<a name="ln5151">  if (virtual_active())</a>
<a name="ln5152">    PAST_LINE = 0;</a>
<a name="ln5153"> </a>
<a name="ln5154">  for (n = cap-&gt;count1; n &gt; 0; --n) {</a>
<a name="ln5155">    if ((!PAST_LINE &amp;&amp; oneright() == false)</a>
<a name="ln5156">        || (PAST_LINE &amp;&amp; *get_cursor_pos_ptr() == NUL)</a>
<a name="ln5157">        ) {</a>
<a name="ln5158">      //          &lt;Space&gt; wraps to next line if 'whichwrap' has 's'.</a>
<a name="ln5159">      //              'l' wraps to next line if 'whichwrap' has 'l'.</a>
<a name="ln5160">      // CURS_RIGHT wraps to next line if 'whichwrap' has '&gt;'.</a>
<a name="ln5161">      if (((cap-&gt;cmdchar == ' ' &amp;&amp; vim_strchr(p_ww, 's') != NULL)</a>
<a name="ln5162">           || (cap-&gt;cmdchar == 'l' &amp;&amp; vim_strchr(p_ww, 'l') != NULL)</a>
<a name="ln5163">           || (cap-&gt;cmdchar == K_RIGHT &amp;&amp; vim_strchr(p_ww, '&gt;') != NULL))</a>
<a name="ln5164">          &amp;&amp; curwin-&gt;w_cursor.lnum &lt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5165">        // When deleting we also count the NL as a character.</a>
<a name="ln5166">        // Set cap-&gt;oap-&gt;inclusive when last char in the line is</a>
<a name="ln5167">        // included, move to next line after that</a>
<a name="ln5168">        if (cap-&gt;oap-&gt;op_type != OP_NOP</a>
<a name="ln5169">            &amp;&amp; !cap-&gt;oap-&gt;inclusive</a>
<a name="ln5170">            &amp;&amp; !LINEEMPTY(curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln5171">          cap-&gt;oap-&gt;inclusive = true;</a>
<a name="ln5172">        } else {</a>
<a name="ln5173">          ++curwin-&gt;w_cursor.lnum;</a>
<a name="ln5174">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln5175">          curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln5176">          curwin-&gt;w_set_curswant = true;</a>
<a name="ln5177">          cap-&gt;oap-&gt;inclusive = false;</a>
<a name="ln5178">        }</a>
<a name="ln5179">        continue;</a>
<a name="ln5180">      }</a>
<a name="ln5181">      if (cap-&gt;oap-&gt;op_type == OP_NOP) {</a>
<a name="ln5182">        // Only beep and flush if not moved at all</a>
<a name="ln5183">        if (n == cap-&gt;count1) {</a>
<a name="ln5184">          beep_flush();</a>
<a name="ln5185">        }</a>
<a name="ln5186">      } else {</a>
<a name="ln5187">        if (!LINEEMPTY(curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln5188">          cap-&gt;oap-&gt;inclusive = true;</a>
<a name="ln5189">        }</a>
<a name="ln5190">      }</a>
<a name="ln5191">      break;</a>
<a name="ln5192">    } else if (PAST_LINE) {</a>
<a name="ln5193">      curwin-&gt;w_set_curswant = true;</a>
<a name="ln5194">      if (virtual_active()) {</a>
<a name="ln5195">        oneright();</a>
<a name="ln5196">      } else {</a>
<a name="ln5197">        curwin-&gt;w_cursor.col += (*mb_ptr2len)(get_cursor_pos_ptr());</a>
<a name="ln5198">      }</a>
<a name="ln5199">    }</a>
<a name="ln5200">  }</a>
<a name="ln5201">  if (n != cap-&gt;count1 &amp;&amp; (fdo_flags &amp; FDO_HOR) &amp;&amp; KeyTyped</a>
<a name="ln5202">      &amp;&amp; cap-&gt;oap-&gt;op_type == OP_NOP)</a>
<a name="ln5203">    foldOpenCursor();</a>
<a name="ln5204">}</a>
<a name="ln5205"> </a>
<a name="ln5206">/*</a>
<a name="ln5207"> * Cursor left commands.</a>
<a name="ln5208"> *</a>
<a name="ln5209"> * Returns true when operator end should not be adjusted.</a>
<a name="ln5210"> */</a>
<a name="ln5211">static void nv_left(cmdarg_T *cap)</a>
<a name="ln5212">{</a>
<a name="ln5213">  long n;</a>
<a name="ln5214"> </a>
<a name="ln5215">  if (mod_mask &amp; (MOD_MASK_SHIFT | MOD_MASK_CTRL)) {</a>
<a name="ln5216">    /* &lt;C-Left&gt; and &lt;S-Left&gt; move a word or WORD left */</a>
<a name="ln5217">    if (mod_mask &amp; MOD_MASK_CTRL)</a>
<a name="ln5218">      cap-&gt;arg = 1;</a>
<a name="ln5219">    nv_bck_word(cap);</a>
<a name="ln5220">    return;</a>
<a name="ln5221">  }</a>
<a name="ln5222"> </a>
<a name="ln5223">  cap-&gt;oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln5224">  cap-&gt;oap-&gt;inclusive = false;</a>
<a name="ln5225">  for (n = cap-&gt;count1; n &gt; 0; --n) {</a>
<a name="ln5226">    if (oneleft() == false) {</a>
<a name="ln5227">      /* &lt;BS&gt; and &lt;Del&gt; wrap to previous line if 'whichwrap' has 'b'.</a>
<a name="ln5228">       *		 'h' wraps to previous line if 'whichwrap' has 'h'.</a>
<a name="ln5229">       *	   CURS_LEFT wraps to previous line if 'whichwrap' has '&lt;'.</a>
<a name="ln5230">       */</a>
<a name="ln5231">      if ((((cap-&gt;cmdchar == K_BS || cap-&gt;cmdchar == Ctrl_H)</a>
<a name="ln5232">            &amp;&amp; vim_strchr(p_ww, 'b') != NULL)</a>
<a name="ln5233">           || (cap-&gt;cmdchar == 'h' &amp;&amp; vim_strchr(p_ww, 'h') != NULL)</a>
<a name="ln5234">           || (cap-&gt;cmdchar == K_LEFT &amp;&amp; vim_strchr(p_ww, '&lt;') != NULL))</a>
<a name="ln5235">          &amp;&amp; curwin-&gt;w_cursor.lnum &gt; 1) {</a>
<a name="ln5236">        curwin-&gt;w_cursor.lnum--;</a>
<a name="ln5237">        coladvance(MAXCOL);</a>
<a name="ln5238">        curwin-&gt;w_set_curswant = true;</a>
<a name="ln5239"> </a>
<a name="ln5240">        // When the NL before the first char has to be deleted we</a>
<a name="ln5241">        // put the cursor on the NUL after the previous line.</a>
<a name="ln5242">        // This is a very special case, be careful!</a>
<a name="ln5243">        // Don't adjust op_end now, otherwise it won't work.</a>
<a name="ln5244">        if ((cap-&gt;oap-&gt;op_type == OP_DELETE || cap-&gt;oap-&gt;op_type == OP_CHANGE)</a>
<a name="ln5245">            &amp;&amp; !LINEEMPTY(curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln5246">          char_u *cp = get_cursor_pos_ptr();</a>
<a name="ln5247"> </a>
<a name="ln5248">          if (*cp != NUL) {</a>
<a name="ln5249">            curwin-&gt;w_cursor.col += utfc_ptr2len(cp);</a>
<a name="ln5250">          }</a>
<a name="ln5251">          cap-&gt;retval |= CA_NO_ADJ_OP_END;</a>
<a name="ln5252">        }</a>
<a name="ln5253">        continue;</a>
<a name="ln5254">      }</a>
<a name="ln5255">      /* Only beep and flush if not moved at all */</a>
<a name="ln5256">      else if (cap-&gt;oap-&gt;op_type == OP_NOP &amp;&amp; n == cap-&gt;count1)</a>
<a name="ln5257">        beep_flush();</a>
<a name="ln5258">      break;</a>
<a name="ln5259">    }</a>
<a name="ln5260">  }</a>
<a name="ln5261">  if (n != cap-&gt;count1 &amp;&amp; (fdo_flags &amp; FDO_HOR) &amp;&amp; KeyTyped</a>
<a name="ln5262">      &amp;&amp; cap-&gt;oap-&gt;op_type == OP_NOP)</a>
<a name="ln5263">    foldOpenCursor();</a>
<a name="ln5264">}</a>
<a name="ln5265"> </a>
<a name="ln5266">/*</a>
<a name="ln5267"> * Cursor up commands.</a>
<a name="ln5268"> * cap-&gt;arg is true for &quot;-&quot;: Move cursor to first non-blank.</a>
<a name="ln5269"> */</a>
<a name="ln5270">static void nv_up(cmdarg_T *cap)</a>
<a name="ln5271">{</a>
<a name="ln5272">  if (mod_mask &amp; MOD_MASK_SHIFT) {</a>
<a name="ln5273">    /* &lt;S-Up&gt; is page up */</a>
<a name="ln5274">    cap-&gt;arg = BACKWARD;</a>
<a name="ln5275">    nv_page(cap);</a>
<a name="ln5276">  } else {</a>
<a name="ln5277">    cap-&gt;oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln5278">    if (cursor_up(cap-&gt;count1, cap-&gt;oap-&gt;op_type == OP_NOP) == false) {</a>
<a name="ln5279">      clearopbeep(cap-&gt;oap);</a>
<a name="ln5280">    } else if (cap-&gt;arg) {</a>
<a name="ln5281">      beginline(BL_WHITE | BL_FIX);</a>
<a name="ln5282">    }</a>
<a name="ln5283">  }</a>
<a name="ln5284">}</a>
<a name="ln5285"> </a>
<a name="ln5286">/*</a>
<a name="ln5287"> * Cursor down commands.</a>
<a name="ln5288"> * cap-&gt;arg is true for CR and &quot;+&quot;: Move cursor to first non-blank.</a>
<a name="ln5289"> */</a>
<a name="ln5290">static void nv_down(cmdarg_T *cap)</a>
<a name="ln5291">{</a>
<a name="ln5292">  if (mod_mask &amp; MOD_MASK_SHIFT) {</a>
<a name="ln5293">    /* &lt;S-Down&gt; is page down */</a>
<a name="ln5294">    cap-&gt;arg = FORWARD;</a>
<a name="ln5295">    nv_page(cap);</a>
<a name="ln5296">  } else if (bt_quickfix(curbuf) &amp;&amp; cap-&gt;cmdchar == CAR) {</a>
<a name="ln5297">    // Quickfix window only: view the result under the cursor.</a>
<a name="ln5298">    qf_view_result(false);</a>
<a name="ln5299">  } else {</a>
<a name="ln5300">    // In the cmdline window a &lt;CR&gt; executes the command.</a>
<a name="ln5301">    if (cmdwin_type != 0 &amp;&amp; cap-&gt;cmdchar == CAR) {</a>
<a name="ln5302">      cmdwin_result = CAR;</a>
<a name="ln5303">    } else if (bt_prompt(curbuf) &amp;&amp; cap-&gt;cmdchar == CAR</a>
<a name="ln5304">               &amp;&amp; curwin-&gt;w_cursor.lnum == curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5305">      // In a prompt buffer a &lt;CR&gt; in the last line invokes the callback.</a>
<a name="ln5306">      invoke_prompt_callback();</a>
<a name="ln5307">      if (restart_edit == 0) {</a>
<a name="ln5308">        restart_edit = 'a';</a>
<a name="ln5309">      }</a>
<a name="ln5310">    } else {</a>
<a name="ln5311">      cap-&gt;oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln5312">      if (cursor_down(cap-&gt;count1, cap-&gt;oap-&gt;op_type == OP_NOP) == false) {</a>
<a name="ln5313">        clearopbeep(cap-&gt;oap);</a>
<a name="ln5314">      } else if (cap-&gt;arg) {</a>
<a name="ln5315">        beginline(BL_WHITE | BL_FIX);</a>
<a name="ln5316">      }</a>
<a name="ln5317">    }</a>
<a name="ln5318">  }</a>
<a name="ln5319">}</a>
<a name="ln5320"> </a>
<a name="ln5321">/*</a>
<a name="ln5322"> * Grab the file name under the cursor and edit it.</a>
<a name="ln5323"> */</a>
<a name="ln5324">static void nv_gotofile(cmdarg_T *cap)</a>
<a name="ln5325">{</a>
<a name="ln5326">  char_u      *ptr;</a>
<a name="ln5327">  linenr_T lnum = -1;</a>
<a name="ln5328"> </a>
<a name="ln5329">  if (text_locked()) {</a>
<a name="ln5330">    clearopbeep(cap-&gt;oap);</a>
<a name="ln5331">    text_locked_msg();</a>
<a name="ln5332">    return;</a>
<a name="ln5333">  }</a>
<a name="ln5334">  if (curbuf_locked()) {</a>
<a name="ln5335">    clearop(cap-&gt;oap);</a>
<a name="ln5336">    return;</a>
<a name="ln5337">  }</a>
<a name="ln5338"> </a>
<a name="ln5339">  ptr = grab_file_name(cap-&gt;count1, &amp;lnum);</a>
<a name="ln5340"> </a>
<a name="ln5341">  if (ptr != NULL) {</a>
<a name="ln5342">    // do autowrite if necessary</a>
<a name="ln5343">    if (curbufIsChanged() &amp;&amp; curbuf-&gt;b_nwindows &lt;= 1 &amp;&amp; !buf_hide(curbuf)) {</a>
<a name="ln5344">      (void)autowrite(curbuf, false);</a>
<a name="ln5345">    }</a>
<a name="ln5346">    setpcmark();</a>
<a name="ln5347">    if (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,</a>
<a name="ln5348">                buf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK</a>
<a name="ln5349">        &amp;&amp; cap-&gt;nchar == 'F' &amp;&amp; lnum &gt;= 0) {</a>
<a name="ln5350">      curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln5351">      check_cursor_lnum();</a>
<a name="ln5352">      beginline(BL_SOL | BL_FIX);</a>
<a name="ln5353">    }</a>
<a name="ln5354">    xfree(ptr);</a>
<a name="ln5355">  } else</a>
<a name="ln5356">    clearop(cap-&gt;oap);</a>
<a name="ln5357">}</a>
<a name="ln5358"> </a>
<a name="ln5359">/*</a>
<a name="ln5360"> * &lt;End&gt; command: to end of current line or last line.</a>
<a name="ln5361"> */</a>
<a name="ln5362">static void nv_end(cmdarg_T *cap)</a>
<a name="ln5363">{</a>
<a name="ln5364">  if (cap-&gt;arg || (mod_mask &amp; MOD_MASK_CTRL)) { /* CTRL-END = goto last line */</a>
<a name="ln5365">    cap-&gt;arg = true;</a>
<a name="ln5366">    nv_goto(cap);</a>
<a name="ln5367">    cap-&gt;count1 = 1;                    /* to end of current line */</a>
<a name="ln5368">  }</a>
<a name="ln5369">  nv_dollar(cap);</a>
<a name="ln5370">}</a>
<a name="ln5371"> </a>
<a name="ln5372">/*</a>
<a name="ln5373"> * Handle the &quot;$&quot; command.</a>
<a name="ln5374"> */</a>
<a name="ln5375">static void nv_dollar(cmdarg_T *cap)</a>
<a name="ln5376">{</a>
<a name="ln5377">  cap-&gt;oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln5378">  cap-&gt;oap-&gt;inclusive = true;</a>
<a name="ln5379">  /* In virtual mode when off the edge of a line and an operator</a>
<a name="ln5380">   * is pending (whew!) keep the cursor where it is.</a>
<a name="ln5381">   * Otherwise, send it to the end of the line. */</a>
<a name="ln5382">  if (!virtual_active() || gchar_cursor() != NUL</a>
<a name="ln5383">      || cap-&gt;oap-&gt;op_type == OP_NOP)</a>
<a name="ln5384">    curwin-&gt;w_curswant = MAXCOL;        /* so we stay at the end */</a>
<a name="ln5385">  if (cursor_down(cap-&gt;count1 - 1,</a>
<a name="ln5386">          cap-&gt;oap-&gt;op_type == OP_NOP) == false)</a>
<a name="ln5387">    clearopbeep(cap-&gt;oap);</a>
<a name="ln5388">  else if ((fdo_flags &amp; FDO_HOR) &amp;&amp; KeyTyped &amp;&amp; cap-&gt;oap-&gt;op_type == OP_NOP)</a>
<a name="ln5389">    foldOpenCursor();</a>
<a name="ln5390">}</a>
<a name="ln5391"> </a>
<a name="ln5392">/*</a>
<a name="ln5393"> * Implementation of '?' and '/' commands.</a>
<a name="ln5394"> * If cap-&gt;arg is true don't set PC mark.</a>
<a name="ln5395"> */</a>
<a name="ln5396">static void nv_search(cmdarg_T *cap)</a>
<a name="ln5397">{</a>
<a name="ln5398">  oparg_T     *oap = cap-&gt;oap;</a>
<a name="ln5399">  pos_T save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln5400"> </a>
<a name="ln5401">  if (cap-&gt;cmdchar == '?' &amp;&amp; cap-&gt;oap-&gt;op_type == OP_ROT13) {</a>
<a name="ln5402">    /* Translate &quot;g??&quot; to &quot;g?g?&quot; */</a>
<a name="ln5403">    cap-&gt;cmdchar = 'g';</a>
<a name="ln5404">    cap-&gt;nchar = '?';</a>
<a name="ln5405">    nv_operator(cap);</a>
<a name="ln5406">    return;</a>
<a name="ln5407">  }</a>
<a name="ln5408"> </a>
<a name="ln5409">  // When using 'incsearch' the cursor may be moved to set a different search</a>
<a name="ln5410">  // start position.</a>
<a name="ln5411">  cap-&gt;searchbuf = getcmdline(cap-&gt;cmdchar, cap-&gt;count1, 0, true);</a>
<a name="ln5412"> </a>
<a name="ln5413">  if (cap-&gt;searchbuf == NULL) {</a>
<a name="ln5414">    clearop(oap);</a>
<a name="ln5415">    return;</a>
<a name="ln5416">  }</a>
<a name="ln5417"> </a>
<a name="ln5418">  (void)normal_search(cap, cap-&gt;cmdchar, cap-&gt;searchbuf,</a>
<a name="ln5419">                      (cap-&gt;arg || !equalpos(save_cursor, curwin-&gt;w_cursor))</a>
<a name="ln5420">                      ? 0 : SEARCH_MARK, NULL);</a>
<a name="ln5421">}</a>
<a name="ln5422"> </a>
<a name="ln5423">/*</a>
<a name="ln5424"> * Handle &quot;N&quot; and &quot;n&quot; commands.</a>
<a name="ln5425"> * cap-&gt;arg is SEARCH_REV for &quot;N&quot;, 0 for &quot;n&quot;.</a>
<a name="ln5426"> */</a>
<a name="ln5427">static void nv_next(cmdarg_T *cap)</a>
<a name="ln5428">{</a>
<a name="ln5429">  pos_T old = curwin-&gt;w_cursor;</a>
<a name="ln5430">  int wrapped = false;</a>
<a name="ln5431">  int i = normal_search(cap, 0, NULL, SEARCH_MARK | cap-&gt;arg, &amp;wrapped);</a>
<a name="ln5432"> </a>
<a name="ln5433">  if (i == 1 &amp;&amp; !wrapped &amp;&amp; equalpos(old, curwin-&gt;w_cursor)) {</a>
<a name="ln5434">    // Avoid getting stuck on the current cursor position, which can happen when</a>
<a name="ln5435">    // an offset is given and the cursor is on the last char in the buffer:</a>
<a name="ln5436">    // Repeat with count + 1.</a>
<a name="ln5437">    cap-&gt;count1 += 1;</a>
<a name="ln5438">    (void)normal_search(cap, 0, NULL, SEARCH_MARK | cap-&gt;arg, NULL);</a>
<a name="ln5439">    cap-&gt;count1 -= 1;</a>
<a name="ln5440">  }</a>
<a name="ln5441">}</a>
<a name="ln5442"> </a>
<a name="ln5443">/*</a>
<a name="ln5444"> * Search for &quot;pat&quot; in direction &quot;dir&quot; ('/' or '?', 0 for repeat).</a>
<a name="ln5445"> * Uses only cap-&gt;count1 and cap-&gt;oap from &quot;cap&quot;.</a>
<a name="ln5446"> * Return 0 for failure, 1 for found, 2 for found and line offset added.</a>
<a name="ln5447"> */</a>
<a name="ln5448">static int normal_search(</a>
<a name="ln5449">    cmdarg_T *cap,</a>
<a name="ln5450">    int dir,</a>
<a name="ln5451">    char_u *pat,</a>
<a name="ln5452">    int opt,        // extra flags for do_search()</a>
<a name="ln5453">    int *wrapped</a>
<a name="ln5454">)</a>
<a name="ln5455">{</a>
<a name="ln5456">  int i;</a>
<a name="ln5457">  searchit_arg_T sia;</a>
<a name="ln5458"> </a>
<a name="ln5459">  cap-&gt;oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln5460">  cap-&gt;oap-&gt;inclusive = false;</a>
<a name="ln5461">  cap-&gt;oap-&gt;use_reg_one = true;</a>
<a name="ln5462">  curwin-&gt;w_set_curswant = true;</a>
<a name="ln5463"> </a>
<a name="ln5464">  memset(&amp;sia, 0, sizeof(sia));</a>
<a name="ln5465">  i = do_search(cap-&gt;oap, dir, dir, pat, cap-&gt;count1,</a>
<a name="ln5466">                opt | SEARCH_OPT | SEARCH_ECHO | SEARCH_MSG, &amp;sia);</a>
<a name="ln5467">  if (wrapped != NULL) {</a>
<a name="ln5468">    *wrapped = sia.sa_wrapped;</a>
<a name="ln5469">  }</a>
<a name="ln5470">  if (i == 0) {</a>
<a name="ln5471">    clearop(cap-&gt;oap);</a>
<a name="ln5472">  } else {</a>
<a name="ln5473">    if (i == 2) {</a>
<a name="ln5474">      cap-&gt;oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln5475">    }</a>
<a name="ln5476">    curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln5477">    if (cap-&gt;oap-&gt;op_type == OP_NOP &amp;&amp; (fdo_flags &amp; FDO_SEARCH) &amp;&amp; KeyTyped)</a>
<a name="ln5478">      foldOpenCursor();</a>
<a name="ln5479">  }</a>
<a name="ln5480"> </a>
<a name="ln5481">  /* &quot;/$&quot; will put the cursor after the end of the line, may need to</a>
<a name="ln5482">   * correct that here */</a>
<a name="ln5483">  check_cursor();</a>
<a name="ln5484">  return i;</a>
<a name="ln5485">}</a>
<a name="ln5486"> </a>
<a name="ln5487">/*</a>
<a name="ln5488"> * Character search commands.</a>
<a name="ln5489"> * cap-&gt;arg is BACKWARD for 'F' and 'T', FORWARD for 'f' and 't', true for</a>
<a name="ln5490"> * ',' and false for ';'.</a>
<a name="ln5491"> * cap-&gt;nchar is NUL for ',' and ';' (repeat the search)</a>
<a name="ln5492"> */</a>
<a name="ln5493">static void nv_csearch(cmdarg_T *cap)</a>
<a name="ln5494">{</a>
<a name="ln5495">  bool t_cmd;</a>
<a name="ln5496"> </a>
<a name="ln5497">  if (cap-&gt;cmdchar == 't' || cap-&gt;cmdchar == 'T')</a>
<a name="ln5498">    t_cmd = true;</a>
<a name="ln5499">  else</a>
<a name="ln5500">    t_cmd = false;</a>
<a name="ln5501"> </a>
<a name="ln5502">  cap-&gt;oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln5503">  if (IS_SPECIAL(cap-&gt;nchar) || searchc(cap, t_cmd) == false) {</a>
<a name="ln5504">    clearopbeep(cap-&gt;oap);</a>
<a name="ln5505">  } else {</a>
<a name="ln5506">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln5507">    /* Include a Tab for &quot;tx&quot; and for &quot;dfx&quot;. */</a>
<a name="ln5508">    if (gchar_cursor() == TAB &amp;&amp; virtual_active() &amp;&amp; cap-&gt;arg == FORWARD</a>
<a name="ln5509">        &amp;&amp; (t_cmd || cap-&gt;oap-&gt;op_type != OP_NOP)) {</a>
<a name="ln5510">      colnr_T scol, ecol;</a>
<a name="ln5511"> </a>
<a name="ln5512">      getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;scol, NULL, &amp;ecol);</a>
<a name="ln5513">      curwin-&gt;w_cursor.coladd = ecol - scol;</a>
<a name="ln5514">    } else</a>
<a name="ln5515">      curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln5516">    adjust_for_sel(cap);</a>
<a name="ln5517">    if ((fdo_flags &amp; FDO_HOR) &amp;&amp; KeyTyped &amp;&amp; cap-&gt;oap-&gt;op_type == OP_NOP)</a>
<a name="ln5518">      foldOpenCursor();</a>
<a name="ln5519">  }</a>
<a name="ln5520">}</a>
<a name="ln5521"> </a>
<a name="ln5522">/*</a>
<a name="ln5523"> * &quot;[&quot; and &quot;]&quot; commands.</a>
<a name="ln5524"> * cap-&gt;arg is BACKWARD for &quot;[&quot; and FORWARD for &quot;]&quot;.</a>
<a name="ln5525"> */</a>
<a name="ln5526">static void nv_brackets(cmdarg_T *cap)</a>
<a name="ln5527">{</a>
<a name="ln5528">  pos_T new_pos = { 0, 0, 0 };</a>
<a name="ln5529">  pos_T prev_pos;</a>
<a name="ln5530">  pos_T       *pos = NULL;          /* init for GCC */</a>
<a name="ln5531">  pos_T old_pos;                    /* cursor position before command */</a>
<a name="ln5532">  int flag;</a>
<a name="ln5533">  long n;</a>
<a name="ln5534">  int findc;</a>
<a name="ln5535">  int c;</a>
<a name="ln5536"> </a>
<a name="ln5537">  cap-&gt;oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln5538">  cap-&gt;oap-&gt;inclusive = false;</a>
<a name="ln5539">  old_pos = curwin-&gt;w_cursor;</a>
<a name="ln5540">  curwin-&gt;w_cursor.coladd = 0;              /* TODO: don't do this for an error. */</a>
<a name="ln5541"> </a>
<a name="ln5542">  /*</a>
<a name="ln5543">   * &quot;[f&quot; or &quot;]f&quot; : Edit file under the cursor (same as &quot;gf&quot;)</a>
<a name="ln5544">   */</a>
<a name="ln5545">  if (cap-&gt;nchar == 'f')</a>
<a name="ln5546">    nv_gotofile(cap);</a>
<a name="ln5547">  else</a>
<a name="ln5548">  /*</a>
<a name="ln5549">   * Find the occurrence(s) of the identifier or define under cursor</a>
<a name="ln5550">   * in current and included files or jump to the first occurrence.</a>
<a name="ln5551">   *</a>
<a name="ln5552">   *			search	     list	    jump</a>
<a name="ln5553">   *		      fwd   bwd    fwd	 bwd	 fwd	bwd</a>
<a name="ln5554">   * identifier     &quot;]i&quot;  &quot;[i&quot;   &quot;]I&quot;  &quot;[I&quot;	&quot;]^I&quot;  &quot;[^I&quot;</a>
<a name="ln5555">   * define	      &quot;]d&quot;  &quot;[d&quot;   &quot;]D&quot;  &quot;[D&quot;	&quot;]^D&quot;  &quot;[^D&quot;</a>
<a name="ln5556">   */</a>
<a name="ln5557">  if (vim_strchr((char_u *)</a>
<a name="ln5558">          &quot;iI\011dD\004&quot;,</a>
<a name="ln5559">          cap-&gt;nchar) != NULL) {</a>
<a name="ln5560">    char_u  *ptr;</a>
<a name="ln5561">    size_t len;</a>
<a name="ln5562"> </a>
<a name="ln5563">    if ((len = find_ident_under_cursor(&amp;ptr, FIND_IDENT)) == 0)</a>
<a name="ln5564">      clearop(cap-&gt;oap);</a>
<a name="ln5565">    else {</a>
<a name="ln5566">      find_pattern_in_path(ptr, 0, len, true,</a>
<a name="ln5567">                           cap-&gt;count0 == 0 ? !isupper(cap-&gt;nchar) : false,</a>
<a name="ln5568">                           (((cap-&gt;nchar &amp; 0xf) == ('d' &amp; 0xf))</a>
<a name="ln5569">                            ? FIND_DEFINE</a>
<a name="ln5570">                            : FIND_ANY),</a>
<a name="ln5571">                           cap-&gt;count1,</a>
<a name="ln5572">                           (isupper(cap-&gt;nchar) ? ACTION_SHOW_ALL :</a>
<a name="ln5573">                            islower(cap-&gt;nchar) ? ACTION_SHOW :</a>
<a name="ln5574">                            ACTION_GOTO),</a>
<a name="ln5575">                           (cap-&gt;cmdchar == ']'</a>
<a name="ln5576">                            ? curwin-&gt;w_cursor.lnum + 1</a>
<a name="ln5577">                            : (linenr_T)1),</a>
<a name="ln5578">                           MAXLNUM);</a>
<a name="ln5579">      curwin-&gt;w_set_curswant = true;</a>
<a name="ln5580">    }</a>
<a name="ln5581">  } else</a>
<a name="ln5582">  /*</a>
<a name="ln5583">   * &quot;[{&quot;, &quot;[(&quot;, &quot;]}&quot; or &quot;])&quot;: go to Nth unclosed '{', '(', '}' or ')'</a>
<a name="ln5584">   * &quot;[#&quot;, &quot;]#&quot;: go to start/end of Nth innermost #if..#endif construct.</a>
<a name="ln5585">   * &quot;[/&quot;, &quot;[*&quot;, &quot;]/&quot;, &quot;]*&quot;: go to Nth comment start/end.</a>
<a name="ln5586">   * &quot;[m&quot; or &quot;]m&quot; search for prev/next start of (Java) method.</a>
<a name="ln5587">   * &quot;[M&quot; or &quot;]M&quot; search for prev/next end of (Java) method.</a>
<a name="ln5588">   */</a>
<a name="ln5589">  if (  (cap-&gt;cmdchar == '['</a>
<a name="ln5590">         &amp;&amp; vim_strchr((char_u *)&quot;{(*/#mM&quot;, cap-&gt;nchar) != NULL)</a>
<a name="ln5591">        || (cap-&gt;cmdchar == ']'</a>
<a name="ln5592">            &amp;&amp; vim_strchr((char_u *)&quot;})*/#mM&quot;, cap-&gt;nchar) != NULL)) {</a>
<a name="ln5593">    if (cap-&gt;nchar == '*')</a>
<a name="ln5594">      cap-&gt;nchar = '/';</a>
<a name="ln5595">    prev_pos.lnum = 0;</a>
<a name="ln5596">    if (cap-&gt;nchar == 'm' || cap-&gt;nchar == 'M') {</a>
<a name="ln5597">      if (cap-&gt;cmdchar == '[')</a>
<a name="ln5598">        findc = '{';</a>
<a name="ln5599">      else</a>
<a name="ln5600">        findc = '}';</a>
<a name="ln5601">      n = 9999;</a>
<a name="ln5602">    } else {</a>
<a name="ln5603">      findc = cap-&gt;nchar;</a>
<a name="ln5604">      n = cap-&gt;count1;</a>
<a name="ln5605">    }</a>
<a name="ln5606">    for (; n &gt; 0; --n) {</a>
<a name="ln5607">      if ((pos = findmatchlimit(cap-&gt;oap, findc,</a>
<a name="ln5608">               (cap-&gt;cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0)) == NULL) {</a>
<a name="ln5609">        if (new_pos.lnum == 0) {        /* nothing found */</a>
<a name="ln5610">          if (cap-&gt;nchar != 'm' &amp;&amp; cap-&gt;nchar != 'M')</a>
<a name="ln5611">            clearopbeep(cap-&gt;oap);</a>
<a name="ln5612">        } else</a>
<a name="ln5613">          pos = &amp;new_pos;               /* use last one found */</a>
<a name="ln5614">        break;</a>
<a name="ln5615">      }</a>
<a name="ln5616">      prev_pos = new_pos;</a>
<a name="ln5617">      curwin-&gt;w_cursor = *pos;</a>
<a name="ln5618">      new_pos = *pos;</a>
<a name="ln5619">    }</a>
<a name="ln5620">    curwin-&gt;w_cursor = old_pos;</a>
<a name="ln5621"> </a>
<a name="ln5622">    /*</a>
<a name="ln5623">     * Handle &quot;[m&quot;, &quot;]m&quot;, &quot;[M&quot; and &quot;[M&quot;.  The findmatchlimit() only</a>
<a name="ln5624">     * brought us to the match for &quot;[m&quot; and &quot;]M&quot; when inside a method.</a>
<a name="ln5625">     * Try finding the '{' or '}' we want to be at.</a>
<a name="ln5626">     * Also repeat for the given count.</a>
<a name="ln5627">     */</a>
<a name="ln5628">    if (cap-&gt;nchar == 'm' || cap-&gt;nchar == 'M') {</a>
<a name="ln5629">      /* norm is true for &quot;]M&quot; and &quot;[m&quot; */</a>
<a name="ln5630">      int norm = ((findc == '{') == (cap-&gt;nchar == 'm'));</a>
<a name="ln5631"> </a>
<a name="ln5632">      n = cap-&gt;count1;</a>
<a name="ln5633">      /* found a match: we were inside a method */</a>
<a name="ln5634">      if (prev_pos.lnum != 0) {</a>
<a name="ln5635">        pos = &amp;prev_pos;</a>
<a name="ln5636">        curwin-&gt;w_cursor = prev_pos;</a>
<a name="ln5637">        if (norm)</a>
<a name="ln5638">          --n;</a>
<a name="ln5639">      } else</a>
<a name="ln5640">        pos = NULL;</a>
<a name="ln5641">      while (n &gt; 0) {</a>
<a name="ln5642">        for (;; ) {</a>
<a name="ln5643">          if ((findc == '{' ? dec_cursor() : inc_cursor()) &lt; 0) {</a>
<a name="ln5644">            /* if not found anything, that's an error */</a>
<a name="ln5645">            if (pos == NULL)</a>
<a name="ln5646">              clearopbeep(cap-&gt;oap);</a>
<a name="ln5647">            n = 0;</a>
<a name="ln5648">            break;</a>
<a name="ln5649">          }</a>
<a name="ln5650">          c = gchar_cursor();</a>
<a name="ln5651">          if (c == '{' || c == '}') {</a>
<a name="ln5652">            /* Must have found end/start of class: use it.</a>
<a name="ln5653">             * Or found the place to be at. */</a>
<a name="ln5654">            if ((c == findc &amp;&amp; norm) || (n == 1 &amp;&amp; !norm)) {</a>
<a name="ln5655">              new_pos = curwin-&gt;w_cursor;</a>
<a name="ln5656">              pos = &amp;new_pos;</a>
<a name="ln5657">              n = 0;</a>
<a name="ln5658">            }</a>
<a name="ln5659">            /* if no match found at all, we started outside of the</a>
<a name="ln5660">             * class and we're inside now.  Just go on. */</a>
<a name="ln5661">            else if (new_pos.lnum == 0) {</a>
<a name="ln5662">              new_pos = curwin-&gt;w_cursor;</a>
<a name="ln5663">              pos = &amp;new_pos;</a>
<a name="ln5664">            }</a>
<a name="ln5665">            /* found start/end of other method: go to match */</a>
<a name="ln5666">            else if ((pos = findmatchlimit(cap-&gt;oap, findc,</a>
<a name="ln5667">                          (cap-&gt;cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,</a>
<a name="ln5668">                          0)) == NULL)</a>
<a name="ln5669">              n = 0;</a>
<a name="ln5670">            else</a>
<a name="ln5671">              curwin-&gt;w_cursor = *pos;</a>
<a name="ln5672">            break;</a>
<a name="ln5673">          }</a>
<a name="ln5674">        }</a>
<a name="ln5675">        --n;</a>
<a name="ln5676">      }</a>
<a name="ln5677">      curwin-&gt;w_cursor = old_pos;</a>
<a name="ln5678">      if (pos == NULL &amp;&amp; new_pos.lnum != 0)</a>
<a name="ln5679">        clearopbeep(cap-&gt;oap);</a>
<a name="ln5680">    }</a>
<a name="ln5681">    if (pos != NULL) {</a>
<a name="ln5682">      setpcmark();</a>
<a name="ln5683">      curwin-&gt;w_cursor = *pos;</a>
<a name="ln5684">      curwin-&gt;w_set_curswant = true;</a>
<a name="ln5685">      if ((fdo_flags &amp; FDO_BLOCK) &amp;&amp; KeyTyped</a>
<a name="ln5686">          &amp;&amp; cap-&gt;oap-&gt;op_type == OP_NOP)</a>
<a name="ln5687">        foldOpenCursor();</a>
<a name="ln5688">    }</a>
<a name="ln5689">  }</a>
<a name="ln5690">  /*</a>
<a name="ln5691">   * &quot;[[&quot;, &quot;[]&quot;, &quot;]]&quot; and &quot;][&quot;: move to start or end of function</a>
<a name="ln5692">   */</a>
<a name="ln5693">  else if (cap-&gt;nchar == '[' || cap-&gt;nchar == ']') {</a>
<a name="ln5694">    if (cap-&gt;nchar == cap-&gt;cmdchar)                 /* &quot;]]&quot; or &quot;[[&quot; */</a>
<a name="ln5695">      flag = '{';</a>
<a name="ln5696">    else</a>
<a name="ln5697">      flag = '}';                   /* &quot;][&quot; or &quot;[]&quot; */</a>
<a name="ln5698"> </a>
<a name="ln5699">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln5700">    /*</a>
<a name="ln5701">     * Imitate strange Vi behaviour: When using &quot;]]&quot; with an operator</a>
<a name="ln5702">     * we also stop at '}'.</a>
<a name="ln5703">     */</a>
<a name="ln5704">    if (!findpar(&amp;cap-&gt;oap-&gt;inclusive, cap-&gt;arg, cap-&gt;count1, flag,</a>
<a name="ln5705">            (cap-&gt;oap-&gt;op_type != OP_NOP</a>
<a name="ln5706">             &amp;&amp; cap-&gt;arg == FORWARD &amp;&amp; flag == '{')))</a>
<a name="ln5707">      clearopbeep(cap-&gt;oap);</a>
<a name="ln5708">    else {</a>
<a name="ln5709">      if (cap-&gt;oap-&gt;op_type == OP_NOP)</a>
<a name="ln5710">        beginline(BL_WHITE | BL_FIX);</a>
<a name="ln5711">      if ((fdo_flags &amp; FDO_BLOCK) &amp;&amp; KeyTyped &amp;&amp; cap-&gt;oap-&gt;op_type == OP_NOP)</a>
<a name="ln5712">        foldOpenCursor();</a>
<a name="ln5713">    }</a>
<a name="ln5714">  } else if (cap-&gt;nchar == 'p' || cap-&gt;nchar == 'P') {</a>
<a name="ln5715">    // &quot;[p&quot;, &quot;[P&quot;, &quot;]P&quot; and &quot;]p&quot;: put with indent adjustment</a>
<a name="ln5716">    nv_put_opt(cap, true);</a>
<a name="ln5717">  }</a>
<a name="ln5718">  /*</a>
<a name="ln5719">   * &quot;['&quot;, &quot;[`&quot;, &quot;]'&quot; and &quot;]`&quot;: jump to next mark</a>
<a name="ln5720">   */</a>
<a name="ln5721">  else if (cap-&gt;nchar == '\'' || cap-&gt;nchar == '`') {</a>
<a name="ln5722">    pos = &amp;curwin-&gt;w_cursor;</a>
<a name="ln5723">    for (n = cap-&gt;count1; n &gt; 0; --n) {</a>
<a name="ln5724">      prev_pos = *pos;</a>
<a name="ln5725">      pos = getnextmark(pos, cap-&gt;cmdchar == '[' ? BACKWARD : FORWARD,</a>
<a name="ln5726">          cap-&gt;nchar == '\'');</a>
<a name="ln5727">      if (pos == NULL)</a>
<a name="ln5728">        break;</a>
<a name="ln5729">    }</a>
<a name="ln5730">    if (pos == NULL)</a>
<a name="ln5731">      pos = &amp;prev_pos;</a>
<a name="ln5732">    nv_cursormark(cap, cap-&gt;nchar == '\'', pos);</a>
<a name="ln5733">  }</a>
<a name="ln5734">  /*</a>
<a name="ln5735">   * [ or ] followed by a middle mouse click: put selected text with</a>
<a name="ln5736">   * indent adjustment.  Any other button just does as usual.</a>
<a name="ln5737">   */</a>
<a name="ln5738">  else if (cap-&gt;nchar &gt;= K_RIGHTRELEASE &amp;&amp; cap-&gt;nchar &lt;= K_LEFTMOUSE) {</a>
<a name="ln5739">    (void)do_mouse(cap-&gt;oap, cap-&gt;nchar,</a>
<a name="ln5740">        (cap-&gt;cmdchar == ']') ? FORWARD : BACKWARD,</a>
<a name="ln5741">        cap-&gt;count1, PUT_FIXINDENT);</a>
<a name="ln5742">  }</a>
<a name="ln5743">  /*</a>
<a name="ln5744">   * &quot;[z&quot; and &quot;]z&quot;: move to start or end of open fold.</a>
<a name="ln5745">   */</a>
<a name="ln5746">  else if (cap-&gt;nchar == 'z') {</a>
<a name="ln5747">    if (foldMoveTo(false, cap-&gt;cmdchar == ']' ? FORWARD : BACKWARD,</a>
<a name="ln5748">            cap-&gt;count1) == false)</a>
<a name="ln5749">      clearopbeep(cap-&gt;oap);</a>
<a name="ln5750">  }</a>
<a name="ln5751">  /*</a>
<a name="ln5752">   * &quot;[c&quot; and &quot;]c&quot;: move to next or previous diff-change.</a>
<a name="ln5753">   */</a>
<a name="ln5754">  else if (cap-&gt;nchar == 'c') {</a>
<a name="ln5755">    if (diff_move_to(cap-&gt;cmdchar == ']' ? FORWARD : BACKWARD,</a>
<a name="ln5756">            cap-&gt;count1) == false)</a>
<a name="ln5757">      clearopbeep(cap-&gt;oap);</a>
<a name="ln5758">  }</a>
<a name="ln5759">  /*</a>
<a name="ln5760">   * &quot;[s&quot;, &quot;[S&quot;, &quot;]s&quot; and &quot;]S&quot;: move to next spell error.</a>
<a name="ln5761">   */</a>
<a name="ln5762">  else if (cap-&gt;nchar == 's' || cap-&gt;nchar == 'S') {</a>
<a name="ln5763">    setpcmark();</a>
<a name="ln5764">    for (n = 0; n &lt; cap-&gt;count1; ++n)</a>
<a name="ln5765">      if (spell_move_to(curwin, cap-&gt;cmdchar == ']' ? FORWARD : BACKWARD,</a>
<a name="ln5766">                        cap-&gt;nchar == 's', false, NULL) == 0) {</a>
<a name="ln5767">        clearopbeep(cap-&gt;oap);</a>
<a name="ln5768">        break;</a>
<a name="ln5769">      } else {</a>
<a name="ln5770">        curwin-&gt;w_set_curswant = true;</a>
<a name="ln5771">      }</a>
<a name="ln5772">    if (cap-&gt;oap-&gt;op_type == OP_NOP &amp;&amp; (fdo_flags &amp; FDO_SEARCH) &amp;&amp; KeyTyped)</a>
<a name="ln5773">      foldOpenCursor();</a>
<a name="ln5774">  }</a>
<a name="ln5775">  /* Not a valid cap-&gt;nchar. */</a>
<a name="ln5776">  else</a>
<a name="ln5777">    clearopbeep(cap-&gt;oap);</a>
<a name="ln5778">}</a>
<a name="ln5779"> </a>
<a name="ln5780">/*</a>
<a name="ln5781"> * Handle Normal mode &quot;%&quot; command.</a>
<a name="ln5782"> */</a>
<a name="ln5783">static void nv_percent(cmdarg_T *cap)</a>
<a name="ln5784">{</a>
<a name="ln5785">  pos_T       *pos;</a>
<a name="ln5786">  linenr_T lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln5787"> </a>
<a name="ln5788">  cap-&gt;oap-&gt;inclusive = true;</a>
<a name="ln5789">  if (cap-&gt;count0) {  // {cnt}% : goto {cnt} percentage in file</a>
<a name="ln5790">    if (cap-&gt;count0 &gt; 100) {</a>
<a name="ln5791">      clearopbeep(cap-&gt;oap);</a>
<a name="ln5792">    } else {</a>
<a name="ln5793">      cap-&gt;oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln5794">      setpcmark();</a>
<a name="ln5795">      // Round up, so 'normal 100%' always jumps at the line line.</a>
<a name="ln5796">      // Beyond 21474836 lines, (ml_line_count * 100 + 99) would</a>
<a name="ln5797">      // overflow on 32-bits, so use a formula with less accuracy</a>
<a name="ln5798">      // to avoid overflows.</a>
<a name="ln5799">      if (curbuf-&gt;b_ml.ml_line_count &gt;= 21474836) {</a>
<a name="ln5800">        curwin-&gt;w_cursor.lnum = (curbuf-&gt;b_ml.ml_line_count + 99L)</a>
<a name="ln5801">                                / 100L * cap-&gt;count0;</a>
<a name="ln5802">      } else {</a>
<a name="ln5803">        curwin-&gt;w_cursor.lnum = (curbuf-&gt;b_ml.ml_line_count *</a>
<a name="ln5804">                                 cap-&gt;count0 + 99L) / 100L;</a>
<a name="ln5805">      }</a>
<a name="ln5806">      if (curwin-&gt;w_cursor.lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5807">        curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln5808">      }</a>
<a name="ln5809">      beginline(BL_SOL | BL_FIX);</a>
<a name="ln5810">    }</a>
<a name="ln5811">  } else {  // &quot;%&quot; : go to matching paren</a>
<a name="ln5812">    cap-&gt;oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln5813">    cap-&gt;oap-&gt;use_reg_one = true;</a>
<a name="ln5814">    if ((pos = findmatch(cap-&gt;oap, NUL)) == NULL)</a>
<a name="ln5815">      clearopbeep(cap-&gt;oap);</a>
<a name="ln5816">    else {</a>
<a name="ln5817">      setpcmark();</a>
<a name="ln5818">      curwin-&gt;w_cursor = *pos;</a>
<a name="ln5819">      curwin-&gt;w_set_curswant = true;</a>
<a name="ln5820">      curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln5821">      adjust_for_sel(cap);</a>
<a name="ln5822">    }</a>
<a name="ln5823">  }</a>
<a name="ln5824">  if (cap-&gt;oap-&gt;op_type == OP_NOP</a>
<a name="ln5825">      &amp;&amp; lnum != curwin-&gt;w_cursor.lnum</a>
<a name="ln5826">      &amp;&amp; (fdo_flags &amp; FDO_PERCENT)</a>
<a name="ln5827">      &amp;&amp; KeyTyped)</a>
<a name="ln5828">    foldOpenCursor();</a>
<a name="ln5829">}</a>
<a name="ln5830"> </a>
<a name="ln5831">/*</a>
<a name="ln5832"> * Handle &quot;(&quot; and &quot;)&quot; commands.</a>
<a name="ln5833"> * cap-&gt;arg is BACKWARD for &quot;(&quot; and FORWARD for &quot;)&quot;.</a>
<a name="ln5834"> */</a>
<a name="ln5835">static void nv_brace(cmdarg_T *cap)</a>
<a name="ln5836">{</a>
<a name="ln5837">  cap-&gt;oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln5838">  cap-&gt;oap-&gt;use_reg_one = true;</a>
<a name="ln5839">  /* The motion used to be inclusive for &quot;(&quot;, but that is not what Vi does. */</a>
<a name="ln5840">  cap-&gt;oap-&gt;inclusive = false;</a>
<a name="ln5841">  curwin-&gt;w_set_curswant = true;</a>
<a name="ln5842"> </a>
<a name="ln5843">  if (findsent(cap-&gt;arg, cap-&gt;count1) == false)</a>
<a name="ln5844">    clearopbeep(cap-&gt;oap);</a>
<a name="ln5845">  else {</a>
<a name="ln5846">    /* Don't leave the cursor on the NUL past end of line. */</a>
<a name="ln5847">    adjust_cursor(cap-&gt;oap);</a>
<a name="ln5848">    curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln5849">    if ((fdo_flags &amp; FDO_BLOCK) &amp;&amp; KeyTyped &amp;&amp; cap-&gt;oap-&gt;op_type == OP_NOP)</a>
<a name="ln5850">      foldOpenCursor();</a>
<a name="ln5851">  }</a>
<a name="ln5852">}</a>
<a name="ln5853"> </a>
<a name="ln5854">/*</a>
<a name="ln5855"> * &quot;m&quot; command: Mark a position.</a>
<a name="ln5856"> */</a>
<a name="ln5857">static void nv_mark(cmdarg_T *cap)</a>
<a name="ln5858">{</a>
<a name="ln5859">  if (!checkclearop(cap-&gt;oap)) {</a>
<a name="ln5860">    if (setmark(cap-&gt;nchar) == false)</a>
<a name="ln5861">      clearopbeep(cap-&gt;oap);</a>
<a name="ln5862">  }</a>
<a name="ln5863">}</a>
<a name="ln5864"> </a>
<a name="ln5865">/*</a>
<a name="ln5866"> * &quot;{&quot; and &quot;}&quot; commands.</a>
<a name="ln5867"> * cmd-&gt;arg is BACKWARD for &quot;{&quot; and FORWARD for &quot;}&quot;.</a>
<a name="ln5868"> */</a>
<a name="ln5869">static void nv_findpar(cmdarg_T *cap)</a>
<a name="ln5870">{</a>
<a name="ln5871">  cap-&gt;oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln5872">  cap-&gt;oap-&gt;inclusive = false;</a>
<a name="ln5873">  cap-&gt;oap-&gt;use_reg_one = true;</a>
<a name="ln5874">  curwin-&gt;w_set_curswant = true;</a>
<a name="ln5875">  if (!findpar(&amp;cap-&gt;oap-&gt;inclusive, cap-&gt;arg, cap-&gt;count1, NUL, false))</a>
<a name="ln5876">    clearopbeep(cap-&gt;oap);</a>
<a name="ln5877">  else {</a>
<a name="ln5878">    curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln5879">    if ((fdo_flags &amp; FDO_BLOCK) &amp;&amp; KeyTyped &amp;&amp; cap-&gt;oap-&gt;op_type == OP_NOP)</a>
<a name="ln5880">      foldOpenCursor();</a>
<a name="ln5881">  }</a>
<a name="ln5882">}</a>
<a name="ln5883"> </a>
<a name="ln5884">/*</a>
<a name="ln5885"> * &quot;u&quot; command: Undo or make lower case.</a>
<a name="ln5886"> */</a>
<a name="ln5887">static void nv_undo(cmdarg_T *cap)</a>
<a name="ln5888">{</a>
<a name="ln5889">  if (cap-&gt;oap-&gt;op_type == OP_LOWER</a>
<a name="ln5890">      || VIsual_active</a>
<a name="ln5891">      ) {</a>
<a name="ln5892">    /* translate &quot;&lt;Visual&gt;u&quot; to &quot;&lt;Visual&gt;gu&quot; and &quot;guu&quot; to &quot;gugu&quot; */</a>
<a name="ln5893">    cap-&gt;cmdchar = 'g';</a>
<a name="ln5894">    cap-&gt;nchar = 'u';</a>
<a name="ln5895">    nv_operator(cap);</a>
<a name="ln5896">  } else</a>
<a name="ln5897">    nv_kundo(cap);</a>
<a name="ln5898">}</a>
<a name="ln5899"> </a>
<a name="ln5900">/*</a>
<a name="ln5901"> * &lt;Undo&gt; command.</a>
<a name="ln5902"> */</a>
<a name="ln5903">static void nv_kundo(cmdarg_T *cap)</a>
<a name="ln5904">{</a>
<a name="ln5905">  if (!checkclearopq(cap-&gt;oap)) {</a>
<a name="ln5906">    if (bt_prompt(curbuf)) {</a>
<a name="ln5907">      clearopbeep(cap-&gt;oap);</a>
<a name="ln5908">      return;</a>
<a name="ln5909">    }</a>
<a name="ln5910">    u_undo((int)cap-&gt;count1);</a>
<a name="ln5911">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln5912">  }</a>
<a name="ln5913">}</a>
<a name="ln5914"> </a>
<a name="ln5915">/*</a>
<a name="ln5916"> * Handle the &quot;r&quot; command.</a>
<a name="ln5917"> */</a>
<a name="ln5918">static void nv_replace(cmdarg_T *cap)</a>
<a name="ln5919">{</a>
<a name="ln5920">  char_u      *ptr;</a>
<a name="ln5921">  int had_ctrl_v;</a>
<a name="ln5922"> </a>
<a name="ln5923">  if (checkclearop(cap-&gt;oap)) {</a>
<a name="ln5924">    return;</a>
<a name="ln5925">  }</a>
<a name="ln5926">  if (bt_prompt(curbuf) &amp;&amp; !prompt_curpos_editable()) {</a>
<a name="ln5927">    clearopbeep(cap-&gt;oap);</a>
<a name="ln5928">    return;</a>
<a name="ln5929">  }</a>
<a name="ln5930"> </a>
<a name="ln5931">  /* get another character */</a>
<a name="ln5932">  if (cap-&gt;nchar == Ctrl_V) {</a>
<a name="ln5933">    had_ctrl_v = Ctrl_V;</a>
<a name="ln5934">    cap-&gt;nchar = get_literal();</a>
<a name="ln5935">    /* Don't redo a multibyte character with CTRL-V. */</a>
<a name="ln5936">    if (cap-&gt;nchar &gt; DEL)</a>
<a name="ln5937">      had_ctrl_v = NUL;</a>
<a name="ln5938">  } else</a>
<a name="ln5939">    had_ctrl_v = NUL;</a>
<a name="ln5940"> </a>
<a name="ln5941">  /* Abort if the character is a special key. */</a>
<a name="ln5942">  if (IS_SPECIAL(cap-&gt;nchar)) {</a>
<a name="ln5943">    clearopbeep(cap-&gt;oap);</a>
<a name="ln5944">    return;</a>
<a name="ln5945">  }</a>
<a name="ln5946"> </a>
<a name="ln5947">  /* Visual mode &quot;r&quot; */</a>
<a name="ln5948">  if (VIsual_active) {</a>
<a name="ln5949">    if (got_int)</a>
<a name="ln5950">      reset_VIsual();</a>
<a name="ln5951">    if (had_ctrl_v) {</a>
<a name="ln5952">      // Use a special (negative) number to make a difference between a</a>
<a name="ln5953">      // literal CR or NL and a line break.</a>
<a name="ln5954">      if (cap-&gt;nchar == CAR) {</a>
<a name="ln5955">        cap-&gt;nchar = REPLACE_CR_NCHAR;</a>
<a name="ln5956">      } else if (cap-&gt;nchar == NL) {</a>
<a name="ln5957">        cap-&gt;nchar = REPLACE_NL_NCHAR;</a>
<a name="ln5958">      }</a>
<a name="ln5959">    }</a>
<a name="ln5960">    nv_operator(cap);</a>
<a name="ln5961">    return;</a>
<a name="ln5962">  }</a>
<a name="ln5963"> </a>
<a name="ln5964">  /* Break tabs, etc. */</a>
<a name="ln5965">  if (virtual_active()) {</a>
<a name="ln5966">    if (u_save_cursor() == false)</a>
<a name="ln5967">      return;</a>
<a name="ln5968">    if (gchar_cursor() == NUL) {</a>
<a name="ln5969">      /* Add extra space and put the cursor on the first one. */</a>
<a name="ln5970">      coladvance_force((colnr_T)(getviscol() + cap-&gt;count1));</a>
<a name="ln5971">      assert(cap-&gt;count1 &lt;= INT_MAX);</a>
<a name="ln5972">      curwin-&gt;w_cursor.col -= (colnr_T)cap-&gt;count1;</a>
<a name="ln5973">    } else if (gchar_cursor() == TAB)</a>
<a name="ln5974">      coladvance_force(getviscol());</a>
<a name="ln5975">  }</a>
<a name="ln5976"> </a>
<a name="ln5977">  /* Abort if not enough characters to replace. */</a>
<a name="ln5978">  ptr = get_cursor_pos_ptr();</a>
<a name="ln5979">  if (STRLEN(ptr) &lt; (unsigned)cap-&gt;count1</a>
<a name="ln5980">      || (mb_charlen(ptr) &lt; cap-&gt;count1)</a>
<a name="ln5981">      ) {</a>
<a name="ln5982">    clearopbeep(cap-&gt;oap);</a>
<a name="ln5983">    return;</a>
<a name="ln5984">  }</a>
<a name="ln5985"> </a>
<a name="ln5986">  // Replacing with a TAB is done by edit() when it is complicated because</a>
<a name="ln5987">  // 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.</a>
<a name="ln5988">  // Other characters are done below to avoid problems with things like</a>
<a name="ln5989">  // CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).</a>
<a name="ln5990">  if (had_ctrl_v != Ctrl_V &amp;&amp; cap-&gt;nchar == '\t' &amp;&amp; (curbuf-&gt;b_p_et || p_sta)) {</a>
<a name="ln5991">    stuffnumReadbuff(cap-&gt;count1);</a>
<a name="ln5992">    stuffcharReadbuff('R');</a>
<a name="ln5993">    stuffcharReadbuff('\t');</a>
<a name="ln5994">    stuffcharReadbuff(ESC);</a>
<a name="ln5995">    return;</a>
<a name="ln5996">  }</a>
<a name="ln5997"> </a>
<a name="ln5998">  /* save line for undo */</a>
<a name="ln5999">  if (u_save_cursor() == false)</a>
<a name="ln6000">    return;</a>
<a name="ln6001"> </a>
<a name="ln6002">  if (had_ctrl_v != Ctrl_V &amp;&amp; (cap-&gt;nchar == '\r' || cap-&gt;nchar == '\n')) {</a>
<a name="ln6003">    /*</a>
<a name="ln6004">     * Replace character(s) by a single newline.</a>
<a name="ln6005">     * Strange vi behaviour: Only one newline is inserted.</a>
<a name="ln6006">     * Delete the characters here.</a>
<a name="ln6007">     * Insert the newline with an insert command, takes care of</a>
<a name="ln6008">     * autoindent.	The insert command depends on being on the last</a>
<a name="ln6009">     * character of a line or not.</a>
<a name="ln6010">     */</a>
<a name="ln6011">    (void)del_chars(cap-&gt;count1, false);        /* delete the characters */</a>
<a name="ln6012">    stuffcharReadbuff('\r');</a>
<a name="ln6013">    stuffcharReadbuff(ESC);</a>
<a name="ln6014"> </a>
<a name="ln6015">    /* Give 'r' to edit(), to get the redo command right. */</a>
<a name="ln6016">    invoke_edit(cap, true, 'r', false);</a>
<a name="ln6017">  } else {</a>
<a name="ln6018">    prep_redo(cap-&gt;oap-&gt;regname, cap-&gt;count1,</a>
<a name="ln6019">        NUL, 'r', NUL, had_ctrl_v, cap-&gt;nchar);</a>
<a name="ln6020"> </a>
<a name="ln6021">    curbuf-&gt;b_op_start = curwin-&gt;w_cursor;</a>
<a name="ln6022">    const int old_State = State;</a>
<a name="ln6023"> </a>
<a name="ln6024">    if (cap-&gt;ncharC1 != 0) {</a>
<a name="ln6025">      AppendCharToRedobuff(cap-&gt;ncharC1);</a>
<a name="ln6026">    }</a>
<a name="ln6027">    if (cap-&gt;ncharC2 != 0) {</a>
<a name="ln6028">      AppendCharToRedobuff(cap-&gt;ncharC2);</a>
<a name="ln6029">    }</a>
<a name="ln6030"> </a>
<a name="ln6031">    // This is slow, but it handles replacing a single-byte with a</a>
<a name="ln6032">    // multi-byte and the other way around.  Also handles adding</a>
<a name="ln6033">    // composing characters for utf-8.</a>
<a name="ln6034">    for (long n = cap-&gt;count1; n &gt; 0; n--) {</a>
<a name="ln6035">      State = REPLACE;</a>
<a name="ln6036">      if (cap-&gt;nchar == Ctrl_E || cap-&gt;nchar == Ctrl_Y) {</a>
<a name="ln6037">        int c = ins_copychar(curwin-&gt;w_cursor.lnum</a>
<a name="ln6038">                             + (cap-&gt;nchar == Ctrl_Y ? -1 : 1));</a>
<a name="ln6039">        if (c != NUL) {</a>
<a name="ln6040">          ins_char(c);</a>
<a name="ln6041">        } else {</a>
<a name="ln6042">          // will be decremented further down</a>
<a name="ln6043">          curwin-&gt;w_cursor.col++;</a>
<a name="ln6044">        }</a>
<a name="ln6045">      } else {</a>
<a name="ln6046">        ins_char(cap-&gt;nchar);</a>
<a name="ln6047">      }</a>
<a name="ln6048">      State = old_State;</a>
<a name="ln6049">      if (cap-&gt;ncharC1 != 0) {</a>
<a name="ln6050">        ins_char(cap-&gt;ncharC1);</a>
<a name="ln6051">      }</a>
<a name="ln6052">      if (cap-&gt;ncharC2 != 0) {</a>
<a name="ln6053">        ins_char(cap-&gt;ncharC2);</a>
<a name="ln6054">      }</a>
<a name="ln6055">    }</a>
<a name="ln6056">    --curwin-&gt;w_cursor.col;         /* cursor on the last replaced char */</a>
<a name="ln6057">    /* if the character on the left of the current cursor is a multi-byte</a>
<a name="ln6058">     * character, move two characters left */</a>
<a name="ln6059">    mb_adjust_cursor();</a>
<a name="ln6060">    curbuf-&gt;b_op_end = curwin-&gt;w_cursor;</a>
<a name="ln6061">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln6062">    set_last_insert(cap-&gt;nchar);</a>
<a name="ln6063">  }</a>
<a name="ln6064"> </a>
<a name="ln6065">  foldUpdateAfterInsert();</a>
<a name="ln6066">}</a>
<a name="ln6067"> </a>
<a name="ln6068">/*</a>
<a name="ln6069"> * 'o': Exchange start and end of Visual area.</a>
<a name="ln6070"> * 'O': same, but in block mode exchange left and right corners.</a>
<a name="ln6071"> */</a>
<a name="ln6072">static void v_swap_corners(int cmdchar)</a>
<a name="ln6073">{</a>
<a name="ln6074">  pos_T old_cursor;</a>
<a name="ln6075">  colnr_T left, right;</a>
<a name="ln6076"> </a>
<a name="ln6077">  if (cmdchar == 'O' &amp;&amp; VIsual_mode == Ctrl_V) {</a>
<a name="ln6078">    old_cursor = curwin-&gt;w_cursor;</a>
<a name="ln6079">    getvcols(curwin, &amp;old_cursor, &amp;VIsual, &amp;left, &amp;right);</a>
<a name="ln6080">    curwin-&gt;w_cursor.lnum = VIsual.lnum;</a>
<a name="ln6081">    coladvance(left);</a>
<a name="ln6082">    VIsual = curwin-&gt;w_cursor;</a>
<a name="ln6083"> </a>
<a name="ln6084">    curwin-&gt;w_cursor.lnum = old_cursor.lnum;</a>
<a name="ln6085">    curwin-&gt;w_curswant = right;</a>
<a name="ln6086">    /* 'selection &quot;exclusive&quot; and cursor at right-bottom corner: move it</a>
<a name="ln6087">     * right one column */</a>
<a name="ln6088">    if (old_cursor.lnum &gt;= VIsual.lnum &amp;&amp; *p_sel == 'e')</a>
<a name="ln6089">      ++curwin-&gt;w_curswant;</a>
<a name="ln6090">    coladvance(curwin-&gt;w_curswant);</a>
<a name="ln6091">    if (curwin-&gt;w_cursor.col == old_cursor.col</a>
<a name="ln6092">        &amp;&amp; (!virtual_active()</a>
<a name="ln6093">            || curwin-&gt;w_cursor.coladd == old_cursor.coladd)</a>
<a name="ln6094">        ) {</a>
<a name="ln6095">      curwin-&gt;w_cursor.lnum = VIsual.lnum;</a>
<a name="ln6096">      if (old_cursor.lnum &lt;= VIsual.lnum &amp;&amp; *p_sel == 'e')</a>
<a name="ln6097">        ++right;</a>
<a name="ln6098">      coladvance(right);</a>
<a name="ln6099">      VIsual = curwin-&gt;w_cursor;</a>
<a name="ln6100"> </a>
<a name="ln6101">      curwin-&gt;w_cursor.lnum = old_cursor.lnum;</a>
<a name="ln6102">      coladvance(left);</a>
<a name="ln6103">      curwin-&gt;w_curswant = left;</a>
<a name="ln6104">    }</a>
<a name="ln6105">  } else {</a>
<a name="ln6106">    old_cursor = curwin-&gt;w_cursor;</a>
<a name="ln6107">    curwin-&gt;w_cursor = VIsual;</a>
<a name="ln6108">    VIsual = old_cursor;</a>
<a name="ln6109">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln6110">  }</a>
<a name="ln6111">}</a>
<a name="ln6112"> </a>
<a name="ln6113">/*</a>
<a name="ln6114"> * &quot;R&quot; (cap-&gt;arg is false) and &quot;gR&quot; (cap-&gt;arg is true).</a>
<a name="ln6115"> */</a>
<a name="ln6116">static void nv_Replace(cmdarg_T *cap)</a>
<a name="ln6117">{</a>
<a name="ln6118">  if (VIsual_active) {          /* &quot;R&quot; is replace lines */</a>
<a name="ln6119">    cap-&gt;cmdchar = 'c';</a>
<a name="ln6120">    cap-&gt;nchar = NUL;</a>
<a name="ln6121">    VIsual_mode_orig = VIsual_mode;     /* remember original area for gv */</a>
<a name="ln6122">    VIsual_mode = 'V';</a>
<a name="ln6123">    nv_operator(cap);</a>
<a name="ln6124">  } else if (!checkclearopq(cap-&gt;oap)) {</a>
<a name="ln6125">    if (!MODIFIABLE(curbuf)) {</a>
<a name="ln6126">      EMSG(_(e_modifiable));</a>
<a name="ln6127">    } else {</a>
<a name="ln6128">      if (virtual_active())</a>
<a name="ln6129">        coladvance(getviscol());</a>
<a name="ln6130">      invoke_edit(cap, false, cap-&gt;arg ? 'V' : 'R', false);</a>
<a name="ln6131">    }</a>
<a name="ln6132">  }</a>
<a name="ln6133">}</a>
<a name="ln6134"> </a>
<a name="ln6135">/*</a>
<a name="ln6136"> * &quot;gr&quot;.</a>
<a name="ln6137"> */</a>
<a name="ln6138">static void nv_vreplace(cmdarg_T *cap)</a>
<a name="ln6139">{</a>
<a name="ln6140">  if (VIsual_active) {</a>
<a name="ln6141">    cap-&gt;cmdchar = 'r';</a>
<a name="ln6142">    cap-&gt;nchar = cap-&gt;extra_char;</a>
<a name="ln6143">    nv_replace(cap);            /* Do same as &quot;r&quot; in Visual mode for now */</a>
<a name="ln6144">  } else if (!checkclearopq(cap-&gt;oap)) {</a>
<a name="ln6145">    if (!MODIFIABLE(curbuf)) {</a>
<a name="ln6146">      EMSG(_(e_modifiable));</a>
<a name="ln6147">    } else {</a>
<a name="ln6148">      if (cap-&gt;extra_char == Ctrl_V)            /* get another character */</a>
<a name="ln6149">        cap-&gt;extra_char = get_literal();</a>
<a name="ln6150">      stuffcharReadbuff(cap-&gt;extra_char);</a>
<a name="ln6151">      stuffcharReadbuff(ESC);</a>
<a name="ln6152">      if (virtual_active())</a>
<a name="ln6153">        coladvance(getviscol());</a>
<a name="ln6154">      invoke_edit(cap, true, 'v', false);</a>
<a name="ln6155">    }</a>
<a name="ln6156">  }</a>
<a name="ln6157">}</a>
<a name="ln6158"> </a>
<a name="ln6159">/*</a>
<a name="ln6160"> * Swap case for &quot;~&quot; command, when it does not work like an operator.</a>
<a name="ln6161"> */</a>
<a name="ln6162">static void n_swapchar(cmdarg_T *cap)</a>
<a name="ln6163">{</a>
<a name="ln6164">  long n;</a>
<a name="ln6165">  pos_T startpos;</a>
<a name="ln6166">  int did_change = 0;</a>
<a name="ln6167"> </a>
<a name="ln6168">  if (checkclearopq(cap-&gt;oap)) {</a>
<a name="ln6169">    return;</a>
<a name="ln6170">  }</a>
<a name="ln6171"> </a>
<a name="ln6172">  if (LINEEMPTY(curwin-&gt;w_cursor.lnum) &amp;&amp; vim_strchr(p_ww, '~') == NULL) {</a>
<a name="ln6173">    clearopbeep(cap-&gt;oap);</a>
<a name="ln6174">    return;</a>
<a name="ln6175">  }</a>
<a name="ln6176"> </a>
<a name="ln6177">  prep_redo_cmd(cap);</a>
<a name="ln6178"> </a>
<a name="ln6179">  if (u_save_cursor() == false)</a>
<a name="ln6180">    return;</a>
<a name="ln6181"> </a>
<a name="ln6182">  startpos = curwin-&gt;w_cursor;</a>
<a name="ln6183">  for (n = cap-&gt;count1; n &gt; 0; --n) {</a>
<a name="ln6184">    did_change |= swapchar(cap-&gt;oap-&gt;op_type, &amp;curwin-&gt;w_cursor);</a>
<a name="ln6185">    inc_cursor();</a>
<a name="ln6186">    if (gchar_cursor() == NUL) {</a>
<a name="ln6187">      if (vim_strchr(p_ww, '~') != NULL</a>
<a name="ln6188">          &amp;&amp; curwin-&gt;w_cursor.lnum &lt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6189">        ++curwin-&gt;w_cursor.lnum;</a>
<a name="ln6190">        curwin-&gt;w_cursor.col = 0;</a>
<a name="ln6191">        if (n &gt; 1) {</a>
<a name="ln6192">          if (u_savesub(curwin-&gt;w_cursor.lnum) == false)</a>
<a name="ln6193">            break;</a>
<a name="ln6194">          u_clearline();</a>
<a name="ln6195">        }</a>
<a name="ln6196">      } else</a>
<a name="ln6197">        break;</a>
<a name="ln6198">    }</a>
<a name="ln6199">  }</a>
<a name="ln6200"> </a>
<a name="ln6201"> </a>
<a name="ln6202">  check_cursor();</a>
<a name="ln6203">  curwin-&gt;w_set_curswant = true;</a>
<a name="ln6204">  if (did_change) {</a>
<a name="ln6205">    changed_lines(startpos.lnum, startpos.col, curwin-&gt;w_cursor.lnum + 1,</a>
<a name="ln6206">                  0L, true);</a>
<a name="ln6207">    curbuf-&gt;b_op_start = startpos;</a>
<a name="ln6208">    curbuf-&gt;b_op_end = curwin-&gt;w_cursor;</a>
<a name="ln6209">    if (curbuf-&gt;b_op_end.col &gt; 0)</a>
<a name="ln6210">      --curbuf-&gt;b_op_end.col;</a>
<a name="ln6211">  }</a>
<a name="ln6212">}</a>
<a name="ln6213"> </a>
<a name="ln6214">/*</a>
<a name="ln6215"> * Move cursor to mark.</a>
<a name="ln6216"> */</a>
<a name="ln6217">static void nv_cursormark(cmdarg_T *cap, int flag, pos_T *pos)</a>
<a name="ln6218">{</a>
<a name="ln6219">  if (check_mark(pos) == false)</a>
<a name="ln6220">    clearop(cap-&gt;oap);</a>
<a name="ln6221">  else {</a>
<a name="ln6222">    if (cap-&gt;cmdchar == '\''</a>
<a name="ln6223">        || cap-&gt;cmdchar == '`'</a>
<a name="ln6224">        || cap-&gt;cmdchar == '['</a>
<a name="ln6225">        || cap-&gt;cmdchar == ']')</a>
<a name="ln6226">      setpcmark();</a>
<a name="ln6227">    curwin-&gt;w_cursor = *pos;</a>
<a name="ln6228">    if (flag)</a>
<a name="ln6229">      beginline(BL_WHITE | BL_FIX);</a>
<a name="ln6230">    else</a>
<a name="ln6231">      check_cursor();</a>
<a name="ln6232">  }</a>
<a name="ln6233">  cap-&gt;oap-&gt;motion_type = flag ? kMTLineWise : kMTCharWise;</a>
<a name="ln6234">  if (cap-&gt;cmdchar == '`') {</a>
<a name="ln6235">    cap-&gt;oap-&gt;use_reg_one = true;</a>
<a name="ln6236">  }</a>
<a name="ln6237">  cap-&gt;oap-&gt;inclusive = false;  // ignored if not kMTCharWise</a>
<a name="ln6238">  curwin-&gt;w_set_curswant = true;</a>
<a name="ln6239">}</a>
<a name="ln6240"> </a>
<a name="ln6241">/*</a>
<a name="ln6242"> * Handle commands that are operators in Visual mode.</a>
<a name="ln6243"> */</a>
<a name="ln6244">static void v_visop(cmdarg_T *cap)</a>
<a name="ln6245">{</a>
<a name="ln6246">  static char_u trans[] = &quot;YyDdCcxdXdAAIIrr&quot;;</a>
<a name="ln6247"> </a>
<a name="ln6248">  /* Uppercase means linewise, except in block mode, then &quot;D&quot; deletes till</a>
<a name="ln6249">   * the end of the line, and &quot;C&quot; replaces till EOL */</a>
<a name="ln6250">  if (isupper(cap-&gt;cmdchar)) {</a>
<a name="ln6251">    if (VIsual_mode != Ctrl_V) {</a>
<a name="ln6252">      VIsual_mode_orig = VIsual_mode;</a>
<a name="ln6253">      VIsual_mode = 'V';</a>
<a name="ln6254">    } else if (cap-&gt;cmdchar == 'C' || cap-&gt;cmdchar == 'D')</a>
<a name="ln6255">      curwin-&gt;w_curswant = MAXCOL;</a>
<a name="ln6256">  }</a>
<a name="ln6257">  cap-&gt;cmdchar = *(vim_strchr(trans, cap-&gt;cmdchar) + 1);</a>
<a name="ln6258">  nv_operator(cap);</a>
<a name="ln6259">}</a>
<a name="ln6260"> </a>
<a name="ln6261">/*</a>
<a name="ln6262"> * &quot;s&quot; and &quot;S&quot; commands.</a>
<a name="ln6263"> */</a>
<a name="ln6264">static void nv_subst(cmdarg_T *cap)</a>
<a name="ln6265">{</a>
<a name="ln6266">  if (bt_prompt(curbuf) &amp;&amp; !prompt_curpos_editable()) {</a>
<a name="ln6267">    clearopbeep(cap-&gt;oap);</a>
<a name="ln6268">    return;</a>
<a name="ln6269">  }</a>
<a name="ln6270">  if (VIsual_active) {  // &quot;vs&quot; and &quot;vS&quot; are the same as &quot;vc&quot;</a>
<a name="ln6271">    if (cap-&gt;cmdchar == 'S') {</a>
<a name="ln6272">      VIsual_mode_orig = VIsual_mode;</a>
<a name="ln6273">      VIsual_mode = 'V';</a>
<a name="ln6274">    }</a>
<a name="ln6275">    cap-&gt;cmdchar = 'c';</a>
<a name="ln6276">    nv_operator(cap);</a>
<a name="ln6277">  } else</a>
<a name="ln6278">    nv_optrans(cap);</a>
<a name="ln6279">}</a>
<a name="ln6280"> </a>
<a name="ln6281">/*</a>
<a name="ln6282"> * Abbreviated commands.</a>
<a name="ln6283"> */</a>
<a name="ln6284">static void nv_abbrev(cmdarg_T *cap)</a>
<a name="ln6285">{</a>
<a name="ln6286">  if (cap-&gt;cmdchar == K_DEL || cap-&gt;cmdchar == K_KDEL)</a>
<a name="ln6287">    cap-&gt;cmdchar = 'x';                 /* DEL key behaves like 'x' */</a>
<a name="ln6288"> </a>
<a name="ln6289">  /* in Visual mode these commands are operators */</a>
<a name="ln6290">  if (VIsual_active)</a>
<a name="ln6291">    v_visop(cap);</a>
<a name="ln6292">  else</a>
<a name="ln6293">    nv_optrans(cap);</a>
<a name="ln6294">}</a>
<a name="ln6295"> </a>
<a name="ln6296">/*</a>
<a name="ln6297"> * Translate a command into another command.</a>
<a name="ln6298"> */</a>
<a name="ln6299">static void nv_optrans(cmdarg_T *cap)</a>
<a name="ln6300">{</a>
<a name="ln6301">  static const char *(ar[]) = { &quot;dl&quot;, &quot;dh&quot;, &quot;d$&quot;, &quot;c$&quot;, &quot;cl&quot;, &quot;cc&quot;, &quot;yy&quot;,</a>
<a name="ln6302">                                &quot;:s\r&quot; };</a>
<a name="ln6303">  static const char *str = &quot;xXDCsSY&amp;&quot;;</a>
<a name="ln6304"> </a>
<a name="ln6305">  if (!checkclearopq(cap-&gt;oap)) {</a>
<a name="ln6306">    if (cap-&gt;count0) {</a>
<a name="ln6307">      stuffnumReadbuff(cap-&gt;count0);</a>
<a name="ln6308">    }</a>
<a name="ln6309">    stuffReadbuff(ar[strchr(str, (char)cap-&gt;cmdchar) - str]);</a>
<a name="ln6310">  }</a>
<a name="ln6311">  cap-&gt;opcount = 0;</a>
<a name="ln6312">}</a>
<a name="ln6313"> </a>
<a name="ln6314">/*</a>
<a name="ln6315"> * &quot;'&quot; and &quot;`&quot; commands.  Also for &quot;g'&quot; and &quot;g`&quot;.</a>
<a name="ln6316"> * cap-&gt;arg is true for &quot;'&quot; and &quot;g'&quot;.</a>
<a name="ln6317"> */</a>
<a name="ln6318">static void nv_gomark(cmdarg_T *cap)</a>
<a name="ln6319">{</a>
<a name="ln6320">  pos_T       *pos;</a>
<a name="ln6321">  int c;</a>
<a name="ln6322">  pos_T old_cursor = curwin-&gt;w_cursor;</a>
<a name="ln6323">  const bool old_KeyTyped = KeyTyped;       // getting file may reset it</a>
<a name="ln6324"> </a>
<a name="ln6325">  if (cap-&gt;cmdchar == 'g')</a>
<a name="ln6326">    c = cap-&gt;extra_char;</a>
<a name="ln6327">  else</a>
<a name="ln6328">    c = cap-&gt;nchar;</a>
<a name="ln6329">  pos = getmark(c, (cap-&gt;oap-&gt;op_type == OP_NOP));</a>
<a name="ln6330">  if (pos == (pos_T *)-1) {         /* jumped to other file */</a>
<a name="ln6331">    if (cap-&gt;arg) {</a>
<a name="ln6332">      check_cursor_lnum();</a>
<a name="ln6333">      beginline(BL_WHITE | BL_FIX);</a>
<a name="ln6334">    } else</a>
<a name="ln6335">      check_cursor();</a>
<a name="ln6336">  } else</a>
<a name="ln6337">    nv_cursormark(cap, cap-&gt;arg, pos);</a>
<a name="ln6338"> </a>
<a name="ln6339">  // May need to clear the coladd that a mark includes.</a>
<a name="ln6340">  if (!virtual_active()) {</a>
<a name="ln6341">    curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln6342">  }</a>
<a name="ln6343">  check_cursor_col();</a>
<a name="ln6344">  if (cap-&gt;oap-&gt;op_type == OP_NOP</a>
<a name="ln6345">      &amp;&amp; pos != NULL</a>
<a name="ln6346">      &amp;&amp; (pos == (pos_T *)-1 || !equalpos(old_cursor, *pos))</a>
<a name="ln6347">      &amp;&amp; (fdo_flags &amp; FDO_MARK)</a>
<a name="ln6348">      &amp;&amp; old_KeyTyped) {</a>
<a name="ln6349">    foldOpenCursor();</a>
<a name="ln6350">  }</a>
<a name="ln6351">}</a>
<a name="ln6352"> </a>
<a name="ln6353">// Handle CTRL-O, CTRL-I, &quot;g;&quot;, &quot;g,&quot;, and &quot;CTRL-Tab&quot; commands.</a>
<a name="ln6354">static void nv_pcmark(cmdarg_T *cap)</a>
<a name="ln6355">{</a>
<a name="ln6356">  pos_T       *pos;</a>
<a name="ln6357">  linenr_T lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln6358">  const bool old_KeyTyped = KeyTyped;       // getting file may reset it</a>
<a name="ln6359"> </a>
<a name="ln6360">  if (!checkclearopq(cap-&gt;oap)) {</a>
<a name="ln6361">    if (cap-&gt;cmdchar == TAB &amp;&amp; mod_mask == MOD_MASK_CTRL) {</a>
<a name="ln6362">      goto_tabpage_lastused();</a>
<a name="ln6363">      return;</a>
<a name="ln6364">    }</a>
<a name="ln6365">    if (cap-&gt;cmdchar == 'g') {</a>
<a name="ln6366">      pos = movechangelist((int)cap-&gt;count1);</a>
<a name="ln6367">    } else {</a>
<a name="ln6368">      pos = movemark((int)cap-&gt;count1);</a>
<a name="ln6369">    }</a>
<a name="ln6370">    if (pos == (pos_T *)-1) {           // jump to other file</a>
<a name="ln6371">      curwin-&gt;w_set_curswant = true;</a>
<a name="ln6372">      check_cursor();</a>
<a name="ln6373">    } else if (pos != NULL)                 /* can jump */</a>
<a name="ln6374">      nv_cursormark(cap, false, pos);</a>
<a name="ln6375">    else if (cap-&gt;cmdchar == 'g') {</a>
<a name="ln6376">      if (curbuf-&gt;b_changelistlen == 0)</a>
<a name="ln6377">        EMSG(_(&quot;E664: changelist is empty&quot;));</a>
<a name="ln6378">      else if (cap-&gt;count1 &lt; 0)</a>
<a name="ln6379">        EMSG(_(&quot;E662: At start of changelist&quot;));</a>
<a name="ln6380">      else</a>
<a name="ln6381">        EMSG(_(&quot;E663: At end of changelist&quot;));</a>
<a name="ln6382">    } else</a>
<a name="ln6383">      clearopbeep(cap-&gt;oap);</a>
<a name="ln6384">    if (cap-&gt;oap-&gt;op_type == OP_NOP</a>
<a name="ln6385">        &amp;&amp; (pos == (pos_T *)-1 || lnum != curwin-&gt;w_cursor.lnum)</a>
<a name="ln6386">        &amp;&amp; (fdo_flags &amp; FDO_MARK)</a>
<a name="ln6387">        &amp;&amp; old_KeyTyped)</a>
<a name="ln6388">      foldOpenCursor();</a>
<a name="ln6389">  }</a>
<a name="ln6390">}</a>
<a name="ln6391"> </a>
<a name="ln6392">/*</a>
<a name="ln6393"> * Handle '&quot;' command.</a>
<a name="ln6394"> */</a>
<a name="ln6395">static void nv_regname(cmdarg_T *cap)</a>
<a name="ln6396">{</a>
<a name="ln6397">  if (checkclearop(cap-&gt;oap))</a>
<a name="ln6398">    return;</a>
<a name="ln6399">  if (cap-&gt;nchar == '=')</a>
<a name="ln6400">    cap-&gt;nchar = get_expr_register();</a>
<a name="ln6401">  if (cap-&gt;nchar != NUL &amp;&amp; valid_yank_reg(cap-&gt;nchar, false)) {</a>
<a name="ln6402">    cap-&gt;oap-&gt;regname = cap-&gt;nchar;</a>
<a name="ln6403">    cap-&gt;opcount = cap-&gt;count0;         /* remember count before '&quot;' */</a>
<a name="ln6404">    set_reg_var(cap-&gt;oap-&gt;regname);</a>
<a name="ln6405">  } else</a>
<a name="ln6406">    clearopbeep(cap-&gt;oap);</a>
<a name="ln6407">}</a>
<a name="ln6408"> </a>
<a name="ln6409">/*</a>
<a name="ln6410"> * Handle &quot;v&quot;, &quot;V&quot; and &quot;CTRL-V&quot; commands.</a>
<a name="ln6411"> * Also for &quot;gh&quot;, &quot;gH&quot; and &quot;g^H&quot; commands: Always start Select mode, cap-&gt;arg</a>
<a name="ln6412"> * is true.</a>
<a name="ln6413"> * Handle CTRL-Q just like CTRL-V.</a>
<a name="ln6414"> */</a>
<a name="ln6415">static void nv_visual(cmdarg_T *cap)</a>
<a name="ln6416">{</a>
<a name="ln6417">  if (cap-&gt;cmdchar == Ctrl_Q)</a>
<a name="ln6418">    cap-&gt;cmdchar = Ctrl_V;</a>
<a name="ln6419"> </a>
<a name="ln6420">  // 'v', 'V' and CTRL-V can be used while an operator is pending to make it</a>
<a name="ln6421">  // charwise, linewise, or blockwise.</a>
<a name="ln6422">  if (cap-&gt;oap-&gt;op_type != OP_NOP) {</a>
<a name="ln6423">    motion_force = cap-&gt;oap-&gt;motion_force = cap-&gt;cmdchar;</a>
<a name="ln6424">    finish_op = false;          // operator doesn't finish now but later</a>
<a name="ln6425">    return;</a>
<a name="ln6426">  }</a>
<a name="ln6427"> </a>
<a name="ln6428">  VIsual_select = cap-&gt;arg;</a>
<a name="ln6429">  if (VIsual_active) {      /* change Visual mode */</a>
<a name="ln6430">    if (VIsual_mode == cap-&gt;cmdchar)        /* stop visual mode */</a>
<a name="ln6431">      end_visual_mode();</a>
<a name="ln6432">    else {                                  /* toggle char/block mode */</a>
<a name="ln6433">                                            /*	   or char/line mode */</a>
<a name="ln6434">      VIsual_mode = cap-&gt;cmdchar;</a>
<a name="ln6435">      showmode();</a>
<a name="ln6436">    }</a>
<a name="ln6437">    redraw_curbuf_later(INVERTED);          // update the inversion</a>
<a name="ln6438">  } else {                // start Visual mode</a>
<a name="ln6439">    if (cap-&gt;count0 &gt; 0 &amp;&amp; resel_VIsual_mode != NUL) {</a>
<a name="ln6440">      /* use previously selected part */</a>
<a name="ln6441">      VIsual = curwin-&gt;w_cursor;</a>
<a name="ln6442"> </a>
<a name="ln6443">      VIsual_active = true;</a>
<a name="ln6444">      VIsual_reselect = true;</a>
<a name="ln6445">      if (!cap-&gt;arg)</a>
<a name="ln6446">        /* start Select mode when 'selectmode' contains &quot;cmd&quot; */</a>
<a name="ln6447">        may_start_select('c');</a>
<a name="ln6448">      setmouse();</a>
<a name="ln6449">      if (p_smd &amp;&amp; msg_silent == 0)</a>
<a name="ln6450">        redraw_cmdline = true;              /* show visual mode later */</a>
<a name="ln6451">      /*</a>
<a name="ln6452">       * For V and ^V, we multiply the number of lines even if there</a>
<a name="ln6453">       * was only one -- webb</a>
<a name="ln6454">       */</a>
<a name="ln6455">      if (resel_VIsual_mode != 'v' || resel_VIsual_line_count &gt; 1) {</a>
<a name="ln6456">        curwin-&gt;w_cursor.lnum +=</a>
<a name="ln6457">          resel_VIsual_line_count * cap-&gt;count0 - 1;</a>
<a name="ln6458">        if (curwin-&gt;w_cursor.lnum &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln6459">          curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln6460">      }</a>
<a name="ln6461">      VIsual_mode = resel_VIsual_mode;</a>
<a name="ln6462">      if (VIsual_mode == 'v') {</a>
<a name="ln6463">        if (resel_VIsual_line_count &lt;= 1) {</a>
<a name="ln6464">          validate_virtcol();</a>
<a name="ln6465">          assert(cap-&gt;count0 &gt;= INT_MIN &amp;&amp; cap-&gt;count0 &lt;= INT_MAX);</a>
<a name="ln6466">          curwin-&gt;w_curswant = (curwin-&gt;w_virtcol</a>
<a name="ln6467">                                + resel_VIsual_vcol * (int)cap-&gt;count0 - 1);</a>
<a name="ln6468">        } else</a>
<a name="ln6469">          curwin-&gt;w_curswant = resel_VIsual_vcol;</a>
<a name="ln6470">        coladvance(curwin-&gt;w_curswant);</a>
<a name="ln6471">      }</a>
<a name="ln6472">      if (resel_VIsual_vcol == MAXCOL) {</a>
<a name="ln6473">        curwin-&gt;w_curswant = MAXCOL;</a>
<a name="ln6474">        coladvance(MAXCOL);</a>
<a name="ln6475">      } else if (VIsual_mode == Ctrl_V) {</a>
<a name="ln6476">        validate_virtcol();</a>
<a name="ln6477">        assert(cap-&gt;count0 &gt;= INT_MIN &amp;&amp; cap-&gt;count0 &lt;= INT_MAX);</a>
<a name="ln6478">        curwin-&gt;w_curswant = (curwin-&gt;w_virtcol</a>
<a name="ln6479">                              + resel_VIsual_vcol * (int)cap-&gt;count0 - 1);</a>
<a name="ln6480">        coladvance(curwin-&gt;w_curswant);</a>
<a name="ln6481">      } else</a>
<a name="ln6482">        curwin-&gt;w_set_curswant = true;</a>
<a name="ln6483">      redraw_curbuf_later(INVERTED);            /* show the inversion */</a>
<a name="ln6484">    } else {</a>
<a name="ln6485">      if (!cap-&gt;arg)</a>
<a name="ln6486">        /* start Select mode when 'selectmode' contains &quot;cmd&quot; */</a>
<a name="ln6487">        may_start_select('c');</a>
<a name="ln6488">      n_start_visual_mode(cap-&gt;cmdchar);</a>
<a name="ln6489">      if (VIsual_mode != 'V' &amp;&amp; *p_sel == 'e')</a>
<a name="ln6490">        ++cap-&gt;count1;          /* include one more char */</a>
<a name="ln6491">      if (cap-&gt;count0 &gt; 0 &amp;&amp; --cap-&gt;count1 &gt; 0) {</a>
<a name="ln6492">        /* With a count select that many characters or lines. */</a>
<a name="ln6493">        if (VIsual_mode == 'v' || VIsual_mode == Ctrl_V)</a>
<a name="ln6494">          nv_right(cap);</a>
<a name="ln6495">        else if (VIsual_mode == 'V')</a>
<a name="ln6496">          nv_down(cap);</a>
<a name="ln6497">      }</a>
<a name="ln6498">    }</a>
<a name="ln6499">  }</a>
<a name="ln6500">}</a>
<a name="ln6501"> </a>
<a name="ln6502">/*</a>
<a name="ln6503"> * Start selection for Shift-movement keys.</a>
<a name="ln6504"> */</a>
<a name="ln6505">void start_selection(void)</a>
<a name="ln6506">{</a>
<a name="ln6507">  /* if 'selectmode' contains &quot;key&quot;, start Select mode */</a>
<a name="ln6508">  may_start_select('k');</a>
<a name="ln6509">  n_start_visual_mode('v');</a>
<a name="ln6510">}</a>
<a name="ln6511"> </a>
<a name="ln6512">/*</a>
<a name="ln6513"> * Start Select mode, if &quot;c&quot; is in 'selectmode' and not in a mapping or menu.</a>
<a name="ln6514"> */</a>
<a name="ln6515">void may_start_select(int c)</a>
<a name="ln6516">{</a>
<a name="ln6517">  VIsual_select = (stuff_empty() &amp;&amp; typebuf_typed()</a>
<a name="ln6518">                   &amp;&amp; (vim_strchr(p_slm, c) != NULL));</a>
<a name="ln6519">}</a>
<a name="ln6520"> </a>
<a name="ln6521">/*</a>
<a name="ln6522"> * Start Visual mode &quot;c&quot;.</a>
<a name="ln6523"> * Should set VIsual_select before calling this.</a>
<a name="ln6524"> */</a>
<a name="ln6525">static void n_start_visual_mode(int c)</a>
<a name="ln6526">{</a>
<a name="ln6527">  VIsual_mode = c;</a>
<a name="ln6528">  VIsual_active = true;</a>
<a name="ln6529">  VIsual_reselect = true;</a>
<a name="ln6530">  /* Corner case: the 0 position in a tab may change when going into</a>
<a name="ln6531">   * virtualedit.  Recalculate curwin-&gt;w_cursor to avoid bad hilighting.</a>
<a name="ln6532">   */</a>
<a name="ln6533">  if (c == Ctrl_V &amp;&amp; (ve_flags &amp; VE_BLOCK) &amp;&amp; gchar_cursor() == TAB) {</a>
<a name="ln6534">    validate_virtcol();</a>
<a name="ln6535">    coladvance(curwin-&gt;w_virtcol);</a>
<a name="ln6536">  }</a>
<a name="ln6537">  VIsual = curwin-&gt;w_cursor;</a>
<a name="ln6538"> </a>
<a name="ln6539">  foldAdjustVisual();</a>
<a name="ln6540"> </a>
<a name="ln6541">  setmouse();</a>
<a name="ln6542">  // Check for redraw after changing the state.</a>
<a name="ln6543">  conceal_check_cursor_line();</a>
<a name="ln6544"> </a>
<a name="ln6545">  if (p_smd &amp;&amp; msg_silent == 0)</a>
<a name="ln6546">    redraw_cmdline = true;      /* show visual mode later */</a>
<a name="ln6547"> </a>
<a name="ln6548">  /* Only need to redraw this line, unless still need to redraw an old</a>
<a name="ln6549">   * Visual area (when 'lazyredraw' is set). */</a>
<a name="ln6550">  if (curwin-&gt;w_redr_type &lt; INVERTED) {</a>
<a name="ln6551">    curwin-&gt;w_old_cursor_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln6552">    curwin-&gt;w_old_visual_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln6553">  }</a>
<a name="ln6554">}</a>
<a name="ln6555"> </a>
<a name="ln6556"> </a>
<a name="ln6557">/*</a>
<a name="ln6558"> * CTRL-W: Window commands</a>
<a name="ln6559"> */</a>
<a name="ln6560">static void nv_window(cmdarg_T *cap)</a>
<a name="ln6561">{</a>
<a name="ln6562">  if (cap-&gt;nchar == ':') {</a>
<a name="ln6563">    // &quot;CTRL-W :&quot; is the same as typing &quot;:&quot;; useful in a terminal window</a>
<a name="ln6564">    cap-&gt;cmdchar = ':';</a>
<a name="ln6565">    cap-&gt;nchar = NUL;</a>
<a name="ln6566">    nv_colon(cap);</a>
<a name="ln6567">  } else if (!checkclearop(cap-&gt;oap)) {</a>
<a name="ln6568">    do_window(cap-&gt;nchar, cap-&gt;count0, NUL);  // everything is in window.c</a>
<a name="ln6569">  }</a>
<a name="ln6570">}</a>
<a name="ln6571"> </a>
<a name="ln6572">/*</a>
<a name="ln6573"> * CTRL-Z: Suspend</a>
<a name="ln6574"> */</a>
<a name="ln6575">static void nv_suspend(cmdarg_T *cap)</a>
<a name="ln6576">{</a>
<a name="ln6577">  clearop(cap-&gt;oap);</a>
<a name="ln6578">  if (VIsual_active)</a>
<a name="ln6579">    end_visual_mode();                  /* stop Visual mode */</a>
<a name="ln6580">  do_cmdline_cmd(&quot;st&quot;);</a>
<a name="ln6581">}</a>
<a name="ln6582"> </a>
<a name="ln6583">/*</a>
<a name="ln6584"> * Commands starting with &quot;g&quot;.</a>
<a name="ln6585"> */</a>
<a name="ln6586">static void nv_g_cmd(cmdarg_T *cap)</a>
<a name="ln6587">{</a>
<a name="ln6588">  oparg_T     *oap = cap-&gt;oap;</a>
<a name="ln6589">  pos_T tpos;</a>
<a name="ln6590">  int i;</a>
<a name="ln6591">  bool flag = false;</a>
<a name="ln6592"> </a>
<a name="ln6593">  switch (cap-&gt;nchar) {</a>
<a name="ln6594">  // &quot;g^A/g^X&quot;: Sequentially increment visually selected region.</a>
<a name="ln6595">  case Ctrl_A:</a>
<a name="ln6596">  case Ctrl_X:</a>
<a name="ln6597">    if (VIsual_active) {</a>
<a name="ln6598">      cap-&gt;arg = true;</a>
<a name="ln6599">      cap-&gt;cmdchar = cap-&gt;nchar;</a>
<a name="ln6600">      cap-&gt;nchar = NUL;</a>
<a name="ln6601">      nv_addsub(cap);</a>
<a name="ln6602">    } else {</a>
<a name="ln6603">      clearopbeep(oap);</a>
<a name="ln6604">    }</a>
<a name="ln6605">    break;</a>
<a name="ln6606"> </a>
<a name="ln6607">  // &quot;gR&quot;: Enter virtual replace mode.</a>
<a name="ln6608">  case 'R':</a>
<a name="ln6609">    cap-&gt;arg = true;</a>
<a name="ln6610">    nv_Replace(cap);</a>
<a name="ln6611">    break;</a>
<a name="ln6612"> </a>
<a name="ln6613">  case 'r':</a>
<a name="ln6614">    nv_vreplace(cap);</a>
<a name="ln6615">    break;</a>
<a name="ln6616"> </a>
<a name="ln6617">  case '&amp;':</a>
<a name="ln6618">    do_cmdline_cmd(&quot;%s//~/&amp;&quot;);</a>
<a name="ln6619">    break;</a>
<a name="ln6620"> </a>
<a name="ln6621">  /*</a>
<a name="ln6622">   * &quot;gv&quot;: Reselect the previous Visual area.  If Visual already active,</a>
<a name="ln6623">   *	     exchange previous and current Visual area.</a>
<a name="ln6624">   */</a>
<a name="ln6625">  case 'v':</a>
<a name="ln6626">    if (checkclearop(oap))</a>
<a name="ln6627">      break;</a>
<a name="ln6628"> </a>
<a name="ln6629">    if (       curbuf-&gt;b_visual.vi_start.lnum == 0</a>
<a name="ln6630">               || curbuf-&gt;b_visual.vi_start.lnum &gt; curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln6631">               || curbuf-&gt;b_visual.vi_end.lnum == 0)</a>
<a name="ln6632">      beep_flush();</a>
<a name="ln6633">    else {</a>
<a name="ln6634">      /* set w_cursor to the start of the Visual area, tpos to the end */</a>
<a name="ln6635">      if (VIsual_active) {</a>
<a name="ln6636">        i = VIsual_mode;</a>
<a name="ln6637">        VIsual_mode = curbuf-&gt;b_visual.vi_mode;</a>
<a name="ln6638">        curbuf-&gt;b_visual.vi_mode = i;</a>
<a name="ln6639">        curbuf-&gt;b_visual_mode_eval = i;</a>
<a name="ln6640">        i = curwin-&gt;w_curswant;</a>
<a name="ln6641">        curwin-&gt;w_curswant = curbuf-&gt;b_visual.vi_curswant;</a>
<a name="ln6642">        curbuf-&gt;b_visual.vi_curswant = i;</a>
<a name="ln6643"> </a>
<a name="ln6644">        tpos = curbuf-&gt;b_visual.vi_end;</a>
<a name="ln6645">        curbuf-&gt;b_visual.vi_end = curwin-&gt;w_cursor;</a>
<a name="ln6646">        curwin-&gt;w_cursor = curbuf-&gt;b_visual.vi_start;</a>
<a name="ln6647">        curbuf-&gt;b_visual.vi_start = VIsual;</a>
<a name="ln6648">      } else {</a>
<a name="ln6649">        VIsual_mode = curbuf-&gt;b_visual.vi_mode;</a>
<a name="ln6650">        curwin-&gt;w_curswant = curbuf-&gt;b_visual.vi_curswant;</a>
<a name="ln6651">        tpos = curbuf-&gt;b_visual.vi_end;</a>
<a name="ln6652">        curwin-&gt;w_cursor = curbuf-&gt;b_visual.vi_start;</a>
<a name="ln6653">      }</a>
<a name="ln6654"> </a>
<a name="ln6655">      VIsual_active = true;</a>
<a name="ln6656">      VIsual_reselect = true;</a>
<a name="ln6657"> </a>
<a name="ln6658">      /* Set Visual to the start and w_cursor to the end of the Visual</a>
<a name="ln6659">       * area.  Make sure they are on an existing character. */</a>
<a name="ln6660">      check_cursor();</a>
<a name="ln6661">      VIsual = curwin-&gt;w_cursor;</a>
<a name="ln6662">      curwin-&gt;w_cursor = tpos;</a>
<a name="ln6663">      check_cursor();</a>
<a name="ln6664">      update_topline(curwin);</a>
<a name="ln6665">      // When called from normal &quot;g&quot; command: start Select mode when</a>
<a name="ln6666">      // 'selectmode' contains &quot;cmd&quot;.  When called for K_SELECT, always</a>
<a name="ln6667">      // start Select mode.</a>
<a name="ln6668">      if (cap-&gt;arg) {</a>
<a name="ln6669">        VIsual_select = true;</a>
<a name="ln6670">      } else {</a>
<a name="ln6671">        may_start_select('c');</a>
<a name="ln6672">      }</a>
<a name="ln6673">      setmouse();</a>
<a name="ln6674">      redraw_curbuf_later(INVERTED);</a>
<a name="ln6675">      showmode();</a>
<a name="ln6676">    }</a>
<a name="ln6677">    break;</a>
<a name="ln6678">  /*</a>
<a name="ln6679">   * &quot;gV&quot;: Don't reselect the previous Visual area after a Select mode</a>
<a name="ln6680">   *	     mapping of menu.</a>
<a name="ln6681">   */</a>
<a name="ln6682">  case 'V':</a>
<a name="ln6683">    VIsual_reselect = false;</a>
<a name="ln6684">    break;</a>
<a name="ln6685"> </a>
<a name="ln6686">  /*</a>
<a name="ln6687">   * &quot;gh&quot;:  start Select mode.</a>
<a name="ln6688">   * &quot;gH&quot;:  start Select line mode.</a>
<a name="ln6689">   * &quot;g^H&quot;: start Select block mode.</a>
<a name="ln6690">   */</a>
<a name="ln6691">  case K_BS:</a>
<a name="ln6692">    cap-&gt;nchar = Ctrl_H;</a>
<a name="ln6693">    FALLTHROUGH;</a>
<a name="ln6694">  case 'h':</a>
<a name="ln6695">  case 'H':</a>
<a name="ln6696">  case Ctrl_H:</a>
<a name="ln6697">    cap-&gt;cmdchar = cap-&gt;nchar + ('v' - 'h');</a>
<a name="ln6698">    cap-&gt;arg = true;</a>
<a name="ln6699">    nv_visual(cap);</a>
<a name="ln6700">    break;</a>
<a name="ln6701"> </a>
<a name="ln6702">  /* &quot;gn&quot;, &quot;gN&quot; visually select next/previous search match</a>
<a name="ln6703">   * &quot;gn&quot; selects next match</a>
<a name="ln6704">   * &quot;gN&quot; selects previous match</a>
<a name="ln6705">   */</a>
<a name="ln6706">  case 'N':</a>
<a name="ln6707">  case 'n':</a>
<a name="ln6708">    if (!current_search(cap-&gt;count1, cap-&gt;nchar == 'n'))</a>
<a name="ln6709">      clearopbeep(oap);</a>
<a name="ln6710">    break;</a>
<a name="ln6711"> </a>
<a name="ln6712">  /*</a>
<a name="ln6713">   * &quot;gj&quot; and &quot;gk&quot; two new funny movement keys -- up and down</a>
<a name="ln6714">   * movement based on *screen* line rather than *file* line.</a>
<a name="ln6715">   */</a>
<a name="ln6716">  case 'j':</a>
<a name="ln6717">  case K_DOWN:</a>
<a name="ln6718">    // with 'nowrap' it works just like the normal &quot;j&quot; command.</a>
<a name="ln6719">    if (!curwin-&gt;w_p_wrap) {</a>
<a name="ln6720">      oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln6721">      i = cursor_down(cap-&gt;count1, oap-&gt;op_type == OP_NOP);</a>
<a name="ln6722">    } else</a>
<a name="ln6723">      i = nv_screengo(oap, FORWARD, cap-&gt;count1);</a>
<a name="ln6724">    if (!i)</a>
<a name="ln6725">      clearopbeep(oap);</a>
<a name="ln6726">    break;</a>
<a name="ln6727"> </a>
<a name="ln6728">  case 'k':</a>
<a name="ln6729">  case K_UP:</a>
<a name="ln6730">    // with 'nowrap' it works just like the normal &quot;k&quot; command.</a>
<a name="ln6731">    if (!curwin-&gt;w_p_wrap) {</a>
<a name="ln6732">      oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln6733">      i = cursor_up(cap-&gt;count1, oap-&gt;op_type == OP_NOP);</a>
<a name="ln6734">    } else</a>
<a name="ln6735">      i = nv_screengo(oap, BACKWARD, cap-&gt;count1);</a>
<a name="ln6736">    if (!i)</a>
<a name="ln6737">      clearopbeep(oap);</a>
<a name="ln6738">    break;</a>
<a name="ln6739"> </a>
<a name="ln6740">  /*</a>
<a name="ln6741">   * &quot;gJ&quot;: join two lines without inserting a space.</a>
<a name="ln6742">   */</a>
<a name="ln6743">  case 'J':</a>
<a name="ln6744">    nv_join(cap);</a>
<a name="ln6745">    break;</a>
<a name="ln6746"> </a>
<a name="ln6747">  /*</a>
<a name="ln6748">   * &quot;g0&quot;, &quot;g^&quot; and &quot;g$&quot;: Like &quot;0&quot;, &quot;^&quot; and &quot;$&quot; but for screen lines.</a>
<a name="ln6749">   * &quot;gm&quot;: middle of &quot;g0&quot; and &quot;g$&quot;.</a>
<a name="ln6750">   */</a>
<a name="ln6751">  case '^':</a>
<a name="ln6752">    flag = true;</a>
<a name="ln6753">    FALLTHROUGH;</a>
<a name="ln6754"> </a>
<a name="ln6755">  case '0':</a>
<a name="ln6756">  case 'm':</a>
<a name="ln6757">  case K_HOME:</a>
<a name="ln6758">  case K_KHOME:</a>
<a name="ln6759">    oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln6760">    oap-&gt;inclusive = false;</a>
<a name="ln6761">    if (curwin-&gt;w_p_wrap</a>
<a name="ln6762">        &amp;&amp; curwin-&gt;w_width_inner != 0</a>
<a name="ln6763">        ) {</a>
<a name="ln6764">      int width1 = curwin-&gt;w_width_inner - curwin_col_off();</a>
<a name="ln6765">      int width2 = width1 + curwin_col_off2();</a>
<a name="ln6766"> </a>
<a name="ln6767">      validate_virtcol();</a>
<a name="ln6768">      i = 0;</a>
<a name="ln6769">      if (curwin-&gt;w_virtcol &gt;= (colnr_T)width1 &amp;&amp; width2 &gt; 0)</a>
<a name="ln6770">        i = (curwin-&gt;w_virtcol - width1) / width2 * width2 + width1;</a>
<a name="ln6771">    } else</a>
<a name="ln6772">      i = curwin-&gt;w_leftcol;</a>
<a name="ln6773">    /* Go to the middle of the screen line.  When 'number' or</a>
<a name="ln6774">     * 'relativenumber' is on and lines are wrapping the middle can be more</a>
<a name="ln6775">     * to the left. */</a>
<a name="ln6776">    if (cap-&gt;nchar == 'm') {</a>
<a name="ln6777">      i += (curwin-&gt;w_width_inner - curwin_col_off()</a>
<a name="ln6778">            + ((curwin-&gt;w_p_wrap &amp;&amp; i &gt; 0)</a>
<a name="ln6779">               ? curwin_col_off2() : 0)) / 2;</a>
<a name="ln6780">    }</a>
<a name="ln6781">    coladvance((colnr_T)i);</a>
<a name="ln6782">    if (flag) {</a>
<a name="ln6783">      do {</a>
<a name="ln6784">        i = gchar_cursor();</a>
<a name="ln6785">      } while (ascii_iswhite(i) &amp;&amp; oneright());</a>
<a name="ln6786">      curwin-&gt;w_valid &amp;= ~VALID_WCOL;</a>
<a name="ln6787">    }</a>
<a name="ln6788">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln6789">    break;</a>
<a name="ln6790"> </a>
<a name="ln6791">  case 'M':</a>
<a name="ln6792">    {</a>
<a name="ln6793">      const char_u *const ptr = get_cursor_line_ptr();</a>
<a name="ln6794"> </a>
<a name="ln6795">      oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln6796">      oap-&gt;inclusive = false;</a>
<a name="ln6797">      i = (int)mb_string2cells_len(ptr, STRLEN(ptr));</a>
<a name="ln6798">      if (cap-&gt;count0 &gt; 0 &amp;&amp; cap-&gt;count0 &lt;= 100) {</a>
<a name="ln6799">        coladvance((colnr_T)(i * cap-&gt;count0 / 100));</a>
<a name="ln6800">      } else {</a>
<a name="ln6801">        coladvance((colnr_T)(i / 2));</a>
<a name="ln6802">      }</a>
<a name="ln6803">      curwin-&gt;w_set_curswant = true;</a>
<a name="ln6804">    }</a>
<a name="ln6805">    break;</a>
<a name="ln6806"> </a>
<a name="ln6807">  case '_':</a>
<a name="ln6808">    /* &quot;g_&quot;: to the last non-blank character in the line or &lt;count&gt; lines</a>
<a name="ln6809">     * downward. */</a>
<a name="ln6810">    cap-&gt;oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln6811">    cap-&gt;oap-&gt;inclusive = true;</a>
<a name="ln6812">    curwin-&gt;w_curswant = MAXCOL;</a>
<a name="ln6813">    if (cursor_down(cap-&gt;count1 - 1,</a>
<a name="ln6814">            cap-&gt;oap-&gt;op_type == OP_NOP) == false)</a>
<a name="ln6815">      clearopbeep(cap-&gt;oap);</a>
<a name="ln6816">    else {</a>
<a name="ln6817">      char_u  *ptr = get_cursor_line_ptr();</a>
<a name="ln6818"> </a>
<a name="ln6819">      /* In Visual mode we may end up after the line. */</a>
<a name="ln6820">      if (curwin-&gt;w_cursor.col &gt; 0 &amp;&amp; ptr[curwin-&gt;w_cursor.col] == NUL)</a>
<a name="ln6821">        --curwin-&gt;w_cursor.col;</a>
<a name="ln6822"> </a>
<a name="ln6823">      /* Decrease the cursor column until it's on a non-blank. */</a>
<a name="ln6824">      while (curwin-&gt;w_cursor.col &gt; 0</a>
<a name="ln6825">             &amp;&amp; ascii_iswhite(ptr[curwin-&gt;w_cursor.col]))</a>
<a name="ln6826">        --curwin-&gt;w_cursor.col;</a>
<a name="ln6827">      curwin-&gt;w_set_curswant = true;</a>
<a name="ln6828">      adjust_for_sel(cap);</a>
<a name="ln6829">    }</a>
<a name="ln6830">    break;</a>
<a name="ln6831"> </a>
<a name="ln6832">  case '$':</a>
<a name="ln6833">  case K_END:</a>
<a name="ln6834">  case K_KEND:</a>
<a name="ln6835">  {</a>
<a name="ln6836">    int col_off = curwin_col_off();</a>
<a name="ln6837"> </a>
<a name="ln6838">    oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln6839">    oap-&gt;inclusive = true;</a>
<a name="ln6840">    if (curwin-&gt;w_p_wrap</a>
<a name="ln6841">        &amp;&amp; curwin-&gt;w_width_inner != 0</a>
<a name="ln6842">        ) {</a>
<a name="ln6843">      curwin-&gt;w_curswant = MAXCOL;              /* so we stay at the end */</a>
<a name="ln6844">      if (cap-&gt;count1 == 1) {</a>
<a name="ln6845">        int width1 = curwin-&gt;w_width_inner - col_off;</a>
<a name="ln6846">        int width2 = width1 + curwin_col_off2();</a>
<a name="ln6847"> </a>
<a name="ln6848">        validate_virtcol();</a>
<a name="ln6849">        i = width1 - 1;</a>
<a name="ln6850">        if (curwin-&gt;w_virtcol &gt;= (colnr_T)width1)</a>
<a name="ln6851">          i += ((curwin-&gt;w_virtcol - width1) / width2 + 1)</a>
<a name="ln6852">               * width2;</a>
<a name="ln6853">        coladvance((colnr_T)i);</a>
<a name="ln6854"> </a>
<a name="ln6855">        /* Make sure we stick in this column. */</a>
<a name="ln6856">        validate_virtcol();</a>
<a name="ln6857">        curwin-&gt;w_curswant = curwin-&gt;w_virtcol;</a>
<a name="ln6858">        curwin-&gt;w_set_curswant = false;</a>
<a name="ln6859">        if (curwin-&gt;w_cursor.col &gt; 0 &amp;&amp; curwin-&gt;w_p_wrap) {</a>
<a name="ln6860">          /*</a>
<a name="ln6861">           * Check for landing on a character that got split at</a>
<a name="ln6862">           * the end of the line.  We do not want to advance to</a>
<a name="ln6863">           * the next screen line.</a>
<a name="ln6864">           */</a>
<a name="ln6865">          if (curwin-&gt;w_virtcol &gt; (colnr_T)i)</a>
<a name="ln6866">            --curwin-&gt;w_cursor.col;</a>
<a name="ln6867">        }</a>
<a name="ln6868">      } else if (nv_screengo(oap, FORWARD, cap-&gt;count1 - 1) == false)</a>
<a name="ln6869">        clearopbeep(oap);</a>
<a name="ln6870">    } else {</a>
<a name="ln6871">      if (cap-&gt;count1 &gt; 1) {</a>
<a name="ln6872">        // if it fails, let the cursor still move to the last char</a>
<a name="ln6873">        (void)cursor_down(cap-&gt;count1 - 1, false);</a>
<a name="ln6874">      }</a>
<a name="ln6875">      i = curwin-&gt;w_leftcol + curwin-&gt;w_width_inner - col_off - 1;</a>
<a name="ln6876">      coladvance((colnr_T)i);</a>
<a name="ln6877"> </a>
<a name="ln6878">      // Make sure we stick in this column.</a>
<a name="ln6879">      validate_virtcol();</a>
<a name="ln6880">      curwin-&gt;w_curswant = curwin-&gt;w_virtcol;</a>
<a name="ln6881">      curwin-&gt;w_set_curswant = false;</a>
<a name="ln6882">    }</a>
<a name="ln6883">  }</a>
<a name="ln6884">  break;</a>
<a name="ln6885"> </a>
<a name="ln6886">  /*</a>
<a name="ln6887">   * &quot;g*&quot; and &quot;g#&quot;, like &quot;*&quot; and &quot;#&quot; but without using &quot;\&lt;&quot; and &quot;\&gt;&quot;</a>
<a name="ln6888">   */</a>
<a name="ln6889">  case '*':</a>
<a name="ln6890">  case '#':</a>
<a name="ln6891">#if POUND != '#'</a>
<a name="ln6892">  case POUND:           /* pound sign (sometimes equal to '#') */</a>
<a name="ln6893">#endif</a>
<a name="ln6894">  case Ctrl_RSB:                /* :tag or :tselect for current identifier */</a>
<a name="ln6895">  case ']':                     /* :tselect for current identifier */</a>
<a name="ln6896">    nv_ident(cap);</a>
<a name="ln6897">    break;</a>
<a name="ln6898"> </a>
<a name="ln6899">  /*</a>
<a name="ln6900">   * ge and gE: go back to end of word</a>
<a name="ln6901">   */</a>
<a name="ln6902">  case 'e':</a>
<a name="ln6903">  case 'E':</a>
<a name="ln6904">    oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln6905">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln6906">    oap-&gt;inclusive = true;</a>
<a name="ln6907">    if (bckend_word(cap-&gt;count1, cap-&gt;nchar == 'E', false) == false)</a>
<a name="ln6908">      clearopbeep(oap);</a>
<a name="ln6909">    break;</a>
<a name="ln6910"> </a>
<a name="ln6911">  // &quot;g CTRL-G&quot;: display info about cursor position</a>
<a name="ln6912">  case Ctrl_G:</a>
<a name="ln6913">    cursor_pos_info(NULL);</a>
<a name="ln6914">    break;</a>
<a name="ln6915"> </a>
<a name="ln6916">  // &quot;gi&quot;: start Insert at the last position.</a>
<a name="ln6917">  case 'i':</a>
<a name="ln6918">    if (curbuf-&gt;b_last_insert.mark.lnum != 0) {</a>
<a name="ln6919">      curwin-&gt;w_cursor = curbuf-&gt;b_last_insert.mark;</a>
<a name="ln6920">      check_cursor_lnum();</a>
<a name="ln6921">      i = (int)STRLEN(get_cursor_line_ptr());</a>
<a name="ln6922">      if (curwin-&gt;w_cursor.col &gt; (colnr_T)i) {</a>
<a name="ln6923">        if (virtual_active())</a>
<a name="ln6924">          curwin-&gt;w_cursor.coladd += curwin-&gt;w_cursor.col - i;</a>
<a name="ln6925">        curwin-&gt;w_cursor.col = i;</a>
<a name="ln6926">      }</a>
<a name="ln6927">    }</a>
<a name="ln6928">    cap-&gt;cmdchar = 'i';</a>
<a name="ln6929">    nv_edit(cap);</a>
<a name="ln6930">    break;</a>
<a name="ln6931"> </a>
<a name="ln6932">  /*</a>
<a name="ln6933">   * &quot;gI&quot;: Start insert in column 1.</a>
<a name="ln6934">   */</a>
<a name="ln6935">  case 'I':</a>
<a name="ln6936">    beginline(0);</a>
<a name="ln6937">    if (!checkclearopq(oap))</a>
<a name="ln6938">      invoke_edit(cap, false, 'g', false);</a>
<a name="ln6939">    break;</a>
<a name="ln6940"> </a>
<a name="ln6941">  /*</a>
<a name="ln6942">   * &quot;gf&quot;: goto file, edit file under cursor</a>
<a name="ln6943">   * &quot;]f&quot; and &quot;[f&quot;: can also be used.</a>
<a name="ln6944">   */</a>
<a name="ln6945">  case 'f':</a>
<a name="ln6946">  case 'F':</a>
<a name="ln6947">    nv_gotofile(cap);</a>
<a name="ln6948">    break;</a>
<a name="ln6949"> </a>
<a name="ln6950">  /* &quot;g'm&quot; and &quot;g`m&quot;: jump to mark without setting pcmark */</a>
<a name="ln6951">  case '\'':</a>
<a name="ln6952">    cap-&gt;arg = true;</a>
<a name="ln6953">    FALLTHROUGH;</a>
<a name="ln6954">  case '`':</a>
<a name="ln6955">    nv_gomark(cap);</a>
<a name="ln6956">    break;</a>
<a name="ln6957"> </a>
<a name="ln6958">  /*</a>
<a name="ln6959">   * &quot;gs&quot;: Goto sleep.</a>
<a name="ln6960">   */</a>
<a name="ln6961">  case 's':</a>
<a name="ln6962">    do_sleep(cap-&gt;count1 * 1000L);</a>
<a name="ln6963">    break;</a>
<a name="ln6964"> </a>
<a name="ln6965">  /*</a>
<a name="ln6966">   * &quot;ga&quot;: Display the ascii value of the character under the</a>
<a name="ln6967">   * cursor.	It is displayed in decimal, hex, and octal. -- webb</a>
<a name="ln6968">   */</a>
<a name="ln6969">  case 'a':</a>
<a name="ln6970">    do_ascii(NULL);</a>
<a name="ln6971">    break;</a>
<a name="ln6972"> </a>
<a name="ln6973">  /*</a>
<a name="ln6974">   * &quot;g8&quot;: Display the bytes used for the UTF-8 character under the</a>
<a name="ln6975">   * cursor.	It is displayed in hex.</a>
<a name="ln6976">   * &quot;8g8&quot; finds illegal byte sequence.</a>
<a name="ln6977">   */</a>
<a name="ln6978">  case '8':</a>
<a name="ln6979">    if (cap-&gt;count0 == 8)</a>
<a name="ln6980">      utf_find_illegal();</a>
<a name="ln6981">    else</a>
<a name="ln6982">      show_utf8();</a>
<a name="ln6983">    break;</a>
<a name="ln6984">  // &quot;g&lt;&quot;: show scrollback text</a>
<a name="ln6985">  case '&lt;':</a>
<a name="ln6986">    show_sb_text();</a>
<a name="ln6987">    break;</a>
<a name="ln6988"> </a>
<a name="ln6989">  /*</a>
<a name="ln6990">   * &quot;gg&quot;: Goto the first line in file.  With a count it goes to</a>
<a name="ln6991">   * that line number like for &quot;G&quot;. -- webb</a>
<a name="ln6992">   */</a>
<a name="ln6993">  case 'g':</a>
<a name="ln6994">    cap-&gt;arg = false;</a>
<a name="ln6995">    nv_goto(cap);</a>
<a name="ln6996">    break;</a>
<a name="ln6997"> </a>
<a name="ln6998">  /*</a>
<a name="ln6999">   *	 Two-character operators:</a>
<a name="ln7000">   *	 &quot;gq&quot;	    Format text</a>
<a name="ln7001">   *	 &quot;gw&quot;	    Format text and keep cursor position</a>
<a name="ln7002">   *	 &quot;g~&quot;	    Toggle the case of the text.</a>
<a name="ln7003">   *	 &quot;gu&quot;	    Change text to lower case.</a>
<a name="ln7004">   *	 &quot;gU&quot;	    Change text to upper case.</a>
<a name="ln7005">   *   &quot;g?&quot;	    rot13 encoding</a>
<a name="ln7006">   *   &quot;g@&quot;	    call 'operatorfunc'</a>
<a name="ln7007">   */</a>
<a name="ln7008">  case 'q':</a>
<a name="ln7009">  case 'w':</a>
<a name="ln7010">    oap-&gt;cursor_start = curwin-&gt;w_cursor;</a>
<a name="ln7011">    FALLTHROUGH;</a>
<a name="ln7012">  case '~':</a>
<a name="ln7013">  case 'u':</a>
<a name="ln7014">  case 'U':</a>
<a name="ln7015">  case '?':</a>
<a name="ln7016">  case '@':</a>
<a name="ln7017">    nv_operator(cap);</a>
<a name="ln7018">    break;</a>
<a name="ln7019"> </a>
<a name="ln7020">  /*</a>
<a name="ln7021">   * &quot;gd&quot;: Find first occurrence of pattern under the cursor in the</a>
<a name="ln7022">   *	 current function</a>
<a name="ln7023">   * &quot;gD&quot;: idem, but in the current file.</a>
<a name="ln7024">   */</a>
<a name="ln7025">  case 'd':</a>
<a name="ln7026">  case 'D':</a>
<a name="ln7027">    nv_gd(oap, cap-&gt;nchar, (int)cap-&gt;count0);</a>
<a name="ln7028">    break;</a>
<a name="ln7029"> </a>
<a name="ln7030">  /*</a>
<a name="ln7031">   * g&lt;*Mouse&gt; : &lt;C-*mouse&gt;</a>
<a name="ln7032">   */</a>
<a name="ln7033">  case K_MIDDLEMOUSE:</a>
<a name="ln7034">  case K_MIDDLEDRAG:</a>
<a name="ln7035">  case K_MIDDLERELEASE:</a>
<a name="ln7036">  case K_LEFTMOUSE:</a>
<a name="ln7037">  case K_LEFTDRAG:</a>
<a name="ln7038">  case K_LEFTRELEASE:</a>
<a name="ln7039">  case K_RIGHTMOUSE:</a>
<a name="ln7040">  case K_RIGHTDRAG:</a>
<a name="ln7041">  case K_RIGHTRELEASE:</a>
<a name="ln7042">  case K_X1MOUSE:</a>
<a name="ln7043">  case K_X1DRAG:</a>
<a name="ln7044">  case K_X1RELEASE:</a>
<a name="ln7045">  case K_X2MOUSE:</a>
<a name="ln7046">  case K_X2DRAG:</a>
<a name="ln7047">  case K_X2RELEASE:</a>
<a name="ln7048">    mod_mask = MOD_MASK_CTRL;</a>
<a name="ln7049">    (void)do_mouse(oap, cap-&gt;nchar, BACKWARD, cap-&gt;count1, 0);</a>
<a name="ln7050">    break;</a>
<a name="ln7051"> </a>
<a name="ln7052">  case K_IGNORE:</a>
<a name="ln7053">    break;</a>
<a name="ln7054"> </a>
<a name="ln7055">  /*</a>
<a name="ln7056">   * &quot;gP&quot; and &quot;gp&quot;: same as &quot;P&quot; and &quot;p&quot; but leave cursor just after new text</a>
<a name="ln7057">   */</a>
<a name="ln7058">  case 'p':</a>
<a name="ln7059">  case 'P':</a>
<a name="ln7060">    nv_put(cap);</a>
<a name="ln7061">    break;</a>
<a name="ln7062"> </a>
<a name="ln7063">  /* &quot;go&quot;: goto byte count from start of buffer */</a>
<a name="ln7064">  case 'o':</a>
<a name="ln7065">    goto_byte(cap-&gt;count0);</a>
<a name="ln7066">    break;</a>
<a name="ln7067"> </a>
<a name="ln7068">  /* &quot;gQ&quot;: improved Ex mode */</a>
<a name="ln7069">  case 'Q':</a>
<a name="ln7070">    if (text_locked()) {</a>
<a name="ln7071">      clearopbeep(cap-&gt;oap);</a>
<a name="ln7072">      text_locked_msg();</a>
<a name="ln7073">      break;</a>
<a name="ln7074">    }</a>
<a name="ln7075"> </a>
<a name="ln7076">    if (!checkclearopq(oap))</a>
<a name="ln7077">      do_exmode(true);</a>
<a name="ln7078">    break;</a>
<a name="ln7079"> </a>
<a name="ln7080">  case ',':</a>
<a name="ln7081">    nv_pcmark(cap);</a>
<a name="ln7082">    break;</a>
<a name="ln7083"> </a>
<a name="ln7084">  case ';':</a>
<a name="ln7085">    cap-&gt;count1 = -cap-&gt;count1;</a>
<a name="ln7086">    nv_pcmark(cap);</a>
<a name="ln7087">    break;</a>
<a name="ln7088"> </a>
<a name="ln7089">  case 't':</a>
<a name="ln7090">    if (!checkclearop(oap))</a>
<a name="ln7091">      goto_tabpage((int)cap-&gt;count0);</a>
<a name="ln7092">    break;</a>
<a name="ln7093">  case 'T':</a>
<a name="ln7094">    if (!checkclearop(oap))</a>
<a name="ln7095">      goto_tabpage(-(int)cap-&gt;count1);</a>
<a name="ln7096">    break;</a>
<a name="ln7097">  case TAB:</a>
<a name="ln7098">    if (!checkclearop(oap)) {</a>
<a name="ln7099">      goto_tabpage_lastused();</a>
<a name="ln7100">    }</a>
<a name="ln7101">    break;</a>
<a name="ln7102"> </a>
<a name="ln7103">  case '+':</a>
<a name="ln7104">  case '-':   /* &quot;g+&quot; and &quot;g-&quot;: undo or redo along the timeline */</a>
<a name="ln7105">    if (!checkclearopq(oap))</a>
<a name="ln7106">      undo_time(cap-&gt;nchar == '-' ? -cap-&gt;count1 : cap-&gt;count1,</a>
<a name="ln7107">          false, false, false);</a>
<a name="ln7108">    break;</a>
<a name="ln7109"> </a>
<a name="ln7110">  default:</a>
<a name="ln7111">    clearopbeep(oap);</a>
<a name="ln7112">    break;</a>
<a name="ln7113">  }</a>
<a name="ln7114">}</a>
<a name="ln7115"> </a>
<a name="ln7116">/*</a>
<a name="ln7117"> * Handle &quot;o&quot; and &quot;O&quot; commands.</a>
<a name="ln7118"> */</a>
<a name="ln7119">static void n_opencmd(cmdarg_T *cap)</a>
<a name="ln7120">{</a>
<a name="ln7121">  if (!checkclearopq(cap-&gt;oap)) {</a>
<a name="ln7122">    if (cap-&gt;cmdchar == 'O')</a>
<a name="ln7123">      /* Open above the first line of a folded sequence of lines */</a>
<a name="ln7124">      (void)hasFolding(curwin-&gt;w_cursor.lnum,</a>
<a name="ln7125">          &amp;curwin-&gt;w_cursor.lnum, NULL);</a>
<a name="ln7126">    else</a>
<a name="ln7127">      /* Open below the last line of a folded sequence of lines */</a>
<a name="ln7128">      (void)hasFolding(curwin-&gt;w_cursor.lnum,</a>
<a name="ln7129">          NULL, &amp;curwin-&gt;w_cursor.lnum);</a>
<a name="ln7130">    if (u_save((linenr_T)(curwin-&gt;w_cursor.lnum -</a>
<a name="ln7131">                          (cap-&gt;cmdchar == 'O' ? 1 : 0)),</a>
<a name="ln7132">            (linenr_T)(curwin-&gt;w_cursor.lnum +</a>
<a name="ln7133">                       (cap-&gt;cmdchar == 'o' ? 1 : 0))</a>
<a name="ln7134">            )</a>
<a name="ln7135">        &amp;&amp; open_line(cap-&gt;cmdchar == 'O' ? BACKWARD : FORWARD,</a>
<a name="ln7136">                     has_format_option(FO_OPEN_COMS)</a>
<a name="ln7137">                     ? OPENLINE_DO_COM : 0,</a>
<a name="ln7138">                     0)) {</a>
<a name="ln7139">      if (win_cursorline_standout(curwin)) {</a>
<a name="ln7140">        // force redraw of cursorline</a>
<a name="ln7141">        curwin-&gt;w_valid &amp;= ~VALID_CROW;</a>
<a name="ln7142">      }</a>
<a name="ln7143">      invoke_edit(cap, false, cap-&gt;cmdchar, true);</a>
<a name="ln7144">    }</a>
<a name="ln7145">  }</a>
<a name="ln7146">}</a>
<a name="ln7147"> </a>
<a name="ln7148">/*</a>
<a name="ln7149"> * &quot;.&quot; command: redo last change.</a>
<a name="ln7150"> */</a>
<a name="ln7151">static void nv_dot(cmdarg_T *cap)</a>
<a name="ln7152">{</a>
<a name="ln7153">  if (!checkclearopq(cap-&gt;oap)) {</a>
<a name="ln7154">    /*</a>
<a name="ln7155">     * If &quot;restart_edit&quot; is true, the last but one command is repeated</a>
<a name="ln7156">     * instead of the last command (inserting text). This is used for</a>
<a name="ln7157">     * CTRL-O &lt;.&gt; in insert mode.</a>
<a name="ln7158">     */</a>
<a name="ln7159">    if (start_redo(cap-&gt;count0, restart_edit != 0 &amp;&amp; !arrow_used) == false)</a>
<a name="ln7160">      clearopbeep(cap-&gt;oap);</a>
<a name="ln7161">  }</a>
<a name="ln7162">}</a>
<a name="ln7163"> </a>
<a name="ln7164">/*</a>
<a name="ln7165"> * CTRL-R: undo undo</a>
<a name="ln7166"> */</a>
<a name="ln7167">static void nv_redo(cmdarg_T *cap)</a>
<a name="ln7168">{</a>
<a name="ln7169">  if (!checkclearopq(cap-&gt;oap)) {</a>
<a name="ln7170">    u_redo((int)cap-&gt;count1);</a>
<a name="ln7171">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln7172">  }</a>
<a name="ln7173">}</a>
<a name="ln7174"> </a>
<a name="ln7175">/*</a>
<a name="ln7176"> * Handle &quot;U&quot; command.</a>
<a name="ln7177"> */</a>
<a name="ln7178">static void nv_Undo(cmdarg_T *cap)</a>
<a name="ln7179">{</a>
<a name="ln7180">  /* In Visual mode and typing &quot;gUU&quot; triggers an operator */</a>
<a name="ln7181">  if (cap-&gt;oap-&gt;op_type == OP_UPPER</a>
<a name="ln7182">      || VIsual_active</a>
<a name="ln7183">      ) {</a>
<a name="ln7184">    /* translate &quot;gUU&quot; to &quot;gUgU&quot; */</a>
<a name="ln7185">    cap-&gt;cmdchar = 'g';</a>
<a name="ln7186">    cap-&gt;nchar = 'U';</a>
<a name="ln7187">    nv_operator(cap);</a>
<a name="ln7188">  } else if (!checkclearopq(cap-&gt;oap)) {</a>
<a name="ln7189">    u_undoline();</a>
<a name="ln7190">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln7191">  }</a>
<a name="ln7192">}</a>
<a name="ln7193"> </a>
<a name="ln7194">/*</a>
<a name="ln7195"> * '~' command: If tilde is not an operator and Visual is off: swap case of a</a>
<a name="ln7196"> * single character.</a>
<a name="ln7197"> */</a>
<a name="ln7198">static void nv_tilde(cmdarg_T *cap)</a>
<a name="ln7199">{</a>
<a name="ln7200">  if (!p_to</a>
<a name="ln7201">      &amp;&amp; !VIsual_active</a>
<a name="ln7202">      &amp;&amp; cap-&gt;oap-&gt;op_type != OP_TILDE) {</a>
<a name="ln7203">    if (bt_prompt(curbuf) &amp;&amp; !prompt_curpos_editable()) {</a>
<a name="ln7204">      clearopbeep(cap-&gt;oap);</a>
<a name="ln7205">      return;</a>
<a name="ln7206">    }</a>
<a name="ln7207">    n_swapchar(cap);</a>
<a name="ln7208">  } else {</a>
<a name="ln7209">    nv_operator(cap);</a>
<a name="ln7210">  }</a>
<a name="ln7211">}</a>
<a name="ln7212"> </a>
<a name="ln7213">/*</a>
<a name="ln7214"> * Handle an operator command.</a>
<a name="ln7215"> * The actual work is done by do_pending_operator().</a>
<a name="ln7216"> */</a>
<a name="ln7217">static void nv_operator(cmdarg_T *cap)</a>
<a name="ln7218">{</a>
<a name="ln7219">  int op_type;</a>
<a name="ln7220"> </a>
<a name="ln7221">  op_type = get_op_type(cap-&gt;cmdchar, cap-&gt;nchar);</a>
<a name="ln7222"> </a>
<a name="ln7223">  if (bt_prompt(curbuf) &amp;&amp; op_is_change(op_type)</a>
<a name="ln7224">      &amp;&amp; !prompt_curpos_editable()) {</a>
<a name="ln7225">    clearopbeep(cap-&gt;oap);</a>
<a name="ln7226">    return;</a>
<a name="ln7227">  }</a>
<a name="ln7228"> </a>
<a name="ln7229">  if (op_type == cap-&gt;oap-&gt;op_type)         /* double operator works on lines */</a>
<a name="ln7230">    nv_lineop(cap);</a>
<a name="ln7231">  else if (!checkclearop(cap-&gt;oap)) {</a>
<a name="ln7232">    cap-&gt;oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln7233">    cap-&gt;oap-&gt;op_type = op_type;</a>
<a name="ln7234">    set_op_var(op_type);</a>
<a name="ln7235">  }</a>
<a name="ln7236">}</a>
<a name="ln7237"> </a>
<a name="ln7238">/*</a>
<a name="ln7239"> * Set v:operator to the characters for &quot;optype&quot;.</a>
<a name="ln7240"> */</a>
<a name="ln7241">static void set_op_var(int optype)</a>
<a name="ln7242">{</a>
<a name="ln7243">  if (optype == OP_NOP) {</a>
<a name="ln7244">    set_vim_var_string(VV_OP, NULL, 0);</a>
<a name="ln7245">  } else {</a>
<a name="ln7246">    char opchars[3];</a>
<a name="ln7247">    int opchar0 = get_op_char(optype);</a>
<a name="ln7248">    assert(opchar0 &gt;= 0 &amp;&amp; opchar0 &lt;= UCHAR_MAX);</a>
<a name="ln7249">    opchars[0] = (char) opchar0;</a>
<a name="ln7250"> </a>
<a name="ln7251">    int opchar1 = get_extra_op_char(optype);</a>
<a name="ln7252">    assert(opchar1 &gt;= 0 &amp;&amp; opchar1 &lt;= UCHAR_MAX);</a>
<a name="ln7253">    opchars[1] = (char) opchar1;</a>
<a name="ln7254"> </a>
<a name="ln7255">    opchars[2] = NUL;</a>
<a name="ln7256">    set_vim_var_string(VV_OP, opchars, -1);</a>
<a name="ln7257">  }</a>
<a name="ln7258">}</a>
<a name="ln7259"> </a>
<a name="ln7260">/*</a>
<a name="ln7261"> * Handle linewise operator &quot;dd&quot;, &quot;yy&quot;, etc.</a>
<a name="ln7262"> *</a>
<a name="ln7263"> * &quot;_&quot; is is a strange motion command that helps make operators more logical.</a>
<a name="ln7264"> * It is actually implemented, but not documented in the real Vi.  This motion</a>
<a name="ln7265"> * command actually refers to &quot;the current line&quot;.  Commands like &quot;dd&quot; and &quot;yy&quot;</a>
<a name="ln7266"> * are really an alternate form of &quot;d_&quot; and &quot;y_&quot;.  It does accept a count, so</a>
<a name="ln7267"> * &quot;d3_&quot; works to delete 3 lines.</a>
<a name="ln7268"> */</a>
<a name="ln7269">static void nv_lineop(cmdarg_T *cap)</a>
<a name="ln7270">{</a>
<a name="ln7271">  cap-&gt;oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln7272">  if (cursor_down(cap-&gt;count1 - 1L, cap-&gt;oap-&gt;op_type == OP_NOP) == false) {</a>
<a name="ln7273">    clearopbeep(cap-&gt;oap);</a>
<a name="ln7274">  } else if ((cap-&gt;oap-&gt;op_type == OP_DELETE</a>
<a name="ln7275">              // only with linewise motions</a>
<a name="ln7276">              &amp;&amp; cap-&gt;oap-&gt;motion_force != 'v'</a>
<a name="ln7277">              &amp;&amp; cap-&gt;oap-&gt;motion_force != Ctrl_V)</a>
<a name="ln7278">             || cap-&gt;oap-&gt;op_type == OP_LSHIFT</a>
<a name="ln7279">             || cap-&gt;oap-&gt;op_type == OP_RSHIFT) {</a>
<a name="ln7280">    beginline(BL_SOL | BL_FIX);</a>
<a name="ln7281">  } else if (cap-&gt;oap-&gt;op_type != OP_YANK) {  // 'Y' does not move cursor</a>
<a name="ln7282">    beginline(BL_WHITE | BL_FIX);</a>
<a name="ln7283">  }</a>
<a name="ln7284">}</a>
<a name="ln7285"> </a>
<a name="ln7286">/*</a>
<a name="ln7287"> * &lt;Home&gt; command.</a>
<a name="ln7288"> */</a>
<a name="ln7289">static void nv_home(cmdarg_T *cap)</a>
<a name="ln7290">{</a>
<a name="ln7291">  /* CTRL-HOME is like &quot;gg&quot; */</a>
<a name="ln7292">  if (mod_mask &amp; MOD_MASK_CTRL)</a>
<a name="ln7293">    nv_goto(cap);</a>
<a name="ln7294">  else {</a>
<a name="ln7295">    cap-&gt;count0 = 1;</a>
<a name="ln7296">    nv_pipe(cap);</a>
<a name="ln7297">  }</a>
<a name="ln7298">  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a</a>
<a name="ln7299">                               one-character line). */</a>
<a name="ln7300">}</a>
<a name="ln7301"> </a>
<a name="ln7302">/*</a>
<a name="ln7303"> * &quot;|&quot; command.</a>
<a name="ln7304"> */</a>
<a name="ln7305">static void nv_pipe(cmdarg_T *cap)</a>
<a name="ln7306">{</a>
<a name="ln7307">  cap-&gt;oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln7308">  cap-&gt;oap-&gt;inclusive = false;</a>
<a name="ln7309">  beginline(0);</a>
<a name="ln7310">  if (cap-&gt;count0 &gt; 0) {</a>
<a name="ln7311">    coladvance((colnr_T)(cap-&gt;count0 - 1));</a>
<a name="ln7312">    curwin-&gt;w_curswant = (colnr_T)(cap-&gt;count0 - 1);</a>
<a name="ln7313">  } else</a>
<a name="ln7314">    curwin-&gt;w_curswant = 0;</a>
<a name="ln7315">  /* keep curswant at the column where we wanted to go, not where</a>
<a name="ln7316">   * we ended; differs if line is too short */</a>
<a name="ln7317">  curwin-&gt;w_set_curswant = false;</a>
<a name="ln7318">}</a>
<a name="ln7319"> </a>
<a name="ln7320">/*</a>
<a name="ln7321"> * Handle back-word command &quot;b&quot; and &quot;B&quot;.</a>
<a name="ln7322"> * cap-&gt;arg is 1 for &quot;B&quot;</a>
<a name="ln7323"> */</a>
<a name="ln7324">static void nv_bck_word(cmdarg_T *cap)</a>
<a name="ln7325">{</a>
<a name="ln7326">  cap-&gt;oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln7327">  cap-&gt;oap-&gt;inclusive = false;</a>
<a name="ln7328">  curwin-&gt;w_set_curswant = true;</a>
<a name="ln7329">  if (bck_word(cap-&gt;count1, cap-&gt;arg, false) == false)</a>
<a name="ln7330">    clearopbeep(cap-&gt;oap);</a>
<a name="ln7331">  else if ((fdo_flags &amp; FDO_HOR) &amp;&amp; KeyTyped &amp;&amp; cap-&gt;oap-&gt;op_type == OP_NOP)</a>
<a name="ln7332">    foldOpenCursor();</a>
<a name="ln7333">}</a>
<a name="ln7334"> </a>
<a name="ln7335">/*</a>
<a name="ln7336"> * Handle word motion commands &quot;e&quot;, &quot;E&quot;, &quot;w&quot; and &quot;W&quot;.</a>
<a name="ln7337"> * cap-&gt;arg is true for &quot;E&quot; and &quot;W&quot;.</a>
<a name="ln7338"> */</a>
<a name="ln7339">static void nv_wordcmd(cmdarg_T *cap)</a>
<a name="ln7340">{</a>
<a name="ln7341">  int n;</a>
<a name="ln7342">  bool word_end;</a>
<a name="ln7343">  bool flag = false;</a>
<a name="ln7344">  pos_T startpos = curwin-&gt;w_cursor;</a>
<a name="ln7345"> </a>
<a name="ln7346">  /*</a>
<a name="ln7347">   * Set inclusive for the &quot;E&quot; and &quot;e&quot; command.</a>
<a name="ln7348">   */</a>
<a name="ln7349">  if (cap-&gt;cmdchar == 'e' || cap-&gt;cmdchar == 'E')</a>
<a name="ln7350">    word_end = true;</a>
<a name="ln7351">  else</a>
<a name="ln7352">    word_end = false;</a>
<a name="ln7353">  cap-&gt;oap-&gt;inclusive = word_end;</a>
<a name="ln7354"> </a>
<a name="ln7355">  /*</a>
<a name="ln7356">   * &quot;cw&quot; and &quot;cW&quot; are a special case.</a>
<a name="ln7357">   */</a>
<a name="ln7358">  if (!word_end &amp;&amp; cap-&gt;oap-&gt;op_type == OP_CHANGE) {</a>
<a name="ln7359">    n = gchar_cursor();</a>
<a name="ln7360">    if (n != NUL &amp;&amp; !ascii_iswhite(n)) {</a>
<a name="ln7361">      // This is a little strange.  To match what the real Vi does, we</a>
<a name="ln7362">      // effectively map &quot;cw&quot; to &quot;ce&quot;, and &quot;cW&quot; to &quot;cE&quot;, provided that we are</a>
<a name="ln7363">      // not on a space or a TAB.  This seems impolite at first, but it's</a>
<a name="ln7364">      // really more what we mean when we say &quot;cw&quot;.</a>
<a name="ln7365">      //</a>
<a name="ln7366">      // Another strangeness: When standing on the end of a word &quot;ce&quot; will</a>
<a name="ln7367">      // change until the end of the next word, but &quot;cw&quot; will change only one</a>
<a name="ln7368">      // character!  This is done by setting &quot;flag&quot;.</a>
<a name="ln7369">      if (vim_strchr(p_cpo, CPO_CHANGEW) != NULL) {</a>
<a name="ln7370">        cap-&gt;oap-&gt;inclusive = true;</a>
<a name="ln7371">        word_end = true;</a>
<a name="ln7372">      }</a>
<a name="ln7373">      flag = true;</a>
<a name="ln7374">    }</a>
<a name="ln7375">  }</a>
<a name="ln7376"> </a>
<a name="ln7377">  cap-&gt;oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln7378">  curwin-&gt;w_set_curswant = true;</a>
<a name="ln7379">  if (word_end)</a>
<a name="ln7380">    n = end_word(cap-&gt;count1, cap-&gt;arg, flag, false);</a>
<a name="ln7381">  else</a>
<a name="ln7382">    n = fwd_word(cap-&gt;count1, cap-&gt;arg, cap-&gt;oap-&gt;op_type != OP_NOP);</a>
<a name="ln7383"> </a>
<a name="ln7384">  /* Don't leave the cursor on the NUL past the end of line. Unless we</a>
<a name="ln7385">   * didn't move it forward. */</a>
<a name="ln7386">  if (lt(startpos, curwin-&gt;w_cursor))</a>
<a name="ln7387">    adjust_cursor(cap-&gt;oap);</a>
<a name="ln7388"> </a>
<a name="ln7389">  if (n == false &amp;&amp; cap-&gt;oap-&gt;op_type == OP_NOP)</a>
<a name="ln7390">    clearopbeep(cap-&gt;oap);</a>
<a name="ln7391">  else {</a>
<a name="ln7392">    adjust_for_sel(cap);</a>
<a name="ln7393">    if ((fdo_flags &amp; FDO_HOR) &amp;&amp; KeyTyped &amp;&amp; cap-&gt;oap-&gt;op_type == OP_NOP)</a>
<a name="ln7394">      foldOpenCursor();</a>
<a name="ln7395">  }</a>
<a name="ln7396">}</a>
<a name="ln7397"> </a>
<a name="ln7398">/*</a>
<a name="ln7399"> * Used after a movement command: If the cursor ends up on the NUL after the</a>
<a name="ln7400"> * end of the line, may move it back to the last character and make the motion</a>
<a name="ln7401"> * inclusive.</a>
<a name="ln7402"> */</a>
<a name="ln7403">static void adjust_cursor(oparg_T *oap)</a>
<a name="ln7404">{</a>
<a name="ln7405">  /* The cursor cannot remain on the NUL when:</a>
<a name="ln7406">   * - the column is &gt; 0</a>
<a name="ln7407">   * - not in Visual mode or 'selection' is &quot;o&quot;</a>
<a name="ln7408">   * - 'virtualedit' is not &quot;all&quot; and not &quot;onemore&quot;.</a>
<a name="ln7409">   */</a>
<a name="ln7410">  if (curwin-&gt;w_cursor.col &gt; 0 &amp;&amp; gchar_cursor() == NUL</a>
<a name="ln7411">      &amp;&amp; (!VIsual_active || *p_sel == 'o')</a>
<a name="ln7412">      &amp;&amp; !virtual_active() &amp;&amp; (ve_flags &amp; VE_ONEMORE) == 0</a>
<a name="ln7413">      ) {</a>
<a name="ln7414">    curwin-&gt;w_cursor.col--;</a>
<a name="ln7415">    // prevent cursor from moving on the trail byte</a>
<a name="ln7416">    mb_adjust_cursor();</a>
<a name="ln7417">    oap-&gt;inclusive = true;</a>
<a name="ln7418">  }</a>
<a name="ln7419">}</a>
<a name="ln7420"> </a>
<a name="ln7421">/*</a>
<a name="ln7422"> * &quot;0&quot; and &quot;^&quot; commands.</a>
<a name="ln7423"> * cap-&gt;arg is the argument for beginline().</a>
<a name="ln7424"> */</a>
<a name="ln7425">static void nv_beginline(cmdarg_T *cap)</a>
<a name="ln7426">{</a>
<a name="ln7427">  cap-&gt;oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln7428">  cap-&gt;oap-&gt;inclusive = false;</a>
<a name="ln7429">  beginline(cap-&gt;arg);</a>
<a name="ln7430">  if ((fdo_flags &amp; FDO_HOR) &amp;&amp; KeyTyped &amp;&amp; cap-&gt;oap-&gt;op_type == OP_NOP)</a>
<a name="ln7431">    foldOpenCursor();</a>
<a name="ln7432">  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a</a>
<a name="ln7433">                               one-character line). */</a>
<a name="ln7434">}</a>
<a name="ln7435"> </a>
<a name="ln7436">/*</a>
<a name="ln7437"> * In exclusive Visual mode, may include the last character.</a>
<a name="ln7438"> */</a>
<a name="ln7439">static void adjust_for_sel(cmdarg_T *cap)</a>
<a name="ln7440">{</a>
<a name="ln7441">  if (VIsual_active &amp;&amp; cap-&gt;oap-&gt;inclusive &amp;&amp; *p_sel == 'e'</a>
<a name="ln7442">      &amp;&amp; gchar_cursor() != NUL &amp;&amp; lt(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln7443">    inc_cursor();</a>
<a name="ln7444">    cap-&gt;oap-&gt;inclusive = false;</a>
<a name="ln7445">  }</a>
<a name="ln7446">}</a>
<a name="ln7447"> </a>
<a name="ln7448">/*</a>
<a name="ln7449"> * Exclude last character at end of Visual area for 'selection' == &quot;exclusive&quot;.</a>
<a name="ln7450"> * Should check VIsual_mode before calling this.</a>
<a name="ln7451"> * Returns true when backed up to the previous line.</a>
<a name="ln7452"> */</a>
<a name="ln7453">static bool unadjust_for_sel(void)</a>
<a name="ln7454">{</a>
<a name="ln7455">  pos_T       *pp;</a>
<a name="ln7456"> </a>
<a name="ln7457">  if (*p_sel == 'e' &amp;&amp; !equalpos(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln7458">    if (lt(VIsual, curwin-&gt;w_cursor))</a>
<a name="ln7459">      pp = &amp;curwin-&gt;w_cursor;</a>
<a name="ln7460">    else</a>
<a name="ln7461">      pp = &amp;VIsual;</a>
<a name="ln7462">    if (pp-&gt;coladd &gt; 0) {</a>
<a name="ln7463">      pp-&gt;coladd--;</a>
<a name="ln7464">    } else if (pp-&gt;col &gt; 0) {</a>
<a name="ln7465">      pp-&gt;col--;</a>
<a name="ln7466">      mark_mb_adjustpos(curbuf, pp);</a>
<a name="ln7467">    } else if (pp-&gt;lnum &gt; 1) {</a>
<a name="ln7468">      --pp-&gt;lnum;</a>
<a name="ln7469">      pp-&gt;col = (colnr_T)STRLEN(ml_get(pp-&gt;lnum));</a>
<a name="ln7470">      return true;</a>
<a name="ln7471">    }</a>
<a name="ln7472">  }</a>
<a name="ln7473">  return false;</a>
<a name="ln7474">}</a>
<a name="ln7475"> </a>
<a name="ln7476">/*</a>
<a name="ln7477"> * SELECT key in Normal or Visual mode: end of Select mode mapping.</a>
<a name="ln7478"> */</a>
<a name="ln7479">static void nv_select(cmdarg_T *cap)</a>
<a name="ln7480">{</a>
<a name="ln7481">  if (VIsual_active)</a>
<a name="ln7482">    VIsual_select = true;</a>
<a name="ln7483">  else if (VIsual_reselect) {</a>
<a name="ln7484">    cap-&gt;nchar = 'v';               /* fake &quot;gv&quot; command */</a>
<a name="ln7485">    cap-&gt;arg = true;</a>
<a name="ln7486">    nv_g_cmd(cap);</a>
<a name="ln7487">  }</a>
<a name="ln7488">}</a>
<a name="ln7489"> </a>
<a name="ln7490"> </a>
<a name="ln7491">/*</a>
<a name="ln7492"> * &quot;G&quot;, &quot;gg&quot;, CTRL-END, CTRL-HOME.</a>
<a name="ln7493"> * cap-&gt;arg is true for &quot;G&quot;.</a>
<a name="ln7494"> */</a>
<a name="ln7495">static void nv_goto(cmdarg_T *cap)</a>
<a name="ln7496">{</a>
<a name="ln7497">  linenr_T lnum;</a>
<a name="ln7498"> </a>
<a name="ln7499">  if (cap-&gt;arg)</a>
<a name="ln7500">    lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln7501">  else</a>
<a name="ln7502">    lnum = 1L;</a>
<a name="ln7503">  cap-&gt;oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln7504">  setpcmark();</a>
<a name="ln7505"> </a>
<a name="ln7506">  /* When a count is given, use it instead of the default lnum */</a>
<a name="ln7507">  if (cap-&gt;count0 != 0)</a>
<a name="ln7508">    lnum = cap-&gt;count0;</a>
<a name="ln7509">  if (lnum &lt; 1L)</a>
<a name="ln7510">    lnum = 1L;</a>
<a name="ln7511">  else if (lnum &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln7512">    lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln7513">  curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln7514">  beginline(BL_SOL | BL_FIX);</a>
<a name="ln7515">  if ((fdo_flags &amp; FDO_JUMP) &amp;&amp; KeyTyped &amp;&amp; cap-&gt;oap-&gt;op_type == OP_NOP)</a>
<a name="ln7516">    foldOpenCursor();</a>
<a name="ln7517">}</a>
<a name="ln7518"> </a>
<a name="ln7519">/*</a>
<a name="ln7520"> * CTRL-\ in Normal mode.</a>
<a name="ln7521"> */</a>
<a name="ln7522">static void nv_normal(cmdarg_T *cap)</a>
<a name="ln7523">{</a>
<a name="ln7524">  if (cap-&gt;nchar == Ctrl_N || cap-&gt;nchar == Ctrl_G) {</a>
<a name="ln7525">    clearop(cap-&gt;oap);</a>
<a name="ln7526">    if (restart_edit != 0 &amp;&amp; mode_displayed)</a>
<a name="ln7527">      clear_cmdline = true;                     /* unshow mode later */</a>
<a name="ln7528">    restart_edit = 0;</a>
<a name="ln7529">    if (cmdwin_type != 0)</a>
<a name="ln7530">      cmdwin_result = Ctrl_C;</a>
<a name="ln7531">    if (VIsual_active) {</a>
<a name="ln7532">      end_visual_mode();                /* stop Visual */</a>
<a name="ln7533">      redraw_curbuf_later(INVERTED);</a>
<a name="ln7534">    }</a>
<a name="ln7535">    /* CTRL-\ CTRL-G restarts Insert mode when 'insertmode' is set. */</a>
<a name="ln7536">    if (cap-&gt;nchar == Ctrl_G &amp;&amp; p_im)</a>
<a name="ln7537">      restart_edit = 'a';</a>
<a name="ln7538">  } else</a>
<a name="ln7539">    clearopbeep(cap-&gt;oap);</a>
<a name="ln7540">}</a>
<a name="ln7541"> </a>
<a name="ln7542">/*</a>
<a name="ln7543"> * ESC in Normal mode: beep, but don't flush buffers.</a>
<a name="ln7544"> * Don't even beep if we are canceling a command.</a>
<a name="ln7545"> */</a>
<a name="ln7546">static void nv_esc(cmdarg_T *cap)</a>
<a name="ln7547">{</a>
<a name="ln7548">  int no_reason;</a>
<a name="ln7549"> </a>
<a name="ln7550">  no_reason = (cap-&gt;oap-&gt;op_type == OP_NOP</a>
<a name="ln7551">               &amp;&amp; cap-&gt;opcount == 0</a>
<a name="ln7552">               &amp;&amp; cap-&gt;count0 == 0</a>
<a name="ln7553">               &amp;&amp; cap-&gt;oap-&gt;regname == 0</a>
<a name="ln7554">               &amp;&amp; !p_im);</a>
<a name="ln7555"> </a>
<a name="ln7556">  if (cap-&gt;arg) {               /* true for CTRL-C */</a>
<a name="ln7557">    if (restart_edit == 0</a>
<a name="ln7558">        &amp;&amp; cmdwin_type == 0</a>
<a name="ln7559">        &amp;&amp; !VIsual_active</a>
<a name="ln7560">        &amp;&amp; no_reason) {</a>
<a name="ln7561">      if (anyBufIsChanged()) {</a>
<a name="ln7562">        MSG(_(&quot;Type  :qa!  and press &lt;Enter&gt; to abandon all changes&quot;</a>
<a name="ln7563">              &quot; and exit Nvim&quot;));</a>
<a name="ln7564">      } else {</a>
<a name="ln7565">        MSG(_(&quot;Type  :qa  and press &lt;Enter&gt; to exit Nvim&quot;));</a>
<a name="ln7566">      }</a>
<a name="ln7567">    }</a>
<a name="ln7568"> </a>
<a name="ln7569">    /* Don't reset &quot;restart_edit&quot; when 'insertmode' is set, it won't be</a>
<a name="ln7570">     * set again below when halfway through a mapping. */</a>
<a name="ln7571">    if (!p_im)</a>
<a name="ln7572">      restart_edit = 0;</a>
<a name="ln7573">    if (cmdwin_type != 0) {</a>
<a name="ln7574">      cmdwin_result = K_IGNORE;</a>
<a name="ln7575">      got_int = false;          /* don't stop executing autocommands et al. */</a>
<a name="ln7576">      return;</a>
<a name="ln7577">    }</a>
<a name="ln7578">  } else if (cmdwin_type != 0 &amp;&amp; ex_normal_busy) {</a>
<a name="ln7579">    // When :normal runs out of characters while in the command line window</a>
<a name="ln7580">    // vgetorpeek() will return ESC.  Exit the cmdline window to break the</a>
<a name="ln7581">    // loop.</a>
<a name="ln7582">    cmdwin_result = K_IGNORE;</a>
<a name="ln7583">    return;</a>
<a name="ln7584">  }</a>
<a name="ln7585"> </a>
<a name="ln7586">  if (VIsual_active) {</a>
<a name="ln7587">    end_visual_mode();          /* stop Visual */</a>
<a name="ln7588">    check_cursor_col();         /* make sure cursor is not beyond EOL */</a>
<a name="ln7589">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln7590">    redraw_curbuf_later(INVERTED);</a>
<a name="ln7591">  } else if (no_reason) {</a>
<a name="ln7592">    vim_beep(BO_ESC);</a>
<a name="ln7593">  }</a>
<a name="ln7594">  clearop(cap-&gt;oap);</a>
<a name="ln7595"> </a>
<a name="ln7596">  /* A CTRL-C is often used at the start of a menu.  When 'insertmode' is</a>
<a name="ln7597">   * set return to Insert mode afterwards. */</a>
<a name="ln7598">  if (restart_edit == 0 &amp;&amp; goto_im()</a>
<a name="ln7599">      &amp;&amp; ex_normal_busy == 0</a>
<a name="ln7600">      )</a>
<a name="ln7601">    restart_edit = 'a';</a>
<a name="ln7602">}</a>
<a name="ln7603"> </a>
<a name="ln7604">// Move the cursor for the &quot;A&quot; command.</a>
<a name="ln7605">void set_cursor_for_append_to_line(void)</a>
<a name="ln7606">{</a>
<a name="ln7607">  curwin-&gt;w_set_curswant = true;</a>
<a name="ln7608">  if (ve_flags == VE_ALL) {</a>
<a name="ln7609">    const int save_State = State;</a>
<a name="ln7610"> </a>
<a name="ln7611">    // Pretend Insert mode here to allow the cursor on the</a>
<a name="ln7612">    // character past the end of the line</a>
<a name="ln7613">    State = INSERT;</a>
<a name="ln7614">    coladvance(MAXCOL);</a>
<a name="ln7615">    State = save_State;</a>
<a name="ln7616">  } else {</a>
<a name="ln7617">    curwin-&gt;w_cursor.col += (colnr_T)STRLEN(get_cursor_pos_ptr());</a>
<a name="ln7618">  }</a>
<a name="ln7619">}</a>
<a name="ln7620"> </a>
<a name="ln7621">/// Handle &quot;A&quot;, &quot;a&quot;, &quot;I&quot;, &quot;i&quot; and &lt;Insert&gt; commands.</a>
<a name="ln7622">static void nv_edit(cmdarg_T *cap)</a>
<a name="ln7623">{</a>
<a name="ln7624">  // &lt;Insert&gt; is equal to &quot;i&quot;</a>
<a name="ln7625">  if (cap-&gt;cmdchar == K_INS || cap-&gt;cmdchar == K_KINS) {</a>
<a name="ln7626">    cap-&gt;cmdchar = 'i';</a>
<a name="ln7627">  }</a>
<a name="ln7628"> </a>
<a name="ln7629">  // in Visual mode &quot;A&quot; and &quot;I&quot; are an operator</a>
<a name="ln7630">  if (VIsual_active &amp;&amp; (cap-&gt;cmdchar == 'A' || cap-&gt;cmdchar == 'I')) {</a>
<a name="ln7631">    v_visop(cap);</a>
<a name="ln7632">  // in Visual mode and after an operator &quot;a&quot; and &quot;i&quot; are for text objects</a>
<a name="ln7633">  } else if ((cap-&gt;cmdchar == 'a' || cap-&gt;cmdchar == 'i')</a>
<a name="ln7634">             &amp;&amp; (cap-&gt;oap-&gt;op_type != OP_NOP || VIsual_active)) {</a>
<a name="ln7635">    nv_object(cap);</a>
<a name="ln7636">  } else if (!curbuf-&gt;b_p_ma &amp;&amp; !p_im &amp;&amp; !curbuf-&gt;terminal) {</a>
<a name="ln7637">    // Only give this error when 'insertmode' is off.</a>
<a name="ln7638">    EMSG(_(e_modifiable));</a>
<a name="ln7639">    clearop(cap-&gt;oap);</a>
<a name="ln7640">  } else if (!checkclearopq(cap-&gt;oap)) {</a>
<a name="ln7641">    switch (cap-&gt;cmdchar) {</a>
<a name="ln7642">    case 'A':           // &quot;A&quot;ppend after the line</a>
<a name="ln7643">      set_cursor_for_append_to_line();</a>
<a name="ln7644">      break;</a>
<a name="ln7645"> </a>
<a name="ln7646">    case 'I':           /* &quot;I&quot;nsert before the first non-blank */</a>
<a name="ln7647">      beginline(BL_WHITE);</a>
<a name="ln7648">      break;</a>
<a name="ln7649"> </a>
<a name="ln7650">    case 'a':           /* &quot;a&quot;ppend is like &quot;i&quot;nsert on the next character. */</a>
<a name="ln7651">      /* increment coladd when in virtual space, increment the</a>
<a name="ln7652">       * column otherwise, also to append after an unprintable char */</a>
<a name="ln7653">      if (virtual_active()</a>
<a name="ln7654">          &amp;&amp; (curwin-&gt;w_cursor.coladd &gt; 0</a>
<a name="ln7655">              || *get_cursor_pos_ptr() == NUL</a>
<a name="ln7656">              || *get_cursor_pos_ptr() == TAB))</a>
<a name="ln7657">        curwin-&gt;w_cursor.coladd++;</a>
<a name="ln7658">      else if (*get_cursor_pos_ptr() != NUL)</a>
<a name="ln7659">        inc_cursor();</a>
<a name="ln7660">      break;</a>
<a name="ln7661">    }</a>
<a name="ln7662"> </a>
<a name="ln7663">    if (curwin-&gt;w_cursor.coladd &amp;&amp; cap-&gt;cmdchar != 'A') {</a>
<a name="ln7664">      int save_State = State;</a>
<a name="ln7665"> </a>
<a name="ln7666">      /* Pretend Insert mode here to allow the cursor on the</a>
<a name="ln7667">       * character past the end of the line */</a>
<a name="ln7668">      State = INSERT;</a>
<a name="ln7669">      coladvance(getviscol());</a>
<a name="ln7670">      State = save_State;</a>
<a name="ln7671">    }</a>
<a name="ln7672"> </a>
<a name="ln7673">    invoke_edit(cap, false, cap-&gt;cmdchar, false);</a>
<a name="ln7674">  }</a>
<a name="ln7675">}</a>
<a name="ln7676"> </a>
<a name="ln7677">/*</a>
<a name="ln7678"> * Invoke edit() and take care of &quot;restart_edit&quot; and the return value.</a>
<a name="ln7679"> */</a>
<a name="ln7680">static void</a>
<a name="ln7681">invoke_edit (</a>
<a name="ln7682">    cmdarg_T *cap,</a>
<a name="ln7683">    int repl,                       /* &quot;r&quot; or &quot;gr&quot; command */</a>
<a name="ln7684">    int cmd,</a>
<a name="ln7685">    int startln</a>
<a name="ln7686">)</a>
<a name="ln7687">{</a>
<a name="ln7688">  int restart_edit_save = 0;</a>
<a name="ln7689"> </a>
<a name="ln7690">  /* Complicated: When the user types &quot;a&lt;C-O&gt;a&quot; we don't want to do Insert</a>
<a name="ln7691">   * mode recursively.  But when doing &quot;a&lt;C-O&gt;.&quot; or &quot;a&lt;C-O&gt;rx&quot; we do allow</a>
<a name="ln7692">   * it. */</a>
<a name="ln7693">  if (repl || !stuff_empty())</a>
<a name="ln7694">    restart_edit_save = restart_edit;</a>
<a name="ln7695">  else</a>
<a name="ln7696">    restart_edit_save = 0;</a>
<a name="ln7697"> </a>
<a name="ln7698">  /* Always reset &quot;restart_edit&quot;, this is not a restarted edit. */</a>
<a name="ln7699">  restart_edit = 0;</a>
<a name="ln7700"> </a>
<a name="ln7701">  if (edit(cmd, startln, cap-&gt;count1))</a>
<a name="ln7702">    cap-&gt;retval |= CA_COMMAND_BUSY;</a>
<a name="ln7703"> </a>
<a name="ln7704">  if (restart_edit == 0)</a>
<a name="ln7705">    restart_edit = restart_edit_save;</a>
<a name="ln7706">}</a>
<a name="ln7707"> </a>
<a name="ln7708">/*</a>
<a name="ln7709"> * &quot;a&quot; or &quot;i&quot; while an operator is pending or in Visual mode: object motion.</a>
<a name="ln7710"> */</a>
<a name="ln7711">static void nv_object(cmdarg_T *cap)</a>
<a name="ln7712">{</a>
<a name="ln7713">  bool flag;</a>
<a name="ln7714">  bool include;</a>
<a name="ln7715">  char_u      *mps_save;</a>
<a name="ln7716"> </a>
<a name="ln7717">  if (cap-&gt;cmdchar == 'i')</a>
<a name="ln7718">    include = false;        /* &quot;ix&quot; = inner object: exclude white space */</a>
<a name="ln7719">  else</a>
<a name="ln7720">    include = true;         /* &quot;ax&quot; = an object: include white space */</a>
<a name="ln7721"> </a>
<a name="ln7722">  /* Make sure (), [], {} and &lt;&gt; are in 'matchpairs' */</a>
<a name="ln7723">  mps_save = curbuf-&gt;b_p_mps;</a>
<a name="ln7724">  curbuf-&gt;b_p_mps = (char_u *)&quot;(:),{:},[:],&lt;:&gt;&quot;;</a>
<a name="ln7725"> </a>
<a name="ln7726">  switch (cap-&gt;nchar) {</a>
<a name="ln7727">  case 'w':       /* &quot;aw&quot; = a word */</a>
<a name="ln7728">    flag = current_word(cap-&gt;oap, cap-&gt;count1, include, false);</a>
<a name="ln7729">    break;</a>
<a name="ln7730">  case 'W':       /* &quot;aW&quot; = a WORD */</a>
<a name="ln7731">    flag = current_word(cap-&gt;oap, cap-&gt;count1, include, true);</a>
<a name="ln7732">    break;</a>
<a name="ln7733">  case 'b':       /* &quot;ab&quot; = a braces block */</a>
<a name="ln7734">  case '(':</a>
<a name="ln7735">  case ')':</a>
<a name="ln7736">    flag = current_block(cap-&gt;oap, cap-&gt;count1, include, '(', ')');</a>
<a name="ln7737">    break;</a>
<a name="ln7738">  case 'B':       /* &quot;aB&quot; = a Brackets block */</a>
<a name="ln7739">  case '{':</a>
<a name="ln7740">  case '}':</a>
<a name="ln7741">    flag = current_block(cap-&gt;oap, cap-&gt;count1, include, '{', '}');</a>
<a name="ln7742">    break;</a>
<a name="ln7743">  case '[':       /* &quot;a[&quot; = a [] block */</a>
<a name="ln7744">  case ']':</a>
<a name="ln7745">    flag = current_block(cap-&gt;oap, cap-&gt;count1, include, '[', ']');</a>
<a name="ln7746">    break;</a>
<a name="ln7747">  case '&lt;':       /* &quot;a&lt;&quot; = a &lt;&gt; block */</a>
<a name="ln7748">  case '&gt;':</a>
<a name="ln7749">    flag = current_block(cap-&gt;oap, cap-&gt;count1, include, '&lt;', '&gt;');</a>
<a name="ln7750">    break;</a>
<a name="ln7751">  case 't':       /* &quot;at&quot; = a tag block (xml and html) */</a>
<a name="ln7752">    // Do not adjust oap-&gt;end in do_pending_operator()</a>
<a name="ln7753">    // otherwise there are different results for 'dit'</a>
<a name="ln7754">    // (note leading whitespace in last line):</a>
<a name="ln7755">    // 1) &lt;b&gt;      2) &lt;b&gt;</a>
<a name="ln7756">    //    foobar      foobar</a>
<a name="ln7757">    //    &lt;/b&gt;            &lt;/b&gt;</a>
<a name="ln7758">    cap-&gt;retval |= CA_NO_ADJ_OP_END;</a>
<a name="ln7759">    flag = current_tagblock(cap-&gt;oap, cap-&gt;count1, include);</a>
<a name="ln7760">    break;</a>
<a name="ln7761">  case 'p':       /* &quot;ap&quot; = a paragraph */</a>
<a name="ln7762">    flag = current_par(cap-&gt;oap, cap-&gt;count1, include, 'p');</a>
<a name="ln7763">    break;</a>
<a name="ln7764">  case 's':       /* &quot;as&quot; = a sentence */</a>
<a name="ln7765">    flag = current_sent(cap-&gt;oap, cap-&gt;count1, include);</a>
<a name="ln7766">    break;</a>
<a name="ln7767">  case '&quot;':       /* &quot;a&quot;&quot; = a double quoted string */</a>
<a name="ln7768">  case '\'':       /* &quot;a'&quot; = a single quoted string */</a>
<a name="ln7769">  case '`':       /* &quot;a`&quot; = a backtick quoted string */</a>
<a name="ln7770">    flag = current_quote(cap-&gt;oap, cap-&gt;count1, include,</a>
<a name="ln7771">        cap-&gt;nchar);</a>
<a name="ln7772">    break;</a>
<a name="ln7773">  default:</a>
<a name="ln7774">    flag = false;</a>
<a name="ln7775">    break;</a>
<a name="ln7776">  }</a>
<a name="ln7777"> </a>
<a name="ln7778">  curbuf-&gt;b_p_mps = mps_save;</a>
<a name="ln7779">  if (!flag)</a>
<a name="ln7780">    clearopbeep(cap-&gt;oap);</a>
<a name="ln7781">  adjust_cursor_col();</a>
<a name="ln7782">  curwin-&gt;w_set_curswant = true;</a>
<a name="ln7783">}</a>
<a name="ln7784"> </a>
<a name="ln7785">/*</a>
<a name="ln7786"> * &quot;q&quot; command: Start/stop recording.</a>
<a name="ln7787"> * &quot;q:&quot;, &quot;q/&quot;, &quot;q?&quot;: edit command-line in command-line window.</a>
<a name="ln7788"> */</a>
<a name="ln7789">static void nv_record(cmdarg_T *cap)</a>
<a name="ln7790">{</a>
<a name="ln7791">  if (cap-&gt;oap-&gt;op_type == OP_FORMAT) {</a>
<a name="ln7792">    /* &quot;gqq&quot; is the same as &quot;gqgq&quot;: format line */</a>
<a name="ln7793">    cap-&gt;cmdchar = 'g';</a>
<a name="ln7794">    cap-&gt;nchar = 'q';</a>
<a name="ln7795">    nv_operator(cap);</a>
<a name="ln7796">  } else if (!checkclearop(cap-&gt;oap)) {</a>
<a name="ln7797">    if (cap-&gt;nchar == ':' || cap-&gt;nchar == '/' || cap-&gt;nchar == '?') {</a>
<a name="ln7798">      stuffcharReadbuff(cap-&gt;nchar);</a>
<a name="ln7799">      stuffcharReadbuff(K_CMDWIN);</a>
<a name="ln7800">    } else {</a>
<a name="ln7801">      // (stop) recording into a named register, unless executing a</a>
<a name="ln7802">      // register.</a>
<a name="ln7803">      if (reg_executing == 0 &amp;&amp; do_record(cap-&gt;nchar) == FAIL) {</a>
<a name="ln7804">        clearopbeep(cap-&gt;oap);</a>
<a name="ln7805">      }</a>
<a name="ln7806">    }</a>
<a name="ln7807">  }</a>
<a name="ln7808">}</a>
<a name="ln7809"> </a>
<a name="ln7810">/*</a>
<a name="ln7811"> * Handle the &quot;@r&quot; command.</a>
<a name="ln7812"> */</a>
<a name="ln7813">static void nv_at(cmdarg_T *cap)</a>
<a name="ln7814">{</a>
<a name="ln7815">  if (checkclearop(cap-&gt;oap))</a>
<a name="ln7816">    return;</a>
<a name="ln7817">  if (cap-&gt;nchar == '=') {</a>
<a name="ln7818">    if (get_expr_register() == NUL)</a>
<a name="ln7819">      return;</a>
<a name="ln7820">  }</a>
<a name="ln7821">  while (cap-&gt;count1-- &amp;&amp; !got_int) {</a>
<a name="ln7822">    if (do_execreg(cap-&gt;nchar, false, false, false) == false) {</a>
<a name="ln7823">      clearopbeep(cap-&gt;oap);</a>
<a name="ln7824">      break;</a>
<a name="ln7825">    }</a>
<a name="ln7826">    line_breakcheck();</a>
<a name="ln7827">  }</a>
<a name="ln7828">}</a>
<a name="ln7829"> </a>
<a name="ln7830">/*</a>
<a name="ln7831"> * Handle the CTRL-U and CTRL-D commands.</a>
<a name="ln7832"> */</a>
<a name="ln7833">static void nv_halfpage(cmdarg_T *cap)</a>
<a name="ln7834">{</a>
<a name="ln7835">  if ((cap-&gt;cmdchar == Ctrl_U &amp;&amp; curwin-&gt;w_cursor.lnum == 1)</a>
<a name="ln7836">      || (cap-&gt;cmdchar == Ctrl_D</a>
<a name="ln7837">          &amp;&amp; curwin-&gt;w_cursor.lnum == curbuf-&gt;b_ml.ml_line_count))</a>
<a name="ln7838">    clearopbeep(cap-&gt;oap);</a>
<a name="ln7839">  else if (!checkclearop(cap-&gt;oap))</a>
<a name="ln7840">    halfpage(cap-&gt;cmdchar == Ctrl_D, cap-&gt;count0);</a>
<a name="ln7841">}</a>
<a name="ln7842"> </a>
<a name="ln7843">/*</a>
<a name="ln7844"> * Handle &quot;J&quot; or &quot;gJ&quot; command.</a>
<a name="ln7845"> */</a>
<a name="ln7846">static void nv_join(cmdarg_T *cap)</a>
<a name="ln7847">{</a>
<a name="ln7848">  if (VIsual_active) {  // join the visual lines</a>
<a name="ln7849">    nv_operator(cap);</a>
<a name="ln7850">  } else if (!checkclearop(cap-&gt;oap)) {</a>
<a name="ln7851">    if (cap-&gt;count0 &lt;= 1) {</a>
<a name="ln7852">      cap-&gt;count0 = 2;  // default for join is two lines!</a>
<a name="ln7853">    }</a>
<a name="ln7854">    if (curwin-&gt;w_cursor.lnum + cap-&gt;count0 - 1 &gt;</a>
<a name="ln7855">        curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln7856">      // can't join when on the last line</a>
<a name="ln7857">      if (cap-&gt;count0 &lt;= 2) {</a>
<a name="ln7858">        clearopbeep(cap-&gt;oap);</a>
<a name="ln7859">        return;</a>
<a name="ln7860">      }</a>
<a name="ln7861">      cap-&gt;count0 = curbuf-&gt;b_ml.ml_line_count - curwin-&gt;w_cursor.lnum + 1;</a>
<a name="ln7862">    }</a>
<a name="ln7863"> </a>
<a name="ln7864">    prep_redo(cap-&gt;oap-&gt;regname, cap-&gt;count0,</a>
<a name="ln7865">              NUL, cap-&gt;cmdchar, NUL, NUL, cap-&gt;nchar);</a>
<a name="ln7866">    do_join((size_t)cap-&gt;count0, cap-&gt;nchar == NUL, true, true, true);</a>
<a name="ln7867">  }</a>
<a name="ln7868">}</a>
<a name="ln7869"> </a>
<a name="ln7870">/*</a>
<a name="ln7871"> * &quot;P&quot;, &quot;gP&quot;, &quot;p&quot; and &quot;gp&quot; commands.</a>
<a name="ln7872"> */</a>
<a name="ln7873">static void nv_put(cmdarg_T *cap)</a>
<a name="ln7874">{</a>
<a name="ln7875">  nv_put_opt(cap, false);</a>
<a name="ln7876">}</a>
<a name="ln7877"> </a>
<a name="ln7878">// &quot;P&quot;, &quot;gP&quot;, &quot;p&quot; and &quot;gp&quot; commands.</a>
<a name="ln7879">// &quot;fix_indent&quot; is true for &quot;[p&quot;, &quot;[P&quot;, &quot;]p&quot; and &quot;]P&quot;.</a>
<a name="ln7880">static void nv_put_opt(cmdarg_T *cap, bool fix_indent)</a>
<a name="ln7881">{</a>
<a name="ln7882">  int regname = 0;</a>
<a name="ln7883">  yankreg_T *savereg = NULL;</a>
<a name="ln7884">  bool empty = false;</a>
<a name="ln7885">  bool was_visual = false;</a>
<a name="ln7886">  int dir;</a>
<a name="ln7887">  int flags = 0;</a>
<a name="ln7888"> </a>
<a name="ln7889">  if (cap-&gt;oap-&gt;op_type != OP_NOP) {</a>
<a name="ln7890">    /* &quot;dp&quot; is &quot;:diffput&quot; */</a>
<a name="ln7891">    if (cap-&gt;oap-&gt;op_type == OP_DELETE &amp;&amp; cap-&gt;cmdchar == 'p') {</a>
<a name="ln7892">      clearop(cap-&gt;oap);</a>
<a name="ln7893">      assert(cap-&gt;opcount &gt;= 0);</a>
<a name="ln7894">      nv_diffgetput(true, (size_t)cap-&gt;opcount);</a>
<a name="ln7895">    } else {</a>
<a name="ln7896">      clearopbeep(cap-&gt;oap);</a>
<a name="ln7897">    }</a>
<a name="ln7898">  } else if (bt_prompt(curbuf) &amp;&amp; !prompt_curpos_editable()) {</a>
<a name="ln7899">    clearopbeep(cap-&gt;oap);</a>
<a name="ln7900">  } else {</a>
<a name="ln7901">    if (fix_indent) {</a>
<a name="ln7902">      dir = (cap-&gt;cmdchar == ']' &amp;&amp; cap-&gt;nchar == 'p')</a>
<a name="ln7903">        ? FORWARD : BACKWARD;</a>
<a name="ln7904">      flags |= PUT_FIXINDENT;</a>
<a name="ln7905">    } else {</a>
<a name="ln7906">      dir = (cap-&gt;cmdchar == 'P'</a>
<a name="ln7907">             || (cap-&gt;cmdchar == 'g' &amp;&amp; cap-&gt;nchar == 'P'))</a>
<a name="ln7908">        ? BACKWARD : FORWARD;</a>
<a name="ln7909">    }</a>
<a name="ln7910">    prep_redo_cmd(cap);</a>
<a name="ln7911">    if (cap-&gt;cmdchar == 'g') {</a>
<a name="ln7912">      flags |= PUT_CURSEND;</a>
<a name="ln7913">    }</a>
<a name="ln7914"> </a>
<a name="ln7915">    if (VIsual_active) {</a>
<a name="ln7916">      /* Putting in Visual mode: The put text replaces the selected</a>
<a name="ln7917">       * text.  First delete the selected text, then put the new text.</a>
<a name="ln7918">       * Need to save and restore the registers that the delete</a>
<a name="ln7919">       * overwrites if the old contents is being put.</a>
<a name="ln7920">       */</a>
<a name="ln7921">      was_visual = true;</a>
<a name="ln7922">      regname = cap-&gt;oap-&gt;regname;</a>
<a name="ln7923">      // '+' and '*' could be the same selection</a>
<a name="ln7924">      bool clipoverwrite = (regname == '+' || regname == '*')</a>
<a name="ln7925">          &amp;&amp; (cb_flags &amp; CB_UNNAMEDMASK);</a>
<a name="ln7926">      if (regname == 0 || regname == '&quot;' || clipoverwrite</a>
<a name="ln7927">          || ascii_isdigit(regname) || regname == '-') {</a>
<a name="ln7928">        // The delete might overwrite the register we want to put, save it first</a>
<a name="ln7929">        savereg = copy_register(regname);</a>
<a name="ln7930">      }</a>
<a name="ln7931"> </a>
<a name="ln7932">      // To place the cursor correctly after a blockwise put, and to leave the</a>
<a name="ln7933">      // text in the correct position when putting over a selection with</a>
<a name="ln7934">      // 'virtualedit' and past the end of the line, we use the 'c' operator in</a>
<a name="ln7935">      // do_put(), which requires the visual selection to still be active.</a>
<a name="ln7936">      if (!VIsual_active || VIsual_mode == 'V' || regname != '.') {</a>
<a name="ln7937">        // Now delete the selected text. Avoid messages here.</a>
<a name="ln7938">        cap-&gt;cmdchar = 'd';</a>
<a name="ln7939">        cap-&gt;nchar = NUL;</a>
<a name="ln7940">        cap-&gt;oap-&gt;regname = NUL;</a>
<a name="ln7941">        msg_silent++;</a>
<a name="ln7942">        nv_operator(cap);</a>
<a name="ln7943">        do_pending_operator(cap, 0, false);</a>
<a name="ln7944">        empty = (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY);</a>
<a name="ln7945">        msg_silent--;</a>
<a name="ln7946"> </a>
<a name="ln7947">        // delete PUT_LINE_BACKWARD;</a>
<a name="ln7948">        cap-&gt;oap-&gt;regname = regname;</a>
<a name="ln7949">      }</a>
<a name="ln7950"> </a>
<a name="ln7951">      // When deleted a linewise Visual area, put the register as</a>
<a name="ln7952">      // lines to avoid it joined with the next line.  When deletion was</a>
<a name="ln7953">      // charwise, split a line when putting lines.</a>
<a name="ln7954">      if (VIsual_mode == 'V') {</a>
<a name="ln7955">        flags |= PUT_LINE;</a>
<a name="ln7956">      } else if (VIsual_mode == 'v') {</a>
<a name="ln7957">        flags |= PUT_LINE_SPLIT;</a>
<a name="ln7958">      }</a>
<a name="ln7959">      if (VIsual_mode == Ctrl_V &amp;&amp; dir == FORWARD) {</a>
<a name="ln7960">        flags |= PUT_LINE_FORWARD;</a>
<a name="ln7961">      }</a>
<a name="ln7962">      dir = BACKWARD;</a>
<a name="ln7963">      if ((VIsual_mode != 'V'</a>
<a name="ln7964">           &amp;&amp; curwin-&gt;w_cursor.col &lt; curbuf-&gt;b_op_start.col)</a>
<a name="ln7965">          || (VIsual_mode == 'V'</a>
<a name="ln7966">              &amp;&amp; curwin-&gt;w_cursor.lnum &lt; curbuf-&gt;b_op_start.lnum))</a>
<a name="ln7967">        /* cursor is at the end of the line or end of file, put</a>
<a name="ln7968">         * forward. */</a>
<a name="ln7969">        dir = FORWARD;</a>
<a name="ln7970">      /* May have been reset in do_put(). */</a>
<a name="ln7971">      VIsual_active = true;</a>
<a name="ln7972">    }</a>
<a name="ln7973">    do_put(cap-&gt;oap-&gt;regname, savereg, dir, cap-&gt;count1, flags);</a>
<a name="ln7974"> </a>
<a name="ln7975">    // If a register was saved, free it</a>
<a name="ln7976">    if (savereg != NULL) {</a>
<a name="ln7977">      free_register(savereg);</a>
<a name="ln7978">      xfree(savereg);</a>
<a name="ln7979">    }</a>
<a name="ln7980"> </a>
<a name="ln7981">    /* What to reselect with &quot;gv&quot;?  Selecting the just put text seems to</a>
<a name="ln7982">     * be the most useful, since the original text was removed. */</a>
<a name="ln7983">    if (was_visual) {</a>
<a name="ln7984">      curbuf-&gt;b_visual.vi_start = curbuf-&gt;b_op_start;</a>
<a name="ln7985">      curbuf-&gt;b_visual.vi_end = curbuf-&gt;b_op_end;</a>
<a name="ln7986">      // need to adjust cursor position</a>
<a name="ln7987">      if (*p_sel == 'e') {</a>
<a name="ln7988">        inc(&amp;curbuf-&gt;b_visual.vi_end);</a>
<a name="ln7989">      }</a>
<a name="ln7990">    }</a>
<a name="ln7991"> </a>
<a name="ln7992">    /* When all lines were selected and deleted do_put() leaves an empty</a>
<a name="ln7993">     * line that needs to be deleted now. */</a>
<a name="ln7994">    if (empty &amp;&amp; *ml_get(curbuf-&gt;b_ml.ml_line_count) == NUL) {</a>
<a name="ln7995">      ml_delete(curbuf-&gt;b_ml.ml_line_count, true);</a>
<a name="ln7996">      deleted_lines(curbuf-&gt;b_ml.ml_line_count + 1, 1);</a>
<a name="ln7997"> </a>
<a name="ln7998">      /* If the cursor was in that line, move it to the end of the last</a>
<a name="ln7999">       * line. */</a>
<a name="ln8000">      if (curwin-&gt;w_cursor.lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln8001">        curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln8002">        coladvance(MAXCOL);</a>
<a name="ln8003">      }</a>
<a name="ln8004">    }</a>
<a name="ln8005">    auto_format(false, true);</a>
<a name="ln8006">  }</a>
<a name="ln8007">}</a>
<a name="ln8008"> </a>
<a name="ln8009">/*</a>
<a name="ln8010"> * &quot;o&quot; and &quot;O&quot; commands.</a>
<a name="ln8011"> */</a>
<a name="ln8012">static void nv_open(cmdarg_T *cap)</a>
<a name="ln8013">{</a>
<a name="ln8014">  /* &quot;do&quot; is &quot;:diffget&quot; */</a>
<a name="ln8015">  if (cap-&gt;oap-&gt;op_type == OP_DELETE &amp;&amp; cap-&gt;cmdchar == 'o') {</a>
<a name="ln8016">    clearop(cap-&gt;oap);</a>
<a name="ln8017">    assert(cap-&gt;opcount &gt;= 0);</a>
<a name="ln8018">    nv_diffgetput(false, (size_t)cap-&gt;opcount);</a>
<a name="ln8019">  } else if (VIsual_active) {</a>
<a name="ln8020">    // switch start and end of visual/</a>
<a name="ln8021">    v_swap_corners(cap-&gt;cmdchar);</a>
<a name="ln8022">  } else if (bt_prompt(curbuf)) {</a>
<a name="ln8023">    clearopbeep(cap-&gt;oap);</a>
<a name="ln8024">  } else {</a>
<a name="ln8025">    n_opencmd(cap);</a>
<a name="ln8026">  }</a>
<a name="ln8027">}</a>
<a name="ln8028"> </a>
<a name="ln8029">// Calculate start/end virtual columns for operating in block mode.</a>
<a name="ln8030">static void get_op_vcol(</a>
<a name="ln8031">    oparg_T *oap,</a>
<a name="ln8032">    colnr_T redo_VIsual_vcol,</a>
<a name="ln8033">    bool initial  // when true: adjust position for 'selectmode'</a>
<a name="ln8034">)</a>
<a name="ln8035">{</a>
<a name="ln8036">  colnr_T start;</a>
<a name="ln8037">  colnr_T end;</a>
<a name="ln8038"> </a>
<a name="ln8039">  if (VIsual_mode != Ctrl_V</a>
<a name="ln8040">      || (!initial &amp;&amp; oap-&gt;end.col &lt; curwin-&gt;w_width_inner)) {</a>
<a name="ln8041">    return;</a>
<a name="ln8042">  }</a>
<a name="ln8043"> </a>
<a name="ln8044">  oap-&gt;motion_type = kMTBlockWise;</a>
<a name="ln8045"> </a>
<a name="ln8046">  // prevent from moving onto a trail byte</a>
<a name="ln8047">  mark_mb_adjustpos(curwin-&gt;w_buffer, &amp;oap-&gt;end);</a>
<a name="ln8048"> </a>
<a name="ln8049">  getvvcol(curwin, &amp;(oap-&gt;start), &amp;oap-&gt;start_vcol, NULL, &amp;oap-&gt;end_vcol);</a>
<a name="ln8050">  if (!redo_VIsual_busy) {</a>
<a name="ln8051">    getvvcol(curwin, &amp;(oap-&gt;end), &amp;start, NULL, &amp;end);</a>
<a name="ln8052"> </a>
<a name="ln8053">    if (start &lt; oap-&gt;start_vcol) {</a>
<a name="ln8054">      oap-&gt;start_vcol = start;</a>
<a name="ln8055">    }</a>
<a name="ln8056">    if (end &gt; oap-&gt;end_vcol) {</a>
<a name="ln8057">      if (initial &amp;&amp; *p_sel == 'e'</a>
<a name="ln8058">          &amp;&amp; start &gt;= 1</a>
<a name="ln8059">          &amp;&amp; start - 1 &gt;= oap-&gt;end_vcol) {</a>
<a name="ln8060">        oap-&gt;end_vcol = start - 1;</a>
<a name="ln8061">      } else {</a>
<a name="ln8062">        oap-&gt;end_vcol = end;</a>
<a name="ln8063">      }</a>
<a name="ln8064">    }</a>
<a name="ln8065">  }</a>
<a name="ln8066"> </a>
<a name="ln8067">  // if '$' was used, get oap-&gt;end_vcol from longest line</a>
<a name="ln8068">  if (curwin-&gt;w_curswant == MAXCOL) {</a>
<a name="ln8069">    curwin-&gt;w_cursor.col = MAXCOL;</a>
<a name="ln8070">    oap-&gt;end_vcol = 0;</a>
<a name="ln8071">    for (curwin-&gt;w_cursor.lnum = oap-&gt;start.lnum;</a>
<a name="ln8072">         curwin-&gt;w_cursor.lnum &lt;= oap-&gt;end.lnum; ++curwin-&gt;w_cursor.lnum) {</a>
<a name="ln8073">      getvvcol(curwin, &amp;curwin-&gt;w_cursor, NULL, NULL, &amp;end);</a>
<a name="ln8074">      if (end &gt; oap-&gt;end_vcol) {</a>
<a name="ln8075">        oap-&gt;end_vcol = end;</a>
<a name="ln8076">      }</a>
<a name="ln8077">    }</a>
<a name="ln8078">  } else if (redo_VIsual_busy) {</a>
<a name="ln8079">    oap-&gt;end_vcol = oap-&gt;start_vcol + redo_VIsual_vcol - 1;</a>
<a name="ln8080">  }</a>
<a name="ln8081"> </a>
<a name="ln8082">  // Correct oap-&gt;end.col and oap-&gt;start.col to be the</a>
<a name="ln8083">  // upper-left and lower-right corner of the block area.</a>
<a name="ln8084">  //</a>
<a name="ln8085">  // (Actually, this does convert column positions into character</a>
<a name="ln8086">  // positions)</a>
<a name="ln8087">  curwin-&gt;w_cursor.lnum = oap-&gt;end.lnum;</a>
<a name="ln8088">  coladvance(oap-&gt;end_vcol);</a>
<a name="ln8089">  oap-&gt;end = curwin-&gt;w_cursor;</a>
<a name="ln8090"> </a>
<a name="ln8091">  curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln8092">  coladvance(oap-&gt;start_vcol);</a>
<a name="ln8093">  oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln8094">}</a>
<a name="ln8095"> </a>
<a name="ln8096">// Handle an arbitrary event in normal mode</a>
<a name="ln8097">static void nv_event(cmdarg_T *cap)</a>
<a name="ln8098">{</a>
<a name="ln8099">  // Garbage collection should have been executed before blocking for events in</a>
<a name="ln8100">  // the `os_inchar` in `state_enter`, but we also disable it here in case the</a>
<a name="ln8101">  // `os_inchar` branch was not executed (!multiqueue_empty(loop.events), which</a>
<a name="ln8102">  // could have `may_garbage_collect` set to true in `normal_check`).</a>
<a name="ln8103">  //</a>
<a name="ln8104">  // That is because here we may run code that calls `os_inchar`</a>
<a name="ln8105">  // later(`f_confirm` or `get_keystroke` for example), but in these cases it is</a>
<a name="ln8106">  // not safe to perform garbage collection because there could be unreferenced</a>
<a name="ln8107">  // lists or dicts being used.</a>
<a name="ln8108">  may_garbage_collect = false;</a>
<a name="ln8109">  bool may_restart = (restart_edit != 0);</a>
<a name="ln8110">  state_handle_k_event();</a>
<a name="ln8111">  finish_op = false;</a>
<a name="ln8112">  if (may_restart) {</a>
<a name="ln8113">    // Tricky: if restart_edit was set before the handler we are in ctrl-o mode,</a>
<a name="ln8114">    // but if not, the event should be allowed to trigger :startinsert.</a>
<a name="ln8115">    cap-&gt;retval |= CA_COMMAND_BUSY;  // don't call edit() now</a>
<a name="ln8116">  }</a>
<a name="ln8117">}</a>
<a name="ln8118"> </a>
<a name="ln8119">/*</a>
<a name="ln8120"> * Return TRUE when 'mousemodel' is set to &quot;popup&quot; or &quot;popup_setpos&quot;.</a>
<a name="ln8121"> */</a>
<a name="ln8122">static int mouse_model_popup(void)</a>
<a name="ln8123">{</a>
<a name="ln8124">  return p_mousem[0] == 'p';</a>
<a name="ln8125">}</a>
<a name="ln8126"> </a>
<a name="ln8127">void normal_cmd(oparg_T *oap, bool toplevel)</a>
<a name="ln8128">{</a>
<a name="ln8129">  NormalState s;</a>
<a name="ln8130">  normal_state_init(&amp;s);</a>
<a name="ln8131">  s.toplevel = toplevel;</a>
<a name="ln8132">  s.oa = *oap;</a>
<a name="ln8133">  normal_prepare(&amp;s);</a>
<a name="ln8134">  (void)normal_execute(&amp;s.state, safe_vgetc());</a>
<a name="ln8135">  *oap = s.oa;</a>
<a name="ln8136">}</a>

</code></pre>
<div class="balloon" rel="3176"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v781/" target="_blank">V781</a> The value of the 'col' index is checked after it was used. Perhaps there is a mistake in program logic.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
