
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ex_docmd.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// ex_docmd.c: functions for executing an Ex command line.</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;string.h&gt;</a>
<a name="ln8">#include &lt;stdbool.h&gt;</a>
<a name="ln9">#include &lt;stdlib.h&gt;</a>
<a name="ln10">#include &lt;inttypes.h&gt;</a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;nvim/vim.h&quot;</a>
<a name="ln13">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln14">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln15">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln16">#include &quot;nvim/change.h&quot;</a>
<a name="ln17">#include &quot;nvim/charset.h&quot;</a>
<a name="ln18">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln19">#include &quot;nvim/diff.h&quot;</a>
<a name="ln20">#include &quot;nvim/digraph.h&quot;</a>
<a name="ln21">#include &quot;nvim/edit.h&quot;</a>
<a name="ln22">#include &quot;nvim/eval.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln24">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln25">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln28">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln29">#include &quot;nvim/fold.h&quot;</a>
<a name="ln30">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln31">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln32">#include &quot;nvim/hardcopy.h&quot;</a>
<a name="ln33">#include &quot;nvim/if_cscope.h&quot;</a>
<a name="ln34">#include &quot;nvim/main.h&quot;</a>
<a name="ln35">#include &quot;nvim/mark.h&quot;</a>
<a name="ln36">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln37">#include &quot;nvim/memline.h&quot;</a>
<a name="ln38">#include &quot;nvim/memory.h&quot;</a>
<a name="ln39">#include &quot;nvim/menu.h&quot;</a>
<a name="ln40">#include &quot;nvim/message.h&quot;</a>
<a name="ln41">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln42">#include &quot;nvim/ex_session.h&quot;</a>
<a name="ln43">#include &quot;nvim/keymap.h&quot;</a>
<a name="ln44">#include &quot;nvim/file_search.h&quot;</a>
<a name="ln45">#include &quot;nvim/garray.h&quot;</a>
<a name="ln46">#include &quot;nvim/move.h&quot;</a>
<a name="ln47">#include &quot;nvim/normal.h&quot;</a>
<a name="ln48">#include &quot;nvim/ops.h&quot;</a>
<a name="ln49">#include &quot;nvim/option.h&quot;</a>
<a name="ln50">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln51">#include &quot;nvim/path.h&quot;</a>
<a name="ln52">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln53">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln54">#include &quot;nvim/screen.h&quot;</a>
<a name="ln55">#include &quot;nvim/search.h&quot;</a>
<a name="ln56">#include &quot;nvim/sign.h&quot;</a>
<a name="ln57">#include &quot;nvim/spell.h&quot;</a>
<a name="ln58">#include &quot;nvim/spellfile.h&quot;</a>
<a name="ln59">#include &quot;nvim/strings.h&quot;</a>
<a name="ln60">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln61">#include &quot;nvim/tag.h&quot;</a>
<a name="ln62">#include &quot;nvim/terminal.h&quot;</a>
<a name="ln63">#include &quot;nvim/ui.h&quot;</a>
<a name="ln64">#include &quot;nvim/undo.h&quot;</a>
<a name="ln65">#include &quot;nvim/version.h&quot;</a>
<a name="ln66">#include &quot;nvim/window.h&quot;</a>
<a name="ln67">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln68">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln69">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln70">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln71">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln72">#include &quot;nvim/event/rstream.h&quot;</a>
<a name="ln73">#include &quot;nvim/event/wstream.h&quot;</a>
<a name="ln74">#include &quot;nvim/shada.h&quot;</a>
<a name="ln75">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln76">#include &quot;nvim/globals.h&quot;</a>
<a name="ln77">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln78"> </a>
<a name="ln79">static int quitmore = 0;</a>
<a name="ln80">static bool ex_pressedreturn = false;</a>
<a name="ln81"> </a>
<a name="ln82">typedef struct ucmd {</a>
<a name="ln83">  char_u      *uc_name;         // The command name</a>
<a name="ln84">  uint32_t uc_argt;             // The argument type</a>
<a name="ln85">  char_u      *uc_rep;          // The command's replacement string</a>
<a name="ln86">  long uc_def;                  // The default value for a range/count</a>
<a name="ln87">  int uc_compl;                 // completion type</a>
<a name="ln88">  cmd_addr_T uc_addr_type;      // The command's address type</a>
<a name="ln89">  sctx_T uc_script_ctx;         // SCTX where the command was defined</a>
<a name="ln90">  char_u      *uc_compl_arg;    // completion argument if any</a>
<a name="ln91">} ucmd_T;</a>
<a name="ln92"> </a>
<a name="ln93">#define UC_BUFFER       1       /* -buffer: local to current buffer */</a>
<a name="ln94"> </a>
<a name="ln95">static garray_T ucmds = {0, 0, sizeof(ucmd_T), 4, NULL};</a>
<a name="ln96"> </a>
<a name="ln97">#define USER_CMD(i) (&amp;((ucmd_T *)(ucmds.ga_data))[i])</a>
<a name="ln98">#define USER_CMD_GA(gap, i) (&amp;((ucmd_T *)((gap)-&gt;ga_data))[i])</a>
<a name="ln99"> </a>
<a name="ln100">/* Wether a command index indicates a user command. */</a>
<a name="ln101"># define IS_USER_CMDIDX(idx) ((int)(idx) &lt; 0)</a>
<a name="ln102"> </a>
<a name="ln103">/* Struct for storing a line inside a while/for loop */</a>
<a name="ln104">typedef struct {</a>
<a name="ln105">  char_u      *line;            /* command line */</a>
<a name="ln106">  linenr_T lnum;                /* sourcing_lnum of the line */</a>
<a name="ln107">} wcmd_T;</a>
<a name="ln108"> </a>
<a name="ln109">#define FREE_WCMD(wcmd) xfree((wcmd)-&gt;line)</a>
<a name="ln110"> </a>
<a name="ln111">/*</a>
<a name="ln112"> * Structure used to store info for line position in a while or for loop.</a>
<a name="ln113"> * This is required, because do_one_cmd() may invoke ex_function(), which</a>
<a name="ln114"> * reads more lines that may come from the while/for loop.</a>
<a name="ln115"> */</a>
<a name="ln116">struct loop_cookie {</a>
<a name="ln117">  garray_T    *lines_gap;               // growarray with line info</a>
<a name="ln118">  int current_line;                     // last read line from growarray</a>
<a name="ln119">  int repeating;                        // TRUE when looping a second time</a>
<a name="ln120">  // When &quot;repeating&quot; is FALSE use &quot;getline&quot; and &quot;cookie&quot; to get lines</a>
<a name="ln121">  char_u      *(*getline)(int, void *, int, bool);</a>
<a name="ln122">  void        *cookie;</a>
<a name="ln123">};</a>
<a name="ln124"> </a>
<a name="ln125"> </a>
<a name="ln126">/* Struct to save a few things while debugging.  Used in do_cmdline() only. */</a>
<a name="ln127">struct dbg_stuff {</a>
<a name="ln128">  int trylevel;</a>
<a name="ln129">  int force_abort;</a>
<a name="ln130">  except_T    *caught_stack;</a>
<a name="ln131">  char_u      *vv_exception;</a>
<a name="ln132">  char_u      *vv_throwpoint;</a>
<a name="ln133">  int did_emsg;</a>
<a name="ln134">  int got_int;</a>
<a name="ln135">  int need_rethrow;</a>
<a name="ln136">  int check_cstack;</a>
<a name="ln137">  except_T    *current_exception;</a>
<a name="ln138">};</a>
<a name="ln139"> </a>
<a name="ln140">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln141"># include &quot;ex_docmd.c.generated.h&quot;</a>
<a name="ln142">#endif</a>
<a name="ln143"> </a>
<a name="ln144">#ifndef HAVE_WORKING_LIBINTL</a>
<a name="ln145"># define ex_language            ex_ni</a>
<a name="ln146">#endif</a>
<a name="ln147"> </a>
<a name="ln148">/*</a>
<a name="ln149"> * Declare cmdnames[].</a>
<a name="ln150"> */</a>
<a name="ln151">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln152"># include &quot;ex_cmds_defs.generated.h&quot;</a>
<a name="ln153">#endif</a>
<a name="ln154"> </a>
<a name="ln155">static char_u dollar_command[2] = {'$', 0};</a>
<a name="ln156"> </a>
<a name="ln157">static void save_dbg_stuff(struct dbg_stuff *dsp)</a>
<a name="ln158">{</a>
<a name="ln159">  dsp-&gt;trylevel       = trylevel;             trylevel = 0;</a>
<a name="ln160">  dsp-&gt;force_abort    = force_abort;          force_abort = FALSE;</a>
<a name="ln161">  dsp-&gt;caught_stack   = caught_stack;         caught_stack = NULL;</a>
<a name="ln162">  dsp-&gt;vv_exception   = v_exception(NULL);</a>
<a name="ln163">  dsp-&gt;vv_throwpoint  = v_throwpoint(NULL);</a>
<a name="ln164"> </a>
<a name="ln165">  // Necessary for debugging an inactive &quot;:catch&quot;, &quot;:finally&quot;, &quot;:endtry&quot;.</a>
<a name="ln166">  dsp-&gt;did_emsg       = did_emsg;             did_emsg     = false;</a>
<a name="ln167">  dsp-&gt;got_int        = got_int;              got_int      = false;</a>
<a name="ln168">  dsp-&gt;need_rethrow   = need_rethrow;         need_rethrow = false;</a>
<a name="ln169">  dsp-&gt;check_cstack   = check_cstack;         check_cstack = false;</a>
<a name="ln170">  dsp-&gt;current_exception = current_exception; current_exception = NULL;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">static void restore_dbg_stuff(struct dbg_stuff *dsp)</a>
<a name="ln174">{</a>
<a name="ln175">  suppress_errthrow = false;</a>
<a name="ln176">  trylevel = dsp-&gt;trylevel;</a>
<a name="ln177">  force_abort = dsp-&gt;force_abort;</a>
<a name="ln178">  caught_stack = dsp-&gt;caught_stack;</a>
<a name="ln179">  (void)v_exception(dsp-&gt;vv_exception);</a>
<a name="ln180">  (void)v_throwpoint(dsp-&gt;vv_throwpoint);</a>
<a name="ln181">  did_emsg = dsp-&gt;did_emsg;</a>
<a name="ln182">  got_int = dsp-&gt;got_int;</a>
<a name="ln183">  need_rethrow = dsp-&gt;need_rethrow;</a>
<a name="ln184">  check_cstack = dsp-&gt;check_cstack;</a>
<a name="ln185">  current_exception = dsp-&gt;current_exception;</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">/// Repeatedly get commands for Ex mode, until the &quot;:vi&quot; command is given.</a>
<a name="ln189">void do_exmode(int improved)</a>
<a name="ln190">{</a>
<a name="ln191">  int save_msg_scroll;</a>
<a name="ln192">  int prev_msg_row;</a>
<a name="ln193">  linenr_T prev_line;</a>
<a name="ln194">  int changedtick;</a>
<a name="ln195"> </a>
<a name="ln196">  if (improved)</a>
<a name="ln197">    exmode_active = EXMODE_VIM;</a>
<a name="ln198">  else</a>
<a name="ln199">    exmode_active = EXMODE_NORMAL;</a>
<a name="ln200">  State = NORMAL;</a>
<a name="ln201"> </a>
<a name="ln202">  /* When using &quot;:global /pat/ visual&quot; and then &quot;Q&quot; we return to continue</a>
<a name="ln203">   * the :global command. */</a>
<a name="ln204">  if (global_busy)</a>
<a name="ln205">    return;</a>
<a name="ln206"> </a>
<a name="ln207">  save_msg_scroll = msg_scroll;</a>
<a name="ln208">  RedrawingDisabled++;  // don't redisplay the window</a>
<a name="ln209">  no_wait_return++;  // don't wait for return</a>
<a name="ln210"> </a>
<a name="ln211">  MSG(_(&quot;Entering Ex mode.  Type \&quot;visual\&quot; to go to Normal mode.&quot;));</a>
<a name="ln212">  while (exmode_active) {</a>
<a name="ln213">    /* Check for a &quot;:normal&quot; command and no more characters left. */</a>
<a name="ln214">    if (ex_normal_busy &gt; 0 &amp;&amp; typebuf.tb_len == 0) {</a>
<a name="ln215">      exmode_active = FALSE;</a>
<a name="ln216">      break;</a>
<a name="ln217">    }</a>
<a name="ln218">    msg_scroll = true;</a>
<a name="ln219">    need_wait_return = false;</a>
<a name="ln220">    ex_pressedreturn = false;</a>
<a name="ln221">    ex_no_reprint = false;</a>
<a name="ln222">    changedtick = buf_get_changedtick(curbuf);</a>
<a name="ln223">    prev_msg_row = msg_row;</a>
<a name="ln224">    prev_line = curwin-&gt;w_cursor.lnum;</a>
<a name="ln225">    cmdline_row = msg_row;</a>
<a name="ln226">    do_cmdline(NULL, getexline, NULL, 0);</a>
<a name="ln227">    lines_left = Rows - 1;</a>
<a name="ln228"> </a>
<a name="ln229">    if ((prev_line != curwin-&gt;w_cursor.lnum</a>
<a name="ln230">         || changedtick != buf_get_changedtick(curbuf)) &amp;&amp; !ex_no_reprint) {</a>
<a name="ln231">      if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln232">        EMSG(_(e_emptybuf));</a>
<a name="ln233">      } else {</a>
<a name="ln234">        if (ex_pressedreturn) {</a>
<a name="ln235">          /* go up one line, to overwrite the &quot;:&lt;CR&gt;&quot; line, so the</a>
<a name="ln236">           * output doesn't contain empty lines. */</a>
<a name="ln237">          msg_row = prev_msg_row;</a>
<a name="ln238">          if (prev_msg_row == Rows - 1)</a>
<a name="ln239">            msg_row--;</a>
<a name="ln240">        }</a>
<a name="ln241">        msg_col = 0;</a>
<a name="ln242">        print_line_no_prefix(curwin-&gt;w_cursor.lnum, FALSE, FALSE);</a>
<a name="ln243">        msg_clr_eos();</a>
<a name="ln244">      }</a>
<a name="ln245">    } else if (ex_pressedreturn &amp;&amp; !ex_no_reprint) {  /* must be at EOF */</a>
<a name="ln246">      if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY)</a>
<a name="ln247">        EMSG(_(e_emptybuf));</a>
<a name="ln248">      else</a>
<a name="ln249">        EMSG(_(&quot;E501: At end-of-file&quot;));</a>
<a name="ln250">    }</a>
<a name="ln251">  }</a>
<a name="ln252"> </a>
<a name="ln253">  RedrawingDisabled--;</a>
<a name="ln254">  no_wait_return--;</a>
<a name="ln255">  redraw_all_later(NOT_VALID);</a>
<a name="ln256">  update_screen(NOT_VALID);</a>
<a name="ln257">  need_wait_return = false;</a>
<a name="ln258">  msg_scroll = save_msg_scroll;</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261">// Print the executed command for when 'verbose' is set.</a>
<a name="ln262">// When &quot;lnum&quot; is 0 only print the command.</a>
<a name="ln263">static void msg_verbose_cmd(linenr_T lnum, char_u *cmd)</a>
<a name="ln264">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln265">{</a>
<a name="ln266">  no_wait_return++;</a>
<a name="ln267">  verbose_enter_scroll();</a>
<a name="ln268"> </a>
<a name="ln269">  if (lnum == 0) {</a>
<a name="ln270">    smsg(_(&quot;Executing: %s&quot;), cmd);</a>
<a name="ln271">  } else {</a>
<a name="ln272">    smsg(_(&quot;line %&quot; PRIdLINENR &quot;: %s&quot;), lnum, cmd);</a>
<a name="ln273">  }</a>
<a name="ln274">  if (msg_silent == 0) {</a>
<a name="ln275">    msg_puts(&quot;\n&quot;);   // don't overwrite this</a>
<a name="ln276">  }</a>
<a name="ln277"> </a>
<a name="ln278">  verbose_leave_scroll();</a>
<a name="ln279">  no_wait_return--;</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">/*</a>
<a name="ln283"> * Execute a simple command line.  Used for translated commands like &quot;*&quot;.</a>
<a name="ln284"> */</a>
<a name="ln285">int do_cmdline_cmd(const char *cmd)</a>
<a name="ln286">{</a>
<a name="ln287">  return do_cmdline((char_u *)cmd, NULL, NULL,</a>
<a name="ln288">                    DOCMD_NOWAIT|DOCMD_KEYTYPED);</a>
<a name="ln289">}</a>
<a name="ln290"> </a>
<a name="ln291">/// do_cmdline(): execute one Ex command line</a>
<a name="ln292">///</a>
<a name="ln293">/// 1. Execute &quot;cmdline&quot; when it is not NULL.</a>
<a name="ln294">///    If &quot;cmdline&quot; is NULL, or more lines are needed, fgetline() is used.</a>
<a name="ln295">/// 2. Split up in parts separated with '|'.</a>
<a name="ln296">///</a>
<a name="ln297">/// This function can be called recursively!</a>
<a name="ln298">///</a>
<a name="ln299">/// flags:</a>
<a name="ln300">///   DOCMD_VERBOSE  - The command will be included in the error message.</a>
<a name="ln301">///   DOCMD_NOWAIT   - Don't call wait_return() and friends.</a>
<a name="ln302">///   DOCMD_REPEAT   - Repeat execution until fgetline() returns NULL.</a>
<a name="ln303">///   DOCMD_KEYTYPED - Don't reset KeyTyped.</a>
<a name="ln304">///   DOCMD_EXCRESET - Reset the exception environment (used for debugging).</a>
<a name="ln305">///   DOCMD_KEEPLINE - Store first typed line (for repeating with &quot;.&quot;).</a>
<a name="ln306">///</a>
<a name="ln307">/// @return FAIL if cmdline could not be executed, OK otherwise</a>
<a name="ln308">int do_cmdline(char_u *cmdline, LineGetter fgetline,</a>
<a name="ln309">               void *cookie, /* argument for fgetline() */</a>
<a name="ln310">               int flags)</a>
<a name="ln311">{</a>
<a name="ln312">  char_u      *next_cmdline;            /* next cmd to execute */</a>
<a name="ln313">  char_u      *cmdline_copy = NULL;     /* copy of cmd line */</a>
<a name="ln314">  int used_getline = FALSE;             /* used &quot;fgetline&quot; to obtain command */</a>
<a name="ln315">  static int recursive = 0;             /* recursive depth */</a>
<a name="ln316">  int msg_didout_before_start = 0;</a>
<a name="ln317">  int count = 0;                        /* line number count */</a>
<a name="ln318">  int did_inc = FALSE;                  /* incremented RedrawingDisabled */</a>
<a name="ln319">  int retval = OK;</a>
<a name="ln320">  cstack_T cstack = {                   // conditional stack</a>
<a name="ln321">    .cs_idx = -1,</a>
<a name="ln322">  };</a>
<a name="ln323">  garray_T lines_ga;                    // keep lines for &quot;:while&quot;/&quot;:for&quot;</a>
<a name="ln324">  int current_line = 0;                 // active line in lines_ga</a>
<a name="ln325">  char_u   *fname = NULL;               // function or script name</a>
<a name="ln326">  linenr_T *breakpoint = NULL;          // ptr to breakpoint field in cookie</a>
<a name="ln327">  int      *dbg_tick = NULL;            // ptr to dbg_tick field in cookie</a>
<a name="ln328">  struct dbg_stuff debug_saved;         // saved things for debug mode</a>
<a name="ln329">  int initial_trylevel;</a>
<a name="ln330">  struct msglist      **saved_msg_list = NULL;</a>
<a name="ln331">  struct msglist      *private_msg_list;</a>
<a name="ln332"> </a>
<a name="ln333">  // &quot;fgetline&quot; and &quot;cookie&quot; passed to do_one_cmd()</a>
<a name="ln334">  char_u      *(*cmd_getline)(int, void *, int, bool);</a>
<a name="ln335">  void        *cmd_cookie;</a>
<a name="ln336">  struct loop_cookie cmd_loop_cookie;</a>
<a name="ln337">  void        *real_cookie;</a>
<a name="ln338">  int getline_is_func;</a>
<a name="ln339">  static int call_depth = 0;            /* recursiveness */</a>
<a name="ln340"> </a>
<a name="ln341">  /* For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory</a>
<a name="ln342">   * location for storing error messages to be converted to an exception.</a>
<a name="ln343">   * This ensures that the do_errthrow() call in do_one_cmd() does not</a>
<a name="ln344">   * combine the messages stored by an earlier invocation of do_one_cmd()</a>
<a name="ln345">   * with the command name of the later one.  This would happen when</a>
<a name="ln346">   * BufWritePost autocommands are executed after a write error. */</a>
<a name="ln347">  saved_msg_list = msg_list;</a>
<a name="ln348">  msg_list = &amp;private_msg_list;</a>
<a name="ln349">  private_msg_list = NULL;</a>
<a name="ln350"> </a>
<a name="ln351">  // It's possible to create an endless loop with &quot;:execute&quot;, catch that</a>
<a name="ln352">  // here.  The value of 200 allows nested function calls, &quot;:source&quot;, etc.</a>
<a name="ln353">  // Allow 200 or 'maxfuncdepth', whatever is larger.</a>
<a name="ln354">  if (call_depth &gt;= 200 &amp;&amp; call_depth &gt;= p_mfd) {</a>
<a name="ln355">    EMSG(_(&quot;E169: Command too recursive&quot;));</a>
<a name="ln356">    // When converting to an exception, we do not include the command name</a>
<a name="ln357">    // since this is not an error of the specific command.</a>
<a name="ln358">    do_errthrow((cstack_T *)NULL, (char_u *)NULL);</a>
<a name="ln359">    msg_list = saved_msg_list;</a>
<a name="ln360">    return FAIL;</a>
<a name="ln361">  }</a>
<a name="ln362">  call_depth++;</a>
<a name="ln363">  start_batch_changes();</a>
<a name="ln364"> </a>
<a name="ln365">  ga_init(&amp;lines_ga, (int)sizeof(wcmd_T), 10);</a>
<a name="ln366"> </a>
<a name="ln367">  real_cookie = getline_cookie(fgetline, cookie);</a>
<a name="ln368"> </a>
<a name="ln369">  /* Inside a function use a higher nesting level. */</a>
<a name="ln370">  getline_is_func = getline_equal(fgetline, cookie, get_func_line);</a>
<a name="ln371">  if (getline_is_func &amp;&amp; ex_nesting_level == func_level(real_cookie))</a>
<a name="ln372">    ++ex_nesting_level;</a>
<a name="ln373"> </a>
<a name="ln374">  /* Get the function or script name and the address where the next breakpoint</a>
<a name="ln375">   * line and the debug tick for a function or script are stored. */</a>
<a name="ln376">  if (getline_is_func) {</a>
<a name="ln377">    fname = func_name(real_cookie);</a>
<a name="ln378">    breakpoint = func_breakpoint(real_cookie);</a>
<a name="ln379">    dbg_tick = func_dbg_tick(real_cookie);</a>
<a name="ln380">  } else if (getline_equal(fgetline, cookie, getsourceline)) {</a>
<a name="ln381">    fname = sourcing_name;</a>
<a name="ln382">    breakpoint = source_breakpoint(real_cookie);</a>
<a name="ln383">    dbg_tick = source_dbg_tick(real_cookie);</a>
<a name="ln384">  }</a>
<a name="ln385"> </a>
<a name="ln386">  /*</a>
<a name="ln387">   * Initialize &quot;force_abort&quot;  and &quot;suppress_errthrow&quot; at the top level.</a>
<a name="ln388">   */</a>
<a name="ln389">  if (!recursive) {</a>
<a name="ln390">    force_abort = false;</a>
<a name="ln391">    suppress_errthrow = false;</a>
<a name="ln392">  }</a>
<a name="ln393"> </a>
<a name="ln394">  // If requested, store and reset the global values controlling the</a>
<a name="ln395">  // exception handling (used when debugging).  Otherwise clear it to avoid</a>
<a name="ln396">  // a bogus compiler warning when the optimizer uses inline functions...</a>
<a name="ln397">  if (flags &amp; DOCMD_EXCRESET) {</a>
<a name="ln398">    save_dbg_stuff(&amp;debug_saved);</a>
<a name="ln399">  } else {</a>
<a name="ln400">    memset(&amp;debug_saved, 0, sizeof(debug_saved));</a>
<a name="ln401">  }</a>
<a name="ln402"> </a>
<a name="ln403">  initial_trylevel = trylevel;</a>
<a name="ln404"> </a>
<a name="ln405">  current_exception = NULL;</a>
<a name="ln406">  // &quot;did_emsg&quot; will be set to TRUE when emsg() is used, in which case we</a>
<a name="ln407">  // cancel the whole command line, and any if/endif or loop.</a>
<a name="ln408">  // If force_abort is set, we cancel everything.</a>
<a name="ln409">  did_emsg = false;</a>
<a name="ln410"> </a>
<a name="ln411">  // KeyTyped is only set when calling vgetc().  Reset it here when not</a>
<a name="ln412">  // calling vgetc() (sourced command lines).</a>
<a name="ln413">  if (!(flags &amp; DOCMD_KEYTYPED)</a>
<a name="ln414">      &amp;&amp; !getline_equal(fgetline, cookie, getexline)) {</a>
<a name="ln415">    KeyTyped = false;</a>
<a name="ln416">  }</a>
<a name="ln417"> </a>
<a name="ln418">  /*</a>
<a name="ln419">   * Continue executing command lines:</a>
<a name="ln420">   * - when inside an &quot;:if&quot;, &quot;:while&quot; or &quot;:for&quot;</a>
<a name="ln421">   * - for multiple commands on one line, separated with '|'</a>
<a name="ln422">   * - when repeating until there are no more lines (for &quot;:source&quot;)</a>
<a name="ln423">   */</a>
<a name="ln424">  next_cmdline = cmdline;</a>
<a name="ln425">  do {</a>
<a name="ln426">    getline_is_func = getline_equal(fgetline, cookie, get_func_line);</a>
<a name="ln427"> </a>
<a name="ln428">    /* stop skipping cmds for an error msg after all endif/while/for */</a>
<a name="ln429">    if (next_cmdline == NULL</a>
<a name="ln430">        &amp;&amp; !force_abort</a>
<a name="ln431">        &amp;&amp; cstack.cs_idx &lt; 0</a>
<a name="ln432">        &amp;&amp; !(getline_is_func &amp;&amp; func_has_abort(real_cookie))</a>
<a name="ln433">        )</a>
<a name="ln434">      did_emsg = FALSE;</a>
<a name="ln435"> </a>
<a name="ln436">    /*</a>
<a name="ln437">     * 1. If repeating a line in a loop, get a line from lines_ga.</a>
<a name="ln438">     * 2. If no line given: Get an allocated line with fgetline().</a>
<a name="ln439">     * 3. If a line is given: Make a copy, so we can mess with it.</a>
<a name="ln440">     */</a>
<a name="ln441"> </a>
<a name="ln442">    /* 1. If repeating, get a previous line from lines_ga. */</a>
<a name="ln443">    if (cstack.cs_looplevel &gt; 0 &amp;&amp; current_line &lt; lines_ga.ga_len) {</a>
<a name="ln444">      /* Each '|' separated command is stored separately in lines_ga, to</a>
<a name="ln445">       * be able to jump to it.  Don't use next_cmdline now. */</a>
<a name="ln446">      XFREE_CLEAR(cmdline_copy);</a>
<a name="ln447"> </a>
<a name="ln448">      /* Check if a function has returned or, unless it has an unclosed</a>
<a name="ln449">       * try conditional, aborted. */</a>
<a name="ln450">      if (getline_is_func) {</a>
<a name="ln451">        if (do_profiling == PROF_YES)</a>
<a name="ln452">          func_line_end(real_cookie);</a>
<a name="ln453">        if (func_has_ended(real_cookie)) {</a>
<a name="ln454">          retval = FAIL;</a>
<a name="ln455">          break;</a>
<a name="ln456">        }</a>
<a name="ln457">      } else if (do_profiling == PROF_YES</a>
<a name="ln458">                 &amp;&amp; getline_equal(fgetline, cookie, getsourceline))</a>
<a name="ln459">        script_line_end();</a>
<a name="ln460"> </a>
<a name="ln461">      /* Check if a sourced file hit a &quot;:finish&quot; command. */</a>
<a name="ln462">      if (source_finished(fgetline, cookie)) {</a>
<a name="ln463">        retval = FAIL;</a>
<a name="ln464">        break;</a>
<a name="ln465">      }</a>
<a name="ln466"> </a>
<a name="ln467">      /* If breakpoints have been added/deleted need to check for it. */</a>
<a name="ln468">      if (breakpoint != NULL &amp;&amp; dbg_tick != NULL</a>
<a name="ln469">          &amp;&amp; *dbg_tick != debug_tick) {</a>
<a name="ln470">        *breakpoint = dbg_find_breakpoint(</a>
<a name="ln471">            getline_equal(fgetline, cookie, getsourceline),</a>
<a name="ln472">            fname, sourcing_lnum);</a>
<a name="ln473">        *dbg_tick = debug_tick;</a>
<a name="ln474">      }</a>
<a name="ln475"> </a>
<a name="ln476">      next_cmdline = ((wcmd_T *)(lines_ga.ga_data))[current_line].line;</a>
<a name="ln477">      sourcing_lnum = ((wcmd_T *)(lines_ga.ga_data))[current_line].lnum;</a>
<a name="ln478"> </a>
<a name="ln479">      /* Did we encounter a breakpoint? */</a>
<a name="ln480">      if (breakpoint != NULL &amp;&amp; *breakpoint != 0</a>
<a name="ln481">          &amp;&amp; *breakpoint &lt;= sourcing_lnum) {</a>
<a name="ln482">        dbg_breakpoint(fname, sourcing_lnum);</a>
<a name="ln483">        /* Find next breakpoint. */</a>
<a name="ln484">        *breakpoint = dbg_find_breakpoint(</a>
<a name="ln485">            getline_equal(fgetline, cookie, getsourceline),</a>
<a name="ln486">            fname, sourcing_lnum);</a>
<a name="ln487">        *dbg_tick = debug_tick;</a>
<a name="ln488">      }</a>
<a name="ln489">      if (do_profiling == PROF_YES) {</a>
<a name="ln490">        if (getline_is_func)</a>
<a name="ln491">          func_line_start(real_cookie);</a>
<a name="ln492">        else if (getline_equal(fgetline, cookie, getsourceline))</a>
<a name="ln493">          script_line_start();</a>
<a name="ln494">      }</a>
<a name="ln495">    }</a>
<a name="ln496"> </a>
<a name="ln497">    if (cstack.cs_looplevel &gt; 0) {</a>
<a name="ln498">      /* Inside a while/for loop we need to store the lines and use them</a>
<a name="ln499">       * again.  Pass a different &quot;fgetline&quot; function to do_one_cmd()</a>
<a name="ln500">       * below, so that it stores lines in or reads them from</a>
<a name="ln501">       * &quot;lines_ga&quot;.  Makes it possible to define a function inside a</a>
<a name="ln502">       * while/for loop. */</a>
<a name="ln503">      cmd_getline = get_loop_line;</a>
<a name="ln504">      cmd_cookie = (void *)&amp;cmd_loop_cookie;</a>
<a name="ln505">      cmd_loop_cookie.lines_gap = &amp;lines_ga;</a>
<a name="ln506">      cmd_loop_cookie.current_line = current_line;</a>
<a name="ln507">      cmd_loop_cookie.getline = fgetline;</a>
<a name="ln508">      cmd_loop_cookie.cookie = cookie;</a>
<a name="ln509">      cmd_loop_cookie.repeating = (current_line &lt; lines_ga.ga_len);</a>
<a name="ln510">    } else {</a>
<a name="ln511">      cmd_getline = fgetline;</a>
<a name="ln512">      cmd_cookie = cookie;</a>
<a name="ln513">    }</a>
<a name="ln514"> </a>
<a name="ln515">    /* 2. If no line given, get an allocated line with fgetline(). */</a>
<a name="ln516">    if (next_cmdline == NULL) {</a>
<a name="ln517">      /*</a>
<a name="ln518">       * Need to set msg_didout for the first line after an &quot;:if&quot;,</a>
<a name="ln519">       * otherwise the &quot;:if&quot; will be overwritten.</a>
<a name="ln520">       */</a>
<a name="ln521">      if (count == 1 &amp;&amp; getline_equal(fgetline, cookie, getexline)) {</a>
<a name="ln522">        msg_didout = true;</a>
<a name="ln523">      }</a>
<a name="ln524">      if (fgetline == NULL</a>
<a name="ln525">          || (next_cmdline = fgetline(':', cookie,</a>
<a name="ln526">                                      cstack.cs_idx &lt;</a>
<a name="ln527">                                      0 ? 0 : (cstack.cs_idx + 1) * 2,</a>
<a name="ln528">                                      true)) == NULL) {</a>
<a name="ln529">        // Don't call wait_return for aborted command line.  The NULL</a>
<a name="ln530">        // returned for the end of a sourced file or executed function</a>
<a name="ln531">        // doesn't do this.</a>
<a name="ln532">        if (KeyTyped &amp;&amp; !(flags &amp; DOCMD_REPEAT)) {</a>
<a name="ln533">          need_wait_return = false;</a>
<a name="ln534">        }</a>
<a name="ln535">        retval = FAIL;</a>
<a name="ln536">        break;</a>
<a name="ln537">      }</a>
<a name="ln538">      used_getline = TRUE;</a>
<a name="ln539"> </a>
<a name="ln540">      /*</a>
<a name="ln541">       * Keep the first typed line.  Clear it when more lines are typed.</a>
<a name="ln542">       */</a>
<a name="ln543">      if (flags &amp; DOCMD_KEEPLINE) {</a>
<a name="ln544">        xfree(repeat_cmdline);</a>
<a name="ln545">        if (count == 0)</a>
<a name="ln546">          repeat_cmdline = vim_strsave(next_cmdline);</a>
<a name="ln547">        else</a>
<a name="ln548">          repeat_cmdline = NULL;</a>
<a name="ln549">      }</a>
<a name="ln550">    }</a>
<a name="ln551">    /* 3. Make a copy of the command so we can mess with it. */</a>
<a name="ln552">    else if (cmdline_copy == NULL) {</a>
<a name="ln553">      next_cmdline = vim_strsave(next_cmdline);</a>
<a name="ln554">    }</a>
<a name="ln555">    cmdline_copy = next_cmdline;</a>
<a name="ln556"> </a>
<a name="ln557">    /*</a>
<a name="ln558">     * Save the current line when inside a &quot;:while&quot; or &quot;:for&quot;, and when</a>
<a name="ln559">     * the command looks like a &quot;:while&quot; or &quot;:for&quot;, because we may need it</a>
<a name="ln560">     * later.  When there is a '|' and another command, it is stored</a>
<a name="ln561">     * separately, because we need to be able to jump back to it from an</a>
<a name="ln562">     * :endwhile/:endfor.</a>
<a name="ln563">     */</a>
<a name="ln564">    if (current_line == lines_ga.ga_len</a>
<a name="ln565">        &amp;&amp; (cstack.cs_looplevel || has_loop_cmd(next_cmdline))) {</a>
<a name="ln566">      store_loop_line(&amp;lines_ga, next_cmdline);</a>
<a name="ln567">    }</a>
<a name="ln568">    did_endif = FALSE;</a>
<a name="ln569"> </a>
<a name="ln570">    if (count++ == 0) {</a>
<a name="ln571">      /*</a>
<a name="ln572">       * All output from the commands is put below each other, without</a>
<a name="ln573">       * waiting for a return. Don't do this when executing commands</a>
<a name="ln574">       * from a script or when being called recursive (e.g. for &quot;:e</a>
<a name="ln575">       * +command file&quot;).</a>
<a name="ln576">       */</a>
<a name="ln577">      if (!(flags &amp; DOCMD_NOWAIT) &amp;&amp; !recursive) {</a>
<a name="ln578">        msg_didout_before_start = msg_didout;</a>
<a name="ln579">        msg_didany = FALSE;         /* no output yet */</a>
<a name="ln580">        msg_start();</a>
<a name="ln581">        msg_scroll = TRUE;          /* put messages below each other */</a>
<a name="ln582">        ++no_wait_return;           /* don't wait for return until finished */</a>
<a name="ln583">        ++RedrawingDisabled;</a>
<a name="ln584">        did_inc = TRUE;</a>
<a name="ln585">      }</a>
<a name="ln586">    }</a>
<a name="ln587"> </a>
<a name="ln588">    if ((p_verbose &gt;= 15 &amp;&amp; sourcing_name != NULL) || p_verbose &gt;= 16) {</a>
<a name="ln589">      msg_verbose_cmd(sourcing_lnum, cmdline_copy);</a>
<a name="ln590">    }</a>
<a name="ln591"> </a>
<a name="ln592">    /*</a>
<a name="ln593">     * 2. Execute one '|' separated command.</a>
<a name="ln594">     *    do_one_cmd() will return NULL if there is no trailing '|'.</a>
<a name="ln595">     *    &quot;cmdline_copy&quot; can change, e.g. for '%' and '#' expansion.</a>
<a name="ln596">     */</a>
<a name="ln597">    recursive++;</a>
<a name="ln598">    next_cmdline = do_one_cmd(&amp;cmdline_copy, flags,</a>
<a name="ln599">                              &amp;cstack,</a>
<a name="ln600">                              cmd_getline, cmd_cookie);</a>
<a name="ln601">    recursive--;</a>
<a name="ln602"> </a>
<a name="ln603">    // Ignore trailing '|'-separated commands in preview-mode ('inccommand').</a>
<a name="ln604">    if (State &amp; CMDPREVIEW) {</a>
<a name="ln605">      next_cmdline = NULL;</a>
<a name="ln606">    }</a>
<a name="ln607"> </a>
<a name="ln608">    if (cmd_cookie == (void *)&amp;cmd_loop_cookie)</a>
<a name="ln609">      /* Use &quot;current_line&quot; from &quot;cmd_loop_cookie&quot;, it may have been</a>
<a name="ln610">       * incremented when defining a function. */</a>
<a name="ln611">      current_line = cmd_loop_cookie.current_line;</a>
<a name="ln612"> </a>
<a name="ln613">    if (next_cmdline == NULL) {</a>
<a name="ln614">      XFREE_CLEAR(cmdline_copy);</a>
<a name="ln615">      //</a>
<a name="ln616">      // If the command was typed, remember it for the ':' register.</a>
<a name="ln617">      // Do this AFTER executing the command to make :@: work.</a>
<a name="ln618">      //</a>
<a name="ln619">      if (getline_equal(fgetline, cookie, getexline)</a>
<a name="ln620">          &amp;&amp; new_last_cmdline != NULL) {</a>
<a name="ln621">        xfree(last_cmdline);</a>
<a name="ln622">        last_cmdline = new_last_cmdline;</a>
<a name="ln623">        new_last_cmdline = NULL;</a>
<a name="ln624">      }</a>
<a name="ln625">    } else {</a>
<a name="ln626">      /* need to copy the command after the '|' to cmdline_copy, for the</a>
<a name="ln627">       * next do_one_cmd() */</a>
<a name="ln628">      STRMOVE(cmdline_copy, next_cmdline);</a>
<a name="ln629">      next_cmdline = cmdline_copy;</a>
<a name="ln630">    }</a>
<a name="ln631"> </a>
<a name="ln632"> </a>
<a name="ln633">    /* reset did_emsg for a function that is not aborted by an error */</a>
<a name="ln634">    if (did_emsg &amp;&amp; !force_abort</a>
<a name="ln635">        &amp;&amp; getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln636">        &amp;&amp; !func_has_abort(real_cookie))</a>
<a name="ln637">      did_emsg = FALSE;</a>
<a name="ln638"> </a>
<a name="ln639">    if (cstack.cs_looplevel &gt; 0) {</a>
<a name="ln640">      ++current_line;</a>
<a name="ln641"> </a>
<a name="ln642">      /*</a>
<a name="ln643">       * An &quot;:endwhile&quot;, &quot;:endfor&quot; and &quot;:continue&quot; is handled here.</a>
<a name="ln644">       * If we were executing commands, jump back to the &quot;:while&quot; or</a>
<a name="ln645">       * &quot;:for&quot;.</a>
<a name="ln646">       * If we were not executing commands, decrement cs_looplevel.</a>
<a name="ln647">       */</a>
<a name="ln648">      if (cstack.cs_lflags &amp; (CSL_HAD_CONT | CSL_HAD_ENDLOOP)) {</a>
<a name="ln649">        cstack.cs_lflags &amp;= ~(CSL_HAD_CONT | CSL_HAD_ENDLOOP);</a>
<a name="ln650"> </a>
<a name="ln651">        /* Jump back to the matching &quot;:while&quot; or &quot;:for&quot;.  Be careful</a>
<a name="ln652">         * not to use a cs_line[] from an entry that isn't a &quot;:while&quot;</a>
<a name="ln653">         * or &quot;:for&quot;: It would make &quot;current_line&quot; invalid and can</a>
<a name="ln654">         * cause a crash. */</a>
<a name="ln655">        if (!did_emsg &amp;&amp; !got_int &amp;&amp; !current_exception</a>
<a name="ln656">            &amp;&amp; cstack.cs_idx &gt;= 0</a>
<a name="ln657">            &amp;&amp; (cstack.cs_flags[cstack.cs_idx]</a>
<a name="ln658">                &amp; (CSF_WHILE | CSF_FOR))</a>
<a name="ln659">            &amp;&amp; cstack.cs_line[cstack.cs_idx] &gt;= 0</a>
<a name="ln660">            &amp;&amp; (cstack.cs_flags[cstack.cs_idx] &amp; CSF_ACTIVE)) {</a>
<a name="ln661">          current_line = cstack.cs_line[cstack.cs_idx];</a>
<a name="ln662">          /* remember we jumped there */</a>
<a name="ln663">          cstack.cs_lflags |= CSL_HAD_LOOP;</a>
<a name="ln664">          line_breakcheck();                    /* check if CTRL-C typed */</a>
<a name="ln665"> </a>
<a name="ln666">          /* Check for the next breakpoint at or after the &quot;:while&quot;</a>
<a name="ln667">           * or &quot;:for&quot;. */</a>
<a name="ln668">          if (breakpoint != NULL) {</a>
<a name="ln669">            *breakpoint = dbg_find_breakpoint(</a>
<a name="ln670">                getline_equal(fgetline, cookie, getsourceline),</a>
<a name="ln671">                fname,</a>
<a name="ln672">                ((wcmd_T *)lines_ga.ga_data)[current_line].lnum-1);</a>
<a name="ln673">            *dbg_tick = debug_tick;</a>
<a name="ln674">          }</a>
<a name="ln675">        } else {</a>
<a name="ln676">          /* can only get here with &quot;:endwhile&quot; or &quot;:endfor&quot; */</a>
<a name="ln677">          if (cstack.cs_idx &gt;= 0)</a>
<a name="ln678">            rewind_conditionals(&amp;cstack, cstack.cs_idx - 1,</a>
<a name="ln679">                CSF_WHILE | CSF_FOR, &amp;cstack.cs_looplevel);</a>
<a name="ln680">        }</a>
<a name="ln681">      }</a>
<a name="ln682">      /*</a>
<a name="ln683">       * For a &quot;:while&quot; or &quot;:for&quot; we need to remember the line number.</a>
<a name="ln684">       */</a>
<a name="ln685">      else if (cstack.cs_lflags &amp; CSL_HAD_LOOP) {</a>
<a name="ln686">        cstack.cs_lflags &amp;= ~CSL_HAD_LOOP;</a>
<a name="ln687">        cstack.cs_line[cstack.cs_idx] = current_line - 1;</a>
<a name="ln688">      }</a>
<a name="ln689">    }</a>
<a name="ln690"> </a>
<a name="ln691">    /*</a>
<a name="ln692">     * When not inside any &quot;:while&quot; loop, clear remembered lines.</a>
<a name="ln693">     */</a>
<a name="ln694">    if (cstack.cs_looplevel == 0) {</a>
<a name="ln695">      if (!GA_EMPTY(&amp;lines_ga)) {</a>
<a name="ln696">        sourcing_lnum = ((wcmd_T *)lines_ga.ga_data)[lines_ga.ga_len - 1].lnum;</a>
<a name="ln697">        GA_DEEP_CLEAR(&amp;lines_ga, wcmd_T, FREE_WCMD);</a>
<a name="ln698">      }</a>
<a name="ln699">      current_line = 0;</a>
<a name="ln700">    }</a>
<a name="ln701"> </a>
<a name="ln702">    /*</a>
<a name="ln703">     * A &quot;:finally&quot; makes did_emsg, got_int and current_exception pending for</a>
<a name="ln704">     * being restored at the &quot;:endtry&quot;.  Reset them here and set the</a>
<a name="ln705">     * ACTIVE and FINALLY flags, so that the finally clause gets executed.</a>
<a name="ln706">     * This includes the case where a missing &quot;:endif&quot;, &quot;:endwhile&quot; or</a>
<a name="ln707">     * &quot;:endfor&quot; was detected by the &quot;:finally&quot; itself.</a>
<a name="ln708">     */</a>
<a name="ln709">    if (cstack.cs_lflags &amp; CSL_HAD_FINA) {</a>
<a name="ln710">      cstack.cs_lflags &amp;= ~CSL_HAD_FINA;</a>
<a name="ln711">      report_make_pending((cstack.cs_pending[cstack.cs_idx]</a>
<a name="ln712">                           &amp; (CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW)),</a>
<a name="ln713">                          current_exception);</a>
<a name="ln714">      did_emsg = got_int = false;</a>
<a name="ln715">      current_exception = NULL;</a>
<a name="ln716">      cstack.cs_flags[cstack.cs_idx] |= CSF_ACTIVE | CSF_FINALLY;</a>
<a name="ln717">    }</a>
<a name="ln718"> </a>
<a name="ln719">    /* Update global &quot;trylevel&quot; for recursive calls to do_cmdline() from</a>
<a name="ln720">     * within this loop. */</a>
<a name="ln721">    trylevel = initial_trylevel + cstack.cs_trylevel;</a>
<a name="ln722"> </a>
<a name="ln723">    // If the outermost try conditional (across function calls and sourced</a>
<a name="ln724">    // files) is aborted because of an error, an interrupt, or an uncaught</a>
<a name="ln725">    // exception, cancel everything.  If it is left normally, reset</a>
<a name="ln726">    // force_abort to get the non-EH compatible abortion behavior for</a>
<a name="ln727">    // the rest of the script.</a>
<a name="ln728">    if (trylevel == 0 &amp;&amp; !did_emsg &amp;&amp; !got_int &amp;&amp; !current_exception) {</a>
<a name="ln729">      force_abort = false;</a>
<a name="ln730">    }</a>
<a name="ln731"> </a>
<a name="ln732">    /* Convert an interrupt to an exception if appropriate. */</a>
<a name="ln733">    (void)do_intthrow(&amp;cstack);</a>
<a name="ln734"> </a>
<a name="ln735">  }</a>
<a name="ln736">  /*</a>
<a name="ln737">   * Continue executing command lines when:</a>
<a name="ln738">   * - no CTRL-C typed, no aborting error, no exception thrown or try</a>
<a name="ln739">   *   conditionals need to be checked for executing finally clauses or</a>
<a name="ln740">   *   catching an interrupt exception</a>
<a name="ln741">   * - didn't get an error message or lines are not typed</a>
<a name="ln742">   * - there is a command after '|', inside a :if, :while, :for or :try, or</a>
<a name="ln743">   *   looping for &quot;:source&quot; command or function call.</a>
<a name="ln744">   */</a>
<a name="ln745">  while (!((got_int || (did_emsg &amp;&amp; force_abort) || current_exception)</a>
<a name="ln746">           &amp;&amp; cstack.cs_trylevel == 0)</a>
<a name="ln747">         &amp;&amp; !(did_emsg</a>
<a name="ln748">              /* Keep going when inside try/catch, so that the error can be</a>
<a name="ln749">               * deal with, except when it is a syntax error, it may cause</a>
<a name="ln750">               * the :endtry to be missed. */</a>
<a name="ln751">              &amp;&amp; (cstack.cs_trylevel == 0 || did_emsg_syntax)</a>
<a name="ln752">              &amp;&amp; used_getline</a>
<a name="ln753">              &amp;&amp; (getline_equal(fgetline, cookie, getexmodeline)</a>
<a name="ln754">                  || getline_equal(fgetline, cookie, getexline)))</a>
<a name="ln755">         &amp;&amp; (next_cmdline != NULL</a>
<a name="ln756">             || cstack.cs_idx &gt;= 0</a>
<a name="ln757">             || (flags &amp; DOCMD_REPEAT)));</a>
<a name="ln758"> </a>
<a name="ln759">  xfree(cmdline_copy);</a>
<a name="ln760">  did_emsg_syntax = FALSE;</a>
<a name="ln761">  GA_DEEP_CLEAR(&amp;lines_ga, wcmd_T, FREE_WCMD);</a>
<a name="ln762"> </a>
<a name="ln763">  if (cstack.cs_idx &gt;= 0) {</a>
<a name="ln764">    /*</a>
<a name="ln765">     * If a sourced file or executed function ran to its end, report the</a>
<a name="ln766">     * unclosed conditional.</a>
<a name="ln767">     */</a>
<a name="ln768">    if (!got_int &amp;&amp; !current_exception</a>
<a name="ln769">        &amp;&amp; ((getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln770">             &amp;&amp; !source_finished(fgetline, cookie))</a>
<a name="ln771">            || (getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln772">                &amp;&amp; !func_has_ended(real_cookie)))) {</a>
<a name="ln773">      if (cstack.cs_flags[cstack.cs_idx] &amp; CSF_TRY)</a>
<a name="ln774">        EMSG(_(e_endtry));</a>
<a name="ln775">      else if (cstack.cs_flags[cstack.cs_idx] &amp; CSF_WHILE)</a>
<a name="ln776">        EMSG(_(e_endwhile));</a>
<a name="ln777">      else if (cstack.cs_flags[cstack.cs_idx] &amp; CSF_FOR)</a>
<a name="ln778">        EMSG(_(e_endfor));</a>
<a name="ln779">      else</a>
<a name="ln780">        EMSG(_(e_endif));</a>
<a name="ln781">    }</a>
<a name="ln782"> </a>
<a name="ln783">    /*</a>
<a name="ln784">     * Reset &quot;trylevel&quot; in case of a &quot;:finish&quot; or &quot;:return&quot; or a missing</a>
<a name="ln785">     * &quot;:endtry&quot; in a sourced file or executed function.  If the try</a>
<a name="ln786">     * conditional is in its finally clause, ignore anything pending.</a>
<a name="ln787">     * If it is in a catch clause, finish the caught exception.</a>
<a name="ln788">     * Also cleanup any &quot;cs_forinfo&quot; structures.</a>
<a name="ln789">     */</a>
<a name="ln790">    do {</a>
<a name="ln791">      int idx = cleanup_conditionals(&amp;cstack, 0, TRUE);</a>
<a name="ln792"> </a>
<a name="ln793">      if (idx &gt;= 0)</a>
<a name="ln794">        --idx;              /* remove try block not in its finally clause */</a>
<a name="ln795">      rewind_conditionals(&amp;cstack, idx, CSF_WHILE | CSF_FOR,</a>
<a name="ln796">          &amp;cstack.cs_looplevel);</a>
<a name="ln797">    } while (cstack.cs_idx &gt;= 0);</a>
<a name="ln798">    trylevel = initial_trylevel;</a>
<a name="ln799">  }</a>
<a name="ln800"> </a>
<a name="ln801">  /* If a missing &quot;:endtry&quot;, &quot;:endwhile&quot;, &quot;:endfor&quot;, or &quot;:endif&quot; or a memory</a>
<a name="ln802">   * lack was reported above and the error message is to be converted to an</a>
<a name="ln803">   * exception, do this now after rewinding the cstack. */</a>
<a name="ln804">  do_errthrow(&amp;cstack, getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln805">      ? (char_u *)&quot;endfunction&quot; : (char_u *)NULL);</a>
<a name="ln806"> </a>
<a name="ln807">  if (trylevel == 0) {</a>
<a name="ln808">    // When an exception is being thrown out of the outermost try</a>
<a name="ln809">    // conditional, discard the uncaught exception, disable the conversion</a>
<a name="ln810">    // of interrupts or errors to exceptions, and ensure that no more</a>
<a name="ln811">    // commands are executed.</a>
<a name="ln812">    if (current_exception) {</a>
<a name="ln813">      void *p = NULL;</a>
<a name="ln814">      char_u *saved_sourcing_name;</a>
<a name="ln815">      int saved_sourcing_lnum;</a>
<a name="ln816">      struct msglist *messages = NULL;</a>
<a name="ln817">      struct msglist *next;</a>
<a name="ln818"> </a>
<a name="ln819">      /*</a>
<a name="ln820">       * If the uncaught exception is a user exception, report it as an</a>
<a name="ln821">       * error.  If it is an error exception, display the saved error</a>
<a name="ln822">       * message now.  For an interrupt exception, do nothing; the</a>
<a name="ln823">       * interrupt message is given elsewhere.</a>
<a name="ln824">       */</a>
<a name="ln825">      switch (current_exception-&gt;type) {</a>
<a name="ln826">      case ET_USER:</a>
<a name="ln827">        vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln828">            _(&quot;E605: Exception not caught: %s&quot;),</a>
<a name="ln829">            current_exception-&gt;value);</a>
<a name="ln830">        p = vim_strsave(IObuff);</a>
<a name="ln831">        break;</a>
<a name="ln832">      case ET_ERROR:</a>
<a name="ln833">        messages = current_exception-&gt;messages;</a>
<a name="ln834">        current_exception-&gt;messages = NULL;</a>
<a name="ln835">        break;</a>
<a name="ln836">      case ET_INTERRUPT:</a>
<a name="ln837">        break;</a>
<a name="ln838">      }</a>
<a name="ln839"> </a>
<a name="ln840">      saved_sourcing_name = sourcing_name;</a>
<a name="ln841">      saved_sourcing_lnum = sourcing_lnum;</a>
<a name="ln842">      sourcing_name = current_exception-&gt;throw_name;</a>
<a name="ln843">      sourcing_lnum = current_exception-&gt;throw_lnum;</a>
<a name="ln844">      current_exception-&gt;throw_name = NULL;</a>
<a name="ln845"> </a>
<a name="ln846">      discard_current_exception();              // uses IObuff if 'verbose'</a>
<a name="ln847">      suppress_errthrow = true;</a>
<a name="ln848">      force_abort = true;</a>
<a name="ln849">      msg_ext_set_kind(&quot;emsg&quot;);  // kind=emsg for :throw, exceptions. #9993</a>
<a name="ln850"> </a>
<a name="ln851">      if (messages != NULL) {</a>
<a name="ln852">        do {</a>
<a name="ln853">          next = messages-&gt;next;</a>
<a name="ln854">          emsg(messages-&gt;msg);</a>
<a name="ln855">          xfree(messages-&gt;msg);</a>
<a name="ln856">          xfree(messages);</a>
<a name="ln857">          messages = next;</a>
<a name="ln858">        } while (messages != NULL);</a>
<a name="ln859">      } else if (p != NULL) {</a>
<a name="ln860">        emsg(p);</a>
<a name="ln861">        xfree(p);</a>
<a name="ln862">      }</a>
<a name="ln863">      xfree(sourcing_name);</a>
<a name="ln864">      sourcing_name = saved_sourcing_name;</a>
<a name="ln865">      sourcing_lnum = saved_sourcing_lnum;</a>
<a name="ln866">    } else if (got_int || (did_emsg &amp;&amp; force_abort)) {</a>
<a name="ln867">      // On an interrupt or an aborting error not converted to an exception,</a>
<a name="ln868">      // disable the conversion of errors to exceptions.  (Interrupts are not</a>
<a name="ln869">      // converted any more, here.) This enables also the interrupt message</a>
<a name="ln870">      // when force_abort is set and did_emsg unset in case of an interrupt</a>
<a name="ln871">      // from a finally clause after an error.</a>
<a name="ln872">      suppress_errthrow = true;</a>
<a name="ln873">    }</a>
<a name="ln874">  }</a>
<a name="ln875"> </a>
<a name="ln876">  // The current cstack will be freed when do_cmdline() returns.  An uncaught</a>
<a name="ln877">  // exception will have to be rethrown in the previous cstack.  If a function</a>
<a name="ln878">  // has just returned or a script file was just finished and the previous</a>
<a name="ln879">  // cstack belongs to the same function or, respectively, script file, it</a>
<a name="ln880">  // will have to be checked for finally clauses to be executed due to the</a>
<a name="ln881">  // &quot;:return&quot; or &quot;:finish&quot;.  This is done in do_one_cmd().</a>
<a name="ln882">  if (current_exception) {</a>
<a name="ln883">    need_rethrow = true;</a>
<a name="ln884">  }</a>
<a name="ln885">  if ((getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln886">       &amp;&amp; ex_nesting_level &gt; source_level(real_cookie))</a>
<a name="ln887">      || (getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln888">          &amp;&amp; ex_nesting_level &gt; func_level(real_cookie) + 1)) {</a>
<a name="ln889">    if (!current_exception) {</a>
<a name="ln890">      check_cstack = true;</a>
<a name="ln891">    }</a>
<a name="ln892">  } else {</a>
<a name="ln893">    /* When leaving a function, reduce nesting level. */</a>
<a name="ln894">    if (getline_equal(fgetline, cookie, get_func_line))</a>
<a name="ln895">      --ex_nesting_level;</a>
<a name="ln896">    /*</a>
<a name="ln897">     * Go to debug mode when returning from a function in which we are</a>
<a name="ln898">     * single-stepping.</a>
<a name="ln899">     */</a>
<a name="ln900">    if ((getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln901">         || getline_equal(fgetline, cookie, get_func_line))</a>
<a name="ln902">        &amp;&amp; ex_nesting_level + 1 &lt;= debug_break_level)</a>
<a name="ln903">      do_debug(getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln904">          ? (char_u *)_(&quot;End of sourced file&quot;)</a>
<a name="ln905">          : (char_u *)_(&quot;End of function&quot;));</a>
<a name="ln906">  }</a>
<a name="ln907"> </a>
<a name="ln908">  /*</a>
<a name="ln909">   * Restore the exception environment (done after returning from the</a>
<a name="ln910">   * debugger).</a>
<a name="ln911">   */</a>
<a name="ln912">  if (flags &amp; DOCMD_EXCRESET)</a>
<a name="ln913">    restore_dbg_stuff(&amp;debug_saved);</a>
<a name="ln914"> </a>
<a name="ln915">  msg_list = saved_msg_list;</a>
<a name="ln916"> </a>
<a name="ln917">  /*</a>
<a name="ln918">   * If there was too much output to fit on the command line, ask the user to</a>
<a name="ln919">   * hit return before redrawing the screen. With the &quot;:global&quot; command we do</a>
<a name="ln920">   * this only once after the command is finished.</a>
<a name="ln921">   */</a>
<a name="ln922">  if (did_inc) {</a>
<a name="ln923">    --RedrawingDisabled;</a>
<a name="ln924">    --no_wait_return;</a>
<a name="ln925">    msg_scroll = FALSE;</a>
<a name="ln926"> </a>
<a name="ln927">    /*</a>
<a name="ln928">     * When just finished an &quot;:if&quot;-&quot;:else&quot; which was typed, no need to</a>
<a name="ln929">     * wait for hit-return.  Also for an error situation.</a>
<a name="ln930">     */</a>
<a name="ln931">    if (retval == FAIL</a>
<a name="ln932">        || (did_endif &amp;&amp; KeyTyped &amp;&amp; !did_emsg)</a>
<a name="ln933">        ) {</a>
<a name="ln934">      need_wait_return = FALSE;</a>
<a name="ln935">      msg_didany = FALSE;               /* don't wait when restarting edit */</a>
<a name="ln936">    } else if (need_wait_return) {</a>
<a name="ln937">      /*</a>
<a name="ln938">       * The msg_start() above clears msg_didout. The wait_return we do</a>
<a name="ln939">       * here should not overwrite the command that may be shown before</a>
<a name="ln940">       * doing that.</a>
<a name="ln941">       */</a>
<a name="ln942">      msg_didout |= msg_didout_before_start;</a>
<a name="ln943">      wait_return(FALSE);</a>
<a name="ln944">    }</a>
<a name="ln945">  }</a>
<a name="ln946"> </a>
<a name="ln947">  did_endif = FALSE;    /* in case do_cmdline used recursively */</a>
<a name="ln948"> </a>
<a name="ln949">  call_depth--;</a>
<a name="ln950">  end_batch_changes();</a>
<a name="ln951">  return retval;</a>
<a name="ln952">}</a>
<a name="ln953"> </a>
<a name="ln954">/*</a>
<a name="ln955"> * Obtain a line when inside a &quot;:while&quot; or &quot;:for&quot; loop.</a>
<a name="ln956"> */</a>
<a name="ln957">static char_u *get_loop_line(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln958">{</a>
<a name="ln959">  struct loop_cookie  *cp = (struct loop_cookie *)cookie;</a>
<a name="ln960">  wcmd_T              *wp;</a>
<a name="ln961">  char_u              *line;</a>
<a name="ln962"> </a>
<a name="ln963">  if (cp-&gt;current_line + 1 &gt;= cp-&gt;lines_gap-&gt;ga_len) {</a>
<a name="ln964">    if (cp-&gt;repeating)</a>
<a name="ln965">      return NULL;              /* trying to read past &quot;:endwhile&quot;/&quot;:endfor&quot; */</a>
<a name="ln966"> </a>
<a name="ln967">    // First time inside the &quot;:while&quot;/&quot;:for&quot;: get line normally.</a>
<a name="ln968">    if (cp-&gt;getline == NULL) {</a>
<a name="ln969">      line = getcmdline(c, 0L, indent, do_concat);</a>
<a name="ln970">    } else {</a>
<a name="ln971">      line = cp-&gt;getline(c, cp-&gt;cookie, indent, do_concat);</a>
<a name="ln972">    }</a>
<a name="ln973">    if (line != NULL) {</a>
<a name="ln974">      store_loop_line(cp-&gt;lines_gap, line);</a>
<a name="ln975">      ++cp-&gt;current_line;</a>
<a name="ln976">    }</a>
<a name="ln977"> </a>
<a name="ln978">    return line;</a>
<a name="ln979">  }</a>
<a name="ln980"> </a>
<a name="ln981">  KeyTyped = false;</a>
<a name="ln982">  cp-&gt;current_line++;</a>
<a name="ln983">  wp = (wcmd_T *)(cp-&gt;lines_gap-&gt;ga_data) + cp-&gt;current_line;</a>
<a name="ln984">  sourcing_lnum = wp-&gt;lnum;</a>
<a name="ln985">  return vim_strsave(wp-&gt;line);</a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988">/*</a>
<a name="ln989"> * Store a line in &quot;gap&quot; so that a &quot;:while&quot; loop can execute it again.</a>
<a name="ln990"> */</a>
<a name="ln991">static void store_loop_line(garray_T *gap, char_u *line)</a>
<a name="ln992">{</a>
<a name="ln993">  wcmd_T *p = GA_APPEND_VIA_PTR(wcmd_T, gap);</a>
<a name="ln994">  p-&gt;line = vim_strsave(line);</a>
<a name="ln995">  p-&gt;lnum = sourcing_lnum;</a>
<a name="ln996">}</a>
<a name="ln997"> </a>
<a name="ln998">/*</a>
<a name="ln999"> * If &quot;fgetline&quot; is get_loop_line(), return TRUE if the getline it uses equals</a>
<a name="ln1000"> * &quot;func&quot;.  * Otherwise return TRUE when &quot;fgetline&quot; equals &quot;func&quot;.</a>
<a name="ln1001"> */</a>
<a name="ln1002">int getline_equal(LineGetter fgetline,</a>
<a name="ln1003">                  void *cookie, /* argument for fgetline() */</a>
<a name="ln1004">                  LineGetter func)</a>
<a name="ln1005">{</a>
<a name="ln1006">  LineGetter gp;</a>
<a name="ln1007">  struct loop_cookie *cp;</a>
<a name="ln1008"> </a>
<a name="ln1009">  /* When &quot;fgetline&quot; is &quot;get_loop_line()&quot; use the &quot;cookie&quot; to find the</a>
<a name="ln1010">   * function that's originally used to obtain the lines.  This may be</a>
<a name="ln1011">   * nested several levels. */</a>
<a name="ln1012">  gp = fgetline;</a>
<a name="ln1013">  cp = (struct loop_cookie *)cookie;</a>
<a name="ln1014">  while (gp == get_loop_line) {</a>
<a name="ln1015">    gp = cp-&gt;getline;</a>
<a name="ln1016">    cp = cp-&gt;cookie;</a>
<a name="ln1017">  }</a>
<a name="ln1018">  return gp == func;</a>
<a name="ln1019">}</a>
<a name="ln1020"> </a>
<a name="ln1021">/*</a>
<a name="ln1022"> * If &quot;fgetline&quot; is get_loop_line(), return the cookie used by the original</a>
<a name="ln1023"> * getline function.  Otherwise return &quot;cookie&quot;.</a>
<a name="ln1024"> */</a>
<a name="ln1025">void * getline_cookie(LineGetter fgetline,</a>
<a name="ln1026">                      void *cookie /* argument for fgetline() */</a>
<a name="ln1027">                      )</a>
<a name="ln1028">{</a>
<a name="ln1029">  LineGetter gp;</a>
<a name="ln1030">  struct loop_cookie *cp;</a>
<a name="ln1031"> </a>
<a name="ln1032">  /* When &quot;fgetline&quot; is &quot;get_loop_line()&quot; use the &quot;cookie&quot; to find the</a>
<a name="ln1033">   * cookie that's originally used to obtain the lines.  This may be nested</a>
<a name="ln1034">   * several levels. */</a>
<a name="ln1035">  gp = fgetline;</a>
<a name="ln1036">  cp = (struct loop_cookie *)cookie;</a>
<a name="ln1037">  while (gp == get_loop_line) {</a>
<a name="ln1038">    gp = cp-&gt;getline;</a>
<a name="ln1039">    cp = cp-&gt;cookie;</a>
<a name="ln1040">  }</a>
<a name="ln1041">  return cp;</a>
<a name="ln1042">}</a>
<a name="ln1043"> </a>
<a name="ln1044">/*</a>
<a name="ln1045"> * Helper function to apply an offset for buffer commands, i.e. &quot;:bdelete&quot;,</a>
<a name="ln1046"> * &quot;:bwipeout&quot;, etc.</a>
<a name="ln1047"> * Returns the buffer number.</a>
<a name="ln1048"> */</a>
<a name="ln1049">static int compute_buffer_local_count(int addr_type, int lnum, int offset)</a>
<a name="ln1050">{</a>
<a name="ln1051">  buf_T *buf;</a>
<a name="ln1052">  buf_T *nextbuf;</a>
<a name="ln1053">  int count = offset;</a>
<a name="ln1054"> </a>
<a name="ln1055">  buf = firstbuf;</a>
<a name="ln1056">  while (buf-&gt;b_next != NULL &amp;&amp; buf-&gt;b_fnum &lt; lnum)</a>
<a name="ln1057">    buf = buf-&gt;b_next;</a>
<a name="ln1058">  while (count != 0) {</a>
<a name="ln1059">    count += (count &lt; 0) ? 1 : -1;</a>
<a name="ln1060">    nextbuf = (offset &lt; 0) ? buf-&gt;b_prev : buf-&gt;b_next;</a>
<a name="ln1061">    if (nextbuf == NULL)</a>
<a name="ln1062">      break;</a>
<a name="ln1063">    buf = nextbuf;</a>
<a name="ln1064">    if (addr_type == ADDR_LOADED_BUFFERS)</a>
<a name="ln1065">      /* skip over unloaded buffers */</a>
<a name="ln1066">      while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1067">        nextbuf = (offset &lt; 0) ? buf-&gt;b_prev : buf-&gt;b_next;</a>
<a name="ln1068">        if (nextbuf == NULL) {</a>
<a name="ln1069">          break;</a>
<a name="ln1070">        }</a>
<a name="ln1071">        buf = nextbuf;</a>
<a name="ln1072">      }</a>
<a name="ln1073">  }</a>
<a name="ln1074">  // we might have gone too far, last buffer is not loaded</a>
<a name="ln1075">  if (addr_type == ADDR_LOADED_BUFFERS) {</a>
<a name="ln1076">    while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1077">      nextbuf = (offset &gt;= 0) ? buf-&gt;b_prev : buf-&gt;b_next;</a>
<a name="ln1078">      if (nextbuf == NULL)</a>
<a name="ln1079">        break;</a>
<a name="ln1080">      buf = nextbuf;</a>
<a name="ln1081">    }</a>
<a name="ln1082">  }</a>
<a name="ln1083">  return buf-&gt;b_fnum;</a>
<a name="ln1084">}</a>
<a name="ln1085"> </a>
<a name="ln1086">// Return the window number of &quot;win&quot;.</a>
<a name="ln1087">// When &quot;win&quot; is NULL return the number of windows.</a>
<a name="ln1088">static int current_win_nr(const win_T *win)</a>
<a name="ln1089">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1090">{</a>
<a name="ln1091">  int nr = 0;</a>
<a name="ln1092"> </a>
<a name="ln1093">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln1094">    ++nr;</a>
<a name="ln1095">    if (wp == win)</a>
<a name="ln1096">      break;</a>
<a name="ln1097">  }</a>
<a name="ln1098">  return nr;</a>
<a name="ln1099">}</a>
<a name="ln1100"> </a>
<a name="ln1101">static int current_tab_nr(tabpage_T *tab)</a>
<a name="ln1102">{</a>
<a name="ln1103">  int nr = 0;</a>
<a name="ln1104"> </a>
<a name="ln1105">  FOR_ALL_TABS(tp) {</a>
<a name="ln1106">    ++nr;</a>
<a name="ln1107">    if (tp == tab)</a>
<a name="ln1108">      break;</a>
<a name="ln1109">  }</a>
<a name="ln1110">  return nr;</a>
<a name="ln1111">}</a>
<a name="ln1112"> </a>
<a name="ln1113">#define CURRENT_WIN_NR current_win_nr(curwin)</a>
<a name="ln1114">#define LAST_WIN_NR current_win_nr(NULL)</a>
<a name="ln1115">#define CURRENT_TAB_NR current_tab_nr(curtab)</a>
<a name="ln1116">#define LAST_TAB_NR current_tab_nr(NULL)</a>
<a name="ln1117"> </a>
<a name="ln1118"> </a>
<a name="ln1119">/// Figure out the address type for &quot;:wincmd&quot;.</a>
<a name="ln1120">static void get_wincmd_addr_type(char_u *arg, exarg_T *eap)</a>
<a name="ln1121">{</a>
<a name="ln1122">  switch (*arg) {</a>
<a name="ln1123">    case 'S':</a>
<a name="ln1124">    case Ctrl_S:</a>
<a name="ln1125">    case 's':</a>
<a name="ln1126">    case Ctrl_N:</a>
<a name="ln1127">    case 'n':</a>
<a name="ln1128">    case 'j':</a>
<a name="ln1129">    case Ctrl_J:</a>
<a name="ln1130">    case 'k':</a>
<a name="ln1131">    case Ctrl_K:</a>
<a name="ln1132">    case 'T':</a>
<a name="ln1133">    case Ctrl_R:</a>
<a name="ln1134">    case 'r':</a>
<a name="ln1135">    case 'R':</a>
<a name="ln1136">    case 'K':</a>
<a name="ln1137">    case 'J':</a>
<a name="ln1138">    case '+':</a>
<a name="ln1139">    case '-':</a>
<a name="ln1140">    case Ctrl__:</a>
<a name="ln1141">    case '_':</a>
<a name="ln1142">    case '|':</a>
<a name="ln1143">    case ']':</a>
<a name="ln1144">    case Ctrl_RSB:</a>
<a name="ln1145">    case 'g':</a>
<a name="ln1146">    case Ctrl_G:</a>
<a name="ln1147">    case Ctrl_V:</a>
<a name="ln1148">    case 'v':</a>
<a name="ln1149">    case 'h':</a>
<a name="ln1150">    case Ctrl_H:</a>
<a name="ln1151">    case 'l':</a>
<a name="ln1152">    case Ctrl_L:</a>
<a name="ln1153">    case 'H':</a>
<a name="ln1154">    case 'L':</a>
<a name="ln1155">    case '&gt;':</a>
<a name="ln1156">    case '&lt;':</a>
<a name="ln1157">    case '}':</a>
<a name="ln1158">    case 'f':</a>
<a name="ln1159">    case 'F':</a>
<a name="ln1160">    case Ctrl_F:</a>
<a name="ln1161">    case 'i':</a>
<a name="ln1162">    case Ctrl_I:</a>
<a name="ln1163">    case 'd':</a>
<a name="ln1164">    case Ctrl_D:</a>
<a name="ln1165">      // window size or any count</a>
<a name="ln1166">      eap-&gt;addr_type = ADDR_OTHER;  // -V1037</a>
<a name="ln1167">      break;</a>
<a name="ln1168"> </a>
<a name="ln1169">    case Ctrl_HAT:</a>
<a name="ln1170">    case '^':</a>
<a name="ln1171">      // buffer number</a>
<a name="ln1172">      eap-&gt;addr_type = ADDR_BUFFERS;</a>
<a name="ln1173">      break;</a>
<a name="ln1174"> </a>
<a name="ln1175">    case Ctrl_Q:</a>
<a name="ln1176">    case 'q':</a>
<a name="ln1177">    case Ctrl_C:</a>
<a name="ln1178">    case 'c':</a>
<a name="ln1179">    case Ctrl_O:</a>
<a name="ln1180">    case 'o':</a>
<a name="ln1181">    case Ctrl_W:</a>
<a name="ln1182">    case 'w':</a>
<a name="ln1183">    case 'W':</a>
<a name="ln1184">    case 'x':</a>
<a name="ln1185">    case Ctrl_X:</a>
<a name="ln1186">      // window number</a>
<a name="ln1187">      eap-&gt;addr_type = ADDR_WINDOWS;</a>
<a name="ln1188">      break;</a>
<a name="ln1189"> </a>
<a name="ln1190">    case Ctrl_Z:</a>
<a name="ln1191">    case 'z':</a>
<a name="ln1192">    case 'P':</a>
<a name="ln1193">    case 't':</a>
<a name="ln1194">    case Ctrl_T:</a>
<a name="ln1195">    case 'b':</a>
<a name="ln1196">    case Ctrl_B:</a>
<a name="ln1197">    case 'p':</a>
<a name="ln1198">    case Ctrl_P:</a>
<a name="ln1199">    case '=':</a>
<a name="ln1200">    case CAR:</a>
<a name="ln1201">      // no count</a>
<a name="ln1202">      eap-&gt;addr_type = ADDR_NONE;</a>
<a name="ln1203">      break;</a>
<a name="ln1204">  }</a>
<a name="ln1205">}</a>
<a name="ln1206"> </a>
<a name="ln1207">/// Skip colons and trailing whitespace, returning a pointer to the first</a>
<a name="ln1208">/// non-colon, non-whitespace character.</a>
<a name="ln1209">//</a>
<a name="ln1210">/// @param skipleadingwhite Skip leading whitespace too</a>
<a name="ln1211">static char_u *skip_colon_white(const char_u *p, bool skipleadingwhite)</a>
<a name="ln1212">{</a>
<a name="ln1213">  if (skipleadingwhite) {</a>
<a name="ln1214">    p = skipwhite(p);</a>
<a name="ln1215">  }</a>
<a name="ln1216"> </a>
<a name="ln1217">  while (*p == ':') {</a>
<a name="ln1218">    p = skipwhite(p + 1);</a>
<a name="ln1219">  }</a>
<a name="ln1220"> </a>
<a name="ln1221">  return (char_u *)p;</a>
<a name="ln1222">}</a>
<a name="ln1223"> </a>
<a name="ln1224">/*</a>
<a name="ln1225"> * Execute one Ex command.</a>
<a name="ln1226"> *</a>
<a name="ln1227"> * If 'sourcing' is TRUE, the command will be included in the error message.</a>
<a name="ln1228"> *</a>
<a name="ln1229"> * 1. skip comment lines and leading space</a>
<a name="ln1230"> * 2. handle command modifiers</a>
<a name="ln1231"> * 3. skip over the range to find the command</a>
<a name="ln1232"> * 4. parse the range</a>
<a name="ln1233"> * 5. parse the command</a>
<a name="ln1234"> * 6. parse arguments</a>
<a name="ln1235"> * 7. switch on command name</a>
<a name="ln1236"> *</a>
<a name="ln1237"> * Note: &quot;fgetline&quot; can be NULL.</a>
<a name="ln1238"> *</a>
<a name="ln1239"> * This function may be called recursively!</a>
<a name="ln1240"> */</a>
<a name="ln1241">static char_u * do_one_cmd(char_u **cmdlinep,</a>
<a name="ln1242">                           int flags,</a>
<a name="ln1243">                           cstack_T *cstack,</a>
<a name="ln1244">                           LineGetter fgetline,</a>
<a name="ln1245">                           void *cookie /* argument for fgetline() */</a>
<a name="ln1246">                           )</a>
<a name="ln1247">{</a>
<a name="ln1248">  char_u              *p;</a>
<a name="ln1249">  linenr_T lnum;</a>
<a name="ln1250">  long n;</a>
<a name="ln1251">  char_u              *errormsg = NULL;  // error message</a>
<a name="ln1252">  char_u              *after_modifier = NULL;</a>
<a name="ln1253">  exarg_T ea;</a>
<a name="ln1254">  const int save_msg_scroll = msg_scroll;</a>
<a name="ln1255">  cmdmod_T save_cmdmod;</a>
<a name="ln1256">  const int save_reg_executing = reg_executing;</a>
<a name="ln1257">  char_u              *cmd;</a>
<a name="ln1258"> </a>
<a name="ln1259">  memset(&amp;ea, 0, sizeof(ea));</a>
<a name="ln1260">  ea.line1 = 1;</a>
<a name="ln1261">  ea.line2 = 1;</a>
<a name="ln1262">  ex_nesting_level++;</a>
<a name="ln1263"> </a>
<a name="ln1264">  /* When the last file has not been edited :q has to be typed twice. */</a>
<a name="ln1265">  if (quitmore</a>
<a name="ln1266">      /* avoid that a function call in 'statusline' does this */</a>
<a name="ln1267">      &amp;&amp; !getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln1268">      /* avoid that an autocommand, e.g. QuitPre, does this */</a>
<a name="ln1269">      &amp;&amp; !getline_equal(fgetline, cookie, getnextac)</a>
<a name="ln1270">      )</a>
<a name="ln1271">    --quitmore;</a>
<a name="ln1272"> </a>
<a name="ln1273">  /*</a>
<a name="ln1274">   * Reset browse, confirm, etc..  They are restored when returning, for</a>
<a name="ln1275">   * recursive calls.</a>
<a name="ln1276">   */</a>
<a name="ln1277">  save_cmdmod = cmdmod;</a>
<a name="ln1278"> </a>
<a name="ln1279">  // &quot;#!anything&quot; is handled like a comment.</a>
<a name="ln1280">  if ((*cmdlinep)[0] == '#' &amp;&amp; (*cmdlinep)[1] == '!') {</a>
<a name="ln1281">    goto doend;</a>
<a name="ln1282">  }</a>
<a name="ln1283"> </a>
<a name="ln1284">  // 1. Skip comment lines and leading white space and colons.</a>
<a name="ln1285">  // 2. Handle command modifiers.</a>
<a name="ln1286"> </a>
<a name="ln1287">  // The &quot;ea&quot; structure holds the arguments that can be used.</a>
<a name="ln1288">  ea.cmd = *cmdlinep;</a>
<a name="ln1289">  ea.cmdlinep = cmdlinep;</a>
<a name="ln1290">  ea.getline = fgetline;</a>
<a name="ln1291">  ea.cookie = cookie;</a>
<a name="ln1292">  ea.cstack = cstack;</a>
<a name="ln1293"> </a>
<a name="ln1294">  if (parse_command_modifiers(&amp;ea, &amp;errormsg, false) == FAIL) {</a>
<a name="ln1295">    goto doend;</a>
<a name="ln1296">  }</a>
<a name="ln1297"> </a>
<a name="ln1298">  after_modifier = ea.cmd;</a>
<a name="ln1299"> </a>
<a name="ln1300">  ea.skip = (did_emsg</a>
<a name="ln1301">             || got_int</a>
<a name="ln1302">             || current_exception</a>
<a name="ln1303">             || (cstack-&gt;cs_idx &gt;= 0</a>
<a name="ln1304">                 &amp;&amp; !(cstack-&gt;cs_flags[cstack-&gt;cs_idx] &amp; CSF_ACTIVE)));</a>
<a name="ln1305"> </a>
<a name="ln1306">  // 3. Skip over the range to find the command. Let &quot;p&quot; point to after it.</a>
<a name="ln1307">  //</a>
<a name="ln1308">  // We need the command to know what kind of range it uses.</a>
<a name="ln1309">  cmd = ea.cmd;</a>
<a name="ln1310">  ea.cmd = skip_range(ea.cmd, NULL);</a>
<a name="ln1311">  if (*ea.cmd == '*') {</a>
<a name="ln1312">    ea.cmd = skipwhite(ea.cmd + 1);</a>
<a name="ln1313">  }</a>
<a name="ln1314">  p = find_command(&amp;ea, NULL);</a>
<a name="ln1315"> </a>
<a name="ln1316">  // Count this line for profiling if skip is TRUE.</a>
<a name="ln1317">  if (do_profiling == PROF_YES</a>
<a name="ln1318">      &amp;&amp; (!ea.skip || cstack-&gt;cs_idx == 0</a>
<a name="ln1319">          || (cstack-&gt;cs_idx &gt; 0</a>
<a name="ln1320">              &amp;&amp; (cstack-&gt;cs_flags[cstack-&gt;cs_idx - 1] &amp; CSF_ACTIVE)))) {</a>
<a name="ln1321">    int skip = did_emsg || got_int || current_exception;</a>
<a name="ln1322"> </a>
<a name="ln1323">    if (ea.cmdidx == CMD_catch) {</a>
<a name="ln1324">      skip = !skip &amp;&amp; !(cstack-&gt;cs_idx &gt;= 0</a>
<a name="ln1325">                        &amp;&amp; (cstack-&gt;cs_flags[cstack-&gt;cs_idx] &amp; CSF_THROWN)</a>
<a name="ln1326">                        &amp;&amp; !(cstack-&gt;cs_flags[cstack-&gt;cs_idx] &amp; CSF_CAUGHT));</a>
<a name="ln1327">    } else if (ea.cmdidx == CMD_else || ea.cmdidx == CMD_elseif) {</a>
<a name="ln1328">      skip = skip || !(cstack-&gt;cs_idx &gt;= 0</a>
<a name="ln1329">                       &amp;&amp; !(cstack-&gt;cs_flags[cstack-&gt;cs_idx]</a>
<a name="ln1330">                            &amp; (CSF_ACTIVE | CSF_TRUE)));</a>
<a name="ln1331">    } else if (ea.cmdidx == CMD_finally) {</a>
<a name="ln1332">      skip = false;</a>
<a name="ln1333">    } else if (ea.cmdidx != CMD_endif</a>
<a name="ln1334">               &amp;&amp; ea.cmdidx != CMD_endfor</a>
<a name="ln1335">               &amp;&amp; ea.cmdidx != CMD_endtry</a>
<a name="ln1336">               &amp;&amp; ea.cmdidx != CMD_endwhile) {</a>
<a name="ln1337">      skip = ea.skip;</a>
<a name="ln1338">    }</a>
<a name="ln1339"> </a>
<a name="ln1340">    if (!skip) {</a>
<a name="ln1341">      if (getline_equal(fgetline, cookie, get_func_line)) {</a>
<a name="ln1342">        func_line_exec(getline_cookie(fgetline, cookie));</a>
<a name="ln1343">      } else if (getline_equal(fgetline, cookie, getsourceline)) {</a>
<a name="ln1344">        script_line_exec();</a>
<a name="ln1345">      }</a>
<a name="ln1346">    }</a>
<a name="ln1347">  }</a>
<a name="ln1348"> </a>
<a name="ln1349">  // May go to debug mode.  If this happens and the &quot;&gt;quit&quot; debug command is</a>
<a name="ln1350">  // used, throw an interrupt exception and skip the next command.</a>
<a name="ln1351">  dbg_check_breakpoint(&amp;ea);</a>
<a name="ln1352">  if (!ea.skip &amp;&amp; got_int) {</a>
<a name="ln1353">    ea.skip = TRUE;</a>
<a name="ln1354">    (void)do_intthrow(cstack);</a>
<a name="ln1355">  }</a>
<a name="ln1356"> </a>
<a name="ln1357">  // 4. Parse a range specifier of the form: addr [,addr] [;addr] ..</a>
<a name="ln1358">  //</a>
<a name="ln1359">  // where 'addr' is:</a>
<a name="ln1360">  //</a>
<a name="ln1361">  // %          (entire file)</a>
<a name="ln1362">  // $  [+-NUM]</a>
<a name="ln1363">  // 'x [+-NUM] (where x denotes a currently defined mark)</a>
<a name="ln1364">  // .  [+-NUM]</a>
<a name="ln1365">  // [+-NUM]..</a>
<a name="ln1366">  // NUM</a>
<a name="ln1367">  //</a>
<a name="ln1368">  // The ea.cmd pointer is updated to point to the first character following the</a>
<a name="ln1369">  // range spec. If an initial address is found, but no second, the upper bound</a>
<a name="ln1370">  // is equal to the lower.</a>
<a name="ln1371"> </a>
<a name="ln1372">  // ea.addr_type for user commands is set by find_ucmd</a>
<a name="ln1373">  if (!IS_USER_CMDIDX(ea.cmdidx)) {</a>
<a name="ln1374">    if (ea.cmdidx != CMD_SIZE) {</a>
<a name="ln1375">      ea.addr_type = cmdnames[(int)ea.cmdidx].cmd_addr_type;</a>
<a name="ln1376">    } else {</a>
<a name="ln1377">      ea.addr_type = ADDR_LINES;</a>
<a name="ln1378">    }</a>
<a name="ln1379">    // :wincmd range depends on the argument</a>
<a name="ln1380">    if (ea.cmdidx == CMD_wincmd &amp;&amp; p != NULL) {</a>
<a name="ln1381">      get_wincmd_addr_type(skipwhite(p), &amp;ea);</a>
<a name="ln1382">    }</a>
<a name="ln1383">    // :.cc in quickfix window uses line number</a>
<a name="ln1384">    if ((ea.cmdidx == CMD_cc || ea.cmdidx == CMD_ll) &amp;&amp; bt_quickfix(curbuf)) {</a>
<a name="ln1385">      ea.addr_type = ADDR_OTHER;</a>
<a name="ln1386">    }</a>
<a name="ln1387">  }</a>
<a name="ln1388"> </a>
<a name="ln1389">  ea.cmd = cmd;</a>
<a name="ln1390">  if (parse_cmd_address(&amp;ea, &amp;errormsg, false) == FAIL) {</a>
<a name="ln1391">    goto doend;</a>
<a name="ln1392">  }</a>
<a name="ln1393"> </a>
<a name="ln1394">  /*</a>
<a name="ln1395">   * 5. Parse the command.</a>
<a name="ln1396">   */</a>
<a name="ln1397"> </a>
<a name="ln1398">  /*</a>
<a name="ln1399">   * Skip ':' and any white space</a>
<a name="ln1400">   */</a>
<a name="ln1401">  ea.cmd = skip_colon_white(ea.cmd, true);</a>
<a name="ln1402"> </a>
<a name="ln1403">  /*</a>
<a name="ln1404">   * If we got a line, but no command, then go to the line.</a>
<a name="ln1405">   * If we find a '|' or '\n' we set ea.nextcmd.</a>
<a name="ln1406">   */</a>
<a name="ln1407">  if (*ea.cmd == NUL || *ea.cmd == '&quot;'</a>
<a name="ln1408">      || (ea.nextcmd = check_nextcmd(ea.cmd)) != NULL) {</a>
<a name="ln1409">    // strange vi behaviour:</a>
<a name="ln1410">    // &quot;:3&quot;     jumps to line 3</a>
<a name="ln1411">    // &quot;:3|...&quot; prints line 3</a>
<a name="ln1412">    // &quot;:|&quot;     prints current line</a>
<a name="ln1413">    if (ea.skip) {  // skip this if inside :if</a>
<a name="ln1414">      goto doend;</a>
<a name="ln1415">    }</a>
<a name="ln1416">    if (*ea.cmd == '|' || (exmode_active &amp;&amp; ea.line1 != ea.line2)) {</a>
<a name="ln1417">      ea.cmdidx = CMD_print;</a>
<a name="ln1418">      ea.argt = EX_RANGE | EX_COUNT | EX_TRLBAR;</a>
<a name="ln1419">      if ((errormsg = invalid_range(&amp;ea)) == NULL) {</a>
<a name="ln1420">        correct_range(&amp;ea);</a>
<a name="ln1421">        ex_print(&amp;ea);</a>
<a name="ln1422">      }</a>
<a name="ln1423">    } else if (ea.addr_count != 0) {</a>
<a name="ln1424">      if (ea.line2 &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1425">        ea.line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1426">      }</a>
<a name="ln1427"> </a>
<a name="ln1428">      if (ea.line2 &lt; 0)</a>
<a name="ln1429">        errormsg = (char_u *)_(e_invrange);</a>
<a name="ln1430">      else {</a>
<a name="ln1431">        if (ea.line2 == 0)</a>
<a name="ln1432">          curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln1433">        else</a>
<a name="ln1434">          curwin-&gt;w_cursor.lnum = ea.line2;</a>
<a name="ln1435">        beginline(BL_SOL | BL_FIX);</a>
<a name="ln1436">      }</a>
<a name="ln1437">    }</a>
<a name="ln1438">    goto doend;</a>
<a name="ln1439">  }</a>
<a name="ln1440"> </a>
<a name="ln1441">  // If this looks like an undefined user command and there are CmdUndefined</a>
<a name="ln1442">  // autocommands defined, trigger the matching autocommands.</a>
<a name="ln1443">  if (p != NULL &amp;&amp; ea.cmdidx == CMD_SIZE &amp;&amp; !ea.skip</a>
<a name="ln1444">      &amp;&amp; ASCII_ISUPPER(*ea.cmd)</a>
<a name="ln1445">      &amp;&amp; has_event(EVENT_CMDUNDEFINED)) {</a>
<a name="ln1446">    p = ea.cmd;</a>
<a name="ln1447">    while (ASCII_ISALNUM(*p)) {</a>
<a name="ln1448">      ++p;</a>
<a name="ln1449">    }</a>
<a name="ln1450">    p = vim_strnsave(ea.cmd, p - ea.cmd);</a>
<a name="ln1451">    int ret = apply_autocmds(EVENT_CMDUNDEFINED, p, p, TRUE, NULL);</a>
<a name="ln1452">    xfree(p);</a>
<a name="ln1453">    // If the autocommands did something and didn't cause an error, try</a>
<a name="ln1454">    // finding the command again.</a>
<a name="ln1455">    p = (ret &amp;&amp; !aborting()) ? find_command(&amp;ea, NULL) : ea.cmd;</a>
<a name="ln1456">  }</a>
<a name="ln1457"> </a>
<a name="ln1458">  if (p == NULL) {</a>
<a name="ln1459">    if (!ea.skip)</a>
<a name="ln1460">      errormsg = (char_u *)_(&quot;E464: Ambiguous use of user-defined command&quot;);</a>
<a name="ln1461">    goto doend;</a>
<a name="ln1462">  }</a>
<a name="ln1463">  // Check for wrong commands.</a>
<a name="ln1464">  if (ea.cmdidx == CMD_SIZE) {</a>
<a name="ln1465">    if (!ea.skip) {</a>
<a name="ln1466">      STRCPY(IObuff, _(&quot;E492: Not an editor command&quot;));</a>
<a name="ln1467">      if (!(flags &amp; DOCMD_VERBOSE)) {</a>
<a name="ln1468">        // If the modifier was parsed OK the error must be in the following</a>
<a name="ln1469">        // command</a>
<a name="ln1470">        if (after_modifier != NULL) {</a>
<a name="ln1471">          append_command(after_modifier);</a>
<a name="ln1472">        } else {</a>
<a name="ln1473">          append_command(*cmdlinep);</a>
<a name="ln1474">        }</a>
<a name="ln1475">      }</a>
<a name="ln1476">      errormsg = IObuff;</a>
<a name="ln1477">      did_emsg_syntax = TRUE;</a>
<a name="ln1478">    }</a>
<a name="ln1479">    goto doend;</a>
<a name="ln1480">  }</a>
<a name="ln1481"> </a>
<a name="ln1482">  // set when Not Implemented</a>
<a name="ln1483">  const int ni = !IS_USER_CMDIDX(ea.cmdidx)</a>
<a name="ln1484">    &amp;&amp; (cmdnames[ea.cmdidx].cmd_func == ex_ni</a>
<a name="ln1485">        || cmdnames[ea.cmdidx].cmd_func == ex_script_ni);</a>
<a name="ln1486"> </a>
<a name="ln1487"> </a>
<a name="ln1488">  // Forced commands.</a>
<a name="ln1489">  if (*p == '!' &amp;&amp; ea.cmdidx != CMD_substitute</a>
<a name="ln1490">      &amp;&amp; ea.cmdidx != CMD_smagic &amp;&amp; ea.cmdidx != CMD_snomagic) {</a>
<a name="ln1491">    p++;</a>
<a name="ln1492">    ea.forceit = true;</a>
<a name="ln1493">  } else {</a>
<a name="ln1494">    ea.forceit = false;</a>
<a name="ln1495">  }</a>
<a name="ln1496"> </a>
<a name="ln1497">  // 6. Parse arguments.  Then check for errors.</a>
<a name="ln1498">  if (!IS_USER_CMDIDX(ea.cmdidx)) {</a>
<a name="ln1499">    ea.argt = cmdnames[(int)ea.cmdidx].cmd_argt;</a>
<a name="ln1500">  }</a>
<a name="ln1501"> </a>
<a name="ln1502">  if (!ea.skip) {</a>
<a name="ln1503">    if (sandbox != 0 &amp;&amp; !(ea.argt &amp; EX_SBOXOK)) {</a>
<a name="ln1504">      // Command not allowed in sandbox.</a>
<a name="ln1505">      errormsg = (char_u *)_(e_sandbox);</a>
<a name="ln1506">      goto doend;</a>
<a name="ln1507">    }</a>
<a name="ln1508">    if (!MODIFIABLE(curbuf) &amp;&amp; (ea.argt &amp; EX_MODIFY)</a>
<a name="ln1509">        // allow :put in terminals</a>
<a name="ln1510">        &amp;&amp; (!curbuf-&gt;terminal || ea.cmdidx != CMD_put)) {</a>
<a name="ln1511">      /* Command not allowed in non-'modifiable' buffer */</a>
<a name="ln1512">      errormsg = (char_u *)_(e_modifiable);</a>
<a name="ln1513">      goto doend;</a>
<a name="ln1514">    }</a>
<a name="ln1515"> </a>
<a name="ln1516">    if (text_locked() &amp;&amp; !(ea.argt &amp; EX_CMDWIN)</a>
<a name="ln1517">        &amp;&amp; !IS_USER_CMDIDX(ea.cmdidx)) {</a>
<a name="ln1518">      // Command not allowed when editing the command line.</a>
<a name="ln1519">      errormsg = (char_u *)_(get_text_locked_msg());</a>
<a name="ln1520">      goto doend;</a>
<a name="ln1521">    }</a>
<a name="ln1522"> </a>
<a name="ln1523">    // Disallow editing another buffer when &quot;curbuf_lock&quot; is set.</a>
<a name="ln1524">    // Do allow &quot;:checktime&quot; (it is postponed).</a>
<a name="ln1525">    // Do allow &quot;:edit&quot; (check for an argument later).</a>
<a name="ln1526">    // Do allow &quot;:file&quot; with no arguments (check for an argument later).</a>
<a name="ln1527">    if (!(ea.argt &amp; EX_CMDWIN)</a>
<a name="ln1528">        &amp;&amp; ea.cmdidx != CMD_checktime</a>
<a name="ln1529">        &amp;&amp; ea.cmdidx != CMD_edit</a>
<a name="ln1530">        &amp;&amp; ea.cmdidx != CMD_file</a>
<a name="ln1531">        &amp;&amp; !IS_USER_CMDIDX(ea.cmdidx)</a>
<a name="ln1532">        &amp;&amp; curbuf_locked()) {</a>
<a name="ln1533">      goto doend;</a>
<a name="ln1534">    }</a>
<a name="ln1535"> </a>
<a name="ln1536">    if (!ni &amp;&amp; !(ea.argt &amp; EX_RANGE) &amp;&amp; ea.addr_count &gt; 0) {</a>
<a name="ln1537">      // no range allowed</a>
<a name="ln1538">      errormsg = (char_u *)_(e_norange);</a>
<a name="ln1539">      goto doend;</a>
<a name="ln1540">    }</a>
<a name="ln1541">  }</a>
<a name="ln1542"> </a>
<a name="ln1543">  if (!ni &amp;&amp; !(ea.argt &amp; EX_BANG) &amp;&amp; ea.forceit) {  // no &lt;!&gt; allowed</a>
<a name="ln1544">    errormsg = (char_u *)_(e_nobang);</a>
<a name="ln1545">    goto doend;</a>
<a name="ln1546">  }</a>
<a name="ln1547"> </a>
<a name="ln1548">  /*</a>
<a name="ln1549">   * Don't complain about the range if it is not used</a>
<a name="ln1550">   * (could happen if line_count is accidentally set to 0).</a>
<a name="ln1551">   */</a>
<a name="ln1552">  if (!ea.skip &amp;&amp; !ni &amp;&amp; (ea.argt &amp; EX_RANGE)) {</a>
<a name="ln1553">    // If the range is backwards, ask for confirmation and, if given, swap</a>
<a name="ln1554">    // ea.line1 &amp; ea.line2 so it's forwards again.</a>
<a name="ln1555">    // When global command is busy, don't ask, will fail below.</a>
<a name="ln1556">    if (!global_busy &amp;&amp; ea.line1 &gt; ea.line2) {</a>
<a name="ln1557">      if (msg_silent == 0) {</a>
<a name="ln1558">        if ((flags &amp; DOCMD_VERBOSE) || exmode_active) {</a>
<a name="ln1559">          errormsg = (char_u *)_(&quot;E493: Backwards range given&quot;);</a>
<a name="ln1560">          goto doend;</a>
<a name="ln1561">        }</a>
<a name="ln1562">        if (ask_yesno(_(&quot;Backwards range given, OK to swap&quot;), false) != 'y') {</a>
<a name="ln1563">          goto doend;</a>
<a name="ln1564">        }</a>
<a name="ln1565">      }</a>
<a name="ln1566">      lnum = ea.line1;</a>
<a name="ln1567">      ea.line1 = ea.line2;</a>
<a name="ln1568">      ea.line2 = lnum;</a>
<a name="ln1569">    }</a>
<a name="ln1570">    if ((errormsg = invalid_range(&amp;ea)) != NULL)</a>
<a name="ln1571">      goto doend;</a>
<a name="ln1572">  }</a>
<a name="ln1573"> </a>
<a name="ln1574">  if ((ea.addr_type == ADDR_OTHER) &amp;&amp; ea.addr_count == 0) {</a>
<a name="ln1575">    // default is 1, not cursor</a>
<a name="ln1576">    ea.line2 = 1;</a>
<a name="ln1577">  }</a>
<a name="ln1578"> </a>
<a name="ln1579">  correct_range(&amp;ea);</a>
<a name="ln1580"> </a>
<a name="ln1581">  if (((ea.argt &amp; EX_WHOLEFOLD) || ea.addr_count &gt;= 2) &amp;&amp; !global_busy</a>
<a name="ln1582">      &amp;&amp; ea.addr_type == ADDR_LINES) {</a>
<a name="ln1583">    // Put the first line at the start of a closed fold, put the last line</a>
<a name="ln1584">    // at the end of a closed fold.</a>
<a name="ln1585">    (void)hasFolding(ea.line1, &amp;ea.line1, NULL);</a>
<a name="ln1586">    (void)hasFolding(ea.line2, NULL, &amp;ea.line2);</a>
<a name="ln1587">  }</a>
<a name="ln1588"> </a>
<a name="ln1589">  /*</a>
<a name="ln1590">   * For the &quot;:make&quot; and &quot;:grep&quot; commands we insert the 'makeprg'/'grepprg'</a>
<a name="ln1591">   * option here, so things like % get expanded.</a>
<a name="ln1592">   */</a>
<a name="ln1593">  p = replace_makeprg(&amp;ea, p, cmdlinep);</a>
<a name="ln1594">  if (p == NULL)</a>
<a name="ln1595">    goto doend;</a>
<a name="ln1596"> </a>
<a name="ln1597">  /*</a>
<a name="ln1598">   * Skip to start of argument.</a>
<a name="ln1599">   * Don't do this for the &quot;:!&quot; command, because &quot;:!! -l&quot; needs the space.</a>
<a name="ln1600">   */</a>
<a name="ln1601">  if (ea.cmdidx == CMD_bang)</a>
<a name="ln1602">    ea.arg = p;</a>
<a name="ln1603">  else</a>
<a name="ln1604">    ea.arg = skipwhite(p);</a>
<a name="ln1605"> </a>
<a name="ln1606">  // &quot;:file&quot; cannot be run with an argument when &quot;curbuf_lock&quot; is set</a>
<a name="ln1607">  if (ea.cmdidx == CMD_file &amp;&amp; *ea.arg != NUL &amp;&amp; curbuf_locked()) {</a>
<a name="ln1608">    goto doend;</a>
<a name="ln1609">  }</a>
<a name="ln1610"> </a>
<a name="ln1611">  /*</a>
<a name="ln1612">   * Check for &quot;++opt=val&quot; argument.</a>
<a name="ln1613">   * Must be first, allow &quot;:w ++enc=utf8 !cmd&quot;</a>
<a name="ln1614">   */</a>
<a name="ln1615">  if (ea.argt &amp; EX_ARGOPT) {</a>
<a name="ln1616">    while (ea.arg[0] == '+' &amp;&amp; ea.arg[1] == '+') {</a>
<a name="ln1617">      if (getargopt(&amp;ea) == FAIL &amp;&amp; !ni) {</a>
<a name="ln1618">        errormsg = (char_u *)_(e_invarg);</a>
<a name="ln1619">        goto doend;</a>
<a name="ln1620">      }</a>
<a name="ln1621">    }</a>
<a name="ln1622">  }</a>
<a name="ln1623"> </a>
<a name="ln1624">  if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update) {</a>
<a name="ln1625">    if (*ea.arg == '&gt;') {                       /* append */</a>
<a name="ln1626">      if (*++ea.arg != '&gt;') {                   /* typed wrong */</a>
<a name="ln1627">        errormsg = (char_u *)_(&quot;E494: Use w or w&gt;&gt;&quot;);</a>
<a name="ln1628">        goto doend;</a>
<a name="ln1629">      }</a>
<a name="ln1630">      ea.arg = skipwhite(ea.arg + 1);</a>
<a name="ln1631">      ea.append = TRUE;</a>
<a name="ln1632">    } else if (*ea.arg == '!' &amp;&amp; ea.cmdidx == CMD_write) { /* :w !filter */</a>
<a name="ln1633">      ++ea.arg;</a>
<a name="ln1634">      ea.usefilter = TRUE;</a>
<a name="ln1635">    }</a>
<a name="ln1636">  }</a>
<a name="ln1637"> </a>
<a name="ln1638">  if (ea.cmdidx == CMD_read) {</a>
<a name="ln1639">    if (ea.forceit) {</a>
<a name="ln1640">      ea.usefilter = TRUE;                      /* :r! filter if ea.forceit */</a>
<a name="ln1641">      ea.forceit = FALSE;</a>
<a name="ln1642">    } else if (*ea.arg == '!') {              /* :r !filter */</a>
<a name="ln1643">      ++ea.arg;</a>
<a name="ln1644">      ea.usefilter = TRUE;</a>
<a name="ln1645">    }</a>
<a name="ln1646">  }</a>
<a name="ln1647"> </a>
<a name="ln1648">  if (ea.cmdidx == CMD_lshift || ea.cmdidx == CMD_rshift) {</a>
<a name="ln1649">    ea.amount = 1;</a>
<a name="ln1650">    while (*ea.arg == *ea.cmd) {                /* count number of '&gt;' or '&lt;' */</a>
<a name="ln1651">      ++ea.arg;</a>
<a name="ln1652">      ++ea.amount;</a>
<a name="ln1653">    }</a>
<a name="ln1654">    ea.arg = skipwhite(ea.arg);</a>
<a name="ln1655">  }</a>
<a name="ln1656"> </a>
<a name="ln1657">  /*</a>
<a name="ln1658">   * Check for &quot;+command&quot; argument, before checking for next command.</a>
<a name="ln1659">   * Don't do this for &quot;:read !cmd&quot; and &quot;:write !cmd&quot;.</a>
<a name="ln1660">   */</a>
<a name="ln1661">  if ((ea.argt &amp; EX_CMDARG) &amp;&amp; !ea.usefilter) {</a>
<a name="ln1662">    ea.do_ecmd_cmd = getargcmd(&amp;ea.arg);</a>
<a name="ln1663">  }</a>
<a name="ln1664"> </a>
<a name="ln1665">  /*</a>
<a name="ln1666">   * Check for '|' to separate commands and '&quot;' to start comments.</a>
<a name="ln1667">   * Don't do this for &quot;:read !cmd&quot; and &quot;:write !cmd&quot;.</a>
<a name="ln1668">   */</a>
<a name="ln1669">  if ((ea.argt &amp; EX_TRLBAR) &amp;&amp; !ea.usefilter) {</a>
<a name="ln1670">    separate_nextcmd(&amp;ea);</a>
<a name="ln1671">  } else if (ea.cmdidx == CMD_bang</a>
<a name="ln1672">             || ea.cmdidx == CMD_terminal</a>
<a name="ln1673">             || ea.cmdidx == CMD_global</a>
<a name="ln1674">             || ea.cmdidx == CMD_vglobal</a>
<a name="ln1675">             || ea.usefilter) {</a>
<a name="ln1676">    // Check for &lt;newline&gt; to end a shell command.</a>
<a name="ln1677">    // Also do this for &quot;:read !cmd&quot;, &quot;:write !cmd&quot; and &quot;:global&quot;.</a>
<a name="ln1678">    // Any others?</a>
<a name="ln1679">    for (p = ea.arg; *p; p++) {</a>
<a name="ln1680">      // Remove one backslash before a newline, so that it's possible to</a>
<a name="ln1681">      // pass a newline to the shell and also a newline that is preceded</a>
<a name="ln1682">      // with a backslash.  This makes it impossible to end a shell</a>
<a name="ln1683">      // command in a backslash, but that doesn't appear useful.</a>
<a name="ln1684">      // Halving the number of backslashes is incompatible with previous</a>
<a name="ln1685">      // versions.</a>
<a name="ln1686">      if (*p == '\\' &amp;&amp; p[1] == '\n') {</a>
<a name="ln1687">        STRMOVE(p, p + 1);</a>
<a name="ln1688">      } else if (*p == '\n') {</a>
<a name="ln1689">        ea.nextcmd = p + 1;</a>
<a name="ln1690">        *p = NUL;</a>
<a name="ln1691">        break;</a>
<a name="ln1692">      }</a>
<a name="ln1693">    }</a>
<a name="ln1694">  }</a>
<a name="ln1695"> </a>
<a name="ln1696">  if ((ea.argt &amp; EX_DFLALL) &amp;&amp; ea.addr_count == 0) {</a>
<a name="ln1697">    buf_T *buf;</a>
<a name="ln1698"> </a>
<a name="ln1699">    ea.line1 = 1;</a>
<a name="ln1700">    switch (ea.addr_type) {</a>
<a name="ln1701">      case ADDR_LINES:</a>
<a name="ln1702">      case ADDR_OTHER:</a>
<a name="ln1703">        ea.line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1704">        break;</a>
<a name="ln1705">      case ADDR_LOADED_BUFFERS:</a>
<a name="ln1706">        buf = firstbuf;</a>
<a name="ln1707">        while (buf-&gt;b_next != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1708">          buf = buf-&gt;b_next;</a>
<a name="ln1709">        }</a>
<a name="ln1710">        ea.line1 = buf-&gt;b_fnum;</a>
<a name="ln1711">        buf = lastbuf;</a>
<a name="ln1712">        while (buf-&gt;b_prev != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1713">          buf = buf-&gt;b_prev;</a>
<a name="ln1714">        }</a>
<a name="ln1715">        ea.line2 = buf-&gt;b_fnum;</a>
<a name="ln1716">        break;</a>
<a name="ln1717">      case ADDR_BUFFERS:</a>
<a name="ln1718">        ea.line1 = firstbuf-&gt;b_fnum;</a>
<a name="ln1719">        ea.line2 = lastbuf-&gt;b_fnum;</a>
<a name="ln1720">        break;</a>
<a name="ln1721">      case ADDR_WINDOWS:</a>
<a name="ln1722">        ea.line2 = LAST_WIN_NR;</a>
<a name="ln1723">        break;</a>
<a name="ln1724">      case ADDR_TABS:</a>
<a name="ln1725">        ea.line2 = LAST_TAB_NR;</a>
<a name="ln1726">        break;</a>
<a name="ln1727">      case ADDR_TABS_RELATIVE:</a>
<a name="ln1728">        ea.line2 = 1;</a>
<a name="ln1729">        break;</a>
<a name="ln1730">      case ADDR_ARGUMENTS:</a>
<a name="ln1731">        if (ARGCOUNT == 0) {</a>
<a name="ln1732">          ea.line1 = ea.line2 = 0;</a>
<a name="ln1733">        } else {</a>
<a name="ln1734">          ea.line2 = ARGCOUNT;</a>
<a name="ln1735">        }</a>
<a name="ln1736">        break;</a>
<a name="ln1737">      case ADDR_QUICKFIX_VALID:</a>
<a name="ln1738">        ea.line2 = qf_get_valid_size(&amp;ea);</a>
<a name="ln1739">        if (ea.line2 == 0) {</a>
<a name="ln1740">          ea.line2 = 1;</a>
<a name="ln1741">        }</a>
<a name="ln1742">        break;</a>
<a name="ln1743">      case ADDR_NONE:</a>
<a name="ln1744">      case ADDR_UNSIGNED:</a>
<a name="ln1745">      case ADDR_QUICKFIX:</a>
<a name="ln1746">        IEMSG(_(&quot;INTERNAL: Cannot use EX_DFLALL &quot;</a>
<a name="ln1747">                &quot;with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX&quot;));</a>
<a name="ln1748">        break;</a>
<a name="ln1749">    }</a>
<a name="ln1750">  }</a>
<a name="ln1751"> </a>
<a name="ln1752">  // accept numbered register only when no count allowed (:put)</a>
<a name="ln1753">  if ((ea.argt &amp; EX_REGSTR)</a>
<a name="ln1754">      &amp;&amp; *ea.arg != NUL</a>
<a name="ln1755">      /* Do not allow register = for user commands */</a>
<a name="ln1756">      &amp;&amp; (!IS_USER_CMDIDX(ea.cmdidx) || *ea.arg != '=')</a>
<a name="ln1757">      &amp;&amp; !((ea.argt &amp; EX_COUNT) &amp;&amp; ascii_isdigit(*ea.arg))) {</a>
<a name="ln1758">    if (valid_yank_reg(*ea.arg, (ea.cmdidx != CMD_put</a>
<a name="ln1759">                                 &amp;&amp; !IS_USER_CMDIDX(ea.cmdidx)))) {</a>
<a name="ln1760">      ea.regname = *ea.arg++;</a>
<a name="ln1761">      /* for '=' register: accept the rest of the line as an expression */</a>
<a name="ln1762">      if (ea.arg[-1] == '=' &amp;&amp; ea.arg[0] != NUL) {</a>
<a name="ln1763">        set_expr_line(vim_strsave(ea.arg));</a>
<a name="ln1764">        ea.arg += STRLEN(ea.arg);</a>
<a name="ln1765">      }</a>
<a name="ln1766">      ea.arg = skipwhite(ea.arg);</a>
<a name="ln1767">    }</a>
<a name="ln1768">  }</a>
<a name="ln1769"> </a>
<a name="ln1770">  //</a>
<a name="ln1771">  // Check for a count.  When accepting a EX_BUFNAME, don't use &quot;123foo&quot; as a</a>
<a name="ln1772">  // count, it's a buffer name.</a>
<a name="ln1773">  ///</a>
<a name="ln1774">  if ((ea.argt &amp; EX_COUNT) &amp;&amp; ascii_isdigit(*ea.arg)</a>
<a name="ln1775">      &amp;&amp; (!(ea.argt &amp; EX_BUFNAME) || *(p = skipdigits(ea.arg)) == NUL</a>
<a name="ln1776">          || ascii_iswhite(*p))) {</a>
<a name="ln1777">    n = getdigits_long(&amp;ea.arg, false, -1);</a>
<a name="ln1778">    ea.arg = skipwhite(ea.arg);</a>
<a name="ln1779">    if (n &lt;= 0 &amp;&amp; !ni &amp;&amp; (ea.argt &amp; EX_ZEROR) == 0) {</a>
<a name="ln1780">      errormsg = (char_u *)_(e_zerocount);</a>
<a name="ln1781">      goto doend;</a>
<a name="ln1782">    }</a>
<a name="ln1783">    if (ea.addr_type != ADDR_LINES) {  // e.g. :buffer 2, :sleep 3</a>
<a name="ln1784">      ea.line2 = n;</a>
<a name="ln1785">      if (ea.addr_count == 0)</a>
<a name="ln1786">        ea.addr_count = 1;</a>
<a name="ln1787">    } else {</a>
<a name="ln1788">      ea.line1 = ea.line2;</a>
<a name="ln1789">      ea.line2 += n - 1;</a>
<a name="ln1790">      ++ea.addr_count;</a>
<a name="ln1791">      // Be vi compatible: no error message for out of range.</a>
<a name="ln1792">      if (ea.line2 &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1793">        ea.line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1794">      }</a>
<a name="ln1795">    }</a>
<a name="ln1796">  }</a>
<a name="ln1797"> </a>
<a name="ln1798">  /*</a>
<a name="ln1799">   * Check for flags: 'l', 'p' and '#'.</a>
<a name="ln1800">   */</a>
<a name="ln1801">  if (ea.argt &amp; EX_FLAGS) {</a>
<a name="ln1802">    get_flags(&amp;ea);</a>
<a name="ln1803">  }</a>
<a name="ln1804">  if (!ni &amp;&amp; !(ea.argt &amp; EX_EXTRA) &amp;&amp; *ea.arg != NUL</a>
<a name="ln1805">      &amp;&amp; *ea.arg != '&quot;' &amp;&amp; (*ea.arg != '|' || (ea.argt &amp; EX_TRLBAR) == 0)) {</a>
<a name="ln1806">    // no arguments allowed but there is something</a>
<a name="ln1807">    errormsg = (char_u *)_(e_trailing);</a>
<a name="ln1808">    goto doend;</a>
<a name="ln1809">  }</a>
<a name="ln1810"> </a>
<a name="ln1811">  if (!ni &amp;&amp; (ea.argt &amp; EX_NEEDARG) &amp;&amp; *ea.arg == NUL) {</a>
<a name="ln1812">    errormsg = (char_u *)_(e_argreq);</a>
<a name="ln1813">    goto doend;</a>
<a name="ln1814">  }</a>
<a name="ln1815"> </a>
<a name="ln1816">  /*</a>
<a name="ln1817">   * Skip the command when it's not going to be executed.</a>
<a name="ln1818">   * The commands like :if, :endif, etc. always need to be executed.</a>
<a name="ln1819">   * Also make an exception for commands that handle a trailing command</a>
<a name="ln1820">   * themselves.</a>
<a name="ln1821">   */</a>
<a name="ln1822">  if (ea.skip) {</a>
<a name="ln1823">    switch (ea.cmdidx) {</a>
<a name="ln1824">    /* commands that need evaluation */</a>
<a name="ln1825">    case CMD_while:</a>
<a name="ln1826">    case CMD_endwhile:</a>
<a name="ln1827">    case CMD_for:</a>
<a name="ln1828">    case CMD_endfor:</a>
<a name="ln1829">    case CMD_if:</a>
<a name="ln1830">    case CMD_elseif:</a>
<a name="ln1831">    case CMD_else:</a>
<a name="ln1832">    case CMD_endif:</a>
<a name="ln1833">    case CMD_try:</a>
<a name="ln1834">    case CMD_catch:</a>
<a name="ln1835">    case CMD_finally:</a>
<a name="ln1836">    case CMD_endtry:</a>
<a name="ln1837">    case CMD_function:</a>
<a name="ln1838">      break;</a>
<a name="ln1839"> </a>
<a name="ln1840">    // Commands that handle '|' themselves.  Check: A command should</a>
<a name="ln1841">    // either have the EX_TRLBAR flag, appear in this list or appear in</a>
<a name="ln1842">    // the list at &quot;:help :bar&quot;.</a>
<a name="ln1843">    case CMD_aboveleft:</a>
<a name="ln1844">    case CMD_and:</a>
<a name="ln1845">    case CMD_belowright:</a>
<a name="ln1846">    case CMD_botright:</a>
<a name="ln1847">    case CMD_browse:</a>
<a name="ln1848">    case CMD_call:</a>
<a name="ln1849">    case CMD_confirm:</a>
<a name="ln1850">    case CMD_const:</a>
<a name="ln1851">    case CMD_delfunction:</a>
<a name="ln1852">    case CMD_djump:</a>
<a name="ln1853">    case CMD_dlist:</a>
<a name="ln1854">    case CMD_dsearch:</a>
<a name="ln1855">    case CMD_dsplit:</a>
<a name="ln1856">    case CMD_echo:</a>
<a name="ln1857">    case CMD_echoerr:</a>
<a name="ln1858">    case CMD_echomsg:</a>
<a name="ln1859">    case CMD_echon:</a>
<a name="ln1860">    case CMD_eval:</a>
<a name="ln1861">    case CMD_execute:</a>
<a name="ln1862">    case CMD_filter:</a>
<a name="ln1863">    case CMD_help:</a>
<a name="ln1864">    case CMD_hide:</a>
<a name="ln1865">    case CMD_ijump:</a>
<a name="ln1866">    case CMD_ilist:</a>
<a name="ln1867">    case CMD_isearch:</a>
<a name="ln1868">    case CMD_isplit:</a>
<a name="ln1869">    case CMD_keepalt:</a>
<a name="ln1870">    case CMD_keepjumps:</a>
<a name="ln1871">    case CMD_keepmarks:</a>
<a name="ln1872">    case CMD_keeppatterns:</a>
<a name="ln1873">    case CMD_leftabove:</a>
<a name="ln1874">    case CMD_let:</a>
<a name="ln1875">    case CMD_lockmarks:</a>
<a name="ln1876">    case CMD_lockvar:</a>
<a name="ln1877">    case CMD_lua:</a>
<a name="ln1878">    case CMD_match:</a>
<a name="ln1879">    case CMD_mzscheme:</a>
<a name="ln1880">    case CMD_noautocmd:</a>
<a name="ln1881">    case CMD_noswapfile:</a>
<a name="ln1882">    case CMD_perl:</a>
<a name="ln1883">    case CMD_psearch:</a>
<a name="ln1884">    case CMD_python:</a>
<a name="ln1885">    case CMD_py3:</a>
<a name="ln1886">    case CMD_python3:</a>
<a name="ln1887">    case CMD_pythonx:</a>
<a name="ln1888">    case CMD_pyx:</a>
<a name="ln1889">    case CMD_return:</a>
<a name="ln1890">    case CMD_rightbelow:</a>
<a name="ln1891">    case CMD_ruby:</a>
<a name="ln1892">    case CMD_silent:</a>
<a name="ln1893">    case CMD_smagic:</a>
<a name="ln1894">    case CMD_snomagic:</a>
<a name="ln1895">    case CMD_substitute:</a>
<a name="ln1896">    case CMD_syntax:</a>
<a name="ln1897">    case CMD_tab:</a>
<a name="ln1898">    case CMD_tcl:</a>
<a name="ln1899">    case CMD_throw:</a>
<a name="ln1900">    case CMD_tilde:</a>
<a name="ln1901">    case CMD_topleft:</a>
<a name="ln1902">    case CMD_unlet:</a>
<a name="ln1903">    case CMD_unlockvar:</a>
<a name="ln1904">    case CMD_verbose:</a>
<a name="ln1905">    case CMD_vertical:</a>
<a name="ln1906">    case CMD_wincmd:</a>
<a name="ln1907">      break;</a>
<a name="ln1908"> </a>
<a name="ln1909">    default:</a>
<a name="ln1910">      goto doend;</a>
<a name="ln1911">    }</a>
<a name="ln1912">  }</a>
<a name="ln1913"> </a>
<a name="ln1914">  if (ea.argt &amp; EX_XFILE) {</a>
<a name="ln1915">    if (expand_filename(&amp;ea, cmdlinep, &amp;errormsg) == FAIL) {</a>
<a name="ln1916">      goto doend;</a>
<a name="ln1917">    }</a>
<a name="ln1918">  }</a>
<a name="ln1919"> </a>
<a name="ln1920">  /*</a>
<a name="ln1921">   * Accept buffer name.  Cannot be used at the same time with a buffer</a>
<a name="ln1922">   * number.  Don't do this for a user command.</a>
<a name="ln1923">   */</a>
<a name="ln1924">  if ((ea.argt &amp; EX_BUFNAME) &amp;&amp; *ea.arg != NUL &amp;&amp; ea.addr_count == 0</a>
<a name="ln1925">      &amp;&amp; !IS_USER_CMDIDX(ea.cmdidx)</a>
<a name="ln1926">      ) {</a>
<a name="ln1927">    /*</a>
<a name="ln1928">     * :bdelete, :bwipeout and :bunload take several arguments, separated</a>
<a name="ln1929">     * by spaces: find next space (skipping over escaped characters).</a>
<a name="ln1930">     * The others take one argument: ignore trailing spaces.</a>
<a name="ln1931">     */</a>
<a name="ln1932">    if (ea.cmdidx == CMD_bdelete || ea.cmdidx == CMD_bwipeout</a>
<a name="ln1933">        || ea.cmdidx == CMD_bunload)</a>
<a name="ln1934">      p = skiptowhite_esc(ea.arg);</a>
<a name="ln1935">    else {</a>
<a name="ln1936">      p = ea.arg + STRLEN(ea.arg);</a>
<a name="ln1937">      while (p &gt; ea.arg &amp;&amp; ascii_iswhite(p[-1]))</a>
<a name="ln1938">        --p;</a>
<a name="ln1939">    }</a>
<a name="ln1940">    ea.line2 = buflist_findpat(ea.arg, p, (ea.argt &amp; EX_BUFUNL) != 0,</a>
<a name="ln1941">                               false, false);</a>
<a name="ln1942">    if (ea.line2 &lt; 0) {  // failed</a>
<a name="ln1943">      goto doend;</a>
<a name="ln1944">    }</a>
<a name="ln1945">    ea.addr_count = 1;</a>
<a name="ln1946">    ea.arg = skipwhite(p);</a>
<a name="ln1947">  }</a>
<a name="ln1948"> </a>
<a name="ln1949">  // The :try command saves the emsg_silent flag, reset it here when</a>
<a name="ln1950">  // &quot;:silent! try&quot; was used, it should only apply to :try itself.</a>
<a name="ln1951">  if (ea.cmdidx == CMD_try &amp;&amp; ea.did_esilent &gt; 0) {</a>
<a name="ln1952">    emsg_silent -= ea.did_esilent;</a>
<a name="ln1953">    if (emsg_silent &lt; 0) {</a>
<a name="ln1954">      emsg_silent = 0;</a>
<a name="ln1955">    }</a>
<a name="ln1956">    ea.did_esilent = 0;</a>
<a name="ln1957">  }</a>
<a name="ln1958"> </a>
<a name="ln1959">  // 7. Execute the command.</a>
<a name="ln1960">  if (IS_USER_CMDIDX(ea.cmdidx)) {</a>
<a name="ln1961">    /*</a>
<a name="ln1962">     * Execute a user-defined command.</a>
<a name="ln1963">     */</a>
<a name="ln1964">    do_ucmd(&amp;ea);</a>
<a name="ln1965">  } else {</a>
<a name="ln1966">    /*</a>
<a name="ln1967">     * Call the function to execute the command.</a>
<a name="ln1968">     */</a>
<a name="ln1969">    ea.errmsg = NULL;</a>
<a name="ln1970">    (cmdnames[ea.cmdidx].cmd_func)(&amp;ea);</a>
<a name="ln1971">    if (ea.errmsg != NULL)</a>
<a name="ln1972">      errormsg = (char_u *)_(ea.errmsg);</a>
<a name="ln1973">  }</a>
<a name="ln1974"> </a>
<a name="ln1975">  /*</a>
<a name="ln1976">   * If the command just executed called do_cmdline(), any throw or &quot;:return&quot;</a>
<a name="ln1977">   * or &quot;:finish&quot; encountered there must also check the cstack of the still</a>
<a name="ln1978">   * active do_cmdline() that called this do_one_cmd().  Rethrow an uncaught</a>
<a name="ln1979">   * exception, or reanimate a returned function or finished script file and</a>
<a name="ln1980">   * return or finish it again.</a>
<a name="ln1981">   */</a>
<a name="ln1982">  if (need_rethrow)</a>
<a name="ln1983">    do_throw(cstack);</a>
<a name="ln1984">  else if (check_cstack) {</a>
<a name="ln1985">    if (source_finished(fgetline, cookie))</a>
<a name="ln1986">      do_finish(&amp;ea, TRUE);</a>
<a name="ln1987">    else if (getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln1988">             &amp;&amp; current_func_returned())</a>
<a name="ln1989">      do_return(&amp;ea, TRUE, FALSE, NULL);</a>
<a name="ln1990">  }</a>
<a name="ln1991">  need_rethrow = check_cstack = FALSE;</a>
<a name="ln1992"> </a>
<a name="ln1993">doend:</a>
<a name="ln1994">  // can happen with zero line number</a>
<a name="ln1995">  if (curwin-&gt;w_cursor.lnum == 0) {</a>
<a name="ln1996">    curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln1997">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln1998">  }</a>
<a name="ln1999"> </a>
<a name="ln2000">  if (errormsg != NULL &amp;&amp; *errormsg != NUL &amp;&amp; !did_emsg) {</a>
<a name="ln2001">    if (flags &amp; DOCMD_VERBOSE) {</a>
<a name="ln2002">      if (errormsg != IObuff) {</a>
<a name="ln2003">        STRCPY(IObuff, errormsg);</a>
<a name="ln2004">        errormsg = IObuff;</a>
<a name="ln2005">      }</a>
<a name="ln2006">      append_command(*cmdlinep);</a>
<a name="ln2007">    }</a>
<a name="ln2008">    emsg(errormsg);</a>
<a name="ln2009">  }</a>
<a name="ln2010">  do_errthrow(cstack,</a>
<a name="ln2011">      (ea.cmdidx != CMD_SIZE &amp;&amp; !IS_USER_CMDIDX(ea.cmdidx))</a>
<a name="ln2012">      ? cmdnames[(int)ea.cmdidx].cmd_name</a>
<a name="ln2013">      : (char_u *)NULL);</a>
<a name="ln2014"> </a>
<a name="ln2015">  undo_cmdmod(&amp;ea, save_msg_scroll);</a>
<a name="ln2016">  cmdmod = save_cmdmod;</a>
<a name="ln2017">  reg_executing = save_reg_executing;</a>
<a name="ln2018"> </a>
<a name="ln2019">  if (ea.did_sandbox) {</a>
<a name="ln2020">    sandbox--;</a>
<a name="ln2021">  }</a>
<a name="ln2022"> </a>
<a name="ln2023">  if (ea.nextcmd &amp;&amp; *ea.nextcmd == NUL)         /* not really a next command */</a>
<a name="ln2024">    ea.nextcmd = NULL;</a>
<a name="ln2025"> </a>
<a name="ln2026">  --ex_nesting_level;</a>
<a name="ln2027"> </a>
<a name="ln2028">  return ea.nextcmd;</a>
<a name="ln2029">}</a>
<a name="ln2030"> </a>
<a name="ln2031">// Parse and skip over command modifiers:</a>
<a name="ln2032">// - update eap-&gt;cmd</a>
<a name="ln2033">// - store flags in &quot;cmdmod&quot;.</a>
<a name="ln2034">// - Set ex_pressedreturn for an empty command line.</a>
<a name="ln2035">// - set msg_silent for &quot;:silent&quot;</a>
<a name="ln2036">// - set 'eventignore' to &quot;all&quot; for &quot;:noautocmd&quot;</a>
<a name="ln2037">// - set p_verbose for &quot;:verbose&quot;</a>
<a name="ln2038">// - Increment &quot;sandbox&quot; for &quot;:sandbox&quot;</a>
<a name="ln2039">// When &quot;skip_only&quot; is true the global variables are not changed, except for</a>
<a name="ln2040">// &quot;cmdmod&quot;.</a>
<a name="ln2041">// Return FAIL when the command is not to be executed.</a>
<a name="ln2042">// May set &quot;errormsg&quot; to an error message.</a>
<a name="ln2043">int parse_command_modifiers(exarg_T *eap, char_u **errormsg, bool skip_only)</a>
<a name="ln2044">{</a>
<a name="ln2045">  char_u *p;</a>
<a name="ln2046"> </a>
<a name="ln2047">  memset(&amp;cmdmod, 0, sizeof(cmdmod));</a>
<a name="ln2048">  eap-&gt;verbose_save = -1;</a>
<a name="ln2049">  eap-&gt;save_msg_silent = -1;</a>
<a name="ln2050"> </a>
<a name="ln2051">  // Repeat until no more command modifiers are found.</a>
<a name="ln2052">  for (;; ) {</a>
<a name="ln2053">    while (*eap-&gt;cmd == ' '</a>
<a name="ln2054">           || *eap-&gt;cmd == '\t'</a>
<a name="ln2055">           || *eap-&gt;cmd == ':') {</a>
<a name="ln2056">      eap-&gt;cmd++;</a>
<a name="ln2057">    }</a>
<a name="ln2058"> </a>
<a name="ln2059">    // in ex mode, an empty line works like :+</a>
<a name="ln2060">    if (*eap-&gt;cmd == NUL &amp;&amp; exmode_active</a>
<a name="ln2061">        &amp;&amp; (getline_equal(eap-&gt;getline, eap-&gt;cookie, getexmodeline)</a>
<a name="ln2062">            || getline_equal(eap-&gt;getline, eap-&gt;cookie, getexline))</a>
<a name="ln2063">        &amp;&amp; curwin-&gt;w_cursor.lnum &lt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2064">      eap-&gt;cmd = (char_u *)&quot;+&quot;;</a>
<a name="ln2065">      if (!skip_only) {</a>
<a name="ln2066">        ex_pressedreturn = true;</a>
<a name="ln2067">      }</a>
<a name="ln2068">    }</a>
<a name="ln2069"> </a>
<a name="ln2070">    // ignore comment and empty lines</a>
<a name="ln2071">    if (*eap-&gt;cmd == '&quot;') {</a>
<a name="ln2072">      return FAIL;</a>
<a name="ln2073">    }</a>
<a name="ln2074">    if (*eap-&gt;cmd == NUL) {</a>
<a name="ln2075">      if (!skip_only) {</a>
<a name="ln2076">        ex_pressedreturn = true;</a>
<a name="ln2077">      }</a>
<a name="ln2078">      return FAIL;</a>
<a name="ln2079">    }</a>
<a name="ln2080"> </a>
<a name="ln2081">    p = skip_range(eap-&gt;cmd, NULL);</a>
<a name="ln2082">    switch (*p) {</a>
<a name="ln2083">    // When adding an entry, also modify cmd_exists().</a>
<a name="ln2084">    case 'a':   if (!checkforcmd(&amp;eap-&gt;cmd, &quot;aboveleft&quot;, 3))</a>
<a name="ln2085">        break;</a>
<a name="ln2086">      cmdmod.split |= WSP_ABOVE;</a>
<a name="ln2087">      continue;</a>
<a name="ln2088"> </a>
<a name="ln2089">    case 'b':   if (checkforcmd(&amp;eap-&gt;cmd, &quot;belowright&quot;, 3)) {</a>
<a name="ln2090">        cmdmod.split |= WSP_BELOW;</a>
<a name="ln2091">        continue;</a>
<a name="ln2092">      }</a>
<a name="ln2093">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;browse&quot;, 3)) {</a>
<a name="ln2094">        cmdmod.browse = true;</a>
<a name="ln2095">        continue;</a>
<a name="ln2096">      }</a>
<a name="ln2097">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;botright&quot;, 2)) {</a>
<a name="ln2098">        break;</a>
<a name="ln2099">      }</a>
<a name="ln2100">      cmdmod.split |= WSP_BOT;</a>
<a name="ln2101">      continue;</a>
<a name="ln2102"> </a>
<a name="ln2103">    case 'c':   if (!checkforcmd(&amp;eap-&gt;cmd, &quot;confirm&quot;, 4))</a>
<a name="ln2104">        break;</a>
<a name="ln2105">      cmdmod.confirm = true;</a>
<a name="ln2106">      continue;</a>
<a name="ln2107"> </a>
<a name="ln2108">    case 'k':   if (checkforcmd(&amp;eap-&gt;cmd, &quot;keepmarks&quot;, 3)) {</a>
<a name="ln2109">        cmdmod.keepmarks = true;</a>
<a name="ln2110">        continue;</a>
<a name="ln2111">    }</a>
<a name="ln2112">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;keepalt&quot;, 5)) {</a>
<a name="ln2113">        cmdmod.keepalt = true;</a>
<a name="ln2114">        continue;</a>
<a name="ln2115">      }</a>
<a name="ln2116">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;keeppatterns&quot;, 5)) {</a>
<a name="ln2117">        cmdmod.keeppatterns = true;</a>
<a name="ln2118">        continue;</a>
<a name="ln2119">      }</a>
<a name="ln2120">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;keepjumps&quot;, 5)) {</a>
<a name="ln2121">        break;</a>
<a name="ln2122">      }</a>
<a name="ln2123">      cmdmod.keepjumps = true;</a>
<a name="ln2124">      continue;</a>
<a name="ln2125"> </a>
<a name="ln2126">    case 'f': {  // only accept &quot;:filter {pat} cmd&quot;</a>
<a name="ln2127">      char_u *reg_pat;</a>
<a name="ln2128"> </a>
<a name="ln2129">      if (!checkforcmd(&amp;p, &quot;filter&quot;, 4) || *p == NUL || ends_excmd(*p)) {</a>
<a name="ln2130">        break;</a>
<a name="ln2131">      }</a>
<a name="ln2132">      if (*p == '!') {</a>
<a name="ln2133">        cmdmod.filter_force = true;</a>
<a name="ln2134">        p = skipwhite(p + 1);</a>
<a name="ln2135">        if (*p == NUL || ends_excmd(*p)) {</a>
<a name="ln2136">          break;</a>
<a name="ln2137">        }</a>
<a name="ln2138">      }</a>
<a name="ln2139">      if (skip_only) {</a>
<a name="ln2140">        p = skip_vimgrep_pat(p, NULL, NULL);</a>
<a name="ln2141">      } else {</a>
<a name="ln2142">        // NOTE: This puts a NUL after the pattern.</a>
<a name="ln2143">        p = skip_vimgrep_pat(p, &amp;reg_pat, NULL);</a>
<a name="ln2144">      }</a>
<a name="ln2145">      if (p == NULL || *p == NUL) {</a>
<a name="ln2146">        break;</a>
<a name="ln2147">      }</a>
<a name="ln2148">      if (!skip_only) {</a>
<a name="ln2149">        cmdmod.filter_regmatch.regprog = vim_regcomp(reg_pat, RE_MAGIC);</a>
<a name="ln2150">        if (cmdmod.filter_regmatch.regprog == NULL) {</a>
<a name="ln2151">          break;</a>
<a name="ln2152">        }</a>
<a name="ln2153">      }</a>
<a name="ln2154">      eap-&gt;cmd = p;</a>
<a name="ln2155">      continue;</a>
<a name="ln2156">    }</a>
<a name="ln2157"> </a>
<a name="ln2158">    // &quot;:hide&quot; and &quot;:hide | cmd&quot; are not modifiers</a>
<a name="ln2159">    case 'h':   if (p != eap-&gt;cmd || !checkforcmd(&amp;p, &quot;hide&quot;, 3)</a>
<a name="ln2160">                    || *p == NUL || ends_excmd(*p))</a>
<a name="ln2161">        break;</a>
<a name="ln2162">      eap-&gt;cmd = p;</a>
<a name="ln2163">      cmdmod.hide = true;</a>
<a name="ln2164">      continue;</a>
<a name="ln2165"> </a>
<a name="ln2166">    case 'l':   if (checkforcmd(&amp;eap-&gt;cmd, &quot;lockmarks&quot;, 3)) {</a>
<a name="ln2167">        cmdmod.lockmarks = true;</a>
<a name="ln2168">        continue;</a>
<a name="ln2169">    }</a>
<a name="ln2170"> </a>
<a name="ln2171">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;leftabove&quot;, 5)) {</a>
<a name="ln2172">        break;</a>
<a name="ln2173">      }</a>
<a name="ln2174">      cmdmod.split |= WSP_ABOVE;</a>
<a name="ln2175">      continue;</a>
<a name="ln2176"> </a>
<a name="ln2177">    case 'n':</a>
<a name="ln2178">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;noautocmd&quot;, 3)) {</a>
<a name="ln2179">        if (cmdmod.save_ei == NULL &amp;&amp; !skip_only) {</a>
<a name="ln2180">          // Set 'eventignore' to &quot;all&quot;. Restore the</a>
<a name="ln2181">          // existing option value later.</a>
<a name="ln2182">          cmdmod.save_ei = vim_strsave(p_ei);</a>
<a name="ln2183">          set_string_option_direct(&quot;ei&quot;, -1,</a>
<a name="ln2184">                                   (char_u *)&quot;all&quot;, OPT_FREE, SID_NONE);</a>
<a name="ln2185">        }</a>
<a name="ln2186">        continue;</a>
<a name="ln2187">      }</a>
<a name="ln2188">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;noswapfile&quot;, 3)) {</a>
<a name="ln2189">        break;</a>
<a name="ln2190">      }</a>
<a name="ln2191">      cmdmod.noswapfile = true;</a>
<a name="ln2192">      continue;</a>
<a name="ln2193"> </a>
<a name="ln2194">    case 'r':   if (!checkforcmd(&amp;eap-&gt;cmd, &quot;rightbelow&quot;, 6))</a>
<a name="ln2195">        break;</a>
<a name="ln2196">      cmdmod.split |= WSP_BELOW;</a>
<a name="ln2197">      continue;</a>
<a name="ln2198"> </a>
<a name="ln2199">    case 's':   if (checkforcmd(&amp;eap-&gt;cmd, &quot;sandbox&quot;, 3)) {</a>
<a name="ln2200">        if (!skip_only) {</a>
<a name="ln2201">          if (!eap-&gt;did_sandbox) {</a>
<a name="ln2202">            sandbox++;</a>
<a name="ln2203">          }</a>
<a name="ln2204">          eap-&gt;did_sandbox = true;</a>
<a name="ln2205">        }</a>
<a name="ln2206">        continue;</a>
<a name="ln2207">    }</a>
<a name="ln2208">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;silent&quot;, 3)) {</a>
<a name="ln2209">        break;</a>
<a name="ln2210">      }</a>
<a name="ln2211">      if (!skip_only) {</a>
<a name="ln2212">        if (eap-&gt;save_msg_silent == -1) {</a>
<a name="ln2213">          eap-&gt;save_msg_silent = msg_silent;</a>
<a name="ln2214">        }</a>
<a name="ln2215">        msg_silent++;</a>
<a name="ln2216">      }</a>
<a name="ln2217">      if (*eap-&gt;cmd == '!' &amp;&amp; !ascii_iswhite(eap-&gt;cmd[-1])) {</a>
<a name="ln2218">        // &quot;:silent!&quot;, but not &quot;silent !cmd&quot;</a>
<a name="ln2219">        eap-&gt;cmd = skipwhite(eap-&gt;cmd + 1);</a>
<a name="ln2220">        if (!skip_only) {</a>
<a name="ln2221">          emsg_silent++;</a>
<a name="ln2222">          eap-&gt;did_esilent++;</a>
<a name="ln2223">        }</a>
<a name="ln2224">      }</a>
<a name="ln2225">      continue;</a>
<a name="ln2226"> </a>
<a name="ln2227">    case 't':   if (checkforcmd(&amp;p, &quot;tab&quot;, 3)) {</a>
<a name="ln2228">      if (!skip_only) {</a>
<a name="ln2229">        long tabnr = get_address(</a>
<a name="ln2230">            eap, &amp;eap-&gt;cmd, ADDR_TABS, eap-&gt;skip, skip_only, false, 1);</a>
<a name="ln2231"> </a>
<a name="ln2232">        if (tabnr == MAXLNUM) {</a>
<a name="ln2233">          cmdmod.tab = tabpage_index(curtab) + 1;</a>
<a name="ln2234">        } else {</a>
<a name="ln2235">          if (tabnr &lt; 0 || tabnr &gt; LAST_TAB_NR) {</a>
<a name="ln2236">            *errormsg = (char_u *)_(e_invrange);</a>
<a name="ln2237">            return false;</a>
<a name="ln2238">          }</a>
<a name="ln2239">          cmdmod.tab = tabnr + 1;</a>
<a name="ln2240">        }</a>
<a name="ln2241">      }</a>
<a name="ln2242">      eap-&gt;cmd = p;</a>
<a name="ln2243">      continue;</a>
<a name="ln2244">    }</a>
<a name="ln2245">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;topleft&quot;, 2)) {</a>
<a name="ln2246">        break;</a>
<a name="ln2247">      }</a>
<a name="ln2248">      cmdmod.split |= WSP_TOP;</a>
<a name="ln2249">      continue;</a>
<a name="ln2250"> </a>
<a name="ln2251">    case 'u':   if (!checkforcmd(&amp;eap-&gt;cmd, &quot;unsilent&quot;, 3))</a>
<a name="ln2252">        break;</a>
<a name="ln2253">      if (!skip_only) {</a>
<a name="ln2254">        if (eap-&gt;save_msg_silent == -1) {</a>
<a name="ln2255">          eap-&gt;save_msg_silent = msg_silent;</a>
<a name="ln2256">        }</a>
<a name="ln2257">        msg_silent = 0;</a>
<a name="ln2258">      }</a>
<a name="ln2259">      continue;</a>
<a name="ln2260"> </a>
<a name="ln2261">    case 'v':   if (checkforcmd(&amp;eap-&gt;cmd, &quot;vertical&quot;, 4)) {</a>
<a name="ln2262">        cmdmod.split |= WSP_VERT;</a>
<a name="ln2263">        continue;</a>
<a name="ln2264">    }</a>
<a name="ln2265">      if (!checkforcmd(&amp;p, &quot;verbose&quot;, 4))</a>
<a name="ln2266">        break;</a>
<a name="ln2267">      if (!skip_only) {</a>
<a name="ln2268">        if (eap-&gt;verbose_save &lt; 0) {</a>
<a name="ln2269">          eap-&gt;verbose_save = p_verbose;</a>
<a name="ln2270">        }</a>
<a name="ln2271">        if (ascii_isdigit(*eap-&gt;cmd)) {</a>
<a name="ln2272">          p_verbose = atoi((char *)eap-&gt;cmd);</a>
<a name="ln2273">        } else {</a>
<a name="ln2274">          p_verbose = 1;</a>
<a name="ln2275">        }</a>
<a name="ln2276">      }</a>
<a name="ln2277">      eap-&gt;cmd = p;</a>
<a name="ln2278">      continue;</a>
<a name="ln2279">    }</a>
<a name="ln2280">    break;</a>
<a name="ln2281">  }</a>
<a name="ln2282"> </a>
<a name="ln2283">  return OK;</a>
<a name="ln2284">}</a>
<a name="ln2285"> </a>
<a name="ln2286">// Undo and free contents of &quot;cmdmod&quot;.</a>
<a name="ln2287">static void undo_cmdmod(const exarg_T *eap, int save_msg_scroll)</a>
<a name="ln2288">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2289">{</a>
<a name="ln2290">  if (eap-&gt;verbose_save &gt;= 0) {</a>
<a name="ln2291">    p_verbose = eap-&gt;verbose_save;</a>
<a name="ln2292">  }</a>
<a name="ln2293"> </a>
<a name="ln2294">  if (cmdmod.save_ei != NULL) {</a>
<a name="ln2295">    // Restore 'eventignore' to the value before &quot;:noautocmd&quot;.</a>
<a name="ln2296">    set_string_option_direct(&quot;ei&quot;, -1, cmdmod.save_ei, OPT_FREE, SID_NONE);</a>
<a name="ln2297">    free_string_option(cmdmod.save_ei);</a>
<a name="ln2298">  }</a>
<a name="ln2299"> </a>
<a name="ln2300">  vim_regfree(cmdmod.filter_regmatch.regprog);</a>
<a name="ln2301"> </a>
<a name="ln2302">  if (eap-&gt;save_msg_silent != -1) {</a>
<a name="ln2303">    // messages could be enabled for a serious error, need to check if the</a>
<a name="ln2304">    // counters don't become negative</a>
<a name="ln2305">    if (!did_emsg || msg_silent &gt; eap-&gt;save_msg_silent) {</a>
<a name="ln2306">      msg_silent = eap-&gt;save_msg_silent;</a>
<a name="ln2307">    }</a>
<a name="ln2308">    emsg_silent -= eap-&gt;did_esilent;</a>
<a name="ln2309">    if (emsg_silent &lt; 0) {</a>
<a name="ln2310">      emsg_silent = 0;</a>
<a name="ln2311">    }</a>
<a name="ln2312">    // Restore msg_scroll, it's set by file I/O commands, even when no</a>
<a name="ln2313">    // message is actually displayed.</a>
<a name="ln2314">    msg_scroll = save_msg_scroll;</a>
<a name="ln2315"> </a>
<a name="ln2316">    // &quot;silent reg&quot; or &quot;silent echo x&quot; inside &quot;redir&quot; leaves msg_col</a>
<a name="ln2317">    // somewhere in the line.  Put it back in the first column.</a>
<a name="ln2318">    if (redirecting()) {</a>
<a name="ln2319">      msg_col = 0;</a>
<a name="ln2320">    }</a>
<a name="ln2321">  }</a>
<a name="ln2322">}</a>
<a name="ln2323"> </a>
<a name="ln2324"> </a>
<a name="ln2325">// Parse the address range, if any, in &quot;eap&quot;.</a>
<a name="ln2326">// May set the last search pattern, unless &quot;silent&quot; is true.</a>
<a name="ln2327">// Return FAIL and set &quot;errormsg&quot; or return OK.</a>
<a name="ln2328">int parse_cmd_address(exarg_T *eap, char_u **errormsg, bool silent)</a>
<a name="ln2329">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2330">{</a>
<a name="ln2331">  int address_count = 1;</a>
<a name="ln2332">  linenr_T lnum;</a>
<a name="ln2333"> </a>
<a name="ln2334">  // Repeat for all ',' or ';' separated addresses.</a>
<a name="ln2335">  for (;;) {</a>
<a name="ln2336">    eap-&gt;line1 = eap-&gt;line2;</a>
<a name="ln2337">    switch (eap-&gt;addr_type) {</a>
<a name="ln2338">      case ADDR_LINES:</a>
<a name="ln2339">      case ADDR_OTHER:</a>
<a name="ln2340">        // default is current line number</a>
<a name="ln2341">        eap-&gt;line2 = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2342">        break;</a>
<a name="ln2343">      case ADDR_WINDOWS:</a>
<a name="ln2344">        eap-&gt;line2 = CURRENT_WIN_NR;</a>
<a name="ln2345">        break;</a>
<a name="ln2346">      case ADDR_ARGUMENTS:</a>
<a name="ln2347">        eap-&gt;line2 = curwin-&gt;w_arg_idx + 1;</a>
<a name="ln2348">        if (eap-&gt;line2 &gt; ARGCOUNT) {</a>
<a name="ln2349">          eap-&gt;line2 = ARGCOUNT;</a>
<a name="ln2350">        }</a>
<a name="ln2351">        break;</a>
<a name="ln2352">      case ADDR_LOADED_BUFFERS:</a>
<a name="ln2353">      case ADDR_BUFFERS:</a>
<a name="ln2354">        eap-&gt;line2 = curbuf-&gt;b_fnum;</a>
<a name="ln2355">        break;</a>
<a name="ln2356">      case ADDR_TABS:</a>
<a name="ln2357">        eap-&gt;line2 = CURRENT_TAB_NR;</a>
<a name="ln2358">        break;</a>
<a name="ln2359">      case ADDR_TABS_RELATIVE:</a>
<a name="ln2360">      case ADDR_UNSIGNED:</a>
<a name="ln2361">        eap-&gt;line2 = 1;</a>
<a name="ln2362">        break;</a>
<a name="ln2363">      case ADDR_QUICKFIX:</a>
<a name="ln2364">        eap-&gt;line2 = qf_get_cur_idx(eap);</a>
<a name="ln2365">        break;</a>
<a name="ln2366">      case ADDR_QUICKFIX_VALID:</a>
<a name="ln2367">        eap-&gt;line2 = qf_get_cur_valid_idx(eap);</a>
<a name="ln2368">        break;</a>
<a name="ln2369">      case ADDR_NONE:</a>
<a name="ln2370">        // Will give an error later if a range is found.</a>
<a name="ln2371">        break;</a>
<a name="ln2372">    }</a>
<a name="ln2373">    eap-&gt;cmd = skipwhite(eap-&gt;cmd);</a>
<a name="ln2374">    lnum = get_address(eap, &amp;eap-&gt;cmd, eap-&gt;addr_type, eap-&gt;skip, silent,</a>
<a name="ln2375">                       eap-&gt;addr_count == 0, address_count++);</a>
<a name="ln2376">    if (eap-&gt;cmd == NULL) {  // error detected</a>
<a name="ln2377">      return FAIL;</a>
<a name="ln2378">    }</a>
<a name="ln2379">    if (lnum == MAXLNUM) {</a>
<a name="ln2380">      if (*eap-&gt;cmd == '%') {  // '%' - all lines</a>
<a name="ln2381">        eap-&gt;cmd++;</a>
<a name="ln2382">        switch (eap-&gt;addr_type) {</a>
<a name="ln2383">          case ADDR_LINES:</a>
<a name="ln2384">          case ADDR_OTHER:</a>
<a name="ln2385">            eap-&gt;line1 = 1;</a>
<a name="ln2386">            eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2387">            break;</a>
<a name="ln2388">          case ADDR_LOADED_BUFFERS: {</a>
<a name="ln2389">            buf_T *buf = firstbuf;</a>
<a name="ln2390"> </a>
<a name="ln2391">            while (buf-&gt;b_next != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln2392">              buf = buf-&gt;b_next;</a>
<a name="ln2393">            }</a>
<a name="ln2394">            eap-&gt;line1 = buf-&gt;b_fnum;</a>
<a name="ln2395">            buf = lastbuf;</a>
<a name="ln2396">            while (buf-&gt;b_prev != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln2397">              buf = buf-&gt;b_prev;</a>
<a name="ln2398">            }</a>
<a name="ln2399">            eap-&gt;line2 = buf-&gt;b_fnum;</a>
<a name="ln2400">            break;</a>
<a name="ln2401">          }</a>
<a name="ln2402">          case ADDR_BUFFERS:</a>
<a name="ln2403">            eap-&gt;line1 = firstbuf-&gt;b_fnum;</a>
<a name="ln2404">            eap-&gt;line2 = lastbuf-&gt;b_fnum;</a>
<a name="ln2405">            break;</a>
<a name="ln2406">          case ADDR_WINDOWS:</a>
<a name="ln2407">          case ADDR_TABS:</a>
<a name="ln2408">            if (IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln2409">              eap-&gt;line1 = 1;</a>
<a name="ln2410">              eap-&gt;line2 = eap-&gt;addr_type == ADDR_WINDOWS</a>
<a name="ln2411">                ? LAST_WIN_NR : LAST_TAB_NR;</a>
<a name="ln2412">            } else {</a>
<a name="ln2413">              // there is no Vim command which uses '%' and</a>
<a name="ln2414">              // ADDR_WINDOWS or ADDR_TABS</a>
<a name="ln2415">              *errormsg = (char_u *)_(e_invrange);</a>
<a name="ln2416">              return FAIL;</a>
<a name="ln2417">            }</a>
<a name="ln2418">            break;</a>
<a name="ln2419">          case ADDR_TABS_RELATIVE:</a>
<a name="ln2420">          case ADDR_UNSIGNED:</a>
<a name="ln2421">          case ADDR_QUICKFIX:</a>
<a name="ln2422">            *errormsg = (char_u *)_(e_invrange);</a>
<a name="ln2423">            return FAIL;</a>
<a name="ln2424">          case ADDR_ARGUMENTS:</a>
<a name="ln2425">            if (ARGCOUNT == 0) {</a>
<a name="ln2426">              eap-&gt;line1 = eap-&gt;line2 = 0;</a>
<a name="ln2427">            } else {</a>
<a name="ln2428">              eap-&gt;line1 = 1;</a>
<a name="ln2429">              eap-&gt;line2 = ARGCOUNT;</a>
<a name="ln2430">            }</a>
<a name="ln2431">            break;</a>
<a name="ln2432">          case ADDR_QUICKFIX_VALID:</a>
<a name="ln2433">            eap-&gt;line1 = 1;</a>
<a name="ln2434">            eap-&gt;line2 = qf_get_valid_size(eap);</a>
<a name="ln2435">            if (eap-&gt;line2 == 0) {</a>
<a name="ln2436">              eap-&gt;line2 = 1;</a>
<a name="ln2437">            }</a>
<a name="ln2438">            break;</a>
<a name="ln2439">          case ADDR_NONE:</a>
<a name="ln2440">            // Will give an error later if a range is found.</a>
<a name="ln2441">            break;</a>
<a name="ln2442">        }</a>
<a name="ln2443">        eap-&gt;addr_count++;</a>
<a name="ln2444">      } else if (*eap-&gt;cmd == '*') {</a>
<a name="ln2445">        // '*' - visual area</a>
<a name="ln2446">        if (eap-&gt;addr_type != ADDR_LINES) {</a>
<a name="ln2447">          *errormsg = (char_u *)_(e_invrange);</a>
<a name="ln2448">          return FAIL;</a>
<a name="ln2449">        }</a>
<a name="ln2450"> </a>
<a name="ln2451">        eap-&gt;cmd++;</a>
<a name="ln2452">        if (!eap-&gt;skip) {</a>
<a name="ln2453">          pos_T *fp = getmark('&lt;', false);</a>
<a name="ln2454">          if (check_mark(fp) == FAIL) {</a>
<a name="ln2455">            return FAIL;</a>
<a name="ln2456">          }</a>
<a name="ln2457">          eap-&gt;line1 = fp-&gt;lnum;</a>
<a name="ln2458">          fp = getmark('&gt;', false);</a>
<a name="ln2459">          if (check_mark(fp) == FAIL) {</a>
<a name="ln2460">            return FAIL;</a>
<a name="ln2461">          }</a>
<a name="ln2462">          eap-&gt;line2 = fp-&gt;lnum;</a>
<a name="ln2463">          eap-&gt;addr_count++;</a>
<a name="ln2464">        }</a>
<a name="ln2465">      }</a>
<a name="ln2466">    } else {</a>
<a name="ln2467">      eap-&gt;line2 = lnum;</a>
<a name="ln2468">    }</a>
<a name="ln2469">    eap-&gt;addr_count++;</a>
<a name="ln2470"> </a>
<a name="ln2471">    if (*eap-&gt;cmd == ';') {</a>
<a name="ln2472">      if (!eap-&gt;skip) {</a>
<a name="ln2473">        curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln2474">        // Don't leave the cursor on an illegal line or column, but do</a>
<a name="ln2475">        // accept zero as address, so 0;/PATTERN/ works correctly.</a>
<a name="ln2476">        if (eap-&gt;line2 &gt; 0) {</a>
<a name="ln2477">          check_cursor();</a>
<a name="ln2478">        }</a>
<a name="ln2479">      }</a>
<a name="ln2480">    } else if (*eap-&gt;cmd != ',') {</a>
<a name="ln2481">      break;</a>
<a name="ln2482">    }</a>
<a name="ln2483">    eap-&gt;cmd++;</a>
<a name="ln2484">  }</a>
<a name="ln2485"> </a>
<a name="ln2486">  // One address given: set start and end lines.</a>
<a name="ln2487">  if (eap-&gt;addr_count == 1) {</a>
<a name="ln2488">    eap-&gt;line1 = eap-&gt;line2;</a>
<a name="ln2489">    // ... but only implicit: really no address given</a>
<a name="ln2490">    if (lnum == MAXLNUM) {</a>
<a name="ln2491">      eap-&gt;addr_count = 0;</a>
<a name="ln2492">    }</a>
<a name="ln2493">  }</a>
<a name="ln2494">  return OK;</a>
<a name="ln2495">}</a>
<a name="ln2496"> </a>
<a name="ln2497">/*</a>
<a name="ln2498"> * Check for an Ex command with optional tail.</a>
<a name="ln2499"> * If there is a match advance &quot;pp&quot; to the argument and return TRUE.</a>
<a name="ln2500"> */</a>
<a name="ln2501">int</a>
<a name="ln2502">checkforcmd(</a>
<a name="ln2503">    char_u **pp,              // start of command</a>
<a name="ln2504">    char *cmd,                // name of command</a>
<a name="ln2505">    int len                   // required length</a>
<a name="ln2506">)</a>
<a name="ln2507">{</a>
<a name="ln2508">  int i;</a>
<a name="ln2509"> </a>
<a name="ln2510">  for (i = 0; cmd[i] != NUL; ++i)</a>
<a name="ln2511">    if (((char_u *)cmd)[i] != (*pp)[i])</a>
<a name="ln2512">      break;</a>
<a name="ln2513">  if (i &gt;= len &amp;&amp; !isalpha((*pp)[i])) {</a>
<a name="ln2514">    *pp = skipwhite(*pp + i);</a>
<a name="ln2515">    return TRUE;</a>
<a name="ln2516">  }</a>
<a name="ln2517">  return FALSE;</a>
<a name="ln2518">}</a>
<a name="ln2519"> </a>
<a name="ln2520">/*</a>
<a name="ln2521"> * Append &quot;cmd&quot; to the error message in IObuff.</a>
<a name="ln2522"> * Takes care of limiting the length and handling 0xa0, which would be</a>
<a name="ln2523"> * invisible otherwise.</a>
<a name="ln2524"> */</a>
<a name="ln2525">static void append_command(char_u *cmd)</a>
<a name="ln2526">{</a>
<a name="ln2527">  char_u *s = cmd;</a>
<a name="ln2528">  char_u *d;</a>
<a name="ln2529"> </a>
<a name="ln2530">  STRCAT(IObuff, &quot;: &quot;);</a>
<a name="ln2531">  d = IObuff + STRLEN(IObuff);</a>
<a name="ln2532">  while (*s != NUL &amp;&amp; d - IObuff &lt; IOSIZE - 7) {</a>
<a name="ln2533">    if (s[0] == 0xc2 &amp;&amp; s[1] == 0xa0) {</a>
<a name="ln2534">      s += 2;</a>
<a name="ln2535">      STRCPY(d, &quot;&lt;a0&gt;&quot;);</a>
<a name="ln2536">      d += 4;</a>
<a name="ln2537">    } else</a>
<a name="ln2538">      MB_COPY_CHAR(s, d);</a>
<a name="ln2539">  }</a>
<a name="ln2540">  *d = NUL;</a>
<a name="ln2541">}</a>
<a name="ln2542"> </a>
<a name="ln2543">// Find an Ex command by its name, either built-in or user.</a>
<a name="ln2544">// Start of the name can be found at eap-&gt;cmd.</a>
<a name="ln2545">// Sets eap-&gt;cmdidx and returns a pointer to char after the command name.</a>
<a name="ln2546">// &quot;full&quot; is set to TRUE if the whole command name matched.</a>
<a name="ln2547">// Returns NULL for an ambiguous user command.</a>
<a name="ln2548">static char_u *find_command(exarg_T *eap, int *full)</a>
<a name="ln2549">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2550">{</a>
<a name="ln2551">  int len;</a>
<a name="ln2552">  char_u      *p;</a>
<a name="ln2553">  int i;</a>
<a name="ln2554"> </a>
<a name="ln2555">  /*</a>
<a name="ln2556">   * Isolate the command and search for it in the command table.</a>
<a name="ln2557">   * Exceptions:</a>
<a name="ln2558">   * - the 'k' command can directly be followed by any character.</a>
<a name="ln2559">   * - the 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r'</a>
<a name="ln2560">   *	    but :sre[wind] is another command, as are :scr[iptnames],</a>
<a name="ln2561">   *	    :scs[cope], :sim[alt], :sig[ns] and :sil[ent].</a>
<a name="ln2562">   * - the &quot;d&quot; command can directly be followed by 'l' or 'p' flag.</a>
<a name="ln2563">   */</a>
<a name="ln2564">  p = eap-&gt;cmd;</a>
<a name="ln2565">  if (*p == 'k') {</a>
<a name="ln2566">    eap-&gt;cmdidx = CMD_k;</a>
<a name="ln2567">    ++p;</a>
<a name="ln2568">  } else if (p[0] == 's'</a>
<a name="ln2569">             &amp;&amp; ((p[1] == 'c'</a>
<a name="ln2570">                  &amp;&amp; (p[2] == NUL</a>
<a name="ln2571">                      || (p[2] != 's' &amp;&amp; p[2] != 'r'</a>
<a name="ln2572">                          &amp;&amp; (p[3] == NUL</a>
<a name="ln2573">                              || (p[3] != 'i' &amp;&amp; p[4] != 'p')))))</a>
<a name="ln2574">                 || p[1] == 'g'</a>
<a name="ln2575">                 || (p[1] == 'i' &amp;&amp; p[2] != 'm' &amp;&amp; p[2] != 'l' &amp;&amp; p[2] != 'g')</a>
<a name="ln2576">                 || p[1] == 'I'</a>
<a name="ln2577">                 || (p[1] == 'r' &amp;&amp; p[2] != 'e'))) {</a>
<a name="ln2578">    eap-&gt;cmdidx = CMD_substitute;</a>
<a name="ln2579">    ++p;</a>
<a name="ln2580">  } else {</a>
<a name="ln2581">    while (ASCII_ISALPHA(*p))</a>
<a name="ln2582">      ++p;</a>
<a name="ln2583">    /* for python 3.x support &quot;:py3&quot;, &quot;:python3&quot;, &quot;:py3file&quot;, etc. */</a>
<a name="ln2584">    if (eap-&gt;cmd[0] == 'p' &amp;&amp; eap-&gt;cmd[1] == 'y')</a>
<a name="ln2585">      while (ASCII_ISALNUM(*p))</a>
<a name="ln2586">        ++p;</a>
<a name="ln2587"> </a>
<a name="ln2588">    /* check for non-alpha command */</a>
<a name="ln2589">    if (p == eap-&gt;cmd &amp;&amp; vim_strchr((char_u *)&quot;@!=&gt;&lt;&amp;~#&quot;, *p) != NULL)</a>
<a name="ln2590">      ++p;</a>
<a name="ln2591">    len = (int)(p - eap-&gt;cmd);</a>
<a name="ln2592">    if (*eap-&gt;cmd == 'd' &amp;&amp; (p[-1] == 'l' || p[-1] == 'p')) {</a>
<a name="ln2593">      /* Check for &quot;:dl&quot;, &quot;:dell&quot;, etc. to &quot;:deletel&quot;: that's</a>
<a name="ln2594">       * :delete with the 'l' flag.  Same for 'p'. */</a>
<a name="ln2595">      for (i = 0; i &lt; len; ++i)</a>
<a name="ln2596">        if (eap-&gt;cmd[i] != ((char_u *)&quot;delete&quot;)[i])</a>
<a name="ln2597">          break;</a>
<a name="ln2598">      if (i == len - 1) {</a>
<a name="ln2599">        --len;</a>
<a name="ln2600">        if (p[-1] == 'l')</a>
<a name="ln2601">          eap-&gt;flags |= EXFLAG_LIST;</a>
<a name="ln2602">        else</a>
<a name="ln2603">          eap-&gt;flags |= EXFLAG_PRINT;</a>
<a name="ln2604">      }</a>
<a name="ln2605">    }</a>
<a name="ln2606"> </a>
<a name="ln2607">    if (ASCII_ISLOWER(eap-&gt;cmd[0])) {</a>
<a name="ln2608">      const int c1 = eap-&gt;cmd[0];</a>
<a name="ln2609">      const int c2 = len == 1 ? NUL : eap-&gt;cmd[1];</a>
<a name="ln2610"> </a>
<a name="ln2611">      if (command_count != (int)CMD_SIZE) {</a>
<a name="ln2612">        iemsg((char *)_(&quot;E943: Command table needs to be updated, run 'make'&quot;));</a>
<a name="ln2613">        getout(1);</a>
<a name="ln2614">      }</a>
<a name="ln2615"> </a>
<a name="ln2616">      // Use a precomputed index for fast look-up in cmdnames[]</a>
<a name="ln2617">      // taking into account the first 2 letters of eap-&gt;cmd.</a>
<a name="ln2618">      eap-&gt;cmdidx = cmdidxs1[CharOrdLow(c1)];</a>
<a name="ln2619">      if (ASCII_ISLOWER(c2)) {</a>
<a name="ln2620">        eap-&gt;cmdidx += cmdidxs2[CharOrdLow(c1)][CharOrdLow(c2)];</a>
<a name="ln2621">      }</a>
<a name="ln2622">    } else {</a>
<a name="ln2623">      eap-&gt;cmdidx = CMD_bang;</a>
<a name="ln2624">    }</a>
<a name="ln2625"> </a>
<a name="ln2626">    for (; (int)eap-&gt;cmdidx &lt; (int)CMD_SIZE;</a>
<a name="ln2627">         eap-&gt;cmdidx = (cmdidx_T)((int)eap-&gt;cmdidx + 1))</a>
<a name="ln2628">      if (STRNCMP(cmdnames[(int)eap-&gt;cmdidx].cmd_name, (char *)eap-&gt;cmd,</a>
<a name="ln2629">              (size_t)len) == 0) {</a>
<a name="ln2630">        if (full != NULL</a>
<a name="ln2631">            &amp;&amp; cmdnames[(int)eap-&gt;cmdidx].cmd_name[len] == NUL)</a>
<a name="ln2632">          *full = TRUE;</a>
<a name="ln2633">        break;</a>
<a name="ln2634">      }</a>
<a name="ln2635"> </a>
<a name="ln2636">    // Look for a user defined command as a last resort.</a>
<a name="ln2637">    if ((eap-&gt;cmdidx == CMD_SIZE)</a>
<a name="ln2638">        &amp;&amp; *eap-&gt;cmd &gt;= 'A' &amp;&amp; *eap-&gt;cmd &lt;= 'Z') {</a>
<a name="ln2639">      /* User defined commands may contain digits. */</a>
<a name="ln2640">      while (ASCII_ISALNUM(*p))</a>
<a name="ln2641">        ++p;</a>
<a name="ln2642">      p = find_ucmd(eap, p, full, NULL, NULL);</a>
<a name="ln2643">    }</a>
<a name="ln2644">    if (p == eap-&gt;cmd)</a>
<a name="ln2645">      eap-&gt;cmdidx = CMD_SIZE;</a>
<a name="ln2646">  }</a>
<a name="ln2647"> </a>
<a name="ln2648">  return p;</a>
<a name="ln2649">}</a>
<a name="ln2650"> </a>
<a name="ln2651">/*</a>
<a name="ln2652"> * Search for a user command that matches &quot;eap-&gt;cmd&quot;.</a>
<a name="ln2653"> * Return cmdidx in &quot;eap-&gt;cmdidx&quot;, flags in &quot;eap-&gt;argt&quot;, idx in &quot;eap-&gt;useridx&quot;.</a>
<a name="ln2654"> * Return a pointer to just after the command.</a>
<a name="ln2655"> * Return NULL if there is no matching command.</a>
<a name="ln2656"> */</a>
<a name="ln2657">static char_u *</a>
<a name="ln2658">find_ucmd (</a>
<a name="ln2659">    exarg_T *eap,</a>
<a name="ln2660">    char_u *p,      // end of the command (possibly including count)</a>
<a name="ln2661">    int *full,      // set to TRUE for a full match</a>
<a name="ln2662">    expand_T *xp,   // used for completion, NULL otherwise</a>
<a name="ln2663">    int *complp     // completion flags or NULL</a>
<a name="ln2664">)</a>
<a name="ln2665">{</a>
<a name="ln2666">  int len = (int)(p - eap-&gt;cmd);</a>
<a name="ln2667">  int j, k, matchlen = 0;</a>
<a name="ln2668">  ucmd_T      *uc;</a>
<a name="ln2669">  int found = FALSE;</a>
<a name="ln2670">  int possible = FALSE;</a>
<a name="ln2671">  char_u      *cp, *np;             /* Point into typed cmd and test name */</a>
<a name="ln2672">  garray_T    *gap;</a>
<a name="ln2673">  int amb_local = FALSE;            /* Found ambiguous buffer-local command,</a>
<a name="ln2674">                                       only full match global is accepted. */</a>
<a name="ln2675"> </a>
<a name="ln2676">  /*</a>
<a name="ln2677">   * Look for buffer-local user commands first, then global ones.</a>
<a name="ln2678">   */</a>
<a name="ln2679">  gap = &amp;curbuf-&gt;b_ucmds;</a>
<a name="ln2680">  for (;; ) {</a>
<a name="ln2681">    for (j = 0; j &lt; gap-&gt;ga_len; ++j) {</a>
<a name="ln2682">      uc = USER_CMD_GA(gap, j);</a>
<a name="ln2683">      cp = eap-&gt;cmd;</a>
<a name="ln2684">      np = uc-&gt;uc_name;</a>
<a name="ln2685">      k = 0;</a>
<a name="ln2686">      while (k &lt; len &amp;&amp; *np != NUL &amp;&amp; *cp++ == *np++)</a>
<a name="ln2687">        k++;</a>
<a name="ln2688">      if (k == len || (*np == NUL &amp;&amp; ascii_isdigit(eap-&gt;cmd[k]))) {</a>
<a name="ln2689">        /* If finding a second match, the command is ambiguous.  But</a>
<a name="ln2690">         * not if a buffer-local command wasn't a full match and a</a>
<a name="ln2691">         * global command is a full match. */</a>
<a name="ln2692">        if (k == len &amp;&amp; found &amp;&amp; *np != NUL) {</a>
<a name="ln2693">          if (gap == &amp;ucmds)</a>
<a name="ln2694">            return NULL;</a>
<a name="ln2695">          amb_local = TRUE;</a>
<a name="ln2696">        }</a>
<a name="ln2697"> </a>
<a name="ln2698">        if (!found || (k == len &amp;&amp; *np == NUL)) {</a>
<a name="ln2699">          /* If we matched up to a digit, then there could</a>
<a name="ln2700">           * be another command including the digit that we</a>
<a name="ln2701">           * should use instead.</a>
<a name="ln2702">           */</a>
<a name="ln2703">          if (k == len)</a>
<a name="ln2704">            found = TRUE;</a>
<a name="ln2705">          else</a>
<a name="ln2706">            possible = TRUE;</a>
<a name="ln2707"> </a>
<a name="ln2708">          if (gap == &amp;ucmds)</a>
<a name="ln2709">            eap-&gt;cmdidx = CMD_USER;</a>
<a name="ln2710">          else</a>
<a name="ln2711">            eap-&gt;cmdidx = CMD_USER_BUF;</a>
<a name="ln2712">          eap-&gt;argt = uc-&gt;uc_argt;</a>
<a name="ln2713">          eap-&gt;useridx = j;</a>
<a name="ln2714">          eap-&gt;addr_type = uc-&gt;uc_addr_type;</a>
<a name="ln2715"> </a>
<a name="ln2716">          if (complp != NULL) {</a>
<a name="ln2717">            *complp = uc-&gt;uc_compl;</a>
<a name="ln2718">          }</a>
<a name="ln2719">          if (xp != NULL) {</a>
<a name="ln2720">            xp-&gt;xp_arg = uc-&gt;uc_compl_arg;</a>
<a name="ln2721">            xp-&gt;xp_script_ctx = uc-&gt;uc_script_ctx;</a>
<a name="ln2722">            xp-&gt;xp_script_ctx.sc_lnum += sourcing_lnum;</a>
<a name="ln2723">          }</a>
<a name="ln2724">          /* Do not search for further abbreviations</a>
<a name="ln2725">           * if this is an exact match. */</a>
<a name="ln2726">          matchlen = k;</a>
<a name="ln2727">          if (k == len &amp;&amp; *np == NUL) {</a>
<a name="ln2728">            if (full != NULL)</a>
<a name="ln2729">              *full = TRUE;</a>
<a name="ln2730">            amb_local = FALSE;</a>
<a name="ln2731">            break;</a>
<a name="ln2732">          }</a>
<a name="ln2733">        }</a>
<a name="ln2734">      }</a>
<a name="ln2735">    }</a>
<a name="ln2736"> </a>
<a name="ln2737">    /* Stop if we found a full match or searched all. */</a>
<a name="ln2738">    if (j &lt; gap-&gt;ga_len || gap == &amp;ucmds)</a>
<a name="ln2739">      break;</a>
<a name="ln2740">    gap = &amp;ucmds;</a>
<a name="ln2741">  }</a>
<a name="ln2742"> </a>
<a name="ln2743">  /* Only found ambiguous matches. */</a>
<a name="ln2744">  if (amb_local) {</a>
<a name="ln2745">    if (xp != NULL)</a>
<a name="ln2746">      xp-&gt;xp_context = EXPAND_UNSUCCESSFUL;</a>
<a name="ln2747">    return NULL;</a>
<a name="ln2748">  }</a>
<a name="ln2749"> </a>
<a name="ln2750">  /* The match we found may be followed immediately by a number.  Move &quot;p&quot;</a>
<a name="ln2751">   * back to point to it. */</a>
<a name="ln2752">  if (found || possible)</a>
<a name="ln2753">    return p + (matchlen - len);</a>
<a name="ln2754">  return p;</a>
<a name="ln2755">}</a>
<a name="ln2756"> </a>
<a name="ln2757">static struct cmdmod {</a>
<a name="ln2758">  char        *name;</a>
<a name="ln2759">  int minlen;</a>
<a name="ln2760">  int has_count;            /* :123verbose  :3tab */</a>
<a name="ln2761">} cmdmods[] = {</a>
<a name="ln2762">  { &quot;aboveleft&quot;, 3, false },</a>
<a name="ln2763">  { &quot;belowright&quot;, 3, false },</a>
<a name="ln2764">  { &quot;botright&quot;, 2, false },</a>
<a name="ln2765">  { &quot;browse&quot;, 3, false },</a>
<a name="ln2766">  { &quot;confirm&quot;, 4, false },</a>
<a name="ln2767">  { &quot;filter&quot;, 4, false },</a>
<a name="ln2768">  { &quot;hide&quot;, 3, false },</a>
<a name="ln2769">  { &quot;keepalt&quot;, 5, false },</a>
<a name="ln2770">  { &quot;keepjumps&quot;, 5, false },</a>
<a name="ln2771">  { &quot;keepmarks&quot;, 3, false },</a>
<a name="ln2772">  { &quot;keeppatterns&quot;, 5, false },</a>
<a name="ln2773">  { &quot;leftabove&quot;, 5, false },</a>
<a name="ln2774">  { &quot;lockmarks&quot;, 3, false },</a>
<a name="ln2775">  { &quot;noautocmd&quot;, 3, false },</a>
<a name="ln2776">  { &quot;noswapfile&quot;, 3, false },</a>
<a name="ln2777">  { &quot;rightbelow&quot;, 6, false },</a>
<a name="ln2778">  { &quot;sandbox&quot;, 3, false },</a>
<a name="ln2779">  { &quot;silent&quot;, 3, false },</a>
<a name="ln2780">  { &quot;tab&quot;, 3, true },</a>
<a name="ln2781">  { &quot;topleft&quot;, 2, false },</a>
<a name="ln2782">  { &quot;unsilent&quot;, 3, false },</a>
<a name="ln2783">  { &quot;verbose&quot;, 4, true },</a>
<a name="ln2784">  { &quot;vertical&quot;, 4, false },</a>
<a name="ln2785">};</a>
<a name="ln2786"> </a>
<a name="ln2787">/*</a>
<a name="ln2788"> * Return length of a command modifier (including optional count).</a>
<a name="ln2789"> * Return zero when it's not a modifier.</a>
<a name="ln2790"> */</a>
<a name="ln2791">int modifier_len(char_u *cmd)</a>
<a name="ln2792">{</a>
<a name="ln2793">  int i, j;</a>
<a name="ln2794">  char_u      *p = cmd;</a>
<a name="ln2795"> </a>
<a name="ln2796">  if (ascii_isdigit(*cmd))</a>
<a name="ln2797">    p = skipwhite(skipdigits(cmd));</a>
<a name="ln2798">  for (i = 0; i &lt; (int)ARRAY_SIZE(cmdmods); ++i) {</a>
<a name="ln2799">    for (j = 0; p[j] != NUL; ++j)</a>
<a name="ln2800">      if (p[j] != cmdmods[i].name[j])</a>
<a name="ln2801">        break;</a>
<a name="ln2802">    if (j &gt;= cmdmods[i].minlen</a>
<a name="ln2803">        &amp;&amp; !ASCII_ISALPHA(p[j])</a>
<a name="ln2804">        &amp;&amp; (p == cmd || cmdmods[i].has_count)) {</a>
<a name="ln2805">      return j + (int)(p - cmd);</a>
<a name="ln2806">    }</a>
<a name="ln2807">  }</a>
<a name="ln2808">  return 0;</a>
<a name="ln2809">}</a>
<a name="ln2810"> </a>
<a name="ln2811">/*</a>
<a name="ln2812"> * Return &gt; 0 if an Ex command &quot;name&quot; exists.</a>
<a name="ln2813"> * Return 2 if there is an exact match.</a>
<a name="ln2814"> * Return 3 if there is an ambiguous match.</a>
<a name="ln2815"> */</a>
<a name="ln2816">int cmd_exists(const char *const name)</a>
<a name="ln2817">{</a>
<a name="ln2818">  exarg_T ea;</a>
<a name="ln2819">  char_u      *p;</a>
<a name="ln2820"> </a>
<a name="ln2821">  // Check command modifiers.</a>
<a name="ln2822">  for (int i = 0; i &lt; (int)ARRAY_SIZE(cmdmods); i++) {</a>
<a name="ln2823">    int j;</a>
<a name="ln2824">    for (j = 0; name[j] != NUL; j++) {</a>
<a name="ln2825">      if (name[j] != (char)cmdmods[i].name[j]) {</a>
<a name="ln2826">        break;</a>
<a name="ln2827">      }</a>
<a name="ln2828">    }</a>
<a name="ln2829">    if (name[j] == NUL &amp;&amp; j &gt;= cmdmods[i].minlen) {</a>
<a name="ln2830">      return cmdmods[i].name[j] == NUL ? 2 : 1;</a>
<a name="ln2831">    }</a>
<a name="ln2832">  }</a>
<a name="ln2833"> </a>
<a name="ln2834">  /* Check built-in commands and user defined commands.</a>
<a name="ln2835">   * For &quot;:2match&quot; and &quot;:3match&quot; we need to skip the number. */</a>
<a name="ln2836">  ea.cmd = (char_u *)((*name == '2' || *name == '3') ? name + 1 : name);</a>
<a name="ln2837">  ea.cmdidx = (cmdidx_T)0;</a>
<a name="ln2838">  int full = false;</a>
<a name="ln2839">  p = find_command(&amp;ea, &amp;full);</a>
<a name="ln2840">  if (p == NULL)</a>
<a name="ln2841">    return 3;</a>
<a name="ln2842">  if (ascii_isdigit(*name) &amp;&amp; ea.cmdidx != CMD_match)</a>
<a name="ln2843">    return 0;</a>
<a name="ln2844">  if (*skipwhite(p) != NUL)</a>
<a name="ln2845">    return 0;           /* trailing garbage */</a>
<a name="ln2846">  return ea.cmdidx == CMD_SIZE ? 0 : (full ? 2 : 1);</a>
<a name="ln2847">}</a>
<a name="ln2848"> </a>
<a name="ln2849">/*</a>
<a name="ln2850"> * This is all pretty much copied from do_one_cmd(), with all the extra stuff</a>
<a name="ln2851"> * we don't need/want deleted.	Maybe this could be done better if we didn't</a>
<a name="ln2852"> * repeat all this stuff.  The only problem is that they may not stay</a>
<a name="ln2853"> * perfectly compatible with each other, but then the command line syntax</a>
<a name="ln2854"> * probably won't change that much -- webb.</a>
<a name="ln2855"> */</a>
<a name="ln2856">const char * set_one_cmd_context(</a>
<a name="ln2857">    expand_T *xp,</a>
<a name="ln2858">    const char *buff          // buffer for command string</a>
<a name="ln2859">)</a>
<a name="ln2860">{</a>
<a name="ln2861">  size_t len = 0;</a>
<a name="ln2862">  exarg_T ea;</a>
<a name="ln2863">  int context = EXPAND_NOTHING;</a>
<a name="ln2864">  bool forceit = false;</a>
<a name="ln2865">  bool usefilter = false;  // Filter instead of file name.</a>
<a name="ln2866"> </a>
<a name="ln2867">  ExpandInit(xp);</a>
<a name="ln2868">  xp-&gt;xp_pattern = (char_u *)buff;</a>
<a name="ln2869">  xp-&gt;xp_context = EXPAND_COMMANDS;  // Default until we get past command</a>
<a name="ln2870">  ea.argt = 0;</a>
<a name="ln2871"> </a>
<a name="ln2872">  // 2. skip comment lines and leading space, colons or bars</a>
<a name="ln2873">  const char *cmd;</a>
<a name="ln2874">  for (cmd = buff; vim_strchr((const char_u *)&quot; \t:|&quot;, *cmd) != NULL; cmd++) {</a>
<a name="ln2875">  }</a>
<a name="ln2876">  xp-&gt;xp_pattern = (char_u *)cmd;</a>
<a name="ln2877"> </a>
<a name="ln2878">  if (*cmd == NUL)</a>
<a name="ln2879">    return NULL;</a>
<a name="ln2880">  if (*cmd == '&quot;') {        /* ignore comment lines */</a>
<a name="ln2881">    xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln2882">    return NULL;</a>
<a name="ln2883">  }</a>
<a name="ln2884"> </a>
<a name="ln2885">  /*</a>
<a name="ln2886">   * 3. parse a range specifier of the form: addr [,addr] [;addr] ..</a>
<a name="ln2887">   */</a>
<a name="ln2888">  cmd = (const char *)skip_range((const char_u *)cmd, &amp;xp-&gt;xp_context);</a>
<a name="ln2889"> </a>
<a name="ln2890">  /*</a>
<a name="ln2891">   * 4. parse command</a>
<a name="ln2892">   */</a>
<a name="ln2893">  xp-&gt;xp_pattern = (char_u *)cmd;</a>
<a name="ln2894">  if (*cmd == NUL) {</a>
<a name="ln2895">    return NULL;</a>
<a name="ln2896">  }</a>
<a name="ln2897">  if (*cmd == '&quot;') {</a>
<a name="ln2898">    xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln2899">    return NULL;</a>
<a name="ln2900">  }</a>
<a name="ln2901"> </a>
<a name="ln2902">  if (*cmd == '|' || *cmd == '\n')</a>
<a name="ln2903">    return cmd + 1;                     /* There's another command */</a>
<a name="ln2904"> </a>
<a name="ln2905">  /*</a>
<a name="ln2906">   * Isolate the command and search for it in the command table.</a>
<a name="ln2907">   * Exceptions:</a>
<a name="ln2908">   * - the 'k' command can directly be followed by any character, but</a>
<a name="ln2909">   *   do accept &quot;keepmarks&quot;, &quot;keepalt&quot; and &quot;keepjumps&quot;.</a>
<a name="ln2910">   * - the 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r'</a>
<a name="ln2911">   */</a>
<a name="ln2912">  const char *p;</a>
<a name="ln2913">  if (*cmd == 'k' &amp;&amp; cmd[1] != 'e') {</a>
<a name="ln2914">    ea.cmdidx = CMD_k;</a>
<a name="ln2915">    p = cmd + 1;</a>
<a name="ln2916">  } else {</a>
<a name="ln2917">    p = cmd;</a>
<a name="ln2918">    while (ASCII_ISALPHA(*p) || *p == '*') {  // Allow * wild card</a>
<a name="ln2919">      p++;</a>
<a name="ln2920">    }</a>
<a name="ln2921">    // a user command may contain digits</a>
<a name="ln2922">    if (ASCII_ISUPPER(cmd[0])) {</a>
<a name="ln2923">      while (ASCII_ISALNUM(*p) || *p == '*') {</a>
<a name="ln2924">        p++;</a>
<a name="ln2925">      }</a>
<a name="ln2926">    }</a>
<a name="ln2927">    // for python 3.x: &quot;:py3*&quot; commands completion</a>
<a name="ln2928">    if (cmd[0] == 'p' &amp;&amp; cmd[1] == 'y' &amp;&amp; p == cmd + 2 &amp;&amp; *p == '3') {</a>
<a name="ln2929">      p++;</a>
<a name="ln2930">      while (ASCII_ISALPHA(*p) || *p == '*') {</a>
<a name="ln2931">        p++;</a>
<a name="ln2932">      }</a>
<a name="ln2933">    }</a>
<a name="ln2934">    // check for non-alpha command</a>
<a name="ln2935">    if (p == cmd &amp;&amp; vim_strchr((const char_u *)&quot;@*!=&gt;&lt;&amp;~#&quot;, *p) != NULL) {</a>
<a name="ln2936">      p++;</a>
<a name="ln2937">    }</a>
<a name="ln2938">    len = (size_t)(p - cmd);</a>
<a name="ln2939"> </a>
<a name="ln2940">    if (len == 0) {</a>
<a name="ln2941">      xp-&gt;xp_context = EXPAND_UNSUCCESSFUL;</a>
<a name="ln2942">      return NULL;</a>
<a name="ln2943">    }</a>
<a name="ln2944">    for (ea.cmdidx = (cmdidx_T)0; (int)ea.cmdidx &lt; (int)CMD_SIZE;</a>
<a name="ln2945">         ea.cmdidx = (cmdidx_T)((int)ea.cmdidx + 1)) {</a>
<a name="ln2946">      if (STRNCMP(cmdnames[(int)ea.cmdidx].cmd_name, cmd, len) == 0) {</a>
<a name="ln2947">        break;</a>
<a name="ln2948">      }</a>
<a name="ln2949">    }</a>
<a name="ln2950"> </a>
<a name="ln2951">    if (cmd[0] &gt;= 'A' &amp;&amp; cmd[0] &lt;= 'Z') {</a>
<a name="ln2952">      while (ASCII_ISALNUM(*p) || *p == '*') {  // Allow * wild card</a>
<a name="ln2953">        p++;</a>
<a name="ln2954">      }</a>
<a name="ln2955">    }</a>
<a name="ln2956">  }</a>
<a name="ln2957"> </a>
<a name="ln2958">  /*</a>
<a name="ln2959">   * If the cursor is touching the command, and it ends in an alpha-numeric</a>
<a name="ln2960">   * character, complete the command name.</a>
<a name="ln2961">   */</a>
<a name="ln2962">  if (*p == NUL &amp;&amp; ASCII_ISALNUM(p[-1]))</a>
<a name="ln2963">    return NULL;</a>
<a name="ln2964"> </a>
<a name="ln2965">  if (ea.cmdidx == CMD_SIZE) {</a>
<a name="ln2966">    if (*cmd == 's' &amp;&amp; vim_strchr((const char_u *)&quot;cgriI&quot;, cmd[1]) != NULL) {</a>
<a name="ln2967">      ea.cmdidx = CMD_substitute;</a>
<a name="ln2968">      p = cmd + 1;</a>
<a name="ln2969">    } else if (cmd[0] &gt;= 'A' &amp;&amp; cmd[0] &lt;= 'Z') {</a>
<a name="ln2970">      ea.cmd = (char_u *)cmd;</a>
<a name="ln2971">      p = (const char *)find_ucmd(&amp;ea, (char_u *)p, NULL, xp, &amp;context);</a>
<a name="ln2972">      if (p == NULL) {</a>
<a name="ln2973">        ea.cmdidx = CMD_SIZE;  // Ambiguous user command.</a>
<a name="ln2974">      }</a>
<a name="ln2975">    }</a>
<a name="ln2976">  }</a>
<a name="ln2977">  if (ea.cmdidx == CMD_SIZE) {</a>
<a name="ln2978">    /* Not still touching the command and it was an illegal one */</a>
<a name="ln2979">    xp-&gt;xp_context = EXPAND_UNSUCCESSFUL;</a>
<a name="ln2980">    return NULL;</a>
<a name="ln2981">  }</a>
<a name="ln2982"> </a>
<a name="ln2983">  xp-&gt;xp_context = EXPAND_NOTHING;   /* Default now that we're past command */</a>
<a name="ln2984"> </a>
<a name="ln2985">  if (*p == '!') {                  // forced commands</a>
<a name="ln2986">    forceit = true;</a>
<a name="ln2987">    p++;</a>
<a name="ln2988">  }</a>
<a name="ln2989"> </a>
<a name="ln2990">  /*</a>
<a name="ln2991">   * 5. parse arguments</a>
<a name="ln2992">   */</a>
<a name="ln2993">  if (!IS_USER_CMDIDX(ea.cmdidx)) {</a>
<a name="ln2994">    ea.argt = cmdnames[(int)ea.cmdidx].cmd_argt;</a>
<a name="ln2995">  }</a>
<a name="ln2996"> </a>
<a name="ln2997">  const char *arg = (const char *)skipwhite((const char_u *)p);</a>
<a name="ln2998"> </a>
<a name="ln2999">  // Skip over ++argopt argument</a>
<a name="ln3000">  if ((ea.argt &amp; EX_ARGOPT) &amp;&amp; *arg != NUL &amp;&amp; strncmp(arg, &quot;++&quot;, 2) == 0) {</a>
<a name="ln3001">    p = arg;</a>
<a name="ln3002">    while (*p &amp;&amp; !ascii_isspace(*p)) {</a>
<a name="ln3003">      MB_PTR_ADV(p);</a>
<a name="ln3004">    }</a>
<a name="ln3005">    arg = (const char *)skipwhite((const char_u *)p);</a>
<a name="ln3006">  }</a>
<a name="ln3007"> </a>
<a name="ln3008">  if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update) {</a>
<a name="ln3009">    if (*arg == '&gt;') {  // Append.</a>
<a name="ln3010">      if (*++arg == '&gt;') {</a>
<a name="ln3011">        arg++;</a>
<a name="ln3012">      }</a>
<a name="ln3013">      arg = (const char *)skipwhite((const char_u *)arg);</a>
<a name="ln3014">    } else if (*arg == '!' &amp;&amp; ea.cmdidx == CMD_write) {  // :w !filter</a>
<a name="ln3015">      arg++;</a>
<a name="ln3016">      usefilter = true;</a>
<a name="ln3017">    }</a>
<a name="ln3018">  }</a>
<a name="ln3019"> </a>
<a name="ln3020">  if (ea.cmdidx == CMD_read) {</a>
<a name="ln3021">    usefilter = forceit;                        // :r! filter if forced</a>
<a name="ln3022">    if (*arg == '!') {                          // :r !filter</a>
<a name="ln3023">      arg++;</a>
<a name="ln3024">      usefilter = true;</a>
<a name="ln3025">    }</a>
<a name="ln3026">  }</a>
<a name="ln3027"> </a>
<a name="ln3028">  if (ea.cmdidx == CMD_lshift || ea.cmdidx == CMD_rshift) {</a>
<a name="ln3029">    while (*arg == *cmd) {  // allow any number of '&gt;' or '&lt;'</a>
<a name="ln3030">      arg++;</a>
<a name="ln3031">    }</a>
<a name="ln3032">    arg = (const char *)skipwhite((const char_u *)arg);</a>
<a name="ln3033">  }</a>
<a name="ln3034"> </a>
<a name="ln3035">  // Does command allow &quot;+command&quot;?</a>
<a name="ln3036">  if ((ea.argt &amp; EX_CMDARG) &amp;&amp; !usefilter &amp;&amp; *arg == '+') {</a>
<a name="ln3037">    // Check if we're in the +command</a>
<a name="ln3038">    p = arg + 1;</a>
<a name="ln3039">    arg = (const char *)skip_cmd_arg((char_u *)arg, false);</a>
<a name="ln3040"> </a>
<a name="ln3041">    // Still touching the command after '+'?</a>
<a name="ln3042">    if (*arg == NUL) {</a>
<a name="ln3043">      return p;</a>
<a name="ln3044">    }</a>
<a name="ln3045"> </a>
<a name="ln3046">    // Skip space(s) after +command to get to the real argument.</a>
<a name="ln3047">    arg = (const char *)skipwhite((const char_u *)arg);</a>
<a name="ln3048">  }</a>
<a name="ln3049"> </a>
<a name="ln3050">  /*</a>
<a name="ln3051">   * Check for '|' to separate commands and '&quot;' to start comments.</a>
<a name="ln3052">   * Don't do this for &quot;:read !cmd&quot; and &quot;:write !cmd&quot;.</a>
<a name="ln3053">   */</a>
<a name="ln3054">  if ((ea.argt &amp; EX_TRLBAR) &amp;&amp; !usefilter) {</a>
<a name="ln3055">    p = arg;</a>
<a name="ln3056">    /* &quot;:redir @&quot; is not the start of a comment */</a>
<a name="ln3057">    if (ea.cmdidx == CMD_redir &amp;&amp; p[0] == '@' &amp;&amp; p[1] == '&quot;')</a>
<a name="ln3058">      p += 2;</a>
<a name="ln3059">    while (*p) {</a>
<a name="ln3060">      if (*p == Ctrl_V) {</a>
<a name="ln3061">        if (p[1] != NUL) {</a>
<a name="ln3062">          p++;</a>
<a name="ln3063">        }</a>
<a name="ln3064">      } else if ((*p == '&quot;' &amp;&amp; !(ea.argt &amp; EX_NOTRLCOM))</a>
<a name="ln3065">                 || *p == '|'</a>
<a name="ln3066">                 || *p == '\n') {</a>
<a name="ln3067">        if (*(p - 1) != '\\') {</a>
<a name="ln3068">          if (*p == '|' || *p == '\n')</a>
<a name="ln3069">            return p + 1;</a>
<a name="ln3070">          return NULL;              /* It's a comment */</a>
<a name="ln3071">        }</a>
<a name="ln3072">      }</a>
<a name="ln3073">      MB_PTR_ADV(p);</a>
<a name="ln3074">    }</a>
<a name="ln3075">  }</a>
<a name="ln3076"> </a>
<a name="ln3077">  if (!(ea.argt &amp; EX_EXTRA) &amp;&amp; *arg != NUL &amp;&amp; strchr(&quot;|\&quot;&quot;, *arg) == NULL) {</a>
<a name="ln3078">    // no arguments allowed but there is something</a>
<a name="ln3079">    return NULL;</a>
<a name="ln3080">  }</a>
<a name="ln3081"> </a>
<a name="ln3082">  /* Find start of last argument (argument just before cursor): */</a>
<a name="ln3083">  p = buff;</a>
<a name="ln3084">  xp-&gt;xp_pattern = (char_u *)p;</a>
<a name="ln3085">  len = strlen(buff);</a>
<a name="ln3086">  while (*p &amp;&amp; p &lt; buff + len) {</a>
<a name="ln3087">    if (*p == ' ' || *p == TAB) {</a>
<a name="ln3088">      // Argument starts after a space.</a>
<a name="ln3089">      xp-&gt;xp_pattern = (char_u *)++p;</a>
<a name="ln3090">    } else {</a>
<a name="ln3091">      if (*p == '\\' &amp;&amp; *(p + 1) != NUL) {</a>
<a name="ln3092">        p++;        // skip over escaped character</a>
<a name="ln3093">      }</a>
<a name="ln3094">      MB_PTR_ADV(p);</a>
<a name="ln3095">    }</a>
<a name="ln3096">  }</a>
<a name="ln3097"> </a>
<a name="ln3098">  if (ea.argt &amp; EX_XFILE) {</a>
<a name="ln3099">    int c;</a>
<a name="ln3100">    int in_quote = false;</a>
<a name="ln3101">    const char *bow = NULL;  // Beginning of word.</a>
<a name="ln3102"> </a>
<a name="ln3103">    /*</a>
<a name="ln3104">     * Allow spaces within back-quotes to count as part of the argument</a>
<a name="ln3105">     * being expanded.</a>
<a name="ln3106">     */</a>
<a name="ln3107">    xp-&gt;xp_pattern = skipwhite((const char_u *)arg);</a>
<a name="ln3108">    p = (const char *)xp-&gt;xp_pattern;</a>
<a name="ln3109">    while (*p != NUL) {</a>
<a name="ln3110">      c = utf_ptr2char((const char_u *)p);</a>
<a name="ln3111">      if (c == '\\' &amp;&amp; p[1] != NUL) {</a>
<a name="ln3112">        p++;</a>
<a name="ln3113">      } else if (c == '`') {</a>
<a name="ln3114">        if (!in_quote) {</a>
<a name="ln3115">          xp-&gt;xp_pattern = (char_u *)p;</a>
<a name="ln3116">          bow = p + 1;</a>
<a name="ln3117">        }</a>
<a name="ln3118">        in_quote = !in_quote;</a>
<a name="ln3119">      }</a>
<a name="ln3120">      /* An argument can contain just about everything, except</a>
<a name="ln3121">       * characters that end the command and white space. */</a>
<a name="ln3122">      else if (c == '|'</a>
<a name="ln3123">            || c == '\n'</a>
<a name="ln3124">            || c == '&quot;'</a>
<a name="ln3125">            || ascii_iswhite(c)) {</a>
<a name="ln3126">        len = 0;          /* avoid getting stuck when space is in 'isfname' */</a>
<a name="ln3127">        while (*p != NUL) {</a>
<a name="ln3128">          c = utf_ptr2char((const char_u *)p);</a>
<a name="ln3129">          if (c == '`' || vim_isfilec_or_wc(c)) {</a>
<a name="ln3130">            break;</a>
<a name="ln3131">          }</a>
<a name="ln3132">          len = (size_t)utfc_ptr2len((const char_u *)p);</a>
<a name="ln3133">          MB_PTR_ADV(p);</a>
<a name="ln3134">        }</a>
<a name="ln3135">        if (in_quote) {</a>
<a name="ln3136">          bow = p;</a>
<a name="ln3137">        } else {</a>
<a name="ln3138">          xp-&gt;xp_pattern = (char_u *)p;</a>
<a name="ln3139">        }</a>
<a name="ln3140">        p -= len;</a>
<a name="ln3141">      }</a>
<a name="ln3142">      MB_PTR_ADV(p);</a>
<a name="ln3143">    }</a>
<a name="ln3144"> </a>
<a name="ln3145">    /*</a>
<a name="ln3146">     * If we are still inside the quotes, and we passed a space, just</a>
<a name="ln3147">     * expand from there.</a>
<a name="ln3148">     */</a>
<a name="ln3149">    if (bow != NULL &amp;&amp; in_quote) {</a>
<a name="ln3150">      xp-&gt;xp_pattern = (char_u *)bow;</a>
<a name="ln3151">    }</a>
<a name="ln3152">    xp-&gt;xp_context = EXPAND_FILES;</a>
<a name="ln3153"> </a>
<a name="ln3154">    /* For a shell command more chars need to be escaped. */</a>
<a name="ln3155">    if (usefilter || ea.cmdidx == CMD_bang || ea.cmdidx == CMD_terminal) {</a>
<a name="ln3156">#ifndef BACKSLASH_IN_FILENAME</a>
<a name="ln3157">      xp-&gt;xp_shell = TRUE;</a>
<a name="ln3158">#endif</a>
<a name="ln3159">      // When still after the command name expand executables.</a>
<a name="ln3160">      if (xp-&gt;xp_pattern == skipwhite((const char_u *)arg)) {</a>
<a name="ln3161">        xp-&gt;xp_context = EXPAND_SHELLCMD;</a>
<a name="ln3162">      }</a>
<a name="ln3163">    }</a>
<a name="ln3164"> </a>
<a name="ln3165">    // Check for environment variable.</a>
<a name="ln3166">    if (*xp-&gt;xp_pattern == '$') {</a>
<a name="ln3167">      for (p = (const char *)xp-&gt;xp_pattern + 1; *p != NUL; p++) {</a>
<a name="ln3168">        if (!vim_isIDc((uint8_t)(*p))) {</a>
<a name="ln3169">          break;</a>
<a name="ln3170">        }</a>
<a name="ln3171">      }</a>
<a name="ln3172">      if (*p == NUL) {</a>
<a name="ln3173">        xp-&gt;xp_context = EXPAND_ENV_VARS;</a>
<a name="ln3174">        xp-&gt;xp_pattern++;</a>
<a name="ln3175">        // Avoid that the assignment uses EXPAND_FILES again.</a>
<a name="ln3176">        if (context != EXPAND_USER_DEFINED &amp;&amp; context != EXPAND_USER_LIST) {</a>
<a name="ln3177">          context = EXPAND_ENV_VARS;</a>
<a name="ln3178">        }</a>
<a name="ln3179">      }</a>
<a name="ln3180">    }</a>
<a name="ln3181">    /* Check for user names */</a>
<a name="ln3182">    if (*xp-&gt;xp_pattern == '~') {</a>
<a name="ln3183">      for (p = (const char *)xp-&gt;xp_pattern + 1; *p != NUL &amp;&amp; *p != '/'; p++) {</a>
<a name="ln3184">      }</a>
<a name="ln3185">      // Complete ~user only if it partially matches a user name.</a>
<a name="ln3186">      // A full match ~user&lt;Tab&gt; will be replaced by user's home</a>
<a name="ln3187">      // directory i.e. something like ~user&lt;Tab&gt; -&gt; /home/user/</a>
<a name="ln3188">      if (*p == NUL &amp;&amp; p &gt; (const char *)xp-&gt;xp_pattern + 1</a>
<a name="ln3189">          &amp;&amp; match_user(xp-&gt;xp_pattern + 1) &gt;= 1) {</a>
<a name="ln3190">        xp-&gt;xp_context = EXPAND_USER;</a>
<a name="ln3191">        ++xp-&gt;xp_pattern;</a>
<a name="ln3192">      }</a>
<a name="ln3193">    }</a>
<a name="ln3194">  }</a>
<a name="ln3195"> </a>
<a name="ln3196">  /*</a>
<a name="ln3197">   * 6. switch on command name</a>
<a name="ln3198">   */</a>
<a name="ln3199">  switch (ea.cmdidx) {</a>
<a name="ln3200">  case CMD_find:</a>
<a name="ln3201">  case CMD_sfind:</a>
<a name="ln3202">  case CMD_tabfind:</a>
<a name="ln3203">    if (xp-&gt;xp_context == EXPAND_FILES)</a>
<a name="ln3204">      xp-&gt;xp_context = EXPAND_FILES_IN_PATH;</a>
<a name="ln3205">    break;</a>
<a name="ln3206">  case CMD_cd:</a>
<a name="ln3207">  case CMD_chdir:</a>
<a name="ln3208">  case CMD_lcd:</a>
<a name="ln3209">  case CMD_lchdir:</a>
<a name="ln3210">  case CMD_tcd:</a>
<a name="ln3211">  case CMD_tchdir:</a>
<a name="ln3212">    if (xp-&gt;xp_context == EXPAND_FILES) {</a>
<a name="ln3213">      xp-&gt;xp_context = EXPAND_DIRECTORIES;</a>
<a name="ln3214">    }</a>
<a name="ln3215">    break;</a>
<a name="ln3216">  case CMD_help:</a>
<a name="ln3217">    xp-&gt;xp_context = EXPAND_HELP;</a>
<a name="ln3218">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3219">    break;</a>
<a name="ln3220"> </a>
<a name="ln3221">  /* Command modifiers: return the argument.</a>
<a name="ln3222">   * Also for commands with an argument that is a command. */</a>
<a name="ln3223">  case CMD_aboveleft:</a>
<a name="ln3224">  case CMD_argdo:</a>
<a name="ln3225">  case CMD_belowright:</a>
<a name="ln3226">  case CMD_botright:</a>
<a name="ln3227">  case CMD_browse:</a>
<a name="ln3228">  case CMD_bufdo:</a>
<a name="ln3229">  case CMD_cdo:</a>
<a name="ln3230">  case CMD_cfdo:</a>
<a name="ln3231">  case CMD_confirm:</a>
<a name="ln3232">  case CMD_debug:</a>
<a name="ln3233">  case CMD_folddoclosed:</a>
<a name="ln3234">  case CMD_folddoopen:</a>
<a name="ln3235">  case CMD_hide:</a>
<a name="ln3236">  case CMD_keepalt:</a>
<a name="ln3237">  case CMD_keepjumps:</a>
<a name="ln3238">  case CMD_keepmarks:</a>
<a name="ln3239">  case CMD_keeppatterns:</a>
<a name="ln3240">  case CMD_ldo:</a>
<a name="ln3241">  case CMD_leftabove:</a>
<a name="ln3242">  case CMD_lfdo:</a>
<a name="ln3243">  case CMD_lockmarks:</a>
<a name="ln3244">  case CMD_noautocmd:</a>
<a name="ln3245">  case CMD_noswapfile:</a>
<a name="ln3246">  case CMD_rightbelow:</a>
<a name="ln3247">  case CMD_sandbox:</a>
<a name="ln3248">  case CMD_silent:</a>
<a name="ln3249">  case CMD_tab:</a>
<a name="ln3250">  case CMD_tabdo:</a>
<a name="ln3251">  case CMD_topleft:</a>
<a name="ln3252">  case CMD_verbose:</a>
<a name="ln3253">  case CMD_vertical:</a>
<a name="ln3254">  case CMD_windo:</a>
<a name="ln3255">    return arg;</a>
<a name="ln3256"> </a>
<a name="ln3257">  case CMD_filter:</a>
<a name="ln3258">    if (*arg != NUL) {</a>
<a name="ln3259">      arg = (const char *)skip_vimgrep_pat((char_u *)arg, NULL, NULL);</a>
<a name="ln3260">    }</a>
<a name="ln3261">    if (arg == NULL || *arg == NUL) {</a>
<a name="ln3262">      xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln3263">      return NULL;</a>
<a name="ln3264">    }</a>
<a name="ln3265">    return (const char *)skipwhite((const char_u *)arg);</a>
<a name="ln3266"> </a>
<a name="ln3267">  case CMD_match:</a>
<a name="ln3268">    if (*arg == NUL || !ends_excmd(*arg)) {</a>
<a name="ln3269">      /* also complete &quot;None&quot; */</a>
<a name="ln3270">      set_context_in_echohl_cmd(xp, arg);</a>
<a name="ln3271">      arg = (const char *)skipwhite(skiptowhite((const char_u *)arg));</a>
<a name="ln3272">      if (*arg != NUL) {</a>
<a name="ln3273">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln3274">        arg = (const char *)skip_regexp((char_u *)arg + 1, (uint8_t)(*arg),</a>
<a name="ln3275">                                        p_magic, NULL);</a>
<a name="ln3276">      }</a>
<a name="ln3277">    }</a>
<a name="ln3278">    return (const char *)find_nextcmd((char_u *)arg);</a>
<a name="ln3279"> </a>
<a name="ln3280">  /*</a>
<a name="ln3281">   * All completion for the +cmdline_compl feature goes here.</a>
<a name="ln3282">   */</a>
<a name="ln3283"> </a>
<a name="ln3284">  case CMD_command:</a>
<a name="ln3285">    /* Check for attributes */</a>
<a name="ln3286">    while (*arg == '-') {</a>
<a name="ln3287">      arg++;  // Skip &quot;-&quot;.</a>
<a name="ln3288">      p = (const char *)skiptowhite((const char_u *)arg);</a>
<a name="ln3289">      if (*p == NUL) {</a>
<a name="ln3290">        // Cursor is still in the attribute.</a>
<a name="ln3291">        p = strchr(arg, '=');</a>
<a name="ln3292">        if (p == NULL) {</a>
<a name="ln3293">          // No &quot;=&quot;, so complete attribute names.</a>
<a name="ln3294">          xp-&gt;xp_context = EXPAND_USER_CMD_FLAGS;</a>
<a name="ln3295">          xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3296">          return NULL;</a>
<a name="ln3297">        }</a>
<a name="ln3298"> </a>
<a name="ln3299">        // For the -complete, -nargs and -addr attributes, we complete</a>
<a name="ln3300">        // their arguments as well.</a>
<a name="ln3301">        if (STRNICMP(arg, &quot;complete&quot;, p - arg) == 0) {</a>
<a name="ln3302">          xp-&gt;xp_context = EXPAND_USER_COMPLETE;</a>
<a name="ln3303">          xp-&gt;xp_pattern = (char_u *)p + 1;</a>
<a name="ln3304">          return NULL;</a>
<a name="ln3305">        } else if (STRNICMP(arg, &quot;nargs&quot;, p - arg) == 0) {</a>
<a name="ln3306">          xp-&gt;xp_context = EXPAND_USER_NARGS;</a>
<a name="ln3307">          xp-&gt;xp_pattern = (char_u *)p + 1;</a>
<a name="ln3308">          return NULL;</a>
<a name="ln3309">        } else if (STRNICMP(arg, &quot;addr&quot;, p - arg) == 0) {</a>
<a name="ln3310">          xp-&gt;xp_context = EXPAND_USER_ADDR_TYPE;</a>
<a name="ln3311">          xp-&gt;xp_pattern = (char_u *)p + 1;</a>
<a name="ln3312">          return NULL;</a>
<a name="ln3313">        }</a>
<a name="ln3314">        return NULL;</a>
<a name="ln3315">      }</a>
<a name="ln3316">      arg = (const char *)skipwhite((char_u *)p);</a>
<a name="ln3317">    }</a>
<a name="ln3318"> </a>
<a name="ln3319">    // After the attributes comes the new command name.</a>
<a name="ln3320">    p = (const char *)skiptowhite((const char_u *)arg);</a>
<a name="ln3321">    if (*p == NUL) {</a>
<a name="ln3322">      xp-&gt;xp_context = EXPAND_USER_COMMANDS;</a>
<a name="ln3323">      xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3324">      break;</a>
<a name="ln3325">    }</a>
<a name="ln3326"> </a>
<a name="ln3327">    // And finally comes a normal command.</a>
<a name="ln3328">    return (const char *)skipwhite((const char_u *)p);</a>
<a name="ln3329"> </a>
<a name="ln3330">  case CMD_delcommand:</a>
<a name="ln3331">    xp-&gt;xp_context = EXPAND_USER_COMMANDS;</a>
<a name="ln3332">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3333">    break;</a>
<a name="ln3334"> </a>
<a name="ln3335">  case CMD_global:</a>
<a name="ln3336">  case CMD_vglobal: {</a>
<a name="ln3337">    const int delim = (uint8_t)(*arg);  // Get the delimiter.</a>
<a name="ln3338">    if (delim) {</a>
<a name="ln3339">      arg++;  // Skip delimiter if there is one.</a>
<a name="ln3340">    }</a>
<a name="ln3341"> </a>
<a name="ln3342">    while (arg[0] != NUL &amp;&amp; (uint8_t)arg[0] != delim) {</a>
<a name="ln3343">      if (arg[0] == '\\' &amp;&amp; arg[1] != NUL) {</a>
<a name="ln3344">        arg++;</a>
<a name="ln3345">      }</a>
<a name="ln3346">      arg++;</a>
<a name="ln3347">    }</a>
<a name="ln3348">    if (arg[0] != NUL)</a>
<a name="ln3349">      return arg + 1;</a>
<a name="ln3350">    break;</a>
<a name="ln3351">  }</a>
<a name="ln3352">  case CMD_and:</a>
<a name="ln3353">  case CMD_substitute: {</a>
<a name="ln3354">    const int delim = (uint8_t)(*arg);</a>
<a name="ln3355">    if (delim) {</a>
<a name="ln3356">      // Skip &quot;from&quot; part.</a>
<a name="ln3357">      arg++;</a>
<a name="ln3358">      arg = (const char *)skip_regexp((char_u *)arg, delim, p_magic, NULL);</a>
<a name="ln3359">    }</a>
<a name="ln3360">    // Skip &quot;to&quot; part.</a>
<a name="ln3361">    while (arg[0] != NUL &amp;&amp; (uint8_t)arg[0] != delim) {</a>
<a name="ln3362">      if (arg[0] == '\\' &amp;&amp; arg[1] != NUL) {</a>
<a name="ln3363">        arg++;</a>
<a name="ln3364">      }</a>
<a name="ln3365">      arg++;</a>
<a name="ln3366">    }</a>
<a name="ln3367">    if (arg[0] != NUL) {  // Skip delimiter.</a>
<a name="ln3368">      arg++;</a>
<a name="ln3369">    }</a>
<a name="ln3370">    while (arg[0] &amp;&amp; strchr(&quot;|\&quot;#&quot;, arg[0]) == NULL) {</a>
<a name="ln3371">      arg++;</a>
<a name="ln3372">    }</a>
<a name="ln3373">    if (arg[0] != NUL) {</a>
<a name="ln3374">      return arg;</a>
<a name="ln3375">    }</a>
<a name="ln3376">    break;</a>
<a name="ln3377">  }</a>
<a name="ln3378">  case CMD_isearch:</a>
<a name="ln3379">  case CMD_dsearch:</a>
<a name="ln3380">  case CMD_ilist:</a>
<a name="ln3381">  case CMD_dlist:</a>
<a name="ln3382">  case CMD_ijump:</a>
<a name="ln3383">  case CMD_psearch:</a>
<a name="ln3384">  case CMD_djump:</a>
<a name="ln3385">  case CMD_isplit:</a>
<a name="ln3386">  case CMD_dsplit:</a>
<a name="ln3387">    // Skip count.</a>
<a name="ln3388">    arg = (const char *)skipwhite(skipdigits((const char_u *)arg));</a>
<a name="ln3389">    if (*arg == '/') {  // Match regexp, not just whole words.</a>
<a name="ln3390">      for (++arg; *arg &amp;&amp; *arg != '/'; arg++) {</a>
<a name="ln3391">        if (*arg == '\\' &amp;&amp; arg[1] != NUL) {</a>
<a name="ln3392">          arg++;</a>
<a name="ln3393">        }</a>
<a name="ln3394">      }</a>
<a name="ln3395">      if (*arg) {</a>
<a name="ln3396">        arg = (const char *)skipwhite((const char_u *)arg + 1);</a>
<a name="ln3397"> </a>
<a name="ln3398">        // Check for trailing illegal characters.</a>
<a name="ln3399">        if (*arg &amp;&amp; strchr(&quot;|\&quot;\n&quot;, *arg) == NULL) {</a>
<a name="ln3400">          xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln3401">        } else {</a>
<a name="ln3402">          return arg;</a>
<a name="ln3403">        }</a>
<a name="ln3404">      }</a>
<a name="ln3405">    }</a>
<a name="ln3406">    break;</a>
<a name="ln3407">  case CMD_autocmd:</a>
<a name="ln3408">    return (const char *)set_context_in_autocmd(xp, (char_u *)arg, false);</a>
<a name="ln3409"> </a>
<a name="ln3410">  case CMD_doautocmd:</a>
<a name="ln3411">  case CMD_doautoall:</a>
<a name="ln3412">    return (const char *)set_context_in_autocmd(xp, (char_u *)arg, true);</a>
<a name="ln3413">  case CMD_set:</a>
<a name="ln3414">    set_context_in_set_cmd(xp, (char_u *)arg, 0);</a>
<a name="ln3415">    break;</a>
<a name="ln3416">  case CMD_setglobal:</a>
<a name="ln3417">    set_context_in_set_cmd(xp, (char_u *)arg, OPT_GLOBAL);</a>
<a name="ln3418">    break;</a>
<a name="ln3419">  case CMD_setlocal:</a>
<a name="ln3420">    set_context_in_set_cmd(xp, (char_u *)arg, OPT_LOCAL);</a>
<a name="ln3421">    break;</a>
<a name="ln3422">  case CMD_tag:</a>
<a name="ln3423">  case CMD_stag:</a>
<a name="ln3424">  case CMD_ptag:</a>
<a name="ln3425">  case CMD_ltag:</a>
<a name="ln3426">  case CMD_tselect:</a>
<a name="ln3427">  case CMD_stselect:</a>
<a name="ln3428">  case CMD_ptselect:</a>
<a name="ln3429">  case CMD_tjump:</a>
<a name="ln3430">  case CMD_stjump:</a>
<a name="ln3431">  case CMD_ptjump:</a>
<a name="ln3432">    if (wop_flags &amp; WOP_TAGFILE) {</a>
<a name="ln3433">      xp-&gt;xp_context = EXPAND_TAGS_LISTFILES;</a>
<a name="ln3434">    } else {</a>
<a name="ln3435">      xp-&gt;xp_context = EXPAND_TAGS;</a>
<a name="ln3436">    }</a>
<a name="ln3437">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3438">    break;</a>
<a name="ln3439">  case CMD_augroup:</a>
<a name="ln3440">    xp-&gt;xp_context = EXPAND_AUGROUP;</a>
<a name="ln3441">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3442">    break;</a>
<a name="ln3443">  case CMD_syntax:</a>
<a name="ln3444">    set_context_in_syntax_cmd(xp, arg);</a>
<a name="ln3445">    break;</a>
<a name="ln3446">  case CMD_const:</a>
<a name="ln3447">  case CMD_let:</a>
<a name="ln3448">  case CMD_if:</a>
<a name="ln3449">  case CMD_elseif:</a>
<a name="ln3450">  case CMD_while:</a>
<a name="ln3451">  case CMD_for:</a>
<a name="ln3452">  case CMD_echo:</a>
<a name="ln3453">  case CMD_echon:</a>
<a name="ln3454">  case CMD_execute:</a>
<a name="ln3455">  case CMD_echomsg:</a>
<a name="ln3456">  case CMD_echoerr:</a>
<a name="ln3457">  case CMD_call:</a>
<a name="ln3458">  case CMD_return:</a>
<a name="ln3459">  case CMD_cexpr:</a>
<a name="ln3460">  case CMD_caddexpr:</a>
<a name="ln3461">  case CMD_cgetexpr:</a>
<a name="ln3462">  case CMD_lexpr:</a>
<a name="ln3463">  case CMD_laddexpr:</a>
<a name="ln3464">  case CMD_lgetexpr:</a>
<a name="ln3465">    set_context_for_expression(xp, (char_u *)arg, ea.cmdidx);</a>
<a name="ln3466">    break;</a>
<a name="ln3467"> </a>
<a name="ln3468">  case CMD_unlet:</a>
<a name="ln3469">    while ((xp-&gt;xp_pattern = (char_u *)strchr(arg, ' ')) != NULL) {</a>
<a name="ln3470">      arg = (const char *)xp-&gt;xp_pattern + 1;</a>
<a name="ln3471">    }</a>
<a name="ln3472"> </a>
<a name="ln3473">    xp-&gt;xp_context = EXPAND_USER_VARS;</a>
<a name="ln3474">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3475"> </a>
<a name="ln3476">    if (*xp-&gt;xp_pattern == '$') {</a>
<a name="ln3477">      xp-&gt;xp_context = EXPAND_ENV_VARS;</a>
<a name="ln3478">      xp-&gt;xp_pattern++;</a>
<a name="ln3479">    }</a>
<a name="ln3480"> </a>
<a name="ln3481">    break;</a>
<a name="ln3482"> </a>
<a name="ln3483">  case CMD_function:</a>
<a name="ln3484">  case CMD_delfunction:</a>
<a name="ln3485">    xp-&gt;xp_context = EXPAND_USER_FUNC;</a>
<a name="ln3486">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3487">    break;</a>
<a name="ln3488"> </a>
<a name="ln3489">  case CMD_echohl:</a>
<a name="ln3490">    set_context_in_echohl_cmd(xp, arg);</a>
<a name="ln3491">    break;</a>
<a name="ln3492">  case CMD_highlight:</a>
<a name="ln3493">    set_context_in_highlight_cmd(xp, arg);</a>
<a name="ln3494">    break;</a>
<a name="ln3495">  case CMD_cscope:</a>
<a name="ln3496">  case CMD_lcscope:</a>
<a name="ln3497">  case CMD_scscope:</a>
<a name="ln3498">    set_context_in_cscope_cmd(xp, arg, ea.cmdidx);</a>
<a name="ln3499">    break;</a>
<a name="ln3500">  case CMD_sign:</a>
<a name="ln3501">    set_context_in_sign_cmd(xp, (char_u *)arg);</a>
<a name="ln3502">    break;</a>
<a name="ln3503">  case CMD_bdelete:</a>
<a name="ln3504">  case CMD_bwipeout:</a>
<a name="ln3505">  case CMD_bunload:</a>
<a name="ln3506">    while ((xp-&gt;xp_pattern = (char_u *)strchr(arg, ' ')) != NULL) {</a>
<a name="ln3507">      arg = (const char *)xp-&gt;xp_pattern + 1;</a>
<a name="ln3508">    }</a>
<a name="ln3509">    FALLTHROUGH;</a>
<a name="ln3510">  case CMD_buffer:</a>
<a name="ln3511">  case CMD_sbuffer:</a>
<a name="ln3512">  case CMD_checktime:</a>
<a name="ln3513">    xp-&gt;xp_context = EXPAND_BUFFERS;</a>
<a name="ln3514">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3515">    break;</a>
<a name="ln3516">  case CMD_diffget:</a>
<a name="ln3517">  case CMD_diffput:</a>
<a name="ln3518">    // If current buffer is in diff mode, complete buffer names</a>
<a name="ln3519">    // which are in diff mode, and different than current buffer.</a>
<a name="ln3520">    xp-&gt;xp_context = EXPAND_DIFF_BUFFERS;</a>
<a name="ln3521">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3522">    break;</a>
<a name="ln3523">  case CMD_USER:</a>
<a name="ln3524">  case CMD_USER_BUF:</a>
<a name="ln3525">    if (context != EXPAND_NOTHING) {</a>
<a name="ln3526">      // EX_XFILE: file names are handled above.</a>
<a name="ln3527">      if (!(ea.argt &amp; EX_XFILE)) {</a>
<a name="ln3528">        if (context == EXPAND_MENUS) {</a>
<a name="ln3529">          return (const char *)set_context_in_menu_cmd(xp, cmd,</a>
<a name="ln3530">                                                       (char_u *)arg, forceit);</a>
<a name="ln3531">        } else if (context == EXPAND_COMMANDS) {</a>
<a name="ln3532">          return arg;</a>
<a name="ln3533">        } else if (context == EXPAND_MAPPINGS) {</a>
<a name="ln3534">          return (const char *)set_context_in_map_cmd(</a>
<a name="ln3535">              xp, (char_u *)&quot;map&quot;, (char_u *)arg, forceit, false, false,</a>
<a name="ln3536">              CMD_map);</a>
<a name="ln3537">        }</a>
<a name="ln3538">        // Find start of last argument.</a>
<a name="ln3539">        p = arg;</a>
<a name="ln3540">        while (*p) {</a>
<a name="ln3541">          if (*p == ' ') {</a>
<a name="ln3542">            // argument starts after a space</a>
<a name="ln3543">            arg = p + 1;</a>
<a name="ln3544">          } else if (*p == '\\' &amp;&amp; *(p + 1) != NUL) {</a>
<a name="ln3545">            p++;                // skip over escaped character</a>
<a name="ln3546">          }</a>
<a name="ln3547">          MB_PTR_ADV(p);</a>
<a name="ln3548">        }</a>
<a name="ln3549">        xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3550">      }</a>
<a name="ln3551">      xp-&gt;xp_context = context;</a>
<a name="ln3552">    }</a>
<a name="ln3553">    break;</a>
<a name="ln3554">  case CMD_map:       case CMD_noremap:</a>
<a name="ln3555">  case CMD_nmap:      case CMD_nnoremap:</a>
<a name="ln3556">  case CMD_vmap:      case CMD_vnoremap:</a>
<a name="ln3557">  case CMD_omap:      case CMD_onoremap:</a>
<a name="ln3558">  case CMD_imap:      case CMD_inoremap:</a>
<a name="ln3559">  case CMD_cmap:      case CMD_cnoremap:</a>
<a name="ln3560">  case CMD_lmap:      case CMD_lnoremap:</a>
<a name="ln3561">  case CMD_smap:      case CMD_snoremap:</a>
<a name="ln3562">  case CMD_xmap:      case CMD_xnoremap:</a>
<a name="ln3563">    return (const char *)set_context_in_map_cmd(</a>
<a name="ln3564">        xp, (char_u *)cmd, (char_u *)arg, forceit, false, false, ea.cmdidx);</a>
<a name="ln3565">  case CMD_unmap:</a>
<a name="ln3566">  case CMD_nunmap:</a>
<a name="ln3567">  case CMD_vunmap:</a>
<a name="ln3568">  case CMD_ounmap:</a>
<a name="ln3569">  case CMD_iunmap:</a>
<a name="ln3570">  case CMD_cunmap:</a>
<a name="ln3571">  case CMD_lunmap:</a>
<a name="ln3572">  case CMD_sunmap:</a>
<a name="ln3573">  case CMD_xunmap:</a>
<a name="ln3574">    return (const char *)set_context_in_map_cmd(</a>
<a name="ln3575">        xp, (char_u *)cmd, (char_u *)arg, forceit, false, true, ea.cmdidx);</a>
<a name="ln3576">  case CMD_mapclear:</a>
<a name="ln3577">  case CMD_nmapclear:</a>
<a name="ln3578">  case CMD_vmapclear:</a>
<a name="ln3579">  case CMD_omapclear:</a>
<a name="ln3580">  case CMD_imapclear:</a>
<a name="ln3581">  case CMD_cmapclear:</a>
<a name="ln3582">  case CMD_lmapclear:</a>
<a name="ln3583">  case CMD_smapclear:</a>
<a name="ln3584">  case CMD_xmapclear:</a>
<a name="ln3585">    xp-&gt;xp_context = EXPAND_MAPCLEAR;</a>
<a name="ln3586">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3587">    break;</a>
<a name="ln3588"> </a>
<a name="ln3589">  case CMD_abbreviate:    case CMD_noreabbrev:</a>
<a name="ln3590">  case CMD_cabbrev:       case CMD_cnoreabbrev:</a>
<a name="ln3591">  case CMD_iabbrev:       case CMD_inoreabbrev:</a>
<a name="ln3592">    return (const char *)set_context_in_map_cmd(</a>
<a name="ln3593">        xp, (char_u *)cmd, (char_u *)arg, forceit, true, false, ea.cmdidx);</a>
<a name="ln3594">  case CMD_unabbreviate:</a>
<a name="ln3595">  case CMD_cunabbrev:</a>
<a name="ln3596">  case CMD_iunabbrev:</a>
<a name="ln3597">    return (const char *)set_context_in_map_cmd(</a>
<a name="ln3598">        xp, (char_u *)cmd, (char_u *)arg, forceit, true, true, ea.cmdidx);</a>
<a name="ln3599">  case CMD_menu:      case CMD_noremenu:      case CMD_unmenu:</a>
<a name="ln3600">  case CMD_amenu:     case CMD_anoremenu:     case CMD_aunmenu:</a>
<a name="ln3601">  case CMD_nmenu:     case CMD_nnoremenu:     case CMD_nunmenu:</a>
<a name="ln3602">  case CMD_vmenu:     case CMD_vnoremenu:     case CMD_vunmenu:</a>
<a name="ln3603">  case CMD_omenu:     case CMD_onoremenu:     case CMD_ounmenu:</a>
<a name="ln3604">  case CMD_imenu:     case CMD_inoremenu:     case CMD_iunmenu:</a>
<a name="ln3605">  case CMD_cmenu:     case CMD_cnoremenu:     case CMD_cunmenu:</a>
<a name="ln3606">  case CMD_tmenu:                             case CMD_tunmenu:</a>
<a name="ln3607">  case CMD_popup:                             case CMD_emenu:</a>
<a name="ln3608">    return (const char *)set_context_in_menu_cmd(</a>
<a name="ln3609">        xp, cmd, (char_u *)arg, forceit);</a>
<a name="ln3610"> </a>
<a name="ln3611">  case CMD_colorscheme:</a>
<a name="ln3612">    xp-&gt;xp_context = EXPAND_COLORS;</a>
<a name="ln3613">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3614">    break;</a>
<a name="ln3615"> </a>
<a name="ln3616">  case CMD_compiler:</a>
<a name="ln3617">    xp-&gt;xp_context = EXPAND_COMPILER;</a>
<a name="ln3618">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3619">    break;</a>
<a name="ln3620"> </a>
<a name="ln3621">  case CMD_ownsyntax:</a>
<a name="ln3622">    xp-&gt;xp_context = EXPAND_OWNSYNTAX;</a>
<a name="ln3623">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3624">    break;</a>
<a name="ln3625"> </a>
<a name="ln3626">  case CMD_setfiletype:</a>
<a name="ln3627">    xp-&gt;xp_context = EXPAND_FILETYPE;</a>
<a name="ln3628">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3629">    break;</a>
<a name="ln3630"> </a>
<a name="ln3631">  case CMD_packadd:</a>
<a name="ln3632">    xp-&gt;xp_context = EXPAND_PACKADD;</a>
<a name="ln3633">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3634">    break;</a>
<a name="ln3635"> </a>
<a name="ln3636">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3637">  case CMD_language:</a>
<a name="ln3638">    p = (const char *)skiptowhite((const char_u *)arg);</a>
<a name="ln3639">    if (*p == NUL) {</a>
<a name="ln3640">      xp-&gt;xp_context = EXPAND_LANGUAGE;</a>
<a name="ln3641">      xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3642">    } else {</a>
<a name="ln3643">      if (strncmp(arg, &quot;messages&quot;, p - arg) == 0</a>
<a name="ln3644">          || strncmp(arg, &quot;ctype&quot;, p - arg) == 0</a>
<a name="ln3645">          || strncmp(arg, &quot;time&quot;, p - arg) == 0) {</a>
<a name="ln3646">        xp-&gt;xp_context = EXPAND_LOCALES;</a>
<a name="ln3647">        xp-&gt;xp_pattern = skipwhite((const char_u *)p);</a>
<a name="ln3648">      } else {</a>
<a name="ln3649">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln3650">      }</a>
<a name="ln3651">    }</a>
<a name="ln3652">    break;</a>
<a name="ln3653">#endif</a>
<a name="ln3654">  case CMD_profile:</a>
<a name="ln3655">    set_context_in_profile_cmd(xp, arg);</a>
<a name="ln3656">    break;</a>
<a name="ln3657">  case CMD_checkhealth:</a>
<a name="ln3658">    xp-&gt;xp_context = EXPAND_CHECKHEALTH;</a>
<a name="ln3659">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3660">    break;</a>
<a name="ln3661">  case CMD_behave:</a>
<a name="ln3662">    xp-&gt;xp_context = EXPAND_BEHAVE;</a>
<a name="ln3663">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3664">    break;</a>
<a name="ln3665"> </a>
<a name="ln3666">  case CMD_messages:</a>
<a name="ln3667">    xp-&gt;xp_context = EXPAND_MESSAGES;</a>
<a name="ln3668">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3669">    break;</a>
<a name="ln3670"> </a>
<a name="ln3671">  case CMD_history:</a>
<a name="ln3672">    xp-&gt;xp_context = EXPAND_HISTORY;</a>
<a name="ln3673">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3674">    break;</a>
<a name="ln3675">  case CMD_syntime:</a>
<a name="ln3676">    xp-&gt;xp_context = EXPAND_SYNTIME;</a>
<a name="ln3677">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3678">    break;</a>
<a name="ln3679"> </a>
<a name="ln3680">  case CMD_argdelete:</a>
<a name="ln3681">    while ((xp-&gt;xp_pattern = vim_strchr((const char_u *)arg, ' ')) != NULL) {</a>
<a name="ln3682">      arg = (const char *)(xp-&gt;xp_pattern + 1);</a>
<a name="ln3683">    }</a>
<a name="ln3684">    xp-&gt;xp_context = EXPAND_ARGLIST;</a>
<a name="ln3685">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3686">    break;</a>
<a name="ln3687"> </a>
<a name="ln3688">  case CMD_lua:</a>
<a name="ln3689">    xp-&gt;xp_context = EXPAND_LUA;</a>
<a name="ln3690">    break;</a>
<a name="ln3691"> </a>
<a name="ln3692">  default:</a>
<a name="ln3693">    break;</a>
<a name="ln3694">  }</a>
<a name="ln3695">  return NULL;</a>
<a name="ln3696">}</a>
<a name="ln3697"> </a>
<a name="ln3698">// Skip a range specifier of the form: addr [,addr] [;addr] ..</a>
<a name="ln3699">//</a>
<a name="ln3700">// Backslashed delimiters after / or ? will be skipped, and commands will</a>
<a name="ln3701">// not be expanded between /'s and ?'s or after &quot;'&quot;.</a>
<a name="ln3702">//</a>
<a name="ln3703">// Also skip white space and &quot;:&quot; characters.</a>
<a name="ln3704">// Returns the &quot;cmd&quot; pointer advanced to beyond the range.</a>
<a name="ln3705">char_u *skip_range(</a>
<a name="ln3706">    const char_u *cmd,</a>
<a name="ln3707">    int *ctx       // pointer to xp_context or NULL</a>
<a name="ln3708">)</a>
<a name="ln3709">{</a>
<a name="ln3710">  unsigned delim;</a>
<a name="ln3711"> </a>
<a name="ln3712">  while (vim_strchr((char_u *)&quot; \t0123456789.$%'/?-+,;\\&quot;, *cmd) != NULL) {</a>
<a name="ln3713">    if (*cmd == '\\') {</a>
<a name="ln3714">      if (cmd[1] == '?' || cmd[1] == '/' || cmd[1] == '&amp;') {</a>
<a name="ln3715">        cmd++;</a>
<a name="ln3716">      } else {</a>
<a name="ln3717">        break;</a>
<a name="ln3718">      }</a>
<a name="ln3719">    } else if (*cmd == '\'') {</a>
<a name="ln3720">      if (*++cmd == NUL &amp;&amp; ctx != NULL) {</a>
<a name="ln3721">        *ctx = EXPAND_NOTHING;</a>
<a name="ln3722">      }</a>
<a name="ln3723">    } else if (*cmd == '/' || *cmd == '?') {</a>
<a name="ln3724">      delim = *cmd++;</a>
<a name="ln3725">      while (*cmd != NUL &amp;&amp; *cmd != delim)</a>
<a name="ln3726">        if (*cmd++ == '\\' &amp;&amp; *cmd != NUL)</a>
<a name="ln3727">          ++cmd;</a>
<a name="ln3728">      if (*cmd == NUL &amp;&amp; ctx != NULL)</a>
<a name="ln3729">        *ctx = EXPAND_NOTHING;</a>
<a name="ln3730">    }</a>
<a name="ln3731">    if (*cmd != NUL)</a>
<a name="ln3732">      ++cmd;</a>
<a name="ln3733">  }</a>
<a name="ln3734"> </a>
<a name="ln3735">  // Skip &quot;:&quot; and white space.</a>
<a name="ln3736">  cmd = skip_colon_white(cmd, false);</a>
<a name="ln3737"> </a>
<a name="ln3738">  return (char_u *)cmd;</a>
<a name="ln3739">}</a>
<a name="ln3740"> </a>
<a name="ln3741">static void addr_error(cmd_addr_T addr_type)</a>
<a name="ln3742">{</a>
<a name="ln3743">  if (addr_type == ADDR_NONE) {</a>
<a name="ln3744">    EMSG(_(e_norange));</a>
<a name="ln3745">  } else {</a>
<a name="ln3746">    EMSG(_(e_invrange));</a>
<a name="ln3747">  }</a>
<a name="ln3748">}</a>
<a name="ln3749"> </a>
<a name="ln3750">// Get a single EX address</a>
<a name="ln3751">//</a>
<a name="ln3752">// Set ptr to the next character after the part that was interpreted.</a>
<a name="ln3753">// Set ptr to NULL when an error is encountered.</a>
<a name="ln3754">// This may set the last used search pattern.</a>
<a name="ln3755">//</a>
<a name="ln3756">// Return MAXLNUM when no Ex address was found.</a>
<a name="ln3757">static linenr_T get_address(exarg_T *eap,</a>
<a name="ln3758">                            char_u **ptr,</a>
<a name="ln3759">                            cmd_addr_T addr_type,</a>
<a name="ln3760">                            int skip,  // only skip the address, don't use it</a>
<a name="ln3761">                            bool silent,  // no errors or side effects</a>
<a name="ln3762">                            int to_other_file,  // flag: may jump to other file</a>
<a name="ln3763">                            int address_count)  // 1 for first, &gt;1 after comma</a>
<a name="ln3764">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3765">{</a>
<a name="ln3766">  int c;</a>
<a name="ln3767">  int i;</a>
<a name="ln3768">  long n;</a>
<a name="ln3769">  char_u      *cmd;</a>
<a name="ln3770">  pos_T pos;</a>
<a name="ln3771">  pos_T       *fp;</a>
<a name="ln3772">  linenr_T lnum;</a>
<a name="ln3773">  buf_T *buf;</a>
<a name="ln3774"> </a>
<a name="ln3775">  cmd = skipwhite(*ptr);</a>
<a name="ln3776">  lnum = MAXLNUM;</a>
<a name="ln3777">  do {</a>
<a name="ln3778">    switch (*cmd) {</a>
<a name="ln3779">    case '.':                               /* '.' - Cursor position */</a>
<a name="ln3780">      ++cmd;</a>
<a name="ln3781">      switch (addr_type) {</a>
<a name="ln3782">        case ADDR_LINES:</a>
<a name="ln3783">        case ADDR_OTHER:</a>
<a name="ln3784">          lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3785">          break;</a>
<a name="ln3786">        case ADDR_WINDOWS:</a>
<a name="ln3787">          lnum = CURRENT_WIN_NR;</a>
<a name="ln3788">          break;</a>
<a name="ln3789">        case ADDR_ARGUMENTS:</a>
<a name="ln3790">          lnum = curwin-&gt;w_arg_idx + 1;</a>
<a name="ln3791">          break;</a>
<a name="ln3792">        case ADDR_LOADED_BUFFERS:</a>
<a name="ln3793">        case ADDR_BUFFERS:</a>
<a name="ln3794">          lnum = curbuf-&gt;b_fnum;</a>
<a name="ln3795">          break;</a>
<a name="ln3796">        case ADDR_TABS:</a>
<a name="ln3797">          lnum = CURRENT_TAB_NR;</a>
<a name="ln3798">          break;</a>
<a name="ln3799">        case ADDR_NONE:</a>
<a name="ln3800">        case ADDR_TABS_RELATIVE:</a>
<a name="ln3801">        case ADDR_UNSIGNED:</a>
<a name="ln3802">          addr_error(addr_type);</a>
<a name="ln3803">          cmd = NULL;</a>
<a name="ln3804">          goto error;</a>
<a name="ln3805">          break;</a>
<a name="ln3806">        case ADDR_QUICKFIX:</a>
<a name="ln3807">          lnum = qf_get_cur_idx(eap);</a>
<a name="ln3808">          break;</a>
<a name="ln3809">        case ADDR_QUICKFIX_VALID:</a>
<a name="ln3810">          lnum = qf_get_cur_valid_idx(eap);</a>
<a name="ln3811">          break;</a>
<a name="ln3812">      }</a>
<a name="ln3813">      break;</a>
<a name="ln3814"> </a>
<a name="ln3815">    case '$':                               /* '$' - last line */</a>
<a name="ln3816">      ++cmd;</a>
<a name="ln3817">      switch (addr_type) {</a>
<a name="ln3818">        case ADDR_LINES:</a>
<a name="ln3819">        case ADDR_OTHER:</a>
<a name="ln3820">          lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3821">          break;</a>
<a name="ln3822">        case ADDR_WINDOWS:</a>
<a name="ln3823">          lnum = LAST_WIN_NR;</a>
<a name="ln3824">          break;</a>
<a name="ln3825">        case ADDR_ARGUMENTS:</a>
<a name="ln3826">          lnum = ARGCOUNT;</a>
<a name="ln3827">          break;</a>
<a name="ln3828">        case ADDR_LOADED_BUFFERS:</a>
<a name="ln3829">          buf = lastbuf;</a>
<a name="ln3830">          while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln3831">            if (buf-&gt;b_prev == NULL) {</a>
<a name="ln3832">              break;</a>
<a name="ln3833">            }</a>
<a name="ln3834">            buf = buf-&gt;b_prev;</a>
<a name="ln3835">          }</a>
<a name="ln3836">          lnum = buf-&gt;b_fnum;</a>
<a name="ln3837">          break;</a>
<a name="ln3838">        case ADDR_BUFFERS:</a>
<a name="ln3839">          lnum = lastbuf-&gt;b_fnum;</a>
<a name="ln3840">          break;</a>
<a name="ln3841">        case ADDR_TABS:</a>
<a name="ln3842">          lnum = LAST_TAB_NR;</a>
<a name="ln3843">          break;</a>
<a name="ln3844">        case ADDR_NONE:</a>
<a name="ln3845">        case ADDR_TABS_RELATIVE:</a>
<a name="ln3846">        case ADDR_UNSIGNED:</a>
<a name="ln3847">          addr_error(addr_type);</a>
<a name="ln3848">          cmd = NULL;</a>
<a name="ln3849">          goto error;</a>
<a name="ln3850">          break;</a>
<a name="ln3851">        case ADDR_QUICKFIX:</a>
<a name="ln3852">          lnum = qf_get_size(eap);</a>
<a name="ln3853">          if (lnum == 0) {</a>
<a name="ln3854">            lnum = 1;</a>
<a name="ln3855">          }</a>
<a name="ln3856">          break;</a>
<a name="ln3857">        case ADDR_QUICKFIX_VALID:</a>
<a name="ln3858">          lnum = qf_get_valid_size(eap);</a>
<a name="ln3859">          if (lnum == 0) {</a>
<a name="ln3860">            lnum = 1;</a>
<a name="ln3861">          }</a>
<a name="ln3862">          break;</a>
<a name="ln3863">      }</a>
<a name="ln3864">      break;</a>
<a name="ln3865"> </a>
<a name="ln3866">    case '\'':                              /* ''' - mark */</a>
<a name="ln3867">      if (*++cmd == NUL) {</a>
<a name="ln3868">        cmd = NULL;</a>
<a name="ln3869">        goto error;</a>
<a name="ln3870">      }</a>
<a name="ln3871">      if (addr_type != ADDR_LINES) {</a>
<a name="ln3872">        addr_error(addr_type);</a>
<a name="ln3873">        cmd = NULL;</a>
<a name="ln3874">        goto error;</a>
<a name="ln3875">      }</a>
<a name="ln3876">      if (skip)</a>
<a name="ln3877">        ++cmd;</a>
<a name="ln3878">      else {</a>
<a name="ln3879">        /* Only accept a mark in another file when it is</a>
<a name="ln3880">         * used by itself: &quot;:'M&quot;. */</a>
<a name="ln3881">        fp = getmark(*cmd, to_other_file &amp;&amp; cmd[1] == NUL);</a>
<a name="ln3882">        ++cmd;</a>
<a name="ln3883">        if (fp == (pos_T *)-1)</a>
<a name="ln3884">          /* Jumped to another file. */</a>
<a name="ln3885">          lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3886">        else {</a>
<a name="ln3887">          if (check_mark(fp) == FAIL) {</a>
<a name="ln3888">            cmd = NULL;</a>
<a name="ln3889">            goto error;</a>
<a name="ln3890">          }</a>
<a name="ln3891">          lnum = fp-&gt;lnum;</a>
<a name="ln3892">        }</a>
<a name="ln3893">      }</a>
<a name="ln3894">      break;</a>
<a name="ln3895"> </a>
<a name="ln3896">    case '/':</a>
<a name="ln3897">    case '?':                           /* '/' or '?' - search */</a>
<a name="ln3898">      c = *cmd++;</a>
<a name="ln3899">      if (addr_type != ADDR_LINES) {</a>
<a name="ln3900">        addr_error(addr_type);</a>
<a name="ln3901">        cmd = NULL;</a>
<a name="ln3902">        goto error;</a>
<a name="ln3903">      }</a>
<a name="ln3904">      if (skip) {                       /* skip &quot;/pat/&quot; */</a>
<a name="ln3905">        cmd = skip_regexp(cmd, c, p_magic, NULL);</a>
<a name="ln3906">        if (*cmd == c)</a>
<a name="ln3907">          ++cmd;</a>
<a name="ln3908">      } else {</a>
<a name="ln3909">        int flags;</a>
<a name="ln3910"> </a>
<a name="ln3911">        pos = curwin-&gt;w_cursor;  // save curwin-&gt;w_cursor</a>
<a name="ln3912"> </a>
<a name="ln3913">        // When '/' or '?' follows another address, start from</a>
<a name="ln3914">        // there.</a>
<a name="ln3915">        if (lnum != MAXLNUM) {</a>
<a name="ln3916">          curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3917">        }</a>
<a name="ln3918"> </a>
<a name="ln3919">        // Start a forward search at the end of the line (unless</a>
<a name="ln3920">        // before the first line).</a>
<a name="ln3921">        // Start a backward search at the start of the line.</a>
<a name="ln3922">        // This makes sure we never match in the current</a>
<a name="ln3923">        // line, and can match anywhere in the</a>
<a name="ln3924">        // next/previous line.</a>
<a name="ln3925">        if (c == '/' &amp;&amp; curwin-&gt;w_cursor.lnum &gt; 0) {</a>
<a name="ln3926">          curwin-&gt;w_cursor.col = MAXCOL;</a>
<a name="ln3927">        } else {</a>
<a name="ln3928">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3929">        }</a>
<a name="ln3930">        searchcmdlen = 0;</a>
<a name="ln3931">        flags = silent ? 0 : SEARCH_HIS | SEARCH_MSG;</a>
<a name="ln3932">        if (!do_search(NULL, c, c, cmd, 1L, flags, NULL)) {</a>
<a name="ln3933">          curwin-&gt;w_cursor = pos;</a>
<a name="ln3934">          cmd = NULL;</a>
<a name="ln3935">          goto error;</a>
<a name="ln3936">        }</a>
<a name="ln3937">        lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3938">        curwin-&gt;w_cursor = pos;</a>
<a name="ln3939">        /* adjust command string pointer */</a>
<a name="ln3940">        cmd += searchcmdlen;</a>
<a name="ln3941">      }</a>
<a name="ln3942">      break;</a>
<a name="ln3943"> </a>
<a name="ln3944">    case '\\':                      /* &quot;\?&quot;, &quot;\/&quot; or &quot;\&amp;&quot;, repeat search */</a>
<a name="ln3945">      ++cmd;</a>
<a name="ln3946">      if (addr_type != ADDR_LINES) {</a>
<a name="ln3947">        addr_error(addr_type);</a>
<a name="ln3948">        cmd = NULL;</a>
<a name="ln3949">        goto error;</a>
<a name="ln3950">      }</a>
<a name="ln3951">      if (*cmd == '&amp;')</a>
<a name="ln3952">        i = RE_SUBST;</a>
<a name="ln3953">      else if (*cmd == '?' || *cmd == '/')</a>
<a name="ln3954">        i = RE_SEARCH;</a>
<a name="ln3955">      else {</a>
<a name="ln3956">        EMSG(_(e_backslash));</a>
<a name="ln3957">        cmd = NULL;</a>
<a name="ln3958">        goto error;</a>
<a name="ln3959">      }</a>
<a name="ln3960"> </a>
<a name="ln3961">      if (!skip) {</a>
<a name="ln3962">        // When search follows another address, start from there.</a>
<a name="ln3963">        pos.lnum = (lnum != MAXLNUM) ? lnum : curwin-&gt;w_cursor.lnum;</a>
<a name="ln3964">        // Start the search just like for the above do_search().</a>
<a name="ln3965">        pos.col = (*cmd != '?') ? MAXCOL : 0;</a>
<a name="ln3966">        pos.coladd = 0;</a>
<a name="ln3967">        if (searchit(curwin, curbuf, &amp;pos, NULL,</a>
<a name="ln3968">                     *cmd == '?' ? BACKWARD : FORWARD,</a>
<a name="ln3969">                     (char_u *)&quot;&quot;, 1L, SEARCH_MSG, i, NULL) != FAIL) {</a>
<a name="ln3970">          lnum = pos.lnum;</a>
<a name="ln3971">        } else {</a>
<a name="ln3972">          cmd = NULL;</a>
<a name="ln3973">          goto error;</a>
<a name="ln3974">        }</a>
<a name="ln3975">      }</a>
<a name="ln3976">      ++cmd;</a>
<a name="ln3977">      break;</a>
<a name="ln3978"> </a>
<a name="ln3979">    default:</a>
<a name="ln3980">      if (ascii_isdigit(*cmd)) {                // absolute line number</a>
<a name="ln3981">        lnum = getdigits_long(&amp;cmd, false, 0);</a>
<a name="ln3982">      }</a>
<a name="ln3983">    }</a>
<a name="ln3984"> </a>
<a name="ln3985">    for (;; ) {</a>
<a name="ln3986">      cmd = skipwhite(cmd);</a>
<a name="ln3987">      if (*cmd != '-' &amp;&amp; *cmd != '+' &amp;&amp; !ascii_isdigit(*cmd)) {</a>
<a name="ln3988">        break;</a>
<a name="ln3989">      }</a>
<a name="ln3990"> </a>
<a name="ln3991">      if (lnum == MAXLNUM) {</a>
<a name="ln3992">        switch (addr_type) {</a>
<a name="ln3993">          case ADDR_LINES:</a>
<a name="ln3994">          case ADDR_OTHER:</a>
<a name="ln3995">            // &quot;+1&quot; is same as &quot;.+1&quot;</a>
<a name="ln3996">            lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3997">            break;</a>
<a name="ln3998">          case ADDR_WINDOWS:</a>
<a name="ln3999">            lnum = CURRENT_WIN_NR;</a>
<a name="ln4000">            break;</a>
<a name="ln4001">          case ADDR_ARGUMENTS:</a>
<a name="ln4002">            lnum = curwin-&gt;w_arg_idx + 1;</a>
<a name="ln4003">            break;</a>
<a name="ln4004">          case ADDR_LOADED_BUFFERS:</a>
<a name="ln4005">          case ADDR_BUFFERS:</a>
<a name="ln4006">            lnum = curbuf-&gt;b_fnum;</a>
<a name="ln4007">            break;</a>
<a name="ln4008">          case ADDR_TABS:</a>
<a name="ln4009">            lnum = CURRENT_TAB_NR;</a>
<a name="ln4010">            break;</a>
<a name="ln4011">          case ADDR_TABS_RELATIVE:</a>
<a name="ln4012">            lnum = 1;</a>
<a name="ln4013">            break;</a>
<a name="ln4014">          case ADDR_QUICKFIX:</a>
<a name="ln4015">            lnum = qf_get_cur_idx(eap);</a>
<a name="ln4016">            break;</a>
<a name="ln4017">          case ADDR_QUICKFIX_VALID:</a>
<a name="ln4018">            lnum = qf_get_cur_valid_idx(eap);</a>
<a name="ln4019">            break;</a>
<a name="ln4020">          case ADDR_NONE:</a>
<a name="ln4021">          case ADDR_UNSIGNED:</a>
<a name="ln4022">            lnum = 0;</a>
<a name="ln4023">            break;</a>
<a name="ln4024">        }</a>
<a name="ln4025">      }</a>
<a name="ln4026"> </a>
<a name="ln4027">      if (ascii_isdigit(*cmd)) {</a>
<a name="ln4028">        i = '+';                        // &quot;number&quot; is same as &quot;+number&quot;</a>
<a name="ln4029">      } else {</a>
<a name="ln4030">        i = *cmd++;</a>
<a name="ln4031">      }</a>
<a name="ln4032">      if (!ascii_isdigit(*cmd)) {       // '+' is '+1', but '+0' is not '+1'</a>
<a name="ln4033">        n = 1;</a>
<a name="ln4034">      } else {</a>
<a name="ln4035">        n = getdigits(&amp;cmd, true, 0);</a>
<a name="ln4036">      }</a>
<a name="ln4037"> </a>
<a name="ln4038">      if (addr_type == ADDR_TABS_RELATIVE) {</a>
<a name="ln4039">        EMSG(_(e_invrange));</a>
<a name="ln4040">        cmd = NULL;</a>
<a name="ln4041">        goto error;</a>
<a name="ln4042">      } else if (addr_type == ADDR_LOADED_BUFFERS || addr_type == ADDR_BUFFERS) {</a>
<a name="ln4043">        lnum = compute_buffer_local_count(</a>
<a name="ln4044">            addr_type, lnum, (i == '-') ? -1 * n : n);</a>
<a name="ln4045">      } else {</a>
<a name="ln4046">        // Relative line addressing, need to adjust for folded lines</a>
<a name="ln4047">        // now, but only do it after the first address.</a>
<a name="ln4048">        if (addr_type == ADDR_LINES &amp;&amp; (i == '-' || i == '+')</a>
<a name="ln4049">            &amp;&amp; address_count &gt;= 2) {</a>
<a name="ln4050">          (void)hasFolding(lnum, NULL, &amp;lnum);</a>
<a name="ln4051">        }</a>
<a name="ln4052">        if (i == '-') {</a>
<a name="ln4053">          lnum -= n;</a>
<a name="ln4054">        } else {</a>
<a name="ln4055">          lnum += n;</a>
<a name="ln4056">        }</a>
<a name="ln4057">      }</a>
<a name="ln4058">    }</a>
<a name="ln4059">  } while (*cmd == '/' || *cmd == '?');</a>
<a name="ln4060"> </a>
<a name="ln4061">error:</a>
<a name="ln4062">  *ptr = cmd;</a>
<a name="ln4063">  return lnum;</a>
<a name="ln4064">}</a>
<a name="ln4065"> </a>
<a name="ln4066">/*</a>
<a name="ln4067"> * Get flags from an Ex command argument.</a>
<a name="ln4068"> */</a>
<a name="ln4069">static void get_flags(exarg_T *eap)</a>
<a name="ln4070">{</a>
<a name="ln4071">  while (vim_strchr((char_u *)&quot;lp#&quot;, *eap-&gt;arg) != NULL) {</a>
<a name="ln4072">    if (*eap-&gt;arg == 'l')</a>
<a name="ln4073">      eap-&gt;flags |= EXFLAG_LIST;</a>
<a name="ln4074">    else if (*eap-&gt;arg == 'p')</a>
<a name="ln4075">      eap-&gt;flags |= EXFLAG_PRINT;</a>
<a name="ln4076">    else</a>
<a name="ln4077">      eap-&gt;flags |= EXFLAG_NR;</a>
<a name="ln4078">    eap-&gt;arg = skipwhite(eap-&gt;arg + 1);</a>
<a name="ln4079">  }</a>
<a name="ln4080">}</a>
<a name="ln4081"> </a>
<a name="ln4082">/// Stub function for command which is Not Implemented. NI!</a>
<a name="ln4083">void ex_ni(exarg_T *eap)</a>
<a name="ln4084">{</a>
<a name="ln4085">  if (!eap-&gt;skip)</a>
<a name="ln4086">    eap-&gt;errmsg = (char_u *)N_(</a>
<a name="ln4087">        &quot;E319: The command is not available in this version&quot;);</a>
<a name="ln4088">}</a>
<a name="ln4089"> </a>
<a name="ln4090">/// Stub function for script command which is Not Implemented. NI!</a>
<a name="ln4091">/// Skips over &quot;:perl &lt;&lt;EOF&quot; constructs.</a>
<a name="ln4092">static void ex_script_ni(exarg_T *eap)</a>
<a name="ln4093">{</a>
<a name="ln4094">  if (!eap-&gt;skip) {</a>
<a name="ln4095">    ex_ni(eap);</a>
<a name="ln4096">  } else {</a>
<a name="ln4097">    size_t len;</a>
<a name="ln4098">    xfree(script_get(eap, &amp;len));</a>
<a name="ln4099">  }</a>
<a name="ln4100">}</a>
<a name="ln4101"> </a>
<a name="ln4102">/*</a>
<a name="ln4103"> * Check range in Ex command for validity.</a>
<a name="ln4104"> * Return NULL when valid, error message when invalid.</a>
<a name="ln4105"> */</a>
<a name="ln4106">static char_u *invalid_range(exarg_T *eap)</a>
<a name="ln4107">{</a>
<a name="ln4108">  buf_T *buf;</a>
<a name="ln4109">  if (eap-&gt;line1 &lt; 0 || eap-&gt;line2 &lt; 0 || eap-&gt;line1 &gt; eap-&gt;line2) {</a>
<a name="ln4110">    return (char_u *)_(e_invrange);</a>
<a name="ln4111">  }</a>
<a name="ln4112"> </a>
<a name="ln4113">  if (eap-&gt;argt &amp; EX_RANGE) {</a>
<a name="ln4114">    switch (eap-&gt;addr_type) {</a>
<a name="ln4115">      case ADDR_LINES:</a>
<a name="ln4116">        if (eap-&gt;line2 &gt; (curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln4117">                          + (eap-&gt;cmdidx == CMD_diffget))) {</a>
<a name="ln4118">          return (char_u *)_(e_invrange);</a>
<a name="ln4119">        }</a>
<a name="ln4120">        break;</a>
<a name="ln4121">      case ADDR_ARGUMENTS:</a>
<a name="ln4122">        // add 1 if ARGCOUNT is 0</a>
<a name="ln4123">        if (eap-&gt;line2 &gt; ARGCOUNT + (!ARGCOUNT)) {</a>
<a name="ln4124">          return (char_u *)_(e_invrange);</a>
<a name="ln4125">        }</a>
<a name="ln4126">        break;</a>
<a name="ln4127">      case ADDR_BUFFERS:</a>
<a name="ln4128">        if (eap-&gt;line1 &lt; firstbuf-&gt;b_fnum</a>
<a name="ln4129">            || eap-&gt;line2 &gt; lastbuf-&gt;b_fnum) {</a>
<a name="ln4130">          return (char_u *)_(e_invrange);</a>
<a name="ln4131">        }</a>
<a name="ln4132">        break;</a>
<a name="ln4133">     case ADDR_LOADED_BUFFERS:</a>
<a name="ln4134">        buf = firstbuf;</a>
<a name="ln4135">        while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln4136">          if (buf-&gt;b_next == NULL) {</a>
<a name="ln4137">            return (char_u *)_(e_invrange);</a>
<a name="ln4138">          }</a>
<a name="ln4139">          buf = buf-&gt;b_next;</a>
<a name="ln4140">        }</a>
<a name="ln4141">        if (eap-&gt;line1 &lt; buf-&gt;b_fnum) {</a>
<a name="ln4142">          return (char_u *)_(e_invrange);</a>
<a name="ln4143">        }</a>
<a name="ln4144">        buf = lastbuf;</a>
<a name="ln4145">        while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln4146">          if (buf-&gt;b_prev == NULL) {</a>
<a name="ln4147">            return (char_u *)_(e_invrange);</a>
<a name="ln4148">          }</a>
<a name="ln4149">          buf = buf-&gt;b_prev;</a>
<a name="ln4150">        }</a>
<a name="ln4151">        if (eap-&gt;line2 &gt; buf-&gt;b_fnum) {</a>
<a name="ln4152">          return (char_u *)_(e_invrange);</a>
<a name="ln4153">        }</a>
<a name="ln4154">        break;</a>
<a name="ln4155">      case ADDR_WINDOWS:</a>
<a name="ln4156">        if (eap-&gt;line2 &gt; LAST_WIN_NR) {</a>
<a name="ln4157">          return (char_u *)_(e_invrange);</a>
<a name="ln4158">        }</a>
<a name="ln4159">        break;</a>
<a name="ln4160">      case ADDR_TABS:</a>
<a name="ln4161">        if (eap-&gt;line2 &gt; LAST_TAB_NR) {</a>
<a name="ln4162">          return (char_u *)_(e_invrange);</a>
<a name="ln4163">        }</a>
<a name="ln4164">        break;</a>
<a name="ln4165">      case ADDR_TABS_RELATIVE:</a>
<a name="ln4166">      case ADDR_OTHER:</a>
<a name="ln4167">        // Any range is OK.</a>
<a name="ln4168">        break;</a>
<a name="ln4169">      case ADDR_QUICKFIX:</a>
<a name="ln4170">        assert(eap-&gt;line2 &gt;= 0);</a>
<a name="ln4171">        // No error for value that is too big, will use the last entry.</a>
<a name="ln4172">        if (eap-&gt;line2 &lt;= 0) {</a>
<a name="ln4173">          return (char_u *)_(e_invrange);</a>
<a name="ln4174">        }</a>
<a name="ln4175">        break;</a>
<a name="ln4176">      case ADDR_QUICKFIX_VALID:</a>
<a name="ln4177">        if ((eap-&gt;line2 != 1 &amp;&amp; (size_t)eap-&gt;line2 &gt; qf_get_valid_size(eap))</a>
<a name="ln4178">            || eap-&gt;line2 &lt; 0) {</a>
<a name="ln4179">          return (char_u *)_(e_invrange);</a>
<a name="ln4180">        }</a>
<a name="ln4181">        break;</a>
<a name="ln4182">      case ADDR_UNSIGNED:</a>
<a name="ln4183">        if (eap-&gt;line2 &lt; 0) {</a>
<a name="ln4184">          return (char_u *)_(e_invrange);</a>
<a name="ln4185">        }</a>
<a name="ln4186">        break;</a>
<a name="ln4187">      case ADDR_NONE:</a>
<a name="ln4188">        // Will give an error elsewhere.</a>
<a name="ln4189">        break;</a>
<a name="ln4190">    }</a>
<a name="ln4191">  }</a>
<a name="ln4192">  return NULL;</a>
<a name="ln4193">}</a>
<a name="ln4194"> </a>
<a name="ln4195">/*</a>
<a name="ln4196"> * Correct the range for zero line number, if required.</a>
<a name="ln4197"> */</a>
<a name="ln4198">static void correct_range(exarg_T *eap)</a>
<a name="ln4199">{</a>
<a name="ln4200">  if (!(eap-&gt;argt &amp; EX_ZEROR)) {  // zero in range not allowed</a>
<a name="ln4201">    if (eap-&gt;line1 == 0) {</a>
<a name="ln4202">      eap-&gt;line1 = 1;</a>
<a name="ln4203">    }</a>
<a name="ln4204">    if (eap-&gt;line2 == 0) {</a>
<a name="ln4205">      eap-&gt;line2 = 1;</a>
<a name="ln4206">    }</a>
<a name="ln4207">  }</a>
<a name="ln4208">}</a>
<a name="ln4209"> </a>
<a name="ln4210"> </a>
<a name="ln4211">/*</a>
<a name="ln4212"> * For a &quot;:vimgrep&quot; or &quot;:vimgrepadd&quot; command return a pointer past the</a>
<a name="ln4213"> * pattern.  Otherwise return eap-&gt;arg.</a>
<a name="ln4214"> */</a>
<a name="ln4215">static char_u *skip_grep_pat(exarg_T *eap)</a>
<a name="ln4216">{</a>
<a name="ln4217">  char_u      *p = eap-&gt;arg;</a>
<a name="ln4218"> </a>
<a name="ln4219">  if (*p != NUL &amp;&amp; (eap-&gt;cmdidx == CMD_vimgrep || eap-&gt;cmdidx == CMD_lvimgrep</a>
<a name="ln4220">                    || eap-&gt;cmdidx == CMD_vimgrepadd</a>
<a name="ln4221">                    || eap-&gt;cmdidx == CMD_lvimgrepadd</a>
<a name="ln4222">                    || grep_internal(eap-&gt;cmdidx))) {</a>
<a name="ln4223">    p = skip_vimgrep_pat(p, NULL, NULL);</a>
<a name="ln4224">    if (p == NULL)</a>
<a name="ln4225">      p = eap-&gt;arg;</a>
<a name="ln4226">  }</a>
<a name="ln4227">  return p;</a>
<a name="ln4228">}</a>
<a name="ln4229"> </a>
<a name="ln4230">/*</a>
<a name="ln4231"> * For the &quot;:make&quot; and &quot;:grep&quot; commands insert the 'makeprg'/'grepprg' option</a>
<a name="ln4232"> * in the command line, so that things like % get expanded.</a>
<a name="ln4233"> */</a>
<a name="ln4234">static char_u *replace_makeprg(exarg_T *eap, char_u *p, char_u **cmdlinep)</a>
<a name="ln4235">{</a>
<a name="ln4236">  char_u      *new_cmdline;</a>
<a name="ln4237">  char_u      *program;</a>
<a name="ln4238">  char_u      *pos;</a>
<a name="ln4239">  char_u      *ptr;</a>
<a name="ln4240">  int len;</a>
<a name="ln4241">  int i;</a>
<a name="ln4242"> </a>
<a name="ln4243">  /*</a>
<a name="ln4244">   * Don't do it when &quot;:vimgrep&quot; is used for &quot;:grep&quot;.</a>
<a name="ln4245">   */</a>
<a name="ln4246">  if ((eap-&gt;cmdidx == CMD_make || eap-&gt;cmdidx == CMD_lmake</a>
<a name="ln4247">       || eap-&gt;cmdidx == CMD_grep || eap-&gt;cmdidx == CMD_lgrep</a>
<a name="ln4248">       || eap-&gt;cmdidx == CMD_grepadd</a>
<a name="ln4249">       || eap-&gt;cmdidx == CMD_lgrepadd)</a>
<a name="ln4250">      &amp;&amp; !grep_internal(eap-&gt;cmdidx)) {</a>
<a name="ln4251">    if (eap-&gt;cmdidx == CMD_grep || eap-&gt;cmdidx == CMD_lgrep</a>
<a name="ln4252">        || eap-&gt;cmdidx == CMD_grepadd || eap-&gt;cmdidx == CMD_lgrepadd) {</a>
<a name="ln4253">      if (*curbuf-&gt;b_p_gp == NUL)</a>
<a name="ln4254">        program = p_gp;</a>
<a name="ln4255">      else</a>
<a name="ln4256">        program = curbuf-&gt;b_p_gp;</a>
<a name="ln4257">    } else {</a>
<a name="ln4258">      if (*curbuf-&gt;b_p_mp == NUL)</a>
<a name="ln4259">        program = p_mp;</a>
<a name="ln4260">      else</a>
<a name="ln4261">        program = curbuf-&gt;b_p_mp;</a>
<a name="ln4262">    }</a>
<a name="ln4263"> </a>
<a name="ln4264">    p = skipwhite(p);</a>
<a name="ln4265"> </a>
<a name="ln4266">    if ((pos = (char_u *)strstr((char *)program, &quot;$*&quot;)) != NULL) {</a>
<a name="ln4267">      /* replace $* by given arguments */</a>
<a name="ln4268">      i = 1;</a>
<a name="ln4269">      while ((pos = (char_u *)strstr((char *)pos + 2, &quot;$*&quot;)) != NULL)</a>
<a name="ln4270">        ++i;</a>
<a name="ln4271">      len = (int)STRLEN(p);</a>
<a name="ln4272">      new_cmdline = xmalloc(STRLEN(program) + i * (len - 2) + 1);</a>
<a name="ln4273">      ptr = new_cmdline;</a>
<a name="ln4274">      while ((pos = (char_u *)strstr((char *)program, &quot;$*&quot;)) != NULL) {</a>
<a name="ln4275">        i = (int)(pos - program);</a>
<a name="ln4276">        memcpy(ptr, program, i);</a>
<a name="ln4277">        STRCPY(ptr += i, p);</a>
<a name="ln4278">        ptr += len;</a>
<a name="ln4279">        program = pos + 2;</a>
<a name="ln4280">      }</a>
<a name="ln4281">      STRCPY(ptr, program);</a>
<a name="ln4282">    } else {</a>
<a name="ln4283">      new_cmdline = xmalloc(STRLEN(program) + STRLEN(p) + 2);</a>
<a name="ln4284">      STRCPY(new_cmdline, program);</a>
<a name="ln4285">      STRCAT(new_cmdline, &quot; &quot;);</a>
<a name="ln4286">      STRCAT(new_cmdline, p);</a>
<a name="ln4287">    }</a>
<a name="ln4288">    msg_make(p);</a>
<a name="ln4289"> </a>
<a name="ln4290">    /* 'eap-&gt;cmd' is not set here, because it is not used at CMD_make */</a>
<a name="ln4291">    xfree(*cmdlinep);</a>
<a name="ln4292">    *cmdlinep = new_cmdline;</a>
<a name="ln4293">    p = new_cmdline;</a>
<a name="ln4294">  }</a>
<a name="ln4295">  return p;</a>
<a name="ln4296">}</a>
<a name="ln4297"> </a>
<a name="ln4298">// Expand file name in Ex command argument.</a>
<a name="ln4299">// When an error is detected, &quot;errormsgp&quot; is set to a non-NULL pointer.</a>
<a name="ln4300">// Return FAIL for failure, OK otherwise.</a>
<a name="ln4301">int expand_filename(exarg_T *eap, char_u **cmdlinep, char_u **errormsgp)</a>
<a name="ln4302">{</a>
<a name="ln4303">  int has_wildcards;            /* need to expand wildcards */</a>
<a name="ln4304">  char_u      *repl;</a>
<a name="ln4305">  size_t srclen;</a>
<a name="ln4306">  char_u      *p;</a>
<a name="ln4307">  int escaped;</a>
<a name="ln4308"> </a>
<a name="ln4309">  /* Skip a regexp pattern for &quot;:vimgrep[add] pat file...&quot; */</a>
<a name="ln4310">  p = skip_grep_pat(eap);</a>
<a name="ln4311"> </a>
<a name="ln4312">  /*</a>
<a name="ln4313">   * Decide to expand wildcards *before* replacing '%', '#', etc.  If</a>
<a name="ln4314">   * the file name contains a wildcard it should not cause expanding.</a>
<a name="ln4315">   * (it will be expanded anyway if there is a wildcard before replacing).</a>
<a name="ln4316">   */</a>
<a name="ln4317">  has_wildcards = path_has_wildcard(p);</a>
<a name="ln4318">  while (*p != NUL) {</a>
<a name="ln4319">    /* Skip over `=expr`, wildcards in it are not expanded. */</a>
<a name="ln4320">    if (p[0] == '`' &amp;&amp; p[1] == '=') {</a>
<a name="ln4321">      p += 2;</a>
<a name="ln4322">      (void)skip_expr(&amp;p);</a>
<a name="ln4323">      if (*p == '`')</a>
<a name="ln4324">        ++p;</a>
<a name="ln4325">      continue;</a>
<a name="ln4326">    }</a>
<a name="ln4327">    /*</a>
<a name="ln4328">     * Quick check if this cannot be the start of a special string.</a>
<a name="ln4329">     * Also removes backslash before '%', '#' and '&lt;'.</a>
<a name="ln4330">     */</a>
<a name="ln4331">    if (vim_strchr((char_u *)&quot;%#&lt;&quot;, *p) == NULL) {</a>
<a name="ln4332">      ++p;</a>
<a name="ln4333">      continue;</a>
<a name="ln4334">    }</a>
<a name="ln4335"> </a>
<a name="ln4336">    /*</a>
<a name="ln4337">     * Try to find a match at this position.</a>
<a name="ln4338">     */</a>
<a name="ln4339">    repl = eval_vars(p, eap-&gt;arg, &amp;srclen, &amp;(eap-&gt;do_ecmd_lnum),</a>
<a name="ln4340">        errormsgp, &amp;escaped);</a>
<a name="ln4341">    if (*errormsgp != NULL)             /* error detected */</a>
<a name="ln4342">      return FAIL;</a>
<a name="ln4343">    if (repl == NULL) {                 /* no match found */</a>
<a name="ln4344">      p += srclen;</a>
<a name="ln4345">      continue;</a>
<a name="ln4346">    }</a>
<a name="ln4347"> </a>
<a name="ln4348">    /* Wildcards won't be expanded below, the replacement is taken</a>
<a name="ln4349">     * literally.  But do expand &quot;~/file&quot;, &quot;~user/file&quot; and &quot;$HOME/file&quot;. */</a>
<a name="ln4350">    if (vim_strchr(repl, '$') != NULL || vim_strchr(repl, '~') != NULL) {</a>
<a name="ln4351">      char_u *l = repl;</a>
<a name="ln4352"> </a>
<a name="ln4353">      repl = expand_env_save(repl);</a>
<a name="ln4354">      xfree(l);</a>
<a name="ln4355">    }</a>
<a name="ln4356"> </a>
<a name="ln4357">    /* Need to escape white space et al. with a backslash.</a>
<a name="ln4358">     * Don't do this for:</a>
<a name="ln4359">     * - replacement that already has been escaped: &quot;##&quot;</a>
<a name="ln4360">     * - shell commands (may have to use quotes instead).</a>
<a name="ln4361">     */</a>
<a name="ln4362">    if (!eap-&gt;usefilter</a>
<a name="ln4363">        &amp;&amp; !escaped</a>
<a name="ln4364">        &amp;&amp; eap-&gt;cmdidx != CMD_bang</a>
<a name="ln4365">        &amp;&amp; eap-&gt;cmdidx != CMD_grep</a>
<a name="ln4366">        &amp;&amp; eap-&gt;cmdidx != CMD_grepadd</a>
<a name="ln4367">        &amp;&amp; eap-&gt;cmdidx != CMD_hardcopy</a>
<a name="ln4368">        &amp;&amp; eap-&gt;cmdidx != CMD_lgrep</a>
<a name="ln4369">        &amp;&amp; eap-&gt;cmdidx != CMD_lgrepadd</a>
<a name="ln4370">        &amp;&amp; eap-&gt;cmdidx != CMD_lmake</a>
<a name="ln4371">        &amp;&amp; eap-&gt;cmdidx != CMD_make</a>
<a name="ln4372">        &amp;&amp; eap-&gt;cmdidx != CMD_terminal</a>
<a name="ln4373">        &amp;&amp; !(eap-&gt;argt &amp; EX_NOSPC)</a>
<a name="ln4374">        ) {</a>
<a name="ln4375">      char_u      *l;</a>
<a name="ln4376">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln4377">      /* Don't escape a backslash here, because rem_backslash() doesn't</a>
<a name="ln4378">       * remove it later. */</a>
<a name="ln4379">      static char_u *nobslash = (char_u *)&quot; \t\&quot;|&quot;;</a>
<a name="ln4380"># define ESCAPE_CHARS nobslash</a>
<a name="ln4381">#else</a>
<a name="ln4382"># define ESCAPE_CHARS escape_chars</a>
<a name="ln4383">#endif</a>
<a name="ln4384"> </a>
<a name="ln4385">      for (l = repl; *l; ++l)</a>
<a name="ln4386">        if (vim_strchr(ESCAPE_CHARS, *l) != NULL) {</a>
<a name="ln4387">          l = vim_strsave_escaped(repl, ESCAPE_CHARS);</a>
<a name="ln4388">          xfree(repl);</a>
<a name="ln4389">          repl = l;</a>
<a name="ln4390">          break;</a>
<a name="ln4391">        }</a>
<a name="ln4392">    }</a>
<a name="ln4393"> </a>
<a name="ln4394">    // For a shell command a '!' must be escaped.</a>
<a name="ln4395">    if ((eap-&gt;usefilter</a>
<a name="ln4396">         || eap-&gt;cmdidx == CMD_bang</a>
<a name="ln4397">         || eap-&gt;cmdidx == CMD_terminal)</a>
<a name="ln4398">        &amp;&amp; vim_strpbrk(repl, (char_u *)&quot;!&quot;) != NULL) {</a>
<a name="ln4399">      char_u      *l;</a>
<a name="ln4400"> </a>
<a name="ln4401">      l = vim_strsave_escaped(repl, (char_u *)&quot;!&quot;);</a>
<a name="ln4402">      xfree(repl);</a>
<a name="ln4403">      repl = l;</a>
<a name="ln4404">    }</a>
<a name="ln4405"> </a>
<a name="ln4406">    p = repl_cmdline(eap, p, srclen, repl, cmdlinep);</a>
<a name="ln4407">    xfree(repl);</a>
<a name="ln4408">  }</a>
<a name="ln4409"> </a>
<a name="ln4410">  /*</a>
<a name="ln4411">   * One file argument: Expand wildcards.</a>
<a name="ln4412">   * Don't do this with &quot;:r !command&quot; or &quot;:w !command&quot;.</a>
<a name="ln4413">   */</a>
<a name="ln4414">  if ((eap-&gt;argt &amp; EX_NOSPC) &amp;&amp; !eap-&gt;usefilter) {</a>
<a name="ln4415">    // Replace environment variables.</a>
<a name="ln4416">    if (has_wildcards) {</a>
<a name="ln4417">      /*</a>
<a name="ln4418">       * May expand environment variables.  This</a>
<a name="ln4419">       * can be done much faster with expand_env() than with</a>
<a name="ln4420">       * something else (e.g., calling a shell).</a>
<a name="ln4421">       * After expanding environment variables, check again</a>
<a name="ln4422">       * if there are still wildcards present.</a>
<a name="ln4423">       */</a>
<a name="ln4424">      if (vim_strchr(eap-&gt;arg, '$') != NULL</a>
<a name="ln4425">          || vim_strchr(eap-&gt;arg, '~') != NULL) {</a>
<a name="ln4426">        expand_env_esc(eap-&gt;arg, NameBuff, MAXPATHL,</a>
<a name="ln4427">            TRUE, TRUE, NULL);</a>
<a name="ln4428">        has_wildcards = path_has_wildcard(NameBuff);</a>
<a name="ln4429">        p = NameBuff;</a>
<a name="ln4430">      } else</a>
<a name="ln4431">        p = NULL;</a>
<a name="ln4432">      if (p != NULL) {</a>
<a name="ln4433">        (void)repl_cmdline(eap, eap-&gt;arg, STRLEN(eap-&gt;arg), p, cmdlinep);</a>
<a name="ln4434">      }</a>
<a name="ln4435">    }</a>
<a name="ln4436"> </a>
<a name="ln4437">    /*</a>
<a name="ln4438">     * Halve the number of backslashes (this is Vi compatible).</a>
<a name="ln4439">     * For Unix, when wildcards are expanded, this is</a>
<a name="ln4440">     * done by ExpandOne() below.</a>
<a name="ln4441">     */</a>
<a name="ln4442">#ifdef UNIX</a>
<a name="ln4443">    if (!has_wildcards)</a>
<a name="ln4444">#endif</a>
<a name="ln4445">    backslash_halve(eap-&gt;arg);</a>
<a name="ln4446"> </a>
<a name="ln4447">    if (has_wildcards) {</a>
<a name="ln4448">      expand_T xpc;</a>
<a name="ln4449">      int options = WILD_LIST_NOTFOUND | WILD_NOERROR | WILD_ADD_SLASH;</a>
<a name="ln4450"> </a>
<a name="ln4451">      ExpandInit(&amp;xpc);</a>
<a name="ln4452">      xpc.xp_context = EXPAND_FILES;</a>
<a name="ln4453">      if (p_wic)</a>
<a name="ln4454">        options += WILD_ICASE;</a>
<a name="ln4455">      p = ExpandOne(&amp;xpc, eap-&gt;arg, NULL, options, WILD_EXPAND_FREE);</a>
<a name="ln4456">      if (p == NULL) {</a>
<a name="ln4457">        return FAIL;</a>
<a name="ln4458">      }</a>
<a name="ln4459">      (void)repl_cmdline(eap, eap-&gt;arg, STRLEN(eap-&gt;arg), p, cmdlinep);</a>
<a name="ln4460">      xfree(p);</a>
<a name="ln4461">    }</a>
<a name="ln4462">  }</a>
<a name="ln4463">  return OK;</a>
<a name="ln4464">}</a>
<a name="ln4465"> </a>
<a name="ln4466">/*</a>
<a name="ln4467"> * Replace part of the command line, keeping eap-&gt;cmd, eap-&gt;arg and</a>
<a name="ln4468"> * eap-&gt;nextcmd correct.</a>
<a name="ln4469"> * &quot;src&quot; points to the part that is to be replaced, of length &quot;srclen&quot;.</a>
<a name="ln4470"> * &quot;repl&quot; is the replacement string.</a>
<a name="ln4471"> * Returns a pointer to the character after the replaced string.</a>
<a name="ln4472"> */</a>
<a name="ln4473">static char_u *repl_cmdline(exarg_T *eap, char_u *src, size_t srclen,</a>
<a name="ln4474">                            char_u *repl, char_u **cmdlinep)</a>
<a name="ln4475">{</a>
<a name="ln4476">  /*</a>
<a name="ln4477">   * The new command line is build in new_cmdline[].</a>
<a name="ln4478">   * First allocate it.</a>
<a name="ln4479">   * Careful: a &quot;+cmd&quot; argument may have been NUL terminated.</a>
<a name="ln4480">   */</a>
<a name="ln4481">  size_t len = STRLEN(repl);</a>
<a name="ln4482">  size_t i = (size_t)(src - *cmdlinep) + STRLEN(src + srclen) + len + 3;</a>
<a name="ln4483">  if (eap-&gt;nextcmd != NULL)</a>
<a name="ln4484">    i += STRLEN(eap-&gt;nextcmd);    /* add space for next command */</a>
<a name="ln4485">  char_u *new_cmdline = xmalloc(i);</a>
<a name="ln4486"> </a>
<a name="ln4487">  /*</a>
<a name="ln4488">   * Copy the stuff before the expanded part.</a>
<a name="ln4489">   * Copy the expanded stuff.</a>
<a name="ln4490">   * Copy what came after the expanded part.</a>
<a name="ln4491">   * Copy the next commands, if there are any.</a>
<a name="ln4492">   */</a>
<a name="ln4493">  i = (size_t)(src - *cmdlinep);   /* length of part before match */</a>
<a name="ln4494">  memmove(new_cmdline, *cmdlinep, i);</a>
<a name="ln4495"> </a>
<a name="ln4496">  memmove(new_cmdline + i, repl, len);</a>
<a name="ln4497">  i += len;                             /* remember the end of the string */</a>
<a name="ln4498">  STRCPY(new_cmdline + i, src + srclen);</a>
<a name="ln4499">  src = new_cmdline + i;                /* remember where to continue */</a>
<a name="ln4500"> </a>
<a name="ln4501">  if (eap-&gt;nextcmd != NULL) {           /* append next command */</a>
<a name="ln4502">    i = STRLEN(new_cmdline) + 1;</a>
<a name="ln4503">    STRCPY(new_cmdline + i, eap-&gt;nextcmd);</a>
<a name="ln4504">    eap-&gt;nextcmd = new_cmdline + i;</a>
<a name="ln4505">  }</a>
<a name="ln4506">  eap-&gt;cmd = new_cmdline + (eap-&gt;cmd - *cmdlinep);</a>
<a name="ln4507">  eap-&gt;arg = new_cmdline + (eap-&gt;arg - *cmdlinep);</a>
<a name="ln4508">  if (eap-&gt;do_ecmd_cmd != NULL &amp;&amp; eap-&gt;do_ecmd_cmd != dollar_command)</a>
<a name="ln4509">    eap-&gt;do_ecmd_cmd = new_cmdline + (eap-&gt;do_ecmd_cmd - *cmdlinep);</a>
<a name="ln4510">  xfree(*cmdlinep);</a>
<a name="ln4511">  *cmdlinep = new_cmdline;</a>
<a name="ln4512"> </a>
<a name="ln4513">  return src;</a>
<a name="ln4514">}</a>
<a name="ln4515"> </a>
<a name="ln4516">/*</a>
<a name="ln4517"> * Check for '|' to separate commands and '&quot;' to start comments.</a>
<a name="ln4518"> */</a>
<a name="ln4519">void separate_nextcmd(exarg_T *eap)</a>
<a name="ln4520">{</a>
<a name="ln4521">  char_u      *p;</a>
<a name="ln4522"> </a>
<a name="ln4523">  p = skip_grep_pat(eap);</a>
<a name="ln4524"> </a>
<a name="ln4525">  for (; *p; MB_PTR_ADV(p)) {</a>
<a name="ln4526">    if (*p == Ctrl_V) {</a>
<a name="ln4527">      if (eap-&gt;argt &amp; (EX_CTRLV | EX_XFILE)) {</a>
<a name="ln4528">        p++;  // skip CTRL-V and next char</a>
<a name="ln4529">      } else {</a>
<a name="ln4530">        // remove CTRL-V and skip next char</a>
<a name="ln4531">        STRMOVE(p, p + 1);</a>
<a name="ln4532">      }</a>
<a name="ln4533">      if (*p == NUL) {  // stop at NUL after CTRL-V</a>
<a name="ln4534">        break;</a>
<a name="ln4535">      }</a>
<a name="ln4536">    } else if (p[0] == '`' &amp;&amp; p[1] == '=' &amp;&amp; (eap-&gt;argt &amp; EX_XFILE)) {</a>
<a name="ln4537">      // Skip over `=expr` when wildcards are expanded.</a>
<a name="ln4538">      p += 2;</a>
<a name="ln4539">      (void)skip_expr(&amp;p);</a>
<a name="ln4540">      if (*p == NUL) {  // stop at NUL after CTRL-V</a>
<a name="ln4541">        break;</a>
<a name="ln4542">      }</a>
<a name="ln4543">    } else if (</a>
<a name="ln4544">        // Check for '&quot;': start of comment or '|': next command */</a>
<a name="ln4545">        // :@&quot; does not start a comment!</a>
<a name="ln4546">        // :redir @&quot; doesn't either.</a>
<a name="ln4547">        (*p == '&quot;'</a>
<a name="ln4548">         &amp;&amp; !(eap-&gt;argt &amp; EX_NOTRLCOM)</a>
<a name="ln4549">         &amp;&amp; (eap-&gt;cmdidx != CMD_at || p != eap-&gt;arg)</a>
<a name="ln4550">         &amp;&amp; (eap-&gt;cmdidx != CMD_redir</a>
<a name="ln4551">             || p != eap-&gt;arg + 1 || p[-1] != '@'))</a>
<a name="ln4552">        || *p == '|'</a>
<a name="ln4553">        || *p == '\n') {</a>
<a name="ln4554">      // We remove the '\' before the '|', unless EX_CTRLV is used</a>
<a name="ln4555">      // AND 'b' is present in 'cpoptions'.</a>
<a name="ln4556">      if ((vim_strchr(p_cpo, CPO_BAR) == NULL</a>
<a name="ln4557">           || !(eap-&gt;argt &amp; EX_CTRLV)) &amp;&amp; *(p - 1) == '\\') {</a>
<a name="ln4558">        STRMOVE(p - 1, p);  // remove the '\'</a>
<a name="ln4559">        p--;</a>
<a name="ln4560">      } else {</a>
<a name="ln4561">        eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln4562">        *p = NUL;</a>
<a name="ln4563">        break;</a>
<a name="ln4564">      }</a>
<a name="ln4565">    }</a>
<a name="ln4566">  }</a>
<a name="ln4567"> </a>
<a name="ln4568">  if (!(eap-&gt;argt &amp; EX_NOTRLCOM)) {  // remove trailing spaces</a>
<a name="ln4569">    del_trailing_spaces(eap-&gt;arg);</a>
<a name="ln4570">  }</a>
<a name="ln4571">}</a>
<a name="ln4572"> </a>
<a name="ln4573">/*</a>
<a name="ln4574"> * get + command from ex argument</a>
<a name="ln4575"> */</a>
<a name="ln4576">static char_u *getargcmd(char_u **argp)</a>
<a name="ln4577">{</a>
<a name="ln4578">  char_u *arg = *argp;</a>
<a name="ln4579">  char_u *command = NULL;</a>
<a name="ln4580"> </a>
<a name="ln4581">  if (*arg == '+') {        /* +[command] */</a>
<a name="ln4582">    ++arg;</a>
<a name="ln4583">    if (ascii_isspace(*arg) || *arg == '\0')</a>
<a name="ln4584">      command = dollar_command;</a>
<a name="ln4585">    else {</a>
<a name="ln4586">      command = arg;</a>
<a name="ln4587">      arg = skip_cmd_arg(command, TRUE);</a>
<a name="ln4588">      if (*arg != NUL)</a>
<a name="ln4589">        *arg++ = NUL;                   /* terminate command with NUL */</a>
<a name="ln4590">    }</a>
<a name="ln4591"> </a>
<a name="ln4592">    arg = skipwhite(arg);       /* skip over spaces */</a>
<a name="ln4593">    *argp = arg;</a>
<a name="ln4594">  }</a>
<a name="ln4595">  return command;</a>
<a name="ln4596">}</a>
<a name="ln4597"> </a>
<a name="ln4598">/*</a>
<a name="ln4599"> * Find end of &quot;+command&quot; argument.  Skip over &quot;\ &quot; and &quot;\\&quot;.</a>
<a name="ln4600"> */</a>
<a name="ln4601">static char_u *</a>
<a name="ln4602">skip_cmd_arg (</a>
<a name="ln4603">    char_u *p,</a>
<a name="ln4604">    int rembs              /* TRUE to halve the number of backslashes */</a>
<a name="ln4605">)</a>
<a name="ln4606">{</a>
<a name="ln4607">  while (*p &amp;&amp; !ascii_isspace(*p)) {</a>
<a name="ln4608">    if (*p == '\\' &amp;&amp; p[1] != NUL) {</a>
<a name="ln4609">      if (rembs)</a>
<a name="ln4610">        STRMOVE(p, p + 1);</a>
<a name="ln4611">      else</a>
<a name="ln4612">        ++p;</a>
<a name="ln4613">    }</a>
<a name="ln4614">    MB_PTR_ADV(p);</a>
<a name="ln4615">  }</a>
<a name="ln4616">  return p;</a>
<a name="ln4617">}</a>
<a name="ln4618"> </a>
<a name="ln4619">int get_bad_opt(const char_u *p, exarg_T *eap)</a>
<a name="ln4620">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4621">{</a>
<a name="ln4622">  if (STRICMP(p, &quot;keep&quot;) == 0) {</a>
<a name="ln4623">    eap-&gt;bad_char = BAD_KEEP;</a>
<a name="ln4624">  } else if (STRICMP(p, &quot;drop&quot;) == 0) {</a>
<a name="ln4625">    eap-&gt;bad_char = BAD_DROP;</a>
<a name="ln4626">  } else if (MB_BYTE2LEN(*p) == 1 &amp;&amp; p[1] == NUL) {</a>
<a name="ln4627">    eap-&gt;bad_char = *p;</a>
<a name="ln4628">  } else {</a>
<a name="ln4629">    return FAIL;</a>
<a name="ln4630">  }</a>
<a name="ln4631">  return OK;</a>
<a name="ln4632">}</a>
<a name="ln4633"> </a>
<a name="ln4634">/*</a>
<a name="ln4635"> * Get &quot;++opt=arg&quot; argument.</a>
<a name="ln4636"> * Return FAIL or OK.</a>
<a name="ln4637"> */</a>
<a name="ln4638">static int getargopt(exarg_T *eap)</a>
<a name="ln4639">{</a>
<a name="ln4640">  char_u      *arg = eap-&gt;arg + 2;</a>
<a name="ln4641">  int         *pp = NULL;</a>
<a name="ln4642">  int bad_char_idx;</a>
<a name="ln4643">  char_u      *p;</a>
<a name="ln4644"> </a>
<a name="ln4645">  /* &quot;:edit ++[no]bin[ary] file&quot; */</a>
<a name="ln4646">  if (STRNCMP(arg, &quot;bin&quot;, 3) == 0 || STRNCMP(arg, &quot;nobin&quot;, 5) == 0) {</a>
<a name="ln4647">    if (*arg == 'n') {</a>
<a name="ln4648">      arg += 2;</a>
<a name="ln4649">      eap-&gt;force_bin = FORCE_NOBIN;</a>
<a name="ln4650">    } else</a>
<a name="ln4651">      eap-&gt;force_bin = FORCE_BIN;</a>
<a name="ln4652">    if (!checkforcmd(&amp;arg, &quot;binary&quot;, 3))</a>
<a name="ln4653">      return FAIL;</a>
<a name="ln4654">    eap-&gt;arg = skipwhite(arg);</a>
<a name="ln4655">    return OK;</a>
<a name="ln4656">  }</a>
<a name="ln4657"> </a>
<a name="ln4658">  /* &quot;:read ++edit file&quot; */</a>
<a name="ln4659">  if (STRNCMP(arg, &quot;edit&quot;, 4) == 0) {</a>
<a name="ln4660">    eap-&gt;read_edit = TRUE;</a>
<a name="ln4661">    eap-&gt;arg = skipwhite(arg + 4);</a>
<a name="ln4662">    return OK;</a>
<a name="ln4663">  }</a>
<a name="ln4664"> </a>
<a name="ln4665">  if (STRNCMP(arg, &quot;ff&quot;, 2) == 0) {</a>
<a name="ln4666">    arg += 2;</a>
<a name="ln4667">    pp = &amp;eap-&gt;force_ff;</a>
<a name="ln4668">  } else if (STRNCMP(arg, &quot;fileformat&quot;, 10) == 0) {</a>
<a name="ln4669">    arg += 10;</a>
<a name="ln4670">    pp = &amp;eap-&gt;force_ff;</a>
<a name="ln4671">  } else if (STRNCMP(arg, &quot;enc&quot;, 3) == 0) {</a>
<a name="ln4672">    if (STRNCMP(arg, &quot;encoding&quot;, 8) == 0)</a>
<a name="ln4673">      arg += 8;</a>
<a name="ln4674">    else</a>
<a name="ln4675">      arg += 3;</a>
<a name="ln4676">    pp = &amp;eap-&gt;force_enc;</a>
<a name="ln4677">  } else if (STRNCMP(arg, &quot;bad&quot;, 3) == 0) {</a>
<a name="ln4678">    arg += 3;</a>
<a name="ln4679">    pp = &amp;bad_char_idx;</a>
<a name="ln4680">  }</a>
<a name="ln4681"> </a>
<a name="ln4682">  if (pp == NULL || *arg != '=')</a>
<a name="ln4683">    return FAIL;</a>
<a name="ln4684"> </a>
<a name="ln4685">  ++arg;</a>
<a name="ln4686">  *pp = (int)(arg - eap-&gt;cmd);</a>
<a name="ln4687">  arg = skip_cmd_arg(arg, FALSE);</a>
<a name="ln4688">  eap-&gt;arg = skipwhite(arg);</a>
<a name="ln4689">  *arg = NUL;</a>
<a name="ln4690"> </a>
<a name="ln4691">  if (pp == &amp;eap-&gt;force_ff) {</a>
<a name="ln4692">    if (check_ff_value(eap-&gt;cmd + eap-&gt;force_ff) == FAIL) {</a>
<a name="ln4693">      return FAIL;</a>
<a name="ln4694">    }</a>
<a name="ln4695">    eap-&gt;force_ff = eap-&gt;cmd[eap-&gt;force_ff];</a>
<a name="ln4696">  } else if (pp == &amp;eap-&gt;force_enc) {</a>
<a name="ln4697">    /* Make 'fileencoding' lower case. */</a>
<a name="ln4698">    for (p = eap-&gt;cmd + eap-&gt;force_enc; *p != NUL; ++p)</a>
<a name="ln4699">      *p = TOLOWER_ASC(*p);</a>
<a name="ln4700">  } else {</a>
<a name="ln4701">    /* Check ++bad= argument.  Must be a single-byte character, &quot;keep&quot; or</a>
<a name="ln4702">     * &quot;drop&quot;. */</a>
<a name="ln4703">    if (get_bad_opt(eap-&gt;cmd + bad_char_idx, eap) == FAIL) {</a>
<a name="ln4704">      return FAIL;</a>
<a name="ln4705">    }</a>
<a name="ln4706">  }</a>
<a name="ln4707"> </a>
<a name="ln4708">  return OK;</a>
<a name="ln4709">}</a>
<a name="ln4710"> </a>
<a name="ln4711">/// Handle the argument for a tabpage related ex command.</a>
<a name="ln4712">/// Returns a tabpage number.</a>
<a name="ln4713">/// When an error is encountered then eap-&gt;errmsg is set.</a>
<a name="ln4714">static int get_tabpage_arg(exarg_T *eap)</a>
<a name="ln4715">{</a>
<a name="ln4716">  int tab_number = 0;</a>
<a name="ln4717">  int unaccept_arg0 = (eap-&gt;cmdidx == CMD_tabmove) ? 0 : 1;</a>
<a name="ln4718"> </a>
<a name="ln4719">  if (eap-&gt;arg &amp;&amp; *eap-&gt;arg != NUL) {</a>
<a name="ln4720">    char_u *p = eap-&gt;arg;</a>
<a name="ln4721">    char_u *p_save;</a>
<a name="ln4722">    int relative = 0; // argument +N/-N means: go to N places to the</a>
<a name="ln4723">                      // right/left relative to the current position.</a>
<a name="ln4724"> </a>
<a name="ln4725">    if (*p == '-') {</a>
<a name="ln4726">      relative = -1;</a>
<a name="ln4727">      p++;</a>
<a name="ln4728">    } else if (*p == '+') {</a>
<a name="ln4729">      relative = 1;</a>
<a name="ln4730">      p++;</a>
<a name="ln4731">    }</a>
<a name="ln4732"> </a>
<a name="ln4733">    p_save = p;</a>
<a name="ln4734">    tab_number = getdigits(&amp;p, false, tab_number);</a>
<a name="ln4735"> </a>
<a name="ln4736">    if (relative == 0) {</a>
<a name="ln4737">      if (STRCMP(p, &quot;$&quot;) == 0) {</a>
<a name="ln4738">        tab_number = LAST_TAB_NR;</a>
<a name="ln4739">      } else if (STRCMP(p, &quot;#&quot;) == 0) {</a>
<a name="ln4740">        tab_number = tabpage_index(lastused_tabpage);</a>
<a name="ln4741">      } else if (p == p_save || *p_save == '-' || *p != NUL</a>
<a name="ln4742">                 || tab_number &gt; LAST_TAB_NR) {</a>
<a name="ln4743">        // No numbers as argument.</a>
<a name="ln4744">        eap-&gt;errmsg = e_invarg;</a>
<a name="ln4745">        goto theend;</a>
<a name="ln4746">      }</a>
<a name="ln4747">    } else {</a>
<a name="ln4748">      if (*p_save == NUL) {</a>
<a name="ln4749">        tab_number = 1;</a>
<a name="ln4750">      }</a>
<a name="ln4751">      else if (p == p_save || *p_save == '-' || *p != NUL || tab_number == 0) {</a>
<a name="ln4752">        // No numbers as argument.</a>
<a name="ln4753">        eap-&gt;errmsg = e_invarg;</a>
<a name="ln4754">        goto theend;</a>
<a name="ln4755">      }</a>
<a name="ln4756">      tab_number = tab_number * relative + tabpage_index(curtab);</a>
<a name="ln4757">      if (!unaccept_arg0 &amp;&amp; relative == -1) {</a>
<a name="ln4758">        --tab_number;</a>
<a name="ln4759">      }</a>
<a name="ln4760">    }</a>
<a name="ln4761">    if (tab_number &lt; unaccept_arg0 || tab_number &gt; LAST_TAB_NR) {</a>
<a name="ln4762">      eap-&gt;errmsg = e_invarg;</a>
<a name="ln4763">    }</a>
<a name="ln4764">  } else if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln4765">    if (unaccept_arg0 &amp;&amp; eap-&gt;line2 == 0) {</a>
<a name="ln4766">      eap-&gt;errmsg = e_invrange;</a>
<a name="ln4767">      tab_number = 0;</a>
<a name="ln4768">    } else {</a>
<a name="ln4769">      tab_number = eap-&gt;line2;</a>
<a name="ln4770">      if (!unaccept_arg0 &amp;&amp; *skipwhite(*eap-&gt;cmdlinep) == '-') {</a>
<a name="ln4771">        tab_number--;</a>
<a name="ln4772">        if (tab_number &lt; unaccept_arg0) {</a>
<a name="ln4773">          eap-&gt;errmsg = e_invarg;</a>
<a name="ln4774">        }</a>
<a name="ln4775">      }</a>
<a name="ln4776">    }</a>
<a name="ln4777">  } else {</a>
<a name="ln4778">    switch (eap-&gt;cmdidx) {</a>
<a name="ln4779">    case CMD_tabnext:</a>
<a name="ln4780">      tab_number = tabpage_index(curtab) + 1;</a>
<a name="ln4781">      if (tab_number &gt; LAST_TAB_NR)</a>
<a name="ln4782">        tab_number = 1;</a>
<a name="ln4783">      break;</a>
<a name="ln4784">    case CMD_tabmove:</a>
<a name="ln4785">      tab_number = LAST_TAB_NR;</a>
<a name="ln4786">      break;</a>
<a name="ln4787">    default:</a>
<a name="ln4788">      tab_number = tabpage_index(curtab);</a>
<a name="ln4789">    }</a>
<a name="ln4790">  }</a>
<a name="ln4791"> </a>
<a name="ln4792">theend:</a>
<a name="ln4793">  return tab_number;</a>
<a name="ln4794">}</a>
<a name="ln4795"> </a>
<a name="ln4796">/*</a>
<a name="ln4797"> * &quot;:abbreviate&quot; and friends.</a>
<a name="ln4798"> */</a>
<a name="ln4799">static void ex_abbreviate(exarg_T *eap)</a>
<a name="ln4800">{</a>
<a name="ln4801">  do_exmap(eap, TRUE);          /* almost the same as mapping */</a>
<a name="ln4802">}</a>
<a name="ln4803"> </a>
<a name="ln4804">/*</a>
<a name="ln4805"> * &quot;:map&quot; and friends.</a>
<a name="ln4806"> */</a>
<a name="ln4807">static void ex_map(exarg_T *eap)</a>
<a name="ln4808">{</a>
<a name="ln4809">  /*</a>
<a name="ln4810">   * If we are sourcing .exrc or .vimrc in current directory we</a>
<a name="ln4811">   * print the mappings for security reasons.</a>
<a name="ln4812">   */</a>
<a name="ln4813">  if (secure) {</a>
<a name="ln4814">    secure = 2;</a>
<a name="ln4815">    msg_outtrans(eap-&gt;cmd);</a>
<a name="ln4816">    msg_putchar('\n');</a>
<a name="ln4817">  }</a>
<a name="ln4818">  do_exmap(eap, FALSE);</a>
<a name="ln4819">}</a>
<a name="ln4820"> </a>
<a name="ln4821">/*</a>
<a name="ln4822"> * &quot;:unmap&quot; and friends.</a>
<a name="ln4823"> */</a>
<a name="ln4824">static void ex_unmap(exarg_T *eap)</a>
<a name="ln4825">{</a>
<a name="ln4826">  do_exmap(eap, FALSE);</a>
<a name="ln4827">}</a>
<a name="ln4828"> </a>
<a name="ln4829">/*</a>
<a name="ln4830"> * &quot;:mapclear&quot; and friends.</a>
<a name="ln4831"> */</a>
<a name="ln4832">static void ex_mapclear(exarg_T *eap)</a>
<a name="ln4833">{</a>
<a name="ln4834">  map_clear_mode(eap-&gt;cmd, eap-&gt;arg, eap-&gt;forceit, false);</a>
<a name="ln4835">}</a>
<a name="ln4836"> </a>
<a name="ln4837">/*</a>
<a name="ln4838"> * &quot;:abclear&quot; and friends.</a>
<a name="ln4839"> */</a>
<a name="ln4840">static void ex_abclear(exarg_T *eap)</a>
<a name="ln4841">{</a>
<a name="ln4842">  map_clear_mode(eap-&gt;cmd, eap-&gt;arg, true, true);</a>
<a name="ln4843">}</a>
<a name="ln4844"> </a>
<a name="ln4845">static void ex_autocmd(exarg_T *eap)</a>
<a name="ln4846">{</a>
<a name="ln4847">  // Disallow autocommands from .exrc and .vimrc in current</a>
<a name="ln4848">  // directory for security reasons.</a>
<a name="ln4849">  if (secure) {</a>
<a name="ln4850">    secure = 2;</a>
<a name="ln4851">    eap-&gt;errmsg = e_curdir;</a>
<a name="ln4852">  } else if (eap-&gt;cmdidx == CMD_autocmd)</a>
<a name="ln4853">    do_autocmd(eap-&gt;arg, eap-&gt;forceit);</a>
<a name="ln4854">  else</a>
<a name="ln4855">    do_augroup(eap-&gt;arg, eap-&gt;forceit);</a>
<a name="ln4856">}</a>
<a name="ln4857"> </a>
<a name="ln4858">/*</a>
<a name="ln4859"> * &quot;:doautocmd&quot;: Apply the automatic commands to the current buffer.</a>
<a name="ln4860"> */</a>
<a name="ln4861">static void ex_doautocmd(exarg_T *eap)</a>
<a name="ln4862">{</a>
<a name="ln4863">  char_u *arg = eap-&gt;arg;</a>
<a name="ln4864">  int call_do_modelines = check_nomodeline(&amp;arg);</a>
<a name="ln4865">  bool did_aucmd;</a>
<a name="ln4866"> </a>
<a name="ln4867">  (void)do_doautocmd(arg, false, &amp;did_aucmd);</a>
<a name="ln4868">  // Only when there is no &lt;nomodeline&gt;.</a>
<a name="ln4869">  if (call_do_modelines &amp;&amp; did_aucmd) {</a>
<a name="ln4870">    do_modelines(0);</a>
<a name="ln4871">  }</a>
<a name="ln4872">}</a>
<a name="ln4873"> </a>
<a name="ln4874">/*</a>
<a name="ln4875"> * :[N]bunload[!] [N] [bufname] unload buffer</a>
<a name="ln4876"> * :[N]bdelete[!] [N] [bufname] delete buffer from buffer list</a>
<a name="ln4877"> * :[N]bwipeout[!] [N] [bufname] delete buffer really</a>
<a name="ln4878"> */</a>
<a name="ln4879">static void ex_bunload(exarg_T *eap)</a>
<a name="ln4880">{</a>
<a name="ln4881">  eap-&gt;errmsg = do_bufdel(</a>
<a name="ln4882">      eap-&gt;cmdidx == CMD_bdelete ? DOBUF_DEL</a>
<a name="ln4883">      : eap-&gt;cmdidx == CMD_bwipeout ? DOBUF_WIPE</a>
<a name="ln4884">      : DOBUF_UNLOAD, eap-&gt;arg,</a>
<a name="ln4885">      eap-&gt;addr_count, (int)eap-&gt;line1, (int)eap-&gt;line2, eap-&gt;forceit);</a>
<a name="ln4886">}</a>
<a name="ln4887"> </a>
<a name="ln4888">/*</a>
<a name="ln4889"> * :[N]buffer [N]	to buffer N</a>
<a name="ln4890"> * :[N]sbuffer [N]	to buffer N</a>
<a name="ln4891"> */</a>
<a name="ln4892">static void ex_buffer(exarg_T *eap)</a>
<a name="ln4893">{</a>
<a name="ln4894">  if (*eap-&gt;arg) {</a>
<a name="ln4895">    eap-&gt;errmsg = e_trailing;</a>
<a name="ln4896">  } else {</a>
<a name="ln4897">    if (eap-&gt;addr_count == 0) {  // default is current buffer</a>
<a name="ln4898">      goto_buffer(eap, DOBUF_CURRENT, FORWARD, 0);</a>
<a name="ln4899">    } else {</a>
<a name="ln4900">      goto_buffer(eap, DOBUF_FIRST, FORWARD, (int)eap-&gt;line2);</a>
<a name="ln4901">    }</a>
<a name="ln4902">    if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4903">      do_cmdline_cmd((char *)eap-&gt;do_ecmd_cmd);</a>
<a name="ln4904">    }</a>
<a name="ln4905">  }</a>
<a name="ln4906">}</a>
<a name="ln4907"> </a>
<a name="ln4908">/*</a>
<a name="ln4909"> * :[N]bmodified [N]	to next mod. buffer</a>
<a name="ln4910"> * :[N]sbmodified [N]	to next mod. buffer</a>
<a name="ln4911"> */</a>
<a name="ln4912">static void ex_bmodified(exarg_T *eap)</a>
<a name="ln4913">{</a>
<a name="ln4914">  goto_buffer(eap, DOBUF_MOD, FORWARD, (int)eap-&gt;line2);</a>
<a name="ln4915">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4916">    do_cmdline_cmd((char *)eap-&gt;do_ecmd_cmd);</a>
<a name="ln4917">  }</a>
<a name="ln4918">}</a>
<a name="ln4919"> </a>
<a name="ln4920">/*</a>
<a name="ln4921"> * :[N]bnext [N]	to next buffer</a>
<a name="ln4922"> * :[N]sbnext [N]	split and to next buffer</a>
<a name="ln4923"> */</a>
<a name="ln4924">static void ex_bnext(exarg_T *eap)</a>
<a name="ln4925">{</a>
<a name="ln4926">  goto_buffer(eap, DOBUF_CURRENT, FORWARD, (int)eap-&gt;line2);</a>
<a name="ln4927">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4928">    do_cmdline_cmd((char *)eap-&gt;do_ecmd_cmd);</a>
<a name="ln4929">  }</a>
<a name="ln4930">}</a>
<a name="ln4931"> </a>
<a name="ln4932">/*</a>
<a name="ln4933"> * :[N]bNext [N]	to previous buffer</a>
<a name="ln4934"> * :[N]bprevious [N]	to previous buffer</a>
<a name="ln4935"> * :[N]sbNext [N]	split and to previous buffer</a>
<a name="ln4936"> * :[N]sbprevious [N]	split and to previous buffer</a>
<a name="ln4937"> */</a>
<a name="ln4938">static void ex_bprevious(exarg_T *eap)</a>
<a name="ln4939">{</a>
<a name="ln4940">  goto_buffer(eap, DOBUF_CURRENT, BACKWARD, (int)eap-&gt;line2);</a>
<a name="ln4941">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4942">    do_cmdline_cmd((char *)eap-&gt;do_ecmd_cmd);</a>
<a name="ln4943">  }</a>
<a name="ln4944">}</a>
<a name="ln4945"> </a>
<a name="ln4946">/*</a>
<a name="ln4947"> * :brewind		to first buffer</a>
<a name="ln4948"> * :bfirst		to first buffer</a>
<a name="ln4949"> * :sbrewind		split and to first buffer</a>
<a name="ln4950"> * :sbfirst		split and to first buffer</a>
<a name="ln4951"> */</a>
<a name="ln4952">static void ex_brewind(exarg_T *eap)</a>
<a name="ln4953">{</a>
<a name="ln4954">  goto_buffer(eap, DOBUF_FIRST, FORWARD, 0);</a>
<a name="ln4955">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4956">    do_cmdline_cmd((char *)eap-&gt;do_ecmd_cmd);</a>
<a name="ln4957">  }</a>
<a name="ln4958">}</a>
<a name="ln4959"> </a>
<a name="ln4960">/*</a>
<a name="ln4961"> * :blast		to last buffer</a>
<a name="ln4962"> * :sblast		split and to last buffer</a>
<a name="ln4963"> */</a>
<a name="ln4964">static void ex_blast(exarg_T *eap)</a>
<a name="ln4965">{</a>
<a name="ln4966">  goto_buffer(eap, DOBUF_LAST, BACKWARD, 0);</a>
<a name="ln4967">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4968">    do_cmdline_cmd((char *)eap-&gt;do_ecmd_cmd);</a>
<a name="ln4969">  }</a>
<a name="ln4970">}</a>
<a name="ln4971"> </a>
<a name="ln4972">int ends_excmd(int c) FUNC_ATTR_CONST</a>
<a name="ln4973">{</a>
<a name="ln4974">  return c == NUL || c == '|' || c == '&quot;' || c == '\n';</a>
<a name="ln4975">}</a>
<a name="ln4976"> </a>
<a name="ln4977">/*</a>
<a name="ln4978"> * Return the next command, after the first '|' or '\n'.</a>
<a name="ln4979"> * Return NULL if not found.</a>
<a name="ln4980"> */</a>
<a name="ln4981">char_u *find_nextcmd(const char_u *p)</a>
<a name="ln4982">{</a>
<a name="ln4983">  while (*p != '|' &amp;&amp; *p != '\n') {</a>
<a name="ln4984">    if (*p == NUL) {</a>
<a name="ln4985">      return NULL;</a>
<a name="ln4986">    }</a>
<a name="ln4987">    p++;</a>
<a name="ln4988">  }</a>
<a name="ln4989">  return (char_u *)p + 1;</a>
<a name="ln4990">}</a>
<a name="ln4991"> </a>
<a name="ln4992">/// Check if *p is a separator between Ex commands, skipping over white space.</a>
<a name="ln4993">/// Return NULL if it isn't, the following character if it is.</a>
<a name="ln4994">char_u *check_nextcmd(char_u *p)</a>
<a name="ln4995">{</a>
<a name="ln4996">    char_u *s = skipwhite(p);</a>
<a name="ln4997"> </a>
<a name="ln4998">    if (*s == '|' || *s == '\n') {</a>
<a name="ln4999">        return (s + 1);</a>
<a name="ln5000">    } else {</a>
<a name="ln5001">        return NULL;</a>
<a name="ln5002">    }</a>
<a name="ln5003">}</a>
<a name="ln5004"> </a>
<a name="ln5005">/*</a>
<a name="ln5006"> * - if there are more files to edit</a>
<a name="ln5007"> * - and this is the last window</a>
<a name="ln5008"> * - and forceit not used</a>
<a name="ln5009"> * - and not repeated twice on a row</a>
<a name="ln5010"> *    return FAIL and give error message if 'message' TRUE</a>
<a name="ln5011"> * return OK otherwise</a>
<a name="ln5012"> */</a>
<a name="ln5013">static int</a>
<a name="ln5014">check_more(</a>
<a name="ln5015">    int message,                // when FALSE check only, no messages</a>
<a name="ln5016">    int forceit</a>
<a name="ln5017">)</a>
<a name="ln5018">{</a>
<a name="ln5019">  int n = ARGCOUNT - curwin-&gt;w_arg_idx - 1;</a>
<a name="ln5020"> </a>
<a name="ln5021">  if (!forceit &amp;&amp; only_one_window()</a>
<a name="ln5022">      &amp;&amp; ARGCOUNT &gt; 1 &amp;&amp; !arg_had_last &amp;&amp; n &gt; 0 &amp;&amp; quitmore == 0) {</a>
<a name="ln5023">    if (message) {</a>
<a name="ln5024">      if ((p_confirm || cmdmod.confirm) &amp;&amp; curbuf-&gt;b_fname != NULL) {</a>
<a name="ln5025">        char_u buff[DIALOG_MSG_SIZE];</a>
<a name="ln5026"> </a>
<a name="ln5027">        if (n == 1)</a>
<a name="ln5028">          STRLCPY(buff, _(&quot;1 more file to edit.  Quit anyway?&quot;),</a>
<a name="ln5029">              DIALOG_MSG_SIZE);</a>
<a name="ln5030">        else</a>
<a name="ln5031">          vim_snprintf((char *)buff, DIALOG_MSG_SIZE,</a>
<a name="ln5032">              _(&quot;%d more files to edit.  Quit anyway?&quot;), n);</a>
<a name="ln5033">        if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 1) == VIM_YES)</a>
<a name="ln5034">          return OK;</a>
<a name="ln5035">        return FAIL;</a>
<a name="ln5036">      }</a>
<a name="ln5037">      if (n == 1)</a>
<a name="ln5038">        EMSG(_(&quot;E173: 1 more file to edit&quot;));</a>
<a name="ln5039">      else</a>
<a name="ln5040">        EMSGN(_(&quot;E173: %&quot; PRId64 &quot; more files to edit&quot;), n);</a>
<a name="ln5041">      quitmore = 2;                 /* next try to quit is allowed */</a>
<a name="ln5042">    }</a>
<a name="ln5043">    return FAIL;</a>
<a name="ln5044">  }</a>
<a name="ln5045">  return OK;</a>
<a name="ln5046">}</a>
<a name="ln5047"> </a>
<a name="ln5048">/*</a>
<a name="ln5049"> * Function given to ExpandGeneric() to obtain the list of command names.</a>
<a name="ln5050"> */</a>
<a name="ln5051">char_u *get_command_name(expand_T *xp, int idx)</a>
<a name="ln5052">{</a>
<a name="ln5053">  if (idx &gt;= (int)CMD_SIZE)</a>
<a name="ln5054">    return get_user_command_name(idx);</a>
<a name="ln5055">  return cmdnames[idx].cmd_name;</a>
<a name="ln5056">}</a>
<a name="ln5057"> </a>
<a name="ln5058">static int uc_add_command(char_u *name, size_t name_len, char_u *rep,</a>
<a name="ln5059">                          uint32_t argt, long def, int flags, int compl,</a>
<a name="ln5060">                          char_u *compl_arg, cmd_addr_T addr_type, bool force)</a>
<a name="ln5061">  FUNC_ATTR_NONNULL_ARG(1, 3)</a>
<a name="ln5062">{</a>
<a name="ln5063">  ucmd_T      *cmd = NULL;</a>
<a name="ln5064">  int i;</a>
<a name="ln5065">  int cmp = 1;</a>
<a name="ln5066">  char_u      *rep_buf = NULL;</a>
<a name="ln5067">  garray_T    *gap;</a>
<a name="ln5068"> </a>
<a name="ln5069">  replace_termcodes(rep, STRLEN(rep), &amp;rep_buf, false, false, true,</a>
<a name="ln5070">                    CPO_TO_CPO_FLAGS);</a>
<a name="ln5071">  if (rep_buf == NULL) {</a>
<a name="ln5072">    /* Can't replace termcodes - try using the string as is */</a>
<a name="ln5073">    rep_buf = vim_strsave(rep);</a>
<a name="ln5074">  }</a>
<a name="ln5075"> </a>
<a name="ln5076">  /* get address of growarray: global or in curbuf */</a>
<a name="ln5077">  if (flags &amp; UC_BUFFER) {</a>
<a name="ln5078">    gap = &amp;curbuf-&gt;b_ucmds;</a>
<a name="ln5079">    if (gap-&gt;ga_itemsize == 0)</a>
<a name="ln5080">      ga_init(gap, (int)sizeof(ucmd_T), 4);</a>
<a name="ln5081">  } else</a>
<a name="ln5082">    gap = &amp;ucmds;</a>
<a name="ln5083"> </a>
<a name="ln5084">  /* Search for the command in the already defined commands. */</a>
<a name="ln5085">  for (i = 0; i &lt; gap-&gt;ga_len; ++i) {</a>
<a name="ln5086">    size_t len;</a>
<a name="ln5087"> </a>
<a name="ln5088">    cmd = USER_CMD_GA(gap, i);</a>
<a name="ln5089">    len = STRLEN(cmd-&gt;uc_name);</a>
<a name="ln5090">    cmp = STRNCMP(name, cmd-&gt;uc_name, name_len);</a>
<a name="ln5091">    if (cmp == 0) {</a>
<a name="ln5092">      if (name_len &lt; len)</a>
<a name="ln5093">        cmp = -1;</a>
<a name="ln5094">      else if (name_len &gt; len)</a>
<a name="ln5095">        cmp = 1;</a>
<a name="ln5096">    }</a>
<a name="ln5097"> </a>
<a name="ln5098">    if (cmp == 0) {</a>
<a name="ln5099">      // Command can be replaced with &quot;command!&quot; and when sourcing the</a>
<a name="ln5100">      // same script again, but only once.</a>
<a name="ln5101">      if (!force</a>
<a name="ln5102">          &amp;&amp; (cmd-&gt;uc_script_ctx.sc_sid != current_sctx.sc_sid</a>
<a name="ln5103">              || cmd-&gt;uc_script_ctx.sc_seq == current_sctx.sc_seq)) {</a>
<a name="ln5104">        EMSG2(_(&quot;E174: Command already exists: add ! to replace it: %s&quot;),</a>
<a name="ln5105">              name);</a>
<a name="ln5106">        goto fail;</a>
<a name="ln5107">      }</a>
<a name="ln5108"> </a>
<a name="ln5109">      XFREE_CLEAR(cmd-&gt;uc_rep);</a>
<a name="ln5110">      XFREE_CLEAR(cmd-&gt;uc_compl_arg);</a>
<a name="ln5111">      break;</a>
<a name="ln5112">    }</a>
<a name="ln5113"> </a>
<a name="ln5114">    /* Stop as soon as we pass the name to add */</a>
<a name="ln5115">    if (cmp &lt; 0)</a>
<a name="ln5116">      break;</a>
<a name="ln5117">  }</a>
<a name="ln5118"> </a>
<a name="ln5119">  /* Extend the array unless we're replacing an existing command */</a>
<a name="ln5120">  if (cmp != 0) {</a>
<a name="ln5121">    ga_grow(gap, 1);</a>
<a name="ln5122"> </a>
<a name="ln5123">    char_u *const p = vim_strnsave(name, name_len);</a>
<a name="ln5124"> </a>
<a name="ln5125">    cmd = USER_CMD_GA(gap, i);</a>
<a name="ln5126">    memmove(cmd + 1, cmd, (gap-&gt;ga_len - i) * sizeof(ucmd_T));</a>
<a name="ln5127"> </a>
<a name="ln5128">    ++gap-&gt;ga_len;</a>
<a name="ln5129"> </a>
<a name="ln5130">    cmd-&gt;uc_name = p;</a>
<a name="ln5131">  }</a>
<a name="ln5132"> </a>
<a name="ln5133">  cmd-&gt;uc_rep = rep_buf;</a>
<a name="ln5134">  cmd-&gt;uc_argt = argt;</a>
<a name="ln5135">  cmd-&gt;uc_def = def;</a>
<a name="ln5136">  cmd-&gt;uc_compl = compl;</a>
<a name="ln5137">  cmd-&gt;uc_script_ctx = current_sctx;</a>
<a name="ln5138">  cmd-&gt;uc_script_ctx.sc_lnum += sourcing_lnum;</a>
<a name="ln5139">  cmd-&gt;uc_compl_arg = compl_arg;</a>
<a name="ln5140">  cmd-&gt;uc_addr_type = addr_type;</a>
<a name="ln5141"> </a>
<a name="ln5142">  return OK;</a>
<a name="ln5143"> </a>
<a name="ln5144">fail:</a>
<a name="ln5145">  xfree(rep_buf);</a>
<a name="ln5146">  xfree(compl_arg);</a>
<a name="ln5147">  return FAIL;</a>
<a name="ln5148">}</a>
<a name="ln5149"> </a>
<a name="ln5150"> </a>
<a name="ln5151">static struct {</a>
<a name="ln5152">  cmd_addr_T expand;</a>
<a name="ln5153">  char *name;</a>
<a name="ln5154">  char *shortname;</a>
<a name="ln5155">} addr_type_complete[] =</a>
<a name="ln5156">{</a>
<a name="ln5157">  { ADDR_ARGUMENTS, &quot;arguments&quot;, &quot;arg&quot; },</a>
<a name="ln5158">  { ADDR_LINES, &quot;lines&quot;, &quot;line&quot; },</a>
<a name="ln5159">  { ADDR_LOADED_BUFFERS, &quot;loaded_buffers&quot;, &quot;load&quot; },</a>
<a name="ln5160">  { ADDR_TABS, &quot;tabs&quot;, &quot;tab&quot; },</a>
<a name="ln5161">  { ADDR_BUFFERS, &quot;buffers&quot;, &quot;buf&quot; },</a>
<a name="ln5162">  { ADDR_WINDOWS, &quot;windows&quot;, &quot;win&quot; },</a>
<a name="ln5163">  { ADDR_QUICKFIX, &quot;quickfix&quot;, &quot;qf&quot; },</a>
<a name="ln5164">  { ADDR_OTHER, &quot;other&quot;, &quot;?&quot; },</a>
<a name="ln5165">  { ADDR_NONE, NULL, NULL }</a>
<a name="ln5166">};</a>
<a name="ln5167"> </a>
<a name="ln5168">/*</a>
<a name="ln5169"> * List of names for completion for &quot;:command&quot; with the EXPAND_ flag.</a>
<a name="ln5170"> * Must be alphabetical for completion.</a>
<a name="ln5171"> */</a>
<a name="ln5172">static const char *command_complete[] =</a>
<a name="ln5173">{</a>
<a name="ln5174">  [EXPAND_ARGLIST] = &quot;arglist&quot;,</a>
<a name="ln5175">  [EXPAND_AUGROUP] = &quot;augroup&quot;,</a>
<a name="ln5176">  [EXPAND_BEHAVE] = &quot;behave&quot;,</a>
<a name="ln5177">  [EXPAND_BUFFERS] = &quot;buffer&quot;,</a>
<a name="ln5178">  [EXPAND_CHECKHEALTH] = &quot;checkhealth&quot;,</a>
<a name="ln5179">  [EXPAND_COLORS] = &quot;color&quot;,</a>
<a name="ln5180">  [EXPAND_COMMANDS] = &quot;command&quot;,</a>
<a name="ln5181">  [EXPAND_COMPILER] = &quot;compiler&quot;,</a>
<a name="ln5182">  [EXPAND_CSCOPE] = &quot;cscope&quot;,</a>
<a name="ln5183">  [EXPAND_USER_DEFINED] = &quot;custom&quot;,</a>
<a name="ln5184">  [EXPAND_USER_LIST] = &quot;customlist&quot;,</a>
<a name="ln5185">  [EXPAND_DIFF_BUFFERS] = &quot;diff_buffer&quot;,</a>
<a name="ln5186">  [EXPAND_DIRECTORIES] = &quot;dir&quot;,</a>
<a name="ln5187">  [EXPAND_ENV_VARS] = &quot;environment&quot;,</a>
<a name="ln5188">  [EXPAND_EVENTS] = &quot;event&quot;,</a>
<a name="ln5189">  [EXPAND_EXPRESSION] = &quot;expression&quot;,</a>
<a name="ln5190">  [EXPAND_FILES] = &quot;file&quot;,</a>
<a name="ln5191">  [EXPAND_FILES_IN_PATH] = &quot;file_in_path&quot;,</a>
<a name="ln5192">  [EXPAND_FILETYPE] = &quot;filetype&quot;,</a>
<a name="ln5193">  [EXPAND_FUNCTIONS] = &quot;function&quot;,</a>
<a name="ln5194">  [EXPAND_HELP] = &quot;help&quot;,</a>
<a name="ln5195">  [EXPAND_HIGHLIGHT] = &quot;highlight&quot;,</a>
<a name="ln5196">  [EXPAND_HISTORY] = &quot;history&quot;,</a>
<a name="ln5197">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln5198">  [EXPAND_LOCALES] = &quot;locale&quot;,</a>
<a name="ln5199">#endif</a>
<a name="ln5200">  [EXPAND_LUA] = &quot;lua&quot;,</a>
<a name="ln5201">  [EXPAND_MAPCLEAR] = &quot;mapclear&quot;,</a>
<a name="ln5202">  [EXPAND_MAPPINGS] = &quot;mapping&quot;,</a>
<a name="ln5203">  [EXPAND_MENUS] = &quot;menu&quot;,</a>
<a name="ln5204">  [EXPAND_MESSAGES] = &quot;messages&quot;,</a>
<a name="ln5205">  [EXPAND_OWNSYNTAX] = &quot;syntax&quot;,</a>
<a name="ln5206">  [EXPAND_SYNTIME] = &quot;syntime&quot;,</a>
<a name="ln5207">  [EXPAND_SETTINGS] = &quot;option&quot;,</a>
<a name="ln5208">  [EXPAND_PACKADD] = &quot;packadd&quot;,</a>
<a name="ln5209">  [EXPAND_SHELLCMD] = &quot;shellcmd&quot;,</a>
<a name="ln5210">  [EXPAND_SIGN] = &quot;sign&quot;,</a>
<a name="ln5211">  [EXPAND_TAGS] = &quot;tag&quot;,</a>
<a name="ln5212">  [EXPAND_TAGS_LISTFILES] = &quot;tag_listfiles&quot;,</a>
<a name="ln5213">  [EXPAND_USER] = &quot;user&quot;,</a>
<a name="ln5214">  [EXPAND_USER_VARS] = &quot;var&quot;,</a>
<a name="ln5215">};</a>
<a name="ln5216"> </a>
<a name="ln5217">static char *get_command_complete(int arg)</a>
<a name="ln5218">{</a>
<a name="ln5219">  if (arg &gt;= (int)(ARRAY_SIZE(command_complete))) {</a>
<a name="ln5220">    return NULL;</a>
<a name="ln5221">  } else {</a>
<a name="ln5222">    return (char *)command_complete[arg];</a>
<a name="ln5223">  }</a>
<a name="ln5224">}</a>
<a name="ln5225"> </a>
<a name="ln5226">static void uc_list(char_u *name, size_t name_len)</a>
<a name="ln5227">{</a>
<a name="ln5228">  int i, j;</a>
<a name="ln5229">  bool found = false;</a>
<a name="ln5230">  ucmd_T      *cmd;</a>
<a name="ln5231">  uint32_t a;</a>
<a name="ln5232"> </a>
<a name="ln5233">  // In cmdwin, the alternative buffer should be used.</a>
<a name="ln5234">  garray_T *gap = (cmdwin_type != 0 &amp;&amp; get_cmdline_type() == NUL)</a>
<a name="ln5235">    ? &amp;prevwin-&gt;w_buffer-&gt;b_ucmds</a>
<a name="ln5236">    : &amp;curbuf-&gt;b_ucmds;</a>
<a name="ln5237">  for (;; ) {</a>
<a name="ln5238">    for (i = 0; i &lt; gap-&gt;ga_len; ++i) {</a>
<a name="ln5239">      cmd = USER_CMD_GA(gap, i);</a>
<a name="ln5240">      a = cmd-&gt;uc_argt;</a>
<a name="ln5241"> </a>
<a name="ln5242">      // Skip commands which don't match the requested prefix and</a>
<a name="ln5243">      // commands filtered out.</a>
<a name="ln5244">      if (STRNCMP(name, cmd-&gt;uc_name, name_len) != 0</a>
<a name="ln5245">          || message_filtered(cmd-&gt;uc_name)) {</a>
<a name="ln5246">        continue;</a>
<a name="ln5247">      }</a>
<a name="ln5248"> </a>
<a name="ln5249">      // Put out the title first time</a>
<a name="ln5250">      if (!found) {</a>
<a name="ln5251">        MSG_PUTS_TITLE(_(&quot;\n    Name              Args Address &quot;</a>
<a name="ln5252">                         &quot;Complete    Definition&quot;));</a>
<a name="ln5253">      }</a>
<a name="ln5254">      found = true;</a>
<a name="ln5255">      msg_putchar('\n');</a>
<a name="ln5256">      if (got_int)</a>
<a name="ln5257">        break;</a>
<a name="ln5258"> </a>
<a name="ln5259">      // Special cases</a>
<a name="ln5260">      int len = 4;</a>
<a name="ln5261">      if (a &amp; EX_BANG) {</a>
<a name="ln5262">        msg_putchar('!');</a>
<a name="ln5263">        len--;</a>
<a name="ln5264">      }</a>
<a name="ln5265">      if (a &amp; EX_REGSTR) {</a>
<a name="ln5266">        msg_putchar('&quot;');</a>
<a name="ln5267">        len--;</a>
<a name="ln5268">      }</a>
<a name="ln5269">      if (gap != &amp;ucmds) {</a>
<a name="ln5270">        msg_putchar('b');</a>
<a name="ln5271">        len--;</a>
<a name="ln5272">      }</a>
<a name="ln5273">      if (a &amp; EX_TRLBAR) {</a>
<a name="ln5274">        msg_putchar('|');</a>
<a name="ln5275">        len--;</a>
<a name="ln5276">      }</a>
<a name="ln5277">      while (len-- &gt; 0) {</a>
<a name="ln5278">        msg_putchar(' ');</a>
<a name="ln5279">      }</a>
<a name="ln5280"> </a>
<a name="ln5281">      msg_outtrans_attr(cmd-&gt;uc_name, HL_ATTR(HLF_D));</a>
<a name="ln5282">      len = (int)STRLEN(cmd-&gt;uc_name) + 4;</a>
<a name="ln5283"> </a>
<a name="ln5284">      do {</a>
<a name="ln5285">        msg_putchar(' ');</a>
<a name="ln5286">        len++;</a>
<a name="ln5287">      } while (len &lt; 22);</a>
<a name="ln5288"> </a>
<a name="ln5289">      // &quot;over&quot; is how much longer the name is than the column width for</a>
<a name="ln5290">      // the name, we'll try to align what comes after.</a>
<a name="ln5291">      const int over = len - 22;</a>
<a name="ln5292">      len = 0;</a>
<a name="ln5293"> </a>
<a name="ln5294">      // Arguments</a>
<a name="ln5295">      switch (a &amp; (EX_EXTRA | EX_NOSPC | EX_NEEDARG)) {</a>
<a name="ln5296">        case 0:</a>
<a name="ln5297">          IObuff[len++] = '0';</a>
<a name="ln5298">          break;</a>
<a name="ln5299">        case (EX_EXTRA):</a>
<a name="ln5300">          IObuff[len++] = '*';</a>
<a name="ln5301">          break;</a>
<a name="ln5302">        case (EX_EXTRA | EX_NOSPC):</a>
<a name="ln5303">          IObuff[len++] = '?';</a>
<a name="ln5304">          break;</a>
<a name="ln5305">        case (EX_EXTRA | EX_NEEDARG):</a>
<a name="ln5306">          IObuff[len++] = '+';</a>
<a name="ln5307">          break;</a>
<a name="ln5308">        case (EX_EXTRA | EX_NOSPC | EX_NEEDARG):</a>
<a name="ln5309">          IObuff[len++] = '1';</a>
<a name="ln5310">          break;</a>
<a name="ln5311">      }</a>
<a name="ln5312"> </a>
<a name="ln5313">      do {</a>
<a name="ln5314">        IObuff[len++] = ' ';</a>
<a name="ln5315">      } while (len &lt; 5 - over);</a>
<a name="ln5316"> </a>
<a name="ln5317">      // Address / Range</a>
<a name="ln5318">      if (a &amp; (EX_RANGE | EX_COUNT)) {</a>
<a name="ln5319">        if (a &amp; EX_COUNT) {</a>
<a name="ln5320">          // -count=N</a>
<a name="ln5321">          snprintf((char *)IObuff + len, IOSIZE, &quot;%&quot; PRId64 &quot;c&quot;,</a>
<a name="ln5322">                   (int64_t)cmd-&gt;uc_def);</a>
<a name="ln5323">          len += (int)STRLEN(IObuff + len);</a>
<a name="ln5324">        } else if (a &amp; EX_DFLALL) {</a>
<a name="ln5325">          IObuff[len++] = '%';</a>
<a name="ln5326">        } else if (cmd-&gt;uc_def &gt;= 0) {</a>
<a name="ln5327">          // -range=N</a>
<a name="ln5328">          snprintf((char *)IObuff + len, IOSIZE, &quot;%&quot; PRId64 &quot;&quot;,</a>
<a name="ln5329">                   (int64_t)cmd-&gt;uc_def);</a>
<a name="ln5330">          len += (int)STRLEN(IObuff + len);</a>
<a name="ln5331">        } else {</a>
<a name="ln5332">          IObuff[len++] = '.';</a>
<a name="ln5333">        }</a>
<a name="ln5334">      }</a>
<a name="ln5335"> </a>
<a name="ln5336">      do {</a>
<a name="ln5337">        IObuff[len++] = ' ';</a>
<a name="ln5338">      } while (len &lt; 8 - over);</a>
<a name="ln5339"> </a>
<a name="ln5340">      // Address Type</a>
<a name="ln5341">      for (j = 0; addr_type_complete[j].expand != ADDR_NONE; j++) {</a>
<a name="ln5342">        if (addr_type_complete[j].expand != ADDR_LINES</a>
<a name="ln5343">            &amp;&amp; addr_type_complete[j].expand == cmd-&gt;uc_addr_type) {</a>
<a name="ln5344">          STRCPY(IObuff + len, addr_type_complete[j].shortname);</a>
<a name="ln5345">          len += (int)STRLEN(IObuff + len);</a>
<a name="ln5346">          break;</a>
<a name="ln5347">        }</a>
<a name="ln5348">      }</a>
<a name="ln5349"> </a>
<a name="ln5350">      do {</a>
<a name="ln5351">        IObuff[len++] = ' ';</a>
<a name="ln5352">      } while (len &lt; 13 - over);</a>
<a name="ln5353"> </a>
<a name="ln5354">      // Completion</a>
<a name="ln5355">      char *cmd_compl = get_command_complete(cmd-&gt;uc_compl);</a>
<a name="ln5356">      if (cmd_compl != NULL) {</a>
<a name="ln5357">        STRCPY(IObuff + len, get_command_complete(cmd-&gt;uc_compl));</a>
<a name="ln5358">        len += (int)STRLEN(IObuff + len);</a>
<a name="ln5359">      }</a>
<a name="ln5360"> </a>
<a name="ln5361">      do {</a>
<a name="ln5362">        IObuff[len++] = ' ';</a>
<a name="ln5363">      } while (len &lt; 25 - over);</a>
<a name="ln5364"> </a>
<a name="ln5365">      IObuff[len] = '\0';</a>
<a name="ln5366">      msg_outtrans(IObuff);</a>
<a name="ln5367"> </a>
<a name="ln5368">      msg_outtrans_special(cmd-&gt;uc_rep, false,</a>
<a name="ln5369">                           name_len == 0 ? Columns - 47 : 0);</a>
<a name="ln5370">      if (p_verbose &gt; 0) {</a>
<a name="ln5371">        last_set_msg(cmd-&gt;uc_script_ctx);</a>
<a name="ln5372">      }</a>
<a name="ln5373">      line_breakcheck();</a>
<a name="ln5374">      if (got_int) {</a>
<a name="ln5375">        break;</a>
<a name="ln5376">      }</a>
<a name="ln5377">    }</a>
<a name="ln5378">    if (gap == &amp;ucmds || i &lt; gap-&gt;ga_len)</a>
<a name="ln5379">      break;</a>
<a name="ln5380">    gap = &amp;ucmds;</a>
<a name="ln5381">  }</a>
<a name="ln5382"> </a>
<a name="ln5383">  if (!found)</a>
<a name="ln5384">    MSG(_(&quot;No user-defined commands found&quot;));</a>
<a name="ln5385">}</a>
<a name="ln5386"> </a>
<a name="ln5387">static int uc_scan_attr(char_u *attr, size_t len, uint32_t *argt, long *def,</a>
<a name="ln5388">                        int *flags, int *complp, char_u **compl_arg,</a>
<a name="ln5389">                        cmd_addr_T *addr_type_arg)</a>
<a name="ln5390">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5391">{</a>
<a name="ln5392">  char_u      *p;</a>
<a name="ln5393"> </a>
<a name="ln5394">  if (len == 0) {</a>
<a name="ln5395">    EMSG(_(&quot;E175: No attribute specified&quot;));</a>
<a name="ln5396">    return FAIL;</a>
<a name="ln5397">  }</a>
<a name="ln5398"> </a>
<a name="ln5399">  // First, try the simple attributes (no arguments)</a>
<a name="ln5400">  if (STRNICMP(attr, &quot;bang&quot;, len) == 0) {</a>
<a name="ln5401">    *argt |= EX_BANG;</a>
<a name="ln5402">  } else if (STRNICMP(attr, &quot;buffer&quot;, len) == 0) {</a>
<a name="ln5403">    *flags |= UC_BUFFER;</a>
<a name="ln5404">  } else if (STRNICMP(attr, &quot;register&quot;, len) == 0) {</a>
<a name="ln5405">    *argt |= EX_REGSTR;</a>
<a name="ln5406">  } else if (STRNICMP(attr, &quot;bar&quot;, len) == 0) {</a>
<a name="ln5407">    *argt |= EX_TRLBAR;</a>
<a name="ln5408">  } else {</a>
<a name="ln5409">    int i;</a>
<a name="ln5410">    char_u  *val = NULL;</a>
<a name="ln5411">    size_t vallen = 0;</a>
<a name="ln5412">    size_t attrlen = len;</a>
<a name="ln5413"> </a>
<a name="ln5414">    // Look for the attribute name - which is the part before any '='</a>
<a name="ln5415">    for (i = 0; i &lt; (int)len; i++) {</a>
<a name="ln5416">      if (attr[i] == '=') {</a>
<a name="ln5417">        val = &amp;attr[i + 1];</a>
<a name="ln5418">        vallen = len - i - 1;</a>
<a name="ln5419">        attrlen = i;</a>
<a name="ln5420">        break;</a>
<a name="ln5421">      }</a>
<a name="ln5422">    }</a>
<a name="ln5423"> </a>
<a name="ln5424">    if (STRNICMP(attr, &quot;nargs&quot;, attrlen) == 0) {</a>
<a name="ln5425">      if (vallen == 1) {</a>
<a name="ln5426">        if (*val == '0') {</a>
<a name="ln5427">          // Do nothing - this is the default;</a>
<a name="ln5428">        } else if (*val == '1') {</a>
<a name="ln5429">          *argt |= (EX_EXTRA | EX_NOSPC | EX_NEEDARG);</a>
<a name="ln5430">        } else if (*val == '*') {</a>
<a name="ln5431">          *argt |= EX_EXTRA;</a>
<a name="ln5432">        } else if (*val == '?') {</a>
<a name="ln5433">          *argt |= (EX_EXTRA | EX_NOSPC);</a>
<a name="ln5434">        } else if (*val == '+') {</a>
<a name="ln5435">          *argt |= (EX_EXTRA | EX_NEEDARG);</a>
<a name="ln5436">        } else {</a>
<a name="ln5437">          goto wrong_nargs;</a>
<a name="ln5438">        }</a>
<a name="ln5439">      } else {</a>
<a name="ln5440">wrong_nargs:</a>
<a name="ln5441">        EMSG(_(&quot;E176: Invalid number of arguments&quot;));</a>
<a name="ln5442">        return FAIL;</a>
<a name="ln5443">      }</a>
<a name="ln5444">    } else if (STRNICMP(attr, &quot;range&quot;, attrlen) == 0) {</a>
<a name="ln5445">      *argt |= EX_RANGE;</a>
<a name="ln5446">      if (vallen == 1 &amp;&amp; *val == '%') {</a>
<a name="ln5447">        *argt |= EX_DFLALL;</a>
<a name="ln5448">      } else if (val != NULL) {</a>
<a name="ln5449">        p = val;</a>
<a name="ln5450">        if (*def &gt;= 0) {</a>
<a name="ln5451">two_count:</a>
<a name="ln5452">          EMSG(_(&quot;E177: Count cannot be specified twice&quot;));</a>
<a name="ln5453">          return FAIL;</a>
<a name="ln5454">        }</a>
<a name="ln5455"> </a>
<a name="ln5456">        *def = getdigits_long(&amp;p, true, 0);</a>
<a name="ln5457">        *argt |= EX_ZEROR;</a>
<a name="ln5458"> </a>
<a name="ln5459">        if (p != val + vallen || vallen == 0) {</a>
<a name="ln5460">invalid_count:</a>
<a name="ln5461">          EMSG(_(&quot;E178: Invalid default value for count&quot;));</a>
<a name="ln5462">          return FAIL;</a>
<a name="ln5463">        }</a>
<a name="ln5464">      }</a>
<a name="ln5465">      // default for -range is using buffer lines</a>
<a name="ln5466">      if (*addr_type_arg == ADDR_NONE) {</a>
<a name="ln5467">        *addr_type_arg = ADDR_LINES;</a>
<a name="ln5468">      }</a>
<a name="ln5469">    } else if (STRNICMP(attr, &quot;count&quot;, attrlen) == 0) {</a>
<a name="ln5470">      *argt |= (EX_COUNT | EX_ZEROR | EX_RANGE);</a>
<a name="ln5471">      // default for -count is using any number</a>
<a name="ln5472">      if (*addr_type_arg == ADDR_NONE) {</a>
<a name="ln5473">        *addr_type_arg = ADDR_OTHER;</a>
<a name="ln5474">      }</a>
<a name="ln5475"> </a>
<a name="ln5476">      if (val != NULL) {</a>
<a name="ln5477">        p = val;</a>
<a name="ln5478">        if (*def &gt;= 0)</a>
<a name="ln5479">          goto two_count;</a>
<a name="ln5480"> </a>
<a name="ln5481">        *def = getdigits_long(&amp;p, true, 0);</a>
<a name="ln5482"> </a>
<a name="ln5483">        if (p != val + vallen)</a>
<a name="ln5484">          goto invalid_count;</a>
<a name="ln5485">      }</a>
<a name="ln5486"> </a>
<a name="ln5487">      if (*def &lt; 0)</a>
<a name="ln5488">        *def = 0;</a>
<a name="ln5489">    } else if (STRNICMP(attr, &quot;complete&quot;, attrlen) == 0) {</a>
<a name="ln5490">      if (val == NULL) {</a>
<a name="ln5491">        EMSG(_(&quot;E179: argument required for -complete&quot;));</a>
<a name="ln5492">        return FAIL;</a>
<a name="ln5493">      }</a>
<a name="ln5494"> </a>
<a name="ln5495">      if (parse_compl_arg(val, (int)vallen, complp, argt, compl_arg)</a>
<a name="ln5496">          == FAIL) {</a>
<a name="ln5497">        return FAIL;</a>
<a name="ln5498">      }</a>
<a name="ln5499">    } else if (STRNICMP(attr, &quot;addr&quot;, attrlen) == 0) {</a>
<a name="ln5500">      *argt |= EX_RANGE;</a>
<a name="ln5501">      if (val == NULL) {</a>
<a name="ln5502">        EMSG(_(&quot;E179: argument required for -addr&quot;));</a>
<a name="ln5503">        return FAIL;</a>
<a name="ln5504">      }</a>
<a name="ln5505">      if (parse_addr_type_arg(val, (int)vallen, addr_type_arg) == FAIL) {</a>
<a name="ln5506">        return FAIL;</a>
<a name="ln5507">      }</a>
<a name="ln5508">      if (*addr_type_arg != ADDR_LINES) {</a>
<a name="ln5509">        *argt |= EX_ZEROR;</a>
<a name="ln5510">      }</a>
<a name="ln5511">    } else {</a>
<a name="ln5512">      char_u ch = attr[len];</a>
<a name="ln5513">      attr[len] = '\0';</a>
<a name="ln5514">      EMSG2(_(&quot;E181: Invalid attribute: %s&quot;), attr);</a>
<a name="ln5515">      attr[len] = ch;</a>
<a name="ln5516">      return FAIL;</a>
<a name="ln5517">    }</a>
<a name="ln5518">  }</a>
<a name="ln5519"> </a>
<a name="ln5520">  return OK;</a>
<a name="ln5521">}</a>
<a name="ln5522"> </a>
<a name="ln5523">/*</a>
<a name="ln5524"> * &quot;:command ...&quot;</a>
<a name="ln5525"> */</a>
<a name="ln5526">static void ex_command(exarg_T *eap)</a>
<a name="ln5527">{</a>
<a name="ln5528">  char_u  *name;</a>
<a name="ln5529">  char_u  *end;</a>
<a name="ln5530">  char_u  *p;</a>
<a name="ln5531">  uint32_t argt = 0;</a>
<a name="ln5532">  long def = -1;</a>
<a name="ln5533">  int flags = 0;</a>
<a name="ln5534">  int     compl = EXPAND_NOTHING;</a>
<a name="ln5535">  char_u  *compl_arg = NULL;</a>
<a name="ln5536">  cmd_addr_T addr_type_arg = ADDR_NONE;</a>
<a name="ln5537">  int has_attr = (eap-&gt;arg[0] == '-');</a>
<a name="ln5538">  int name_len;</a>
<a name="ln5539"> </a>
<a name="ln5540">  p = eap-&gt;arg;</a>
<a name="ln5541"> </a>
<a name="ln5542">  /* Check for attributes */</a>
<a name="ln5543">  while (*p == '-') {</a>
<a name="ln5544">    ++p;</a>
<a name="ln5545">    end = skiptowhite(p);</a>
<a name="ln5546">    if (uc_scan_attr(p, end - p, &amp;argt, &amp;def, &amp;flags, &amp;compl, &amp;compl_arg,</a>
<a name="ln5547">                     &amp;addr_type_arg) == FAIL) {</a>
<a name="ln5548">      return;</a>
<a name="ln5549">    }</a>
<a name="ln5550">    p = skipwhite(end);</a>
<a name="ln5551">  }</a>
<a name="ln5552"> </a>
<a name="ln5553">  // Get the name (if any) and skip to the following argument.</a>
<a name="ln5554">  name = p;</a>
<a name="ln5555">  if (ASCII_ISALPHA(*p)) {</a>
<a name="ln5556">    while (ASCII_ISALNUM(*p)) {</a>
<a name="ln5557">      p++;</a>
<a name="ln5558">    }</a>
<a name="ln5559">  }</a>
<a name="ln5560">  if (!ends_excmd(*p) &amp;&amp; !ascii_iswhite(*p)) {</a>
<a name="ln5561">    EMSG(_(&quot;E182: Invalid command name&quot;));</a>
<a name="ln5562">    return;</a>
<a name="ln5563">  }</a>
<a name="ln5564">  end = p;</a>
<a name="ln5565">  name_len = (int)(end - name);</a>
<a name="ln5566"> </a>
<a name="ln5567">  // If there is nothing after the name, and no attributes were specified,</a>
<a name="ln5568">  // we are listing commands</a>
<a name="ln5569">  p = skipwhite(end);</a>
<a name="ln5570">  if (!has_attr &amp;&amp; ends_excmd(*p)) {</a>
<a name="ln5571">    uc_list(name, end - name);</a>
<a name="ln5572">  } else if (!ASCII_ISUPPER(*name)) {</a>
<a name="ln5573">    EMSG(_(&quot;E183: User defined commands must start with an uppercase letter&quot;));</a>
<a name="ln5574">    return;</a>
<a name="ln5575">  } else if (name_len &lt;= 4 &amp;&amp; STRNCMP(name, &quot;Next&quot;, name_len) == 0) {</a>
<a name="ln5576">    EMSG(_(&quot;E841: Reserved name, cannot be used for user defined command&quot;));</a>
<a name="ln5577">    return;</a>
<a name="ln5578">  } else {</a>
<a name="ln5579">    uc_add_command(name, end - name, p, argt, def, flags, compl, compl_arg,</a>
<a name="ln5580">                   addr_type_arg, eap-&gt;forceit);</a>
<a name="ln5581">  }</a>
<a name="ln5582">}</a>
<a name="ln5583"> </a>
<a name="ln5584">/*</a>
<a name="ln5585"> * &quot;:comclear&quot;</a>
<a name="ln5586"> * Clear all user commands, global and for current buffer.</a>
<a name="ln5587"> */</a>
<a name="ln5588">void ex_comclear(exarg_T *eap)</a>
<a name="ln5589">{</a>
<a name="ln5590">  uc_clear(&amp;ucmds);</a>
<a name="ln5591">  uc_clear(&amp;curbuf-&gt;b_ucmds);</a>
<a name="ln5592">}</a>
<a name="ln5593"> </a>
<a name="ln5594">static void free_ucmd(ucmd_T* cmd) {</a>
<a name="ln5595">  xfree(cmd-&gt;uc_name);</a>
<a name="ln5596">  xfree(cmd-&gt;uc_rep);</a>
<a name="ln5597">  xfree(cmd-&gt;uc_compl_arg);</a>
<a name="ln5598">}</a>
<a name="ln5599"> </a>
<a name="ln5600">/*</a>
<a name="ln5601"> * Clear all user commands for &quot;gap&quot;.</a>
<a name="ln5602"> */</a>
<a name="ln5603">void uc_clear(garray_T *gap)</a>
<a name="ln5604">{</a>
<a name="ln5605">  GA_DEEP_CLEAR(gap, ucmd_T, free_ucmd);</a>
<a name="ln5606">}</a>
<a name="ln5607"> </a>
<a name="ln5608">static void ex_delcommand(exarg_T *eap)</a>
<a name="ln5609">{</a>
<a name="ln5610">  int i = 0;</a>
<a name="ln5611">  ucmd_T      *cmd = NULL;</a>
<a name="ln5612">  int cmp = -1;</a>
<a name="ln5613">  garray_T    *gap;</a>
<a name="ln5614"> </a>
<a name="ln5615">  gap = &amp;curbuf-&gt;b_ucmds;</a>
<a name="ln5616">  for (;; ) {</a>
<a name="ln5617">    for (i = 0; i &lt; gap-&gt;ga_len; ++i) {</a>
<a name="ln5618">      cmd = USER_CMD_GA(gap, i);</a>
<a name="ln5619">      cmp = STRCMP(eap-&gt;arg, cmd-&gt;uc_name);</a>
<a name="ln5620">      if (cmp &lt;= 0)</a>
<a name="ln5621">        break;</a>
<a name="ln5622">    }</a>
<a name="ln5623">    if (gap == &amp;ucmds || cmp == 0)</a>
<a name="ln5624">      break;</a>
<a name="ln5625">    gap = &amp;ucmds;</a>
<a name="ln5626">  }</a>
<a name="ln5627"> </a>
<a name="ln5628">  if (cmp != 0) {</a>
<a name="ln5629">    EMSG2(_(&quot;E184: No such user-defined command: %s&quot;), eap-&gt;arg);</a>
<a name="ln5630">    return;</a>
<a name="ln5631">  }</a>
<a name="ln5632"> </a>
<a name="ln5633">  xfree(cmd-&gt;uc_name);</a>
<a name="ln5634">  xfree(cmd-&gt;uc_rep);</a>
<a name="ln5635">  xfree(cmd-&gt;uc_compl_arg);</a>
<a name="ln5636"> </a>
<a name="ln5637">  --gap-&gt;ga_len;</a>
<a name="ln5638"> </a>
<a name="ln5639">  if (i &lt; gap-&gt;ga_len)</a>
<a name="ln5640">    memmove(cmd, cmd + 1, (gap-&gt;ga_len - i) * sizeof(ucmd_T));</a>
<a name="ln5641">}</a>
<a name="ln5642"> </a>
<a name="ln5643">/*</a>
<a name="ln5644"> * split and quote args for &lt;f-args&gt;</a>
<a name="ln5645"> */</a>
<a name="ln5646">static char_u *uc_split_args(char_u *arg, size_t *lenp)</a>
<a name="ln5647">{</a>
<a name="ln5648">  char_u *buf;</a>
<a name="ln5649">  char_u *p;</a>
<a name="ln5650">  char_u *q;</a>
<a name="ln5651">  int len;</a>
<a name="ln5652"> </a>
<a name="ln5653">  /* Precalculate length */</a>
<a name="ln5654">  p = arg;</a>
<a name="ln5655">  len = 2;   /* Initial and final quotes */</a>
<a name="ln5656"> </a>
<a name="ln5657">  while (*p) {</a>
<a name="ln5658">    if (p[0] == '\\' &amp;&amp; p[1] == '\\') {</a>
<a name="ln5659">      len += 2;</a>
<a name="ln5660">      p += 2;</a>
<a name="ln5661">    } else if (p[0] == '\\' &amp;&amp; ascii_iswhite(p[1])) {</a>
<a name="ln5662">      len += 1;</a>
<a name="ln5663">      p += 2;</a>
<a name="ln5664">    } else if (*p == '\\' || *p == '&quot;') {</a>
<a name="ln5665">      len += 2;</a>
<a name="ln5666">      p += 1;</a>
<a name="ln5667">    } else if (ascii_iswhite(*p)) {</a>
<a name="ln5668">      p = skipwhite(p);</a>
<a name="ln5669">      if (*p == NUL)</a>
<a name="ln5670">        break;</a>
<a name="ln5671">      len += 3;       /* &quot;,&quot; */</a>
<a name="ln5672">    } else {</a>
<a name="ln5673">      const int charlen = utfc_ptr2len(p);</a>
<a name="ln5674"> </a>
<a name="ln5675">      len += charlen;</a>
<a name="ln5676">      p += charlen;</a>
<a name="ln5677">    }</a>
<a name="ln5678">  }</a>
<a name="ln5679"> </a>
<a name="ln5680">  buf = xmalloc(len + 1);</a>
<a name="ln5681"> </a>
<a name="ln5682">  p = arg;</a>
<a name="ln5683">  q = buf;</a>
<a name="ln5684">  *q++ = '&quot;';</a>
<a name="ln5685">  while (*p) {</a>
<a name="ln5686">    if (p[0] == '\\' &amp;&amp; p[1] == '\\') {</a>
<a name="ln5687">      *q++ = '\\';</a>
<a name="ln5688">      *q++ = '\\';</a>
<a name="ln5689">      p += 2;</a>
<a name="ln5690">    } else if (p[0] == '\\' &amp;&amp; ascii_iswhite(p[1])) {</a>
<a name="ln5691">      *q++ = p[1];</a>
<a name="ln5692">      p += 2;</a>
<a name="ln5693">    } else if (*p == '\\' || *p == '&quot;') {</a>
<a name="ln5694">      *q++ = '\\';</a>
<a name="ln5695">      *q++ = *p++;</a>
<a name="ln5696">    } else if (ascii_iswhite(*p)) {</a>
<a name="ln5697">      p = skipwhite(p);</a>
<a name="ln5698">      if (*p == NUL)</a>
<a name="ln5699">        break;</a>
<a name="ln5700">      *q++ = '&quot;';</a>
<a name="ln5701">      *q++ = ',';</a>
<a name="ln5702">      *q++ = '&quot;';</a>
<a name="ln5703">    } else {</a>
<a name="ln5704">      MB_COPY_CHAR(p, q);</a>
<a name="ln5705">    }</a>
<a name="ln5706">  }</a>
<a name="ln5707">  *q++ = '&quot;';</a>
<a name="ln5708">  *q = 0;</a>
<a name="ln5709"> </a>
<a name="ln5710">  *lenp = len;</a>
<a name="ln5711">  return buf;</a>
<a name="ln5712">}</a>
<a name="ln5713"> </a>
<a name="ln5714">static size_t add_cmd_modifier(char_u *buf, char *mod_str, bool *multi_mods)</a>
<a name="ln5715">{</a>
<a name="ln5716">  size_t result = STRLEN(mod_str);</a>
<a name="ln5717">  if (*multi_mods) {</a>
<a name="ln5718">    result++;</a>
<a name="ln5719">  }</a>
<a name="ln5720"> </a>
<a name="ln5721">  if (buf != NULL) {</a>
<a name="ln5722">    if (*multi_mods) {</a>
<a name="ln5723">      STRCAT(buf, &quot; &quot;);</a>
<a name="ln5724">    }</a>
<a name="ln5725">    STRCAT(buf, mod_str);</a>
<a name="ln5726">  }</a>
<a name="ln5727"> </a>
<a name="ln5728">  *multi_mods = true;</a>
<a name="ln5729">  return result;</a>
<a name="ln5730">}</a>
<a name="ln5731"> </a>
<a name="ln5732">/*</a>
<a name="ln5733"> * Check for a &lt;&gt; code in a user command.</a>
<a name="ln5734"> * &quot;code&quot; points to the '&lt;'.  &quot;len&quot; the length of the &lt;&gt; (inclusive).</a>
<a name="ln5735"> * &quot;buf&quot; is where the result is to be added.</a>
<a name="ln5736"> * &quot;split_buf&quot; points to a buffer used for splitting, caller should free it.</a>
<a name="ln5737"> * &quot;split_len&quot; is the length of what &quot;split_buf&quot; contains.</a>
<a name="ln5738"> * Returns the length of the replacement, which has been added to &quot;buf&quot;.</a>
<a name="ln5739"> * Returns -1 if there was no match, and only the &quot;&lt;&quot; has been copied.</a>
<a name="ln5740"> */</a>
<a name="ln5741">static size_t</a>
<a name="ln5742">uc_check_code(</a>
<a name="ln5743">    char_u *code,</a>
<a name="ln5744">    size_t len,</a>
<a name="ln5745">    char_u *buf,</a>
<a name="ln5746">    ucmd_T *cmd,               /* the user command we're expanding */</a>
<a name="ln5747">    exarg_T *eap,               /* ex arguments */</a>
<a name="ln5748">    char_u **split_buf,</a>
<a name="ln5749">    size_t *split_len</a>
<a name="ln5750">)</a>
<a name="ln5751">{</a>
<a name="ln5752">  size_t result = 0;</a>
<a name="ln5753">  char_u      *p = code + 1;</a>
<a name="ln5754">  size_t l = len - 2;</a>
<a name="ln5755">  int quote = 0;</a>
<a name="ln5756">  enum {</a>
<a name="ln5757">    ct_ARGS,</a>
<a name="ln5758">    ct_BANG,</a>
<a name="ln5759">    ct_COUNT,</a>
<a name="ln5760">    ct_LINE1,</a>
<a name="ln5761">    ct_LINE2,</a>
<a name="ln5762">    ct_RANGE,</a>
<a name="ln5763">    ct_MODS,</a>
<a name="ln5764">    ct_REGISTER,</a>
<a name="ln5765">    ct_LT,</a>
<a name="ln5766">    ct_NONE</a>
<a name="ln5767">  } type = ct_NONE;</a>
<a name="ln5768"> </a>
<a name="ln5769">  if ((vim_strchr((char_u *)&quot;qQfF&quot;, *p) != NULL) &amp;&amp; p[1] == '-') {</a>
<a name="ln5770">    quote = (*p == 'q' || *p == 'Q') ? 1 : 2;</a>
<a name="ln5771">    p += 2;</a>
<a name="ln5772">    l -= 2;</a>
<a name="ln5773">  }</a>
<a name="ln5774"> </a>
<a name="ln5775">  l++;</a>
<a name="ln5776">  if (l &lt;= 1) {</a>
<a name="ln5777">    type = ct_NONE;</a>
<a name="ln5778">  } else if (STRNICMP(p, &quot;args&gt;&quot;, l) == 0) {</a>
<a name="ln5779">    type = ct_ARGS;</a>
<a name="ln5780">  } else if (STRNICMP(p, &quot;bang&gt;&quot;, l) == 0) {</a>
<a name="ln5781">    type = ct_BANG;</a>
<a name="ln5782">  } else if (STRNICMP(p, &quot;count&gt;&quot;, l) == 0) {</a>
<a name="ln5783">    type = ct_COUNT;</a>
<a name="ln5784">  } else if (STRNICMP(p, &quot;line1&gt;&quot;, l) == 0) {</a>
<a name="ln5785">    type = ct_LINE1;</a>
<a name="ln5786">  } else if (STRNICMP(p, &quot;line2&gt;&quot;, l) == 0) {</a>
<a name="ln5787">    type = ct_LINE2;</a>
<a name="ln5788">  } else if (STRNICMP(p, &quot;range&gt;&quot;, l) == 0) {</a>
<a name="ln5789">    type = ct_RANGE;</a>
<a name="ln5790">  } else if (STRNICMP(p, &quot;lt&gt;&quot;, l) == 0) {</a>
<a name="ln5791">    type = ct_LT;</a>
<a name="ln5792">  } else if (STRNICMP(p, &quot;reg&gt;&quot;, l) == 0 || STRNICMP(p, &quot;register&gt;&quot;, l) == 0) {</a>
<a name="ln5793">    type = ct_REGISTER;</a>
<a name="ln5794">  } else if (STRNICMP(p, &quot;mods&gt;&quot;, l) == 0) {</a>
<a name="ln5795">    type = ct_MODS;</a>
<a name="ln5796">  }</a>
<a name="ln5797"> </a>
<a name="ln5798">  switch (type) {</a>
<a name="ln5799">  case ct_ARGS:</a>
<a name="ln5800">    /* Simple case first */</a>
<a name="ln5801">    if (*eap-&gt;arg == NUL) {</a>
<a name="ln5802">      if (quote == 1) {</a>
<a name="ln5803">        result = 2;</a>
<a name="ln5804">        if (buf != NULL)</a>
<a name="ln5805">          STRCPY(buf, &quot;''&quot;);</a>
<a name="ln5806">      } else</a>
<a name="ln5807">        result = 0;</a>
<a name="ln5808">      break;</a>
<a name="ln5809">    }</a>
<a name="ln5810"> </a>
<a name="ln5811">    /* When specified there is a single argument don't split it.</a>
<a name="ln5812">     * Works for &quot;:Cmd %&quot; when % is &quot;a b c&quot;. */</a>
<a name="ln5813">    if ((eap-&gt;argt &amp; EX_NOSPC) &amp;&amp; quote == 2) {</a>
<a name="ln5814">      quote = 1;</a>
<a name="ln5815">    }</a>
<a name="ln5816"> </a>
<a name="ln5817">    switch (quote) {</a>
<a name="ln5818">    case 0:     /* No quoting, no splitting */</a>
<a name="ln5819">      result = STRLEN(eap-&gt;arg);</a>
<a name="ln5820">      if (buf != NULL)</a>
<a name="ln5821">        STRCPY(buf, eap-&gt;arg);</a>
<a name="ln5822">      break;</a>
<a name="ln5823">    case 1:     /* Quote, but don't split */</a>
<a name="ln5824">      result = STRLEN(eap-&gt;arg) + 2;</a>
<a name="ln5825">      for (p = eap-&gt;arg; *p; p++) {</a>
<a name="ln5826">        if (*p == '\\' || *p == '&quot;') {</a>
<a name="ln5827">          result++;</a>
<a name="ln5828">        }</a>
<a name="ln5829">      }</a>
<a name="ln5830"> </a>
<a name="ln5831">      if (buf != NULL) {</a>
<a name="ln5832">        *buf++ = '&quot;';</a>
<a name="ln5833">        for (p = eap-&gt;arg; *p; p++) {</a>
<a name="ln5834">          if (*p == '\\' || *p == '&quot;') {</a>
<a name="ln5835">            *buf++ = '\\';</a>
<a name="ln5836">          }</a>
<a name="ln5837">          *buf++ = *p;</a>
<a name="ln5838">        }</a>
<a name="ln5839">        *buf = '&quot;';</a>
<a name="ln5840">      }</a>
<a name="ln5841"> </a>
<a name="ln5842">      break;</a>
<a name="ln5843">    case 2:     /* Quote and split (&lt;f-args&gt;) */</a>
<a name="ln5844">      /* This is hard, so only do it once, and cache the result */</a>
<a name="ln5845">      if (*split_buf == NULL)</a>
<a name="ln5846">        *split_buf = uc_split_args(eap-&gt;arg, split_len);</a>
<a name="ln5847"> </a>
<a name="ln5848">      result = *split_len;</a>
<a name="ln5849">      if (buf != NULL &amp;&amp; result != 0)</a>
<a name="ln5850">        STRCPY(buf, *split_buf);</a>
<a name="ln5851"> </a>
<a name="ln5852">      break;</a>
<a name="ln5853">    }</a>
<a name="ln5854">    break;</a>
<a name="ln5855"> </a>
<a name="ln5856">  case ct_BANG:</a>
<a name="ln5857">    result = eap-&gt;forceit ? 1 : 0;</a>
<a name="ln5858">    if (quote)</a>
<a name="ln5859">      result += 2;</a>
<a name="ln5860">    if (buf != NULL) {</a>
<a name="ln5861">      if (quote)</a>
<a name="ln5862">        *buf++ = '&quot;';</a>
<a name="ln5863">      if (eap-&gt;forceit)</a>
<a name="ln5864">        *buf++ = '!';</a>
<a name="ln5865">      if (quote)</a>
<a name="ln5866">        *buf = '&quot;';</a>
<a name="ln5867">    }</a>
<a name="ln5868">    break;</a>
<a name="ln5869"> </a>
<a name="ln5870">  case ct_LINE1:</a>
<a name="ln5871">  case ct_LINE2:</a>
<a name="ln5872">  case ct_RANGE:</a>
<a name="ln5873">  case ct_COUNT:</a>
<a name="ln5874">  {</a>
<a name="ln5875">    char num_buf[20];</a>
<a name="ln5876">    long num = (type == ct_LINE1) ? eap-&gt;line1 :</a>
<a name="ln5877">               (type == ct_LINE2) ? eap-&gt;line2 :</a>
<a name="ln5878">               (type == ct_RANGE) ? eap-&gt;addr_count :</a>
<a name="ln5879">               (eap-&gt;addr_count &gt; 0) ? eap-&gt;line2 : cmd-&gt;uc_def;</a>
<a name="ln5880">    size_t num_len;</a>
<a name="ln5881"> </a>
<a name="ln5882">    sprintf(num_buf, &quot;%&quot; PRId64, (int64_t)num);</a>
<a name="ln5883">    num_len = STRLEN(num_buf);</a>
<a name="ln5884">    result = num_len;</a>
<a name="ln5885"> </a>
<a name="ln5886">    if (quote)</a>
<a name="ln5887">      result += 2;</a>
<a name="ln5888"> </a>
<a name="ln5889">    if (buf != NULL) {</a>
<a name="ln5890">      if (quote)</a>
<a name="ln5891">        *buf++ = '&quot;';</a>
<a name="ln5892">      STRCPY(buf, num_buf);</a>
<a name="ln5893">      buf += num_len;</a>
<a name="ln5894">      if (quote)</a>
<a name="ln5895">        *buf = '&quot;';</a>
<a name="ln5896">    }</a>
<a name="ln5897"> </a>
<a name="ln5898">    break;</a>
<a name="ln5899">  }</a>
<a name="ln5900"> </a>
<a name="ln5901">  case ct_MODS:</a>
<a name="ln5902">  {</a>
<a name="ln5903">    result = quote ? 2 : 0;</a>
<a name="ln5904">    if (buf != NULL) {</a>
<a name="ln5905">      if (quote) {</a>
<a name="ln5906">        *buf++ = '&quot;';</a>
<a name="ln5907">      }</a>
<a name="ln5908">      *buf = '\0';</a>
<a name="ln5909">    }</a>
<a name="ln5910"> </a>
<a name="ln5911">    bool multi_mods = false;</a>
<a name="ln5912"> </a>
<a name="ln5913">    // :aboveleft and :leftabove</a>
<a name="ln5914">    if (cmdmod.split &amp; WSP_ABOVE) {</a>
<a name="ln5915">      result += add_cmd_modifier(buf, &quot;aboveleft&quot;, &amp;multi_mods);</a>
<a name="ln5916">    }</a>
<a name="ln5917">    // :belowright and :rightbelow</a>
<a name="ln5918">    if (cmdmod.split &amp; WSP_BELOW) {</a>
<a name="ln5919">      result += add_cmd_modifier(buf, &quot;belowright&quot;, &amp;multi_mods);</a>
<a name="ln5920">    }</a>
<a name="ln5921">    // :botright</a>
<a name="ln5922">    if (cmdmod.split &amp; WSP_BOT) {</a>
<a name="ln5923">      result += add_cmd_modifier(buf, &quot;botright&quot;, &amp;multi_mods);</a>
<a name="ln5924">    }</a>
<a name="ln5925"> </a>
<a name="ln5926">    typedef struct {</a>
<a name="ln5927">      bool *set;</a>
<a name="ln5928">      char *name;</a>
<a name="ln5929">    } mod_entry_T;</a>
<a name="ln5930">    static mod_entry_T mod_entries[] = {</a>
<a name="ln5931">      { &amp;cmdmod.browse, &quot;browse&quot; },</a>
<a name="ln5932">      { &amp;cmdmod.confirm, &quot;confirm&quot; },</a>
<a name="ln5933">      { &amp;cmdmod.hide, &quot;hide&quot; },</a>
<a name="ln5934">      { &amp;cmdmod.keepalt, &quot;keepalt&quot; },</a>
<a name="ln5935">      { &amp;cmdmod.keepjumps, &quot;keepjumps&quot; },</a>
<a name="ln5936">      { &amp;cmdmod.keepmarks, &quot;keepmarks&quot; },</a>
<a name="ln5937">      { &amp;cmdmod.keeppatterns, &quot;keeppatterns&quot; },</a>
<a name="ln5938">      { &amp;cmdmod.lockmarks, &quot;lockmarks&quot; },</a>
<a name="ln5939">      { &amp;cmdmod.noswapfile, &quot;noswapfile&quot; }</a>
<a name="ln5940">    };</a>
<a name="ln5941">    // the modifiers that are simple flags</a>
<a name="ln5942">    for (size_t i = 0; i &lt; ARRAY_SIZE(mod_entries); i++) {</a>
<a name="ln5943">      if (*mod_entries[i].set) {</a>
<a name="ln5944">        result += add_cmd_modifier(buf, mod_entries[i].name, &amp;multi_mods);</a>
<a name="ln5945">      }</a>
<a name="ln5946">    }</a>
<a name="ln5947"> </a>
<a name="ln5948">    // TODO(vim): How to support :noautocmd?</a>
<a name="ln5949">    // TODO(vim): How to support :sandbox?</a>
<a name="ln5950"> </a>
<a name="ln5951">    // :silent</a>
<a name="ln5952">    if (msg_silent &gt; 0) {</a>
<a name="ln5953">      result += add_cmd_modifier(buf, emsg_silent &gt; 0 ? &quot;silent!&quot; : &quot;silent&quot;,</a>
<a name="ln5954">                                 &amp;multi_mods);</a>
<a name="ln5955">    }</a>
<a name="ln5956">    // :tab</a>
<a name="ln5957">    if (cmdmod.tab &gt; 0) {</a>
<a name="ln5958">      result += add_cmd_modifier(buf, &quot;tab&quot;, &amp;multi_mods);</a>
<a name="ln5959">    }</a>
<a name="ln5960">    // :topleft</a>
<a name="ln5961">    if (cmdmod.split &amp; WSP_TOP) {</a>
<a name="ln5962">      result += add_cmd_modifier(buf, &quot;topleft&quot;, &amp;multi_mods);</a>
<a name="ln5963">    }</a>
<a name="ln5964"> </a>
<a name="ln5965">    // TODO(vim): How to support :unsilent?</a>
<a name="ln5966"> </a>
<a name="ln5967">    // :verbose</a>
<a name="ln5968">    if (p_verbose &gt; 0) {</a>
<a name="ln5969">      result += add_cmd_modifier(buf, &quot;verbose&quot;, &amp;multi_mods);</a>
<a name="ln5970">    }</a>
<a name="ln5971">    // :vertical</a>
<a name="ln5972">    if (cmdmod.split &amp; WSP_VERT) {</a>
<a name="ln5973">      result += add_cmd_modifier(buf, &quot;vertical&quot;, &amp;multi_mods);</a>
<a name="ln5974">    }</a>
<a name="ln5975">    if (quote &amp;&amp; buf != NULL) {</a>
<a name="ln5976">      buf += result - 2;</a>
<a name="ln5977">      *buf = '&quot;';</a>
<a name="ln5978">    }</a>
<a name="ln5979">    break;</a>
<a name="ln5980">  }</a>
<a name="ln5981"> </a>
<a name="ln5982">  case ct_REGISTER:</a>
<a name="ln5983">    result = eap-&gt;regname ? 1 : 0;</a>
<a name="ln5984">    if (quote)</a>
<a name="ln5985">      result += 2;</a>
<a name="ln5986">    if (buf != NULL) {</a>
<a name="ln5987">      if (quote)</a>
<a name="ln5988">        *buf++ = '\'';</a>
<a name="ln5989">      if (eap-&gt;regname)</a>
<a name="ln5990">        *buf++ = eap-&gt;regname;</a>
<a name="ln5991">      if (quote)</a>
<a name="ln5992">        *buf = '\'';</a>
<a name="ln5993">    }</a>
<a name="ln5994">    break;</a>
<a name="ln5995"> </a>
<a name="ln5996">  case ct_LT:</a>
<a name="ln5997">    result = 1;</a>
<a name="ln5998">    if (buf != NULL)</a>
<a name="ln5999">      *buf = '&lt;';</a>
<a name="ln6000">    break;</a>
<a name="ln6001"> </a>
<a name="ln6002">  default:</a>
<a name="ln6003">    /* Not recognized: just copy the '&lt;' and return -1. */</a>
<a name="ln6004">    result = (size_t)-1;</a>
<a name="ln6005">    if (buf != NULL)</a>
<a name="ln6006">      *buf = '&lt;';</a>
<a name="ln6007">    break;</a>
<a name="ln6008">  }</a>
<a name="ln6009"> </a>
<a name="ln6010">  return result;</a>
<a name="ln6011">}</a>
<a name="ln6012"> </a>
<a name="ln6013">static void do_ucmd(exarg_T *eap)</a>
<a name="ln6014">{</a>
<a name="ln6015">  char_u      *buf;</a>
<a name="ln6016">  char_u      *p;</a>
<a name="ln6017">  char_u      *q;</a>
<a name="ln6018"> </a>
<a name="ln6019">  char_u      *start;</a>
<a name="ln6020">  char_u      *end = NULL;</a>
<a name="ln6021">  char_u      *ksp;</a>
<a name="ln6022">  size_t len, totlen;</a>
<a name="ln6023"> </a>
<a name="ln6024">  size_t split_len = 0;</a>
<a name="ln6025">  char_u      *split_buf = NULL;</a>
<a name="ln6026">  ucmd_T      *cmd;</a>
<a name="ln6027">  const sctx_T save_current_sctx = current_sctx;</a>
<a name="ln6028"> </a>
<a name="ln6029">  if (eap-&gt;cmdidx == CMD_USER)</a>
<a name="ln6030">    cmd = USER_CMD(eap-&gt;useridx);</a>
<a name="ln6031">  else</a>
<a name="ln6032">    cmd = USER_CMD_GA(&amp;curbuf-&gt;b_ucmds, eap-&gt;useridx);</a>
<a name="ln6033"> </a>
<a name="ln6034">  /*</a>
<a name="ln6035">   * Replace &lt;&gt; in the command by the arguments.</a>
<a name="ln6036">   * First round: &quot;buf&quot; is NULL, compute length, allocate &quot;buf&quot;.</a>
<a name="ln6037">   * Second round: copy result into &quot;buf&quot;.</a>
<a name="ln6038">   */</a>
<a name="ln6039">  buf = NULL;</a>
<a name="ln6040">  for (;; ) {</a>
<a name="ln6041">    p = cmd-&gt;uc_rep;        /* source */</a>
<a name="ln6042">    q = buf;                /* destination */</a>
<a name="ln6043">    totlen = 0;</a>
<a name="ln6044"> </a>
<a name="ln6045">    for (;; ) {</a>
<a name="ln6046">      start = vim_strchr(p, '&lt;');</a>
<a name="ln6047">      if (start != NULL)</a>
<a name="ln6048">        end = vim_strchr(start + 1, '&gt;');</a>
<a name="ln6049">      if (buf != NULL) {</a>
<a name="ln6050">        for (ksp = p; *ksp != NUL &amp;&amp; *ksp != K_SPECIAL; ksp++) {</a>
<a name="ln6051">        }</a>
<a name="ln6052">        if (*ksp == K_SPECIAL</a>
<a name="ln6053">            &amp;&amp; (start == NULL || ksp &lt; start || end == NULL)</a>
<a name="ln6054">            &amp;&amp; (ksp[1] == KS_SPECIAL &amp;&amp; ksp[2] == KE_FILLER)) {</a>
<a name="ln6055">          // K_SPECIAL has been put in the buffer as K_SPECIAL</a>
<a name="ln6056">          // KS_SPECIAL KE_FILLER, like for mappings, but</a>
<a name="ln6057">          // do_cmdline() doesn't handle that, so convert it back.</a>
<a name="ln6058">          // Also change K_SPECIAL KS_EXTRA KE_CSI into CSI.</a>
<a name="ln6059">          len = ksp - p;</a>
<a name="ln6060">          if (len &gt; 0) {</a>
<a name="ln6061">            memmove(q, p, len);</a>
<a name="ln6062">            q += len;</a>
<a name="ln6063">          }</a>
<a name="ln6064">          *q++ = K_SPECIAL;</a>
<a name="ln6065">          p = ksp + 3;</a>
<a name="ln6066">          continue;</a>
<a name="ln6067">        }</a>
<a name="ln6068">      }</a>
<a name="ln6069"> </a>
<a name="ln6070">      /* break if there no &lt;item&gt; is found */</a>
<a name="ln6071">      if (start == NULL || end == NULL)</a>
<a name="ln6072">        break;</a>
<a name="ln6073"> </a>
<a name="ln6074">      /* Include the '&gt;' */</a>
<a name="ln6075">      ++end;</a>
<a name="ln6076"> </a>
<a name="ln6077">      /* Take everything up to the '&lt;' */</a>
<a name="ln6078">      len = start - p;</a>
<a name="ln6079">      if (buf == NULL)</a>
<a name="ln6080">        totlen += len;</a>
<a name="ln6081">      else {</a>
<a name="ln6082">        memmove(q, p, len);</a>
<a name="ln6083">        q += len;</a>
<a name="ln6084">      }</a>
<a name="ln6085"> </a>
<a name="ln6086">      len = uc_check_code(start, end - start, q, cmd, eap,</a>
<a name="ln6087">          &amp;split_buf, &amp;split_len);</a>
<a name="ln6088">      if (len == (size_t)-1) {</a>
<a name="ln6089">        /* no match, continue after '&lt;' */</a>
<a name="ln6090">        p = start + 1;</a>
<a name="ln6091">        len = 1;</a>
<a name="ln6092">      } else</a>
<a name="ln6093">        p = end;</a>
<a name="ln6094">      if (buf == NULL)</a>
<a name="ln6095">        totlen += len;</a>
<a name="ln6096">      else</a>
<a name="ln6097">        q += len;</a>
<a name="ln6098">    }</a>
<a name="ln6099">    if (buf != NULL) {              /* second time here, finished */</a>
<a name="ln6100">      STRCPY(q, p);</a>
<a name="ln6101">      break;</a>
<a name="ln6102">    }</a>
<a name="ln6103"> </a>
<a name="ln6104">    totlen += STRLEN(p);            /* Add on the trailing characters */</a>
<a name="ln6105">    buf = xmalloc(totlen + 1);</a>
<a name="ln6106">  }</a>
<a name="ln6107"> </a>
<a name="ln6108">  current_sctx.sc_sid = cmd-&gt;uc_script_ctx.sc_sid;</a>
<a name="ln6109">  (void)do_cmdline(buf, eap-&gt;getline, eap-&gt;cookie,</a>
<a name="ln6110">                   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);</a>
<a name="ln6111">  current_sctx = save_current_sctx;</a>
<a name="ln6112">  xfree(buf);</a>
<a name="ln6113">  xfree(split_buf);</a>
<a name="ln6114">}</a>
<a name="ln6115"> </a>
<a name="ln6116">static char_u *get_user_command_name(int idx)</a>
<a name="ln6117">{</a>
<a name="ln6118">  return get_user_commands(NULL, idx - (int)CMD_SIZE);</a>
<a name="ln6119">}</a>
<a name="ln6120">/*</a>
<a name="ln6121"> * Function given to ExpandGeneric() to obtain the list of user address type names.</a>
<a name="ln6122"> */</a>
<a name="ln6123">char_u *get_user_cmd_addr_type(expand_T *xp, int idx)</a>
<a name="ln6124">{</a>
<a name="ln6125">  return (char_u *)addr_type_complete[idx].name;</a>
<a name="ln6126">}</a>
<a name="ln6127"> </a>
<a name="ln6128">/*</a>
<a name="ln6129"> * Function given to ExpandGeneric() to obtain the list of user command names.</a>
<a name="ln6130"> */</a>
<a name="ln6131">char_u *get_user_commands(expand_T *xp FUNC_ATTR_UNUSED, int idx)</a>
<a name="ln6132">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6133">{</a>
<a name="ln6134">  // In cmdwin, the alternative buffer should be used.</a>
<a name="ln6135">  const buf_T *const buf = (cmdwin_type != 0 &amp;&amp; get_cmdline_type() == NUL)</a>
<a name="ln6136">    ? prevwin-&gt;w_buffer</a>
<a name="ln6137">    : curbuf;</a>
<a name="ln6138"> </a>
<a name="ln6139">  if (idx &lt; buf-&gt;b_ucmds.ga_len) {</a>
<a name="ln6140">    return USER_CMD_GA(&amp;buf-&gt;b_ucmds, idx)-&gt;uc_name;</a>
<a name="ln6141">  }</a>
<a name="ln6142">  idx -= buf-&gt;b_ucmds.ga_len;</a>
<a name="ln6143">  if (idx &lt; ucmds.ga_len) {</a>
<a name="ln6144">    return USER_CMD(idx)-&gt;uc_name;</a>
<a name="ln6145">  }</a>
<a name="ln6146">  return NULL;</a>
<a name="ln6147">}</a>
<a name="ln6148"> </a>
<a name="ln6149">/*</a>
<a name="ln6150"> * Function given to ExpandGeneric() to obtain the list of user command</a>
<a name="ln6151"> * attributes.</a>
<a name="ln6152"> */</a>
<a name="ln6153">char_u *get_user_cmd_flags(expand_T *xp, int idx)</a>
<a name="ln6154">{</a>
<a name="ln6155">  static char *user_cmd_flags[] = {&quot;addr&quot;,   &quot;bang&quot;,     &quot;bar&quot;,</a>
<a name="ln6156">                                   &quot;buffer&quot;, &quot;complete&quot;, &quot;count&quot;,</a>
<a name="ln6157">                                   &quot;nargs&quot;,  &quot;range&quot;,    &quot;register&quot;};</a>
<a name="ln6158"> </a>
<a name="ln6159">  if (idx &gt;= (int)ARRAY_SIZE(user_cmd_flags))</a>
<a name="ln6160">    return NULL;</a>
<a name="ln6161">  return (char_u *)user_cmd_flags[idx];</a>
<a name="ln6162">}</a>
<a name="ln6163"> </a>
<a name="ln6164">/*</a>
<a name="ln6165"> * Function given to ExpandGeneric() to obtain the list of values for -nargs.</a>
<a name="ln6166"> */</a>
<a name="ln6167">char_u *get_user_cmd_nargs(expand_T *xp, int idx)</a>
<a name="ln6168">{</a>
<a name="ln6169">  static char *user_cmd_nargs[] = {&quot;0&quot;, &quot;1&quot;, &quot;*&quot;, &quot;?&quot;, &quot;+&quot;};</a>
<a name="ln6170"> </a>
<a name="ln6171">  if (idx &gt;= (int)ARRAY_SIZE(user_cmd_nargs))</a>
<a name="ln6172">    return NULL;</a>
<a name="ln6173">  return (char_u *)user_cmd_nargs[idx];</a>
<a name="ln6174">}</a>
<a name="ln6175"> </a>
<a name="ln6176">/*</a>
<a name="ln6177"> * Function given to ExpandGeneric() to obtain the list of values for -complete.</a>
<a name="ln6178"> */</a>
<a name="ln6179">char_u *get_user_cmd_complete(expand_T *xp, int idx)</a>
<a name="ln6180">{</a>
<a name="ln6181">  if (idx &gt;= (int)ARRAY_SIZE(command_complete)) {</a>
<a name="ln6182">    return NULL;</a>
<a name="ln6183">  }</a>
<a name="ln6184">  char *cmd_compl = get_command_complete(idx);</a>
<a name="ln6185">  if (cmd_compl == NULL) {</a>
<a name="ln6186">    return (char_u *)&quot;&quot;;</a>
<a name="ln6187">  } else {</a>
<a name="ln6188">    return (char_u *)cmd_compl;</a>
<a name="ln6189">  }</a>
<a name="ln6190">}</a>
<a name="ln6191"> </a>
<a name="ln6192">/*</a>
<a name="ln6193"> * Parse address type argument</a>
<a name="ln6194"> */</a>
<a name="ln6195">int parse_addr_type_arg(char_u *value, int vallen, cmd_addr_T *addr_type_arg)</a>
<a name="ln6196">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6197">{</a>
<a name="ln6198">  int i, a, b;</a>
<a name="ln6199"> </a>
<a name="ln6200">  for (i = 0; addr_type_complete[i].expand != ADDR_NONE; i++) {</a>
<a name="ln6201">    a = (int)STRLEN(addr_type_complete[i].name) == vallen;</a>
<a name="ln6202">    b = STRNCMP(value, addr_type_complete[i].name, vallen) == 0;</a>
<a name="ln6203">    if (a &amp;&amp; b) {</a>
<a name="ln6204">      *addr_type_arg = addr_type_complete[i].expand;</a>
<a name="ln6205">      break;</a>
<a name="ln6206">    }</a>
<a name="ln6207">  }</a>
<a name="ln6208"> </a>
<a name="ln6209">  if (addr_type_complete[i].expand == ADDR_NONE) {</a>
<a name="ln6210">    char_u *err = value;</a>
<a name="ln6211"> </a>
<a name="ln6212">    for (i = 0; err[i] != NUL &amp;&amp; !ascii_iswhite(err[i]); i++) {}</a>
<a name="ln6213">    err[i] = NUL;</a>
<a name="ln6214">    EMSG2(_(&quot;E180: Invalid address type value: %s&quot;), err);</a>
<a name="ln6215">    return FAIL;</a>
<a name="ln6216">  }</a>
<a name="ln6217"> </a>
<a name="ln6218">  return OK;</a>
<a name="ln6219">}</a>
<a name="ln6220"> </a>
<a name="ln6221">/*</a>
<a name="ln6222"> * Parse a completion argument &quot;value[vallen]&quot;.</a>
<a name="ln6223"> * The detected completion goes in &quot;*complp&quot;, argument type in &quot;*argt&quot;.</a>
<a name="ln6224"> * When there is an argument, for function and user defined completion, it's</a>
<a name="ln6225"> * copied to allocated memory and stored in &quot;*compl_arg&quot;.</a>
<a name="ln6226"> * Returns FAIL if something is wrong.</a>
<a name="ln6227"> */</a>
<a name="ln6228">int parse_compl_arg(const char_u *value, int vallen, int *complp,</a>
<a name="ln6229">                    uint32_t *argt, char_u **compl_arg)</a>
<a name="ln6230">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6231">{</a>
<a name="ln6232">  const char_u *arg = NULL;</a>
<a name="ln6233">  size_t arglen = 0;</a>
<a name="ln6234">  int i;</a>
<a name="ln6235">  int valend = vallen;</a>
<a name="ln6236"> </a>
<a name="ln6237">  /* Look for any argument part - which is the part after any ',' */</a>
<a name="ln6238">  for (i = 0; i &lt; vallen; ++i) {</a>
<a name="ln6239">    if (value[i] == ',') {</a>
<a name="ln6240">      arg = &amp;value[i + 1];</a>
<a name="ln6241">      arglen = vallen - i - 1;</a>
<a name="ln6242">      valend = i;</a>
<a name="ln6243">      break;</a>
<a name="ln6244">    }</a>
<a name="ln6245">  }</a>
<a name="ln6246"> </a>
<a name="ln6247">  for (i = 0; i &lt; (int)ARRAY_SIZE(command_complete); i++) {</a>
<a name="ln6248">    if (get_command_complete(i) == NULL) {</a>
<a name="ln6249">      continue;</a>
<a name="ln6250">    }</a>
<a name="ln6251">    if ((int)STRLEN(command_complete[i]) == valend</a>
<a name="ln6252">        &amp;&amp; STRNCMP(value, command_complete[i], valend) == 0) {</a>
<a name="ln6253">      *complp = i;</a>
<a name="ln6254">      if (i == EXPAND_BUFFERS) {</a>
<a name="ln6255">        *argt |= EX_BUFNAME;</a>
<a name="ln6256">      } else if (i == EXPAND_DIRECTORIES || i == EXPAND_FILES) {</a>
<a name="ln6257">        *argt |= EX_XFILE;</a>
<a name="ln6258">      }</a>
<a name="ln6259">      break;</a>
<a name="ln6260">    }</a>
<a name="ln6261">  }</a>
<a name="ln6262"> </a>
<a name="ln6263">  if (i == (int)ARRAY_SIZE(command_complete)) {</a>
<a name="ln6264">    EMSG2(_(&quot;E180: Invalid complete value: %s&quot;), value);</a>
<a name="ln6265">    return FAIL;</a>
<a name="ln6266">  }</a>
<a name="ln6267"> </a>
<a name="ln6268">  if (*complp != EXPAND_USER_DEFINED &amp;&amp; *complp != EXPAND_USER_LIST</a>
<a name="ln6269">      &amp;&amp; arg != NULL) {</a>
<a name="ln6270">    EMSG(_(&quot;E468: Completion argument only allowed for custom completion&quot;));</a>
<a name="ln6271">    return FAIL;</a>
<a name="ln6272">  }</a>
<a name="ln6273"> </a>
<a name="ln6274">  if ((*complp == EXPAND_USER_DEFINED || *complp == EXPAND_USER_LIST)</a>
<a name="ln6275">      &amp;&amp; arg == NULL) {</a>
<a name="ln6276">    EMSG(_(&quot;E467: Custom completion requires a function argument&quot;));</a>
<a name="ln6277">    return FAIL;</a>
<a name="ln6278">  }</a>
<a name="ln6279"> </a>
<a name="ln6280">  if (arg != NULL) {</a>
<a name="ln6281">    *compl_arg = vim_strnsave(arg, arglen);</a>
<a name="ln6282">  }</a>
<a name="ln6283">  return OK;</a>
<a name="ln6284">}</a>
<a name="ln6285"> </a>
<a name="ln6286">int cmdcomplete_str_to_type(const char *complete_str)</a>
<a name="ln6287">{</a>
<a name="ln6288">    for (int i = 0; i &lt; (int)(ARRAY_SIZE(command_complete)); i++) {</a>
<a name="ln6289">      char *cmd_compl = get_command_complete(i);</a>
<a name="ln6290">      if (cmd_compl == NULL) {</a>
<a name="ln6291">        continue;</a>
<a name="ln6292">      }</a>
<a name="ln6293">      if (strcmp(complete_str, command_complete[i]) == 0) {</a>
<a name="ln6294">        return i;</a>
<a name="ln6295">      }</a>
<a name="ln6296">    }</a>
<a name="ln6297"> </a>
<a name="ln6298">    return EXPAND_NOTHING;</a>
<a name="ln6299">}</a>
<a name="ln6300"> </a>
<a name="ln6301">static void ex_colorscheme(exarg_T *eap)</a>
<a name="ln6302">{</a>
<a name="ln6303">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln6304">    char_u *expr = vim_strsave((char_u *)&quot;g:colors_name&quot;);</a>
<a name="ln6305">    char_u *p = NULL;</a>
<a name="ln6306"> </a>
<a name="ln6307">    ++emsg_off;</a>
<a name="ln6308">    p = eval_to_string(expr, NULL, FALSE);</a>
<a name="ln6309">    --emsg_off;</a>
<a name="ln6310">    xfree(expr);</a>
<a name="ln6311"> </a>
<a name="ln6312">    if (p != NULL) {</a>
<a name="ln6313">      MSG(p);</a>
<a name="ln6314">      xfree(p);</a>
<a name="ln6315">    } else</a>
<a name="ln6316">      MSG(&quot;default&quot;);</a>
<a name="ln6317">  } else if (load_colors(eap-&gt;arg) == FAIL)</a>
<a name="ln6318">    EMSG2(_(&quot;E185: Cannot find color scheme '%s'&quot;), eap-&gt;arg);</a>
<a name="ln6319">}</a>
<a name="ln6320"> </a>
<a name="ln6321">static void ex_highlight(exarg_T *eap)</a>
<a name="ln6322">{</a>
<a name="ln6323">  if (*eap-&gt;arg == NUL &amp;&amp; eap-&gt;cmd[2] == '!') {</a>
<a name="ln6324">    MSG(_(&quot;Greetings, Vim user!&quot;));</a>
<a name="ln6325">  }</a>
<a name="ln6326">  do_highlight((const char *)eap-&gt;arg, eap-&gt;forceit, false);</a>
<a name="ln6327">}</a>
<a name="ln6328"> </a>
<a name="ln6329"> </a>
<a name="ln6330">/*</a>
<a name="ln6331"> * Call this function if we thought we were going to exit, but we won't</a>
<a name="ln6332"> * (because of an error).  May need to restore the terminal mode.</a>
<a name="ln6333"> */</a>
<a name="ln6334">void not_exiting(void)</a>
<a name="ln6335">{</a>
<a name="ln6336">  exiting = false;</a>
<a name="ln6337">}</a>
<a name="ln6338"> </a>
<a name="ln6339">static bool before_quit_autocmds(win_T *wp, bool quit_all, int forceit)</a>
<a name="ln6340">{</a>
<a name="ln6341">  apply_autocmds(EVENT_QUITPRE, NULL, NULL, false, wp-&gt;w_buffer);</a>
<a name="ln6342"> </a>
<a name="ln6343">  // Bail out when autocommands closed the window.</a>
<a name="ln6344">  // Refuse to quit when the buffer in the last window is being closed (can</a>
<a name="ln6345">  // only happen in autocommands).</a>
<a name="ln6346">  if (!win_valid(wp)</a>
<a name="ln6347">      || curbuf_locked()</a>
<a name="ln6348">      || (wp-&gt;w_buffer-&gt;b_nwindows == 1 &amp;&amp; wp-&gt;w_buffer-&gt;b_locked &gt; 0)) {</a>
<a name="ln6349">    return true;</a>
<a name="ln6350">  }</a>
<a name="ln6351"> </a>
<a name="ln6352">  if (quit_all</a>
<a name="ln6353">      || (check_more(false, forceit) == OK &amp;&amp; only_one_window())) {</a>
<a name="ln6354">    apply_autocmds(EVENT_EXITPRE, NULL, NULL, false, curbuf);</a>
<a name="ln6355">    // Refuse to quit when locked or when the window was closed or the</a>
<a name="ln6356">    // buffer in the last window is being closed (can only happen in</a>
<a name="ln6357">    // autocommands).</a>
<a name="ln6358">    if (!win_valid(wp)</a>
<a name="ln6359">        || curbuf_locked()</a>
<a name="ln6360">        || (curbuf-&gt;b_nwindows == 1 &amp;&amp; curbuf-&gt;b_locked &gt; 0)) {</a>
<a name="ln6361">      return true;</a>
<a name="ln6362">    }</a>
<a name="ln6363">  }</a>
<a name="ln6364"> </a>
<a name="ln6365">  return false;</a>
<a name="ln6366">}</a>
<a name="ln6367"> </a>
<a name="ln6368">// &quot;:quit&quot;: quit current window, quit Vim if the last window is closed.</a>
<a name="ln6369">// &quot;:{nr}quit&quot;: quit window {nr}</a>
<a name="ln6370">static void ex_quit(exarg_T *eap)</a>
<a name="ln6371">{</a>
<a name="ln6372">  if (cmdwin_type != 0) {</a>
<a name="ln6373">    cmdwin_result = Ctrl_C;</a>
<a name="ln6374">    return;</a>
<a name="ln6375">  }</a>
<a name="ln6376">  /* Don't quit while editing the command line. */</a>
<a name="ln6377">  if (text_locked()) {</a>
<a name="ln6378">    text_locked_msg();</a>
<a name="ln6379">    return;</a>
<a name="ln6380">  }</a>
<a name="ln6381"> </a>
<a name="ln6382">  win_T *wp;</a>
<a name="ln6383"> </a>
<a name="ln6384">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln6385">    int wnr = eap-&gt;line2;</a>
<a name="ln6386"> </a>
<a name="ln6387">    for (wp = firstwin; wp-&gt;w_next != NULL; wp = wp-&gt;w_next) {</a>
<a name="ln6388">      if (--wnr &lt;= 0)</a>
<a name="ln6389">        break;</a>
<a name="ln6390">    }</a>
<a name="ln6391">  } else {</a>
<a name="ln6392">    wp = curwin;</a>
<a name="ln6393">  }</a>
<a name="ln6394"> </a>
<a name="ln6395">  // Refuse to quit when locked.</a>
<a name="ln6396">  if (curbuf_locked()) {</a>
<a name="ln6397">    return;</a>
<a name="ln6398">  }</a>
<a name="ln6399"> </a>
<a name="ln6400">  // Trigger QuitPre and maybe ExitPre</a>
<a name="ln6401">  if (before_quit_autocmds(wp, false, eap-&gt;forceit)) {</a>
<a name="ln6402">    return;</a>
<a name="ln6403">  }</a>
<a name="ln6404"> </a>
<a name="ln6405">  // If there are more files or windows we won't exit.</a>
<a name="ln6406">  if (check_more(false, eap-&gt;forceit) == OK &amp;&amp; only_one_window()) {</a>
<a name="ln6407">    exiting = true;</a>
<a name="ln6408">  }</a>
<a name="ln6409">  if ((!buf_hide(wp-&gt;w_buffer)</a>
<a name="ln6410">       &amp;&amp; check_changed(wp-&gt;w_buffer, (p_awa ? CCGD_AW : 0)</a>
<a name="ln6411">                        | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln6412">                        | CCGD_EXCMD))</a>
<a name="ln6413">      || check_more(true, eap-&gt;forceit) == FAIL</a>
<a name="ln6414">      || (only_one_window() &amp;&amp; check_changed_any(eap-&gt;forceit, true))) {</a>
<a name="ln6415">    not_exiting();</a>
<a name="ln6416">  } else {</a>
<a name="ln6417">    // quit last window</a>
<a name="ln6418">    // Note: only_one_window() returns true, even so a help window is</a>
<a name="ln6419">    // still open. In that case only quit, if no address has been</a>
<a name="ln6420">    // specified. Example:</a>
<a name="ln6421">    // :h|wincmd w|1q     - don't quit</a>
<a name="ln6422">    // :h|wincmd w|q      - quit</a>
<a name="ln6423">    if (only_one_window() &amp;&amp; (ONE_WINDOW || eap-&gt;addr_count == 0)) {</a>
<a name="ln6424">      getout(0);</a>
<a name="ln6425">    }</a>
<a name="ln6426">    not_exiting();</a>
<a name="ln6427">    // close window; may free buffer</a>
<a name="ln6428">    win_close(wp, !buf_hide(wp-&gt;w_buffer) || eap-&gt;forceit);</a>
<a name="ln6429">  }</a>
<a name="ln6430">}</a>
<a name="ln6431"> </a>
<a name="ln6432">/// &quot;:cquit&quot;.</a>
<a name="ln6433">static void ex_cquit(exarg_T *eap)</a>
<a name="ln6434">{</a>
<a name="ln6435">  // this does not always pass on the exit code to the Manx compiler. why?</a>
<a name="ln6436">  getout(eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : EXIT_FAILURE);</a>
<a name="ln6437">}</a>
<a name="ln6438"> </a>
<a name="ln6439">/// &quot;:qall&quot;: try to quit all windows</a>
<a name="ln6440">static void ex_quit_all(exarg_T *eap)</a>
<a name="ln6441">{</a>
<a name="ln6442">  if (cmdwin_type != 0) {</a>
<a name="ln6443">    if (eap-&gt;forceit) {</a>
<a name="ln6444">      cmdwin_result = K_XF1;            // open_cmdwin() takes care of this</a>
<a name="ln6445">    } else {</a>
<a name="ln6446">      cmdwin_result = K_XF2;</a>
<a name="ln6447">    }</a>
<a name="ln6448">    return;</a>
<a name="ln6449">  }</a>
<a name="ln6450"> </a>
<a name="ln6451">  /* Don't quit while editing the command line. */</a>
<a name="ln6452">  if (text_locked()) {</a>
<a name="ln6453">    text_locked_msg();</a>
<a name="ln6454">    return;</a>
<a name="ln6455">  }</a>
<a name="ln6456"> </a>
<a name="ln6457">  if (before_quit_autocmds(curwin, true, eap-&gt;forceit)) {</a>
<a name="ln6458">    return;</a>
<a name="ln6459">  }</a>
<a name="ln6460"> </a>
<a name="ln6461">  exiting = true;</a>
<a name="ln6462">  if (eap-&gt;forceit || !check_changed_any(false, false)) {</a>
<a name="ln6463">    getout(0);</a>
<a name="ln6464">  }</a>
<a name="ln6465">  not_exiting();</a>
<a name="ln6466">}</a>
<a name="ln6467"> </a>
<a name="ln6468">/*</a>
<a name="ln6469"> * &quot;:close&quot;: close current window, unless it is the last one</a>
<a name="ln6470"> */</a>
<a name="ln6471">static void ex_close(exarg_T *eap)</a>
<a name="ln6472">{</a>
<a name="ln6473">  win_T *win = NULL;</a>
<a name="ln6474">  int winnr = 0;</a>
<a name="ln6475">  if (cmdwin_type != 0) {</a>
<a name="ln6476">    cmdwin_result = Ctrl_C;</a>
<a name="ln6477">  } else if (!text_locked() &amp;&amp; !curbuf_locked()) {</a>
<a name="ln6478">    if (eap-&gt;addr_count == 0) {</a>
<a name="ln6479">      ex_win_close(eap-&gt;forceit, curwin, NULL);</a>
<a name="ln6480">    } else {</a>
<a name="ln6481">      FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln6482">        winnr++;</a>
<a name="ln6483">        if (winnr == eap-&gt;line2) {</a>
<a name="ln6484">          win = wp;</a>
<a name="ln6485">          break;</a>
<a name="ln6486">        }</a>
<a name="ln6487">      }</a>
<a name="ln6488">      if (win == NULL)</a>
<a name="ln6489">        win = lastwin;</a>
<a name="ln6490">      ex_win_close(eap-&gt;forceit, win, NULL);</a>
<a name="ln6491">    }</a>
<a name="ln6492">  }</a>
<a name="ln6493">}</a>
<a name="ln6494"> </a>
<a name="ln6495">/*</a>
<a name="ln6496"> * &quot;:pclose&quot;: Close any preview window.</a>
<a name="ln6497"> */</a>
<a name="ln6498">static void ex_pclose(exarg_T *eap)</a>
<a name="ln6499">{</a>
<a name="ln6500">  FOR_ALL_WINDOWS_IN_TAB(win, curtab) {</a>
<a name="ln6501">    if (win-&gt;w_p_pvw) {</a>
<a name="ln6502">      ex_win_close(eap-&gt;forceit, win, NULL);</a>
<a name="ln6503">      break;</a>
<a name="ln6504">    }</a>
<a name="ln6505">  }</a>
<a name="ln6506">}</a>
<a name="ln6507"> </a>
<a name="ln6508">/*</a>
<a name="ln6509"> * Close window &quot;win&quot; and take care of handling closing the last window for a</a>
<a name="ln6510"> * modified buffer.</a>
<a name="ln6511"> */</a>
<a name="ln6512">void</a>
<a name="ln6513">ex_win_close(</a>
<a name="ln6514">    int forceit,</a>
<a name="ln6515">    win_T *win,</a>
<a name="ln6516">    tabpage_T *tp                /* NULL or the tab page &quot;win&quot; is in */</a>
<a name="ln6517">)</a>
<a name="ln6518">{</a>
<a name="ln6519">  int need_hide;</a>
<a name="ln6520">  buf_T       *buf = win-&gt;w_buffer;</a>
<a name="ln6521"> </a>
<a name="ln6522">  need_hide = (bufIsChanged(buf) &amp;&amp; buf-&gt;b_nwindows &lt;= 1);</a>
<a name="ln6523">  if (need_hide &amp;&amp; !buf_hide(buf) &amp;&amp; !forceit) {</a>
<a name="ln6524">    if ((p_confirm || cmdmod.confirm) &amp;&amp; p_write) {</a>
<a name="ln6525">      bufref_T bufref;</a>
<a name="ln6526">      set_bufref(&amp;bufref, buf);</a>
<a name="ln6527">      dialog_changed(buf, false);</a>
<a name="ln6528">      if (bufref_valid(&amp;bufref) &amp;&amp; bufIsChanged(buf)) {</a>
<a name="ln6529">        return;</a>
<a name="ln6530">      }</a>
<a name="ln6531">      need_hide = false;</a>
<a name="ln6532">    } else {</a>
<a name="ln6533">      no_write_message();</a>
<a name="ln6534">      return;</a>
<a name="ln6535">    }</a>
<a name="ln6536">  }</a>
<a name="ln6537"> </a>
<a name="ln6538"> </a>
<a name="ln6539">  // free buffer when not hiding it or when it's a scratch buffer</a>
<a name="ln6540">  if (tp == NULL) {</a>
<a name="ln6541">    win_close(win, !need_hide &amp;&amp; !buf_hide(buf));</a>
<a name="ln6542">  } else {</a>
<a name="ln6543">    win_close_othertab(win, !need_hide &amp;&amp; !buf_hide(buf), tp);</a>
<a name="ln6544">  }</a>
<a name="ln6545">}</a>
<a name="ln6546"> </a>
<a name="ln6547">/*</a>
<a name="ln6548"> * &quot;:tabclose&quot;: close current tab page, unless it is the last one.</a>
<a name="ln6549"> * &quot;:tabclose N&quot;: close tab page N.</a>
<a name="ln6550"> */</a>
<a name="ln6551">static void ex_tabclose(exarg_T *eap)</a>
<a name="ln6552">{</a>
<a name="ln6553">  tabpage_T   *tp;</a>
<a name="ln6554"> </a>
<a name="ln6555">  if (cmdwin_type != 0)</a>
<a name="ln6556">    cmdwin_result = K_IGNORE;</a>
<a name="ln6557">  else if (first_tabpage-&gt;tp_next == NULL)</a>
<a name="ln6558">    EMSG(_(&quot;E784: Cannot close last tab page&quot;));</a>
<a name="ln6559">  else {</a>
<a name="ln6560">    int tab_number = get_tabpage_arg(eap);</a>
<a name="ln6561">    if (eap-&gt;errmsg == NULL) {</a>
<a name="ln6562">      tp = find_tabpage(tab_number);</a>
<a name="ln6563">      if (tp == NULL) {</a>
<a name="ln6564">        beep_flush();</a>
<a name="ln6565">        return;</a>
<a name="ln6566">      }</a>
<a name="ln6567">      if (tp != curtab) {</a>
<a name="ln6568">        tabpage_close_other(tp, eap-&gt;forceit);</a>
<a name="ln6569">        return;</a>
<a name="ln6570">      } else if (!text_locked() &amp;&amp; !curbuf_locked()) {</a>
<a name="ln6571">        tabpage_close(eap-&gt;forceit);</a>
<a name="ln6572">      }</a>
<a name="ln6573">    }</a>
<a name="ln6574">  }</a>
<a name="ln6575">}</a>
<a name="ln6576"> </a>
<a name="ln6577">/// &quot;:tabonly&quot;: close all tab pages except the current one</a>
<a name="ln6578">static void ex_tabonly(exarg_T *eap)</a>
<a name="ln6579">{</a>
<a name="ln6580">  if (cmdwin_type != 0) {</a>
<a name="ln6581">    cmdwin_result = K_IGNORE;</a>
<a name="ln6582">  } else if (first_tabpage-&gt;tp_next == NULL) {</a>
<a name="ln6583">      MSG(_(&quot;Already only one tab page&quot;));</a>
<a name="ln6584">  } else {</a>
<a name="ln6585">    int tab_number = get_tabpage_arg(eap);</a>
<a name="ln6586">    if (eap-&gt;errmsg == NULL) {</a>
<a name="ln6587">      goto_tabpage(tab_number);</a>
<a name="ln6588">      // Repeat this up to a 1000 times, because autocommands may</a>
<a name="ln6589">      // mess up the lists.</a>
<a name="ln6590">      for (int done = 0; done &lt; 1000; done++) {</a>
<a name="ln6591">        FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln6592">          assert(wp != aucmd_win);</a>
<a name="ln6593">        }</a>
<a name="ln6594">        FOR_ALL_TABS(tp) {</a>
<a name="ln6595">          if (tp-&gt;tp_topframe != topframe) {</a>
<a name="ln6596">            tabpage_close_other(tp, eap-&gt;forceit);</a>
<a name="ln6597">            // if we failed to close it quit</a>
<a name="ln6598">            if (valid_tabpage(tp)) {</a>
<a name="ln6599">              done = 1000;</a>
<a name="ln6600">            }</a>
<a name="ln6601">            // start over, &quot;tp&quot; is now invalid</a>
<a name="ln6602">            break;</a>
<a name="ln6603">          }</a>
<a name="ln6604">        }</a>
<a name="ln6605">        assert(first_tabpage);</a>
<a name="ln6606">        if (first_tabpage-&gt;tp_next == NULL) {</a>
<a name="ln6607">          break;</a>
<a name="ln6608">        }</a>
<a name="ln6609">      }</a>
<a name="ln6610">    }</a>
<a name="ln6611">  }</a>
<a name="ln6612">}</a>
<a name="ln6613"> </a>
<a name="ln6614">/*</a>
<a name="ln6615"> * Close the current tab page.</a>
<a name="ln6616"> */</a>
<a name="ln6617">void tabpage_close(int forceit)</a>
<a name="ln6618">{</a>
<a name="ln6619">  // First close all the windows but the current one.  If that worked then</a>
<a name="ln6620">  // close the last window in this tab, that will close it.</a>
<a name="ln6621">  while (curwin-&gt;w_floating) {</a>
<a name="ln6622">    ex_win_close(forceit, curwin, NULL);</a>
<a name="ln6623">  }</a>
<a name="ln6624">  if (!ONE_WINDOW) {</a>
<a name="ln6625">    close_others(true, forceit);</a>
<a name="ln6626">  }</a>
<a name="ln6627">  if (ONE_WINDOW) {</a>
<a name="ln6628">    ex_win_close(forceit, curwin, NULL);</a>
<a name="ln6629">  }</a>
<a name="ln6630">}</a>
<a name="ln6631"> </a>
<a name="ln6632">/*</a>
<a name="ln6633"> * Close tab page &quot;tp&quot;, which is not the current tab page.</a>
<a name="ln6634"> * Note that autocommands may make &quot;tp&quot; invalid.</a>
<a name="ln6635"> * Also takes care of the tab pages line disappearing when closing the</a>
<a name="ln6636"> * last-but-one tab page.</a>
<a name="ln6637"> */</a>
<a name="ln6638">void tabpage_close_other(tabpage_T *tp, int forceit)</a>
<a name="ln6639">{</a>
<a name="ln6640">  int done = 0;</a>
<a name="ln6641">  win_T       *wp;</a>
<a name="ln6642">  int h = tabline_height();</a>
<a name="ln6643">  char_u prev_idx[NUMBUFLEN];</a>
<a name="ln6644"> </a>
<a name="ln6645">  /* Limit to 1000 windows, autocommands may add a window while we close</a>
<a name="ln6646">   * one.  OK, so I'm paranoid... */</a>
<a name="ln6647">  while (++done &lt; 1000) {</a>
<a name="ln6648">    snprintf((char *)prev_idx, sizeof(prev_idx), &quot;%i&quot;, tabpage_index(tp));</a>
<a name="ln6649">    wp = tp-&gt;tp_lastwin;</a>
<a name="ln6650">    ex_win_close(forceit, wp, tp);</a>
<a name="ln6651"> </a>
<a name="ln6652">    /* Autocommands may delete the tab page under our fingers and we may</a>
<a name="ln6653">     * fail to close a window with a modified buffer. */</a>
<a name="ln6654">    if (!valid_tabpage(tp) || tp-&gt;tp_firstwin == wp)</a>
<a name="ln6655">      break;</a>
<a name="ln6656">  }</a>
<a name="ln6657"> </a>
<a name="ln6658">  redraw_tabline = TRUE;</a>
<a name="ln6659">  if (h != tabline_height())</a>
<a name="ln6660">    shell_new_rows();</a>
<a name="ln6661">}</a>
<a name="ln6662"> </a>
<a name="ln6663">/*</a>
<a name="ln6664"> * &quot;:only&quot;.</a>
<a name="ln6665"> */</a>
<a name="ln6666">static void ex_only(exarg_T *eap)</a>
<a name="ln6667">{</a>
<a name="ln6668">  win_T *wp;</a>
<a name="ln6669">  int wnr;</a>
<a name="ln6670"> </a>
<a name="ln6671">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln6672">    wnr = eap-&gt;line2;</a>
<a name="ln6673">    for (wp = firstwin; --wnr &gt; 0;) {</a>
<a name="ln6674">      if (wp-&gt;w_next == NULL)</a>
<a name="ln6675">        break;</a>
<a name="ln6676">      else</a>
<a name="ln6677">        wp = wp-&gt;w_next;</a>
<a name="ln6678">    }</a>
<a name="ln6679">  } else {</a>
<a name="ln6680">    wp = curwin;</a>
<a name="ln6681">  }</a>
<a name="ln6682">  if (wp != curwin) {</a>
<a name="ln6683">    win_goto(wp);</a>
<a name="ln6684">  }</a>
<a name="ln6685">  close_others(TRUE, eap-&gt;forceit);</a>
<a name="ln6686">}</a>
<a name="ln6687"> </a>
<a name="ln6688">/*</a>
<a name="ln6689"> * &quot;:all&quot; and &quot;:sall&quot;.</a>
<a name="ln6690"> * Also used for &quot;:tab drop file ...&quot; after setting the argument list.</a>
<a name="ln6691"> */</a>
<a name="ln6692">void ex_all(exarg_T *eap)</a>
<a name="ln6693">{</a>
<a name="ln6694">  if (eap-&gt;addr_count == 0)</a>
<a name="ln6695">    eap-&gt;line2 = 9999;</a>
<a name="ln6696">  do_arg_all((int)eap-&gt;line2, eap-&gt;forceit, eap-&gt;cmdidx == CMD_drop);</a>
<a name="ln6697">}</a>
<a name="ln6698"> </a>
<a name="ln6699">static void ex_hide(exarg_T *eap)</a>
<a name="ln6700">{</a>
<a name="ln6701">    // &quot;:hide&quot; or &quot;:hide | cmd&quot;: hide current window</a>
<a name="ln6702">    if (!eap-&gt;skip) {</a>
<a name="ln6703">        if (eap-&gt;addr_count == 0) {</a>
<a name="ln6704">            win_close(curwin, false);  // don't free buffer</a>
<a name="ln6705">        } else {</a>
<a name="ln6706">            int winnr = 0;</a>
<a name="ln6707">            win_T *win = NULL;</a>
<a name="ln6708"> </a>
<a name="ln6709">            FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln6710">                winnr++;</a>
<a name="ln6711">                if (winnr == eap-&gt;line2) {</a>
<a name="ln6712">                    win = wp;</a>
<a name="ln6713">                    break;</a>
<a name="ln6714">                }</a>
<a name="ln6715">            }</a>
<a name="ln6716">            if (win == NULL) {</a>
<a name="ln6717">                win = lastwin;</a>
<a name="ln6718">            }</a>
<a name="ln6719">            win_close(win, false);</a>
<a name="ln6720">        }</a>
<a name="ln6721">    }</a>
<a name="ln6722">}</a>
<a name="ln6723"> </a>
<a name="ln6724">/// &quot;:stop&quot; and &quot;:suspend&quot;: Suspend Vim.</a>
<a name="ln6725">static void ex_stop(exarg_T *eap)</a>
<a name="ln6726">{</a>
<a name="ln6727">  if (!eap-&gt;forceit) {</a>
<a name="ln6728">    autowrite_all();</a>
<a name="ln6729">  }</a>
<a name="ln6730">  apply_autocmds(EVENT_VIMSUSPEND, NULL, NULL, false, NULL);</a>
<a name="ln6731"> </a>
<a name="ln6732">  // TODO(bfredl): the TUI should do this on suspend</a>
<a name="ln6733">  ui_cursor_goto(Rows - 1, 0);</a>
<a name="ln6734">  ui_call_grid_scroll(1, 0, Rows, 0, Columns, 1, 0);</a>
<a name="ln6735">  ui_flush();</a>
<a name="ln6736">  ui_call_suspend();  // call machine specific function</a>
<a name="ln6737"> </a>
<a name="ln6738">  ui_flush();</a>
<a name="ln6739">  maketitle();</a>
<a name="ln6740">  resettitle();  // force updating the title</a>
<a name="ln6741">  ui_refresh();  // may have resized window</a>
<a name="ln6742">  apply_autocmds(EVENT_VIMRESUME, NULL, NULL, false, NULL);</a>
<a name="ln6743">}</a>
<a name="ln6744"> </a>
<a name="ln6745">// &quot;:exit&quot;, &quot;:xit&quot; and &quot;:wq&quot;: Write file and quite the current window.</a>
<a name="ln6746">static void ex_exit(exarg_T *eap)</a>
<a name="ln6747">{</a>
<a name="ln6748">  if (cmdwin_type != 0) {</a>
<a name="ln6749">    cmdwin_result = Ctrl_C;</a>
<a name="ln6750">    return;</a>
<a name="ln6751">  }</a>
<a name="ln6752">  /* Don't quit while editing the command line. */</a>
<a name="ln6753">  if (text_locked()) {</a>
<a name="ln6754">    text_locked_msg();</a>
<a name="ln6755">    return;</a>
<a name="ln6756">  }</a>
<a name="ln6757"> </a>
<a name="ln6758">  if (before_quit_autocmds(curwin, false, eap-&gt;forceit)) {</a>
<a name="ln6759">    return;</a>
<a name="ln6760">  }</a>
<a name="ln6761"> </a>
<a name="ln6762">  // if more files or windows we won't exit</a>
<a name="ln6763">  if (check_more(false, eap-&gt;forceit) == OK &amp;&amp; only_one_window()) {</a>
<a name="ln6764">    exiting = true;</a>
<a name="ln6765">  }</a>
<a name="ln6766">  if (((eap-&gt;cmdidx == CMD_wq</a>
<a name="ln6767">        || curbufIsChanged())</a>
<a name="ln6768">       &amp;&amp; do_write(eap) == FAIL)</a>
<a name="ln6769">      || check_more(true, eap-&gt;forceit) == FAIL</a>
<a name="ln6770">      || (only_one_window() &amp;&amp; check_changed_any(eap-&gt;forceit, false))) {</a>
<a name="ln6771">    not_exiting();</a>
<a name="ln6772">  } else {</a>
<a name="ln6773">    if (only_one_window()) {</a>
<a name="ln6774">      // quit last window, exit Vim</a>
<a name="ln6775">      getout(0);</a>
<a name="ln6776">    }</a>
<a name="ln6777">    not_exiting();</a>
<a name="ln6778">    // Quit current window, may free the buffer.</a>
<a name="ln6779">    win_close(curwin, !buf_hide(curwin-&gt;w_buffer));</a>
<a name="ln6780">  }</a>
<a name="ln6781">}</a>
<a name="ln6782"> </a>
<a name="ln6783">/*</a>
<a name="ln6784"> * &quot;:print&quot;, &quot;:list&quot;, &quot;:number&quot;.</a>
<a name="ln6785"> */</a>
<a name="ln6786">static void ex_print(exarg_T *eap)</a>
<a name="ln6787">{</a>
<a name="ln6788">  if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY)</a>
<a name="ln6789">    EMSG(_(e_emptybuf));</a>
<a name="ln6790">  else {</a>
<a name="ln6791">    for (; !got_int; os_breakcheck()) {</a>
<a name="ln6792">      print_line(eap-&gt;line1,</a>
<a name="ln6793">          (eap-&gt;cmdidx == CMD_number || eap-&gt;cmdidx == CMD_pound</a>
<a name="ln6794">           || (eap-&gt;flags &amp; EXFLAG_NR)),</a>
<a name="ln6795">          eap-&gt;cmdidx == CMD_list || (eap-&gt;flags &amp; EXFLAG_LIST));</a>
<a name="ln6796">      if (++eap-&gt;line1 &gt; eap-&gt;line2)</a>
<a name="ln6797">        break;</a>
<a name="ln6798">      ui_flush();                  /* show one line at a time */</a>
<a name="ln6799">    }</a>
<a name="ln6800">    setpcmark();</a>
<a name="ln6801">    /* put cursor at last line */</a>
<a name="ln6802">    curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln6803">    beginline(BL_SOL | BL_FIX);</a>
<a name="ln6804">  }</a>
<a name="ln6805"> </a>
<a name="ln6806">  ex_no_reprint = TRUE;</a>
<a name="ln6807">}</a>
<a name="ln6808"> </a>
<a name="ln6809">static void ex_goto(exarg_T *eap)</a>
<a name="ln6810">{</a>
<a name="ln6811">  goto_byte(eap-&gt;line2);</a>
<a name="ln6812">}</a>
<a name="ln6813"> </a>
<a name="ln6814">/*</a>
<a name="ln6815"> * Clear an argument list: free all file names and reset it to zero entries.</a>
<a name="ln6816"> */</a>
<a name="ln6817">void alist_clear(alist_T *al)</a>
<a name="ln6818">{</a>
<a name="ln6819"># define FREE_AENTRY_FNAME(arg) xfree(arg-&gt;ae_fname)</a>
<a name="ln6820">  GA_DEEP_CLEAR(&amp;al-&gt;al_ga, aentry_T, FREE_AENTRY_FNAME);</a>
<a name="ln6821">}</a>
<a name="ln6822"> </a>
<a name="ln6823">/*</a>
<a name="ln6824"> * Init an argument list.</a>
<a name="ln6825"> */</a>
<a name="ln6826">void alist_init(alist_T *al)</a>
<a name="ln6827">{</a>
<a name="ln6828">  ga_init(&amp;al-&gt;al_ga, (int)sizeof(aentry_T), 5);</a>
<a name="ln6829">}</a>
<a name="ln6830"> </a>
<a name="ln6831"> </a>
<a name="ln6832">/*</a>
<a name="ln6833"> * Remove a reference from an argument list.</a>
<a name="ln6834"> * Ignored when the argument list is the global one.</a>
<a name="ln6835"> * If the argument list is no longer used by any window, free it.</a>
<a name="ln6836"> */</a>
<a name="ln6837">void alist_unlink(alist_T *al)</a>
<a name="ln6838">{</a>
<a name="ln6839">  if (al != &amp;global_alist &amp;&amp; --al-&gt;al_refcount &lt;= 0) {</a>
<a name="ln6840">    alist_clear(al);</a>
<a name="ln6841">    xfree(al);</a>
<a name="ln6842">  }</a>
<a name="ln6843">}</a>
<a name="ln6844"> </a>
<a name="ln6845">/*</a>
<a name="ln6846"> * Create a new argument list and use it for the current window.</a>
<a name="ln6847"> */</a>
<a name="ln6848">void alist_new(void)</a>
<a name="ln6849">{</a>
<a name="ln6850">  curwin-&gt;w_alist = xmalloc(sizeof(*curwin-&gt;w_alist));</a>
<a name="ln6851">  curwin-&gt;w_alist-&gt;al_refcount = 1;</a>
<a name="ln6852">  curwin-&gt;w_alist-&gt;id = ++max_alist_id;</a>
<a name="ln6853">  alist_init(curwin-&gt;w_alist);</a>
<a name="ln6854">}</a>
<a name="ln6855"> </a>
<a name="ln6856">#if !defined(UNIX)</a>
<a name="ln6857">/*</a>
<a name="ln6858"> * Expand the file names in the global argument list.</a>
<a name="ln6859"> * If &quot;fnum_list&quot; is not NULL, use &quot;fnum_list[fnum_len]&quot; as a list of buffer</a>
<a name="ln6860"> * numbers to be re-used.</a>
<a name="ln6861"> */</a>
<a name="ln6862">void alist_expand(int *fnum_list, int fnum_len)</a>
<a name="ln6863">{</a>
<a name="ln6864">  char_u      **old_arg_files;</a>
<a name="ln6865">  int old_arg_count;</a>
<a name="ln6866">  char_u      **new_arg_files;</a>
<a name="ln6867">  int new_arg_file_count;</a>
<a name="ln6868">  char_u      *save_p_su = p_su;</a>
<a name="ln6869">  int i;</a>
<a name="ln6870"> </a>
<a name="ln6871">  /* Don't use 'suffixes' here.  This should work like the shell did the</a>
<a name="ln6872">   * expansion.  Also, the vimrc file isn't read yet, thus the user</a>
<a name="ln6873">   * can't set the options. */</a>
<a name="ln6874">  p_su = empty_option;</a>
<a name="ln6875">  old_arg_files = xmalloc(sizeof(*old_arg_files) * GARGCOUNT);</a>
<a name="ln6876">  for (i = 0; i &lt; GARGCOUNT; ++i)</a>
<a name="ln6877">    old_arg_files[i] = vim_strsave(GARGLIST[i].ae_fname);</a>
<a name="ln6878">  old_arg_count = GARGCOUNT;</a>
<a name="ln6879">  if (expand_wildcards(old_arg_count, old_arg_files,</a>
<a name="ln6880">          &amp;new_arg_file_count, &amp;new_arg_files,</a>
<a name="ln6881">          EW_FILE|EW_NOTFOUND|EW_ADDSLASH|EW_NOERROR) == OK</a>
<a name="ln6882">      &amp;&amp; new_arg_file_count &gt; 0) {</a>
<a name="ln6883">    alist_set(&amp;global_alist, new_arg_file_count, new_arg_files,</a>
<a name="ln6884">        TRUE, fnum_list, fnum_len);</a>
<a name="ln6885">    FreeWild(old_arg_count, old_arg_files);</a>
<a name="ln6886">  }</a>
<a name="ln6887">  p_su = save_p_su;</a>
<a name="ln6888">}</a>
<a name="ln6889">#endif</a>
<a name="ln6890"> </a>
<a name="ln6891">/*</a>
<a name="ln6892"> * Set the argument list for the current window.</a>
<a name="ln6893"> * Takes over the allocated files[] and the allocated fnames in it.</a>
<a name="ln6894"> */</a>
<a name="ln6895">void alist_set(alist_T *al, int count, char_u **files, int use_curbuf, int *fnum_list, int fnum_len)</a>
<a name="ln6896">{</a>
<a name="ln6897">  int i;</a>
<a name="ln6898">  static int recursive = 0;</a>
<a name="ln6899"> </a>
<a name="ln6900">  if (recursive) {</a>
<a name="ln6901">    EMSG(_(e_au_recursive));</a>
<a name="ln6902">    return;</a>
<a name="ln6903">  }</a>
<a name="ln6904">  recursive++;</a>
<a name="ln6905"> </a>
<a name="ln6906">  alist_clear(al);</a>
<a name="ln6907">  ga_grow(&amp;al-&gt;al_ga, count);</a>
<a name="ln6908">  {</a>
<a name="ln6909">    for (i = 0; i &lt; count; ++i) {</a>
<a name="ln6910">      if (got_int) {</a>
<a name="ln6911">        /* When adding many buffers this can take a long time.  Allow</a>
<a name="ln6912">         * interrupting here. */</a>
<a name="ln6913">        while (i &lt; count)</a>
<a name="ln6914">          xfree(files[i++]);</a>
<a name="ln6915">        break;</a>
<a name="ln6916">      }</a>
<a name="ln6917"> </a>
<a name="ln6918">      /* May set buffer name of a buffer previously used for the</a>
<a name="ln6919">       * argument list, so that it's re-used by alist_add. */</a>
<a name="ln6920">      if (fnum_list != NULL &amp;&amp; i &lt; fnum_len)</a>
<a name="ln6921">        buf_set_name(fnum_list[i], files[i]);</a>
<a name="ln6922"> </a>
<a name="ln6923">      alist_add(al, files[i], use_curbuf ? 2 : 1);</a>
<a name="ln6924">      os_breakcheck();</a>
<a name="ln6925">    }</a>
<a name="ln6926">    xfree(files);</a>
<a name="ln6927">  }</a>
<a name="ln6928"> </a>
<a name="ln6929">  if (al == &amp;global_alist) {</a>
<a name="ln6930">    arg_had_last = false;</a>
<a name="ln6931">  }</a>
<a name="ln6932">  recursive--;</a>
<a name="ln6933">}</a>
<a name="ln6934"> </a>
<a name="ln6935">/*</a>
<a name="ln6936"> * Add file &quot;fname&quot; to argument list &quot;al&quot;.</a>
<a name="ln6937"> * &quot;fname&quot; must have been allocated and &quot;al&quot; must have been checked for room.</a>
<a name="ln6938"> */</a>
<a name="ln6939">void</a>
<a name="ln6940">alist_add(</a>
<a name="ln6941">    alist_T *al,</a>
<a name="ln6942">    char_u *fname,</a>
<a name="ln6943">    int set_fnum                   /* 1: set buffer number; 2: re-use curbuf */</a>
<a name="ln6944">)</a>
<a name="ln6945">{</a>
<a name="ln6946">  if (fname == NULL)            /* don't add NULL file names */</a>
<a name="ln6947">    return;</a>
<a name="ln6948">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln6949">  slash_adjust(fname);</a>
<a name="ln6950">#endif</a>
<a name="ln6951">  AARGLIST(al)[al-&gt;al_ga.ga_len].ae_fname = fname;</a>
<a name="ln6952">  if (set_fnum &gt; 0)</a>
<a name="ln6953">    AARGLIST(al)[al-&gt;al_ga.ga_len].ae_fnum =</a>
<a name="ln6954">      buflist_add(fname, BLN_LISTED | (set_fnum == 2 ? BLN_CURBUF : 0));</a>
<a name="ln6955">  ++al-&gt;al_ga.ga_len;</a>
<a name="ln6956">}</a>
<a name="ln6957"> </a>
<a name="ln6958">#if defined(BACKSLASH_IN_FILENAME)</a>
<a name="ln6959">/*</a>
<a name="ln6960"> * Adjust slashes in file names.  Called after 'shellslash' was set.</a>
<a name="ln6961"> */</a>
<a name="ln6962">void alist_slash_adjust(void)</a>
<a name="ln6963">{</a>
<a name="ln6964">  for (int i = 0; i &lt; GARGCOUNT; ++i) {</a>
<a name="ln6965">    if (GARGLIST[i].ae_fname != NULL) {</a>
<a name="ln6966">      slash_adjust(GARGLIST[i].ae_fname);</a>
<a name="ln6967">    }</a>
<a name="ln6968">  }</a>
<a name="ln6969"> </a>
<a name="ln6970">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln6971">    if (wp-&gt;w_alist != &amp;global_alist) {</a>
<a name="ln6972">      for (int i = 0; i &lt; WARGCOUNT(wp); ++i) {</a>
<a name="ln6973">        if (WARGLIST(wp)[i].ae_fname != NULL) {</a>
<a name="ln6974">          slash_adjust(WARGLIST(wp)[i].ae_fname);</a>
<a name="ln6975">        }</a>
<a name="ln6976">      }</a>
<a name="ln6977">    }</a>
<a name="ln6978">  }</a>
<a name="ln6979">}</a>
<a name="ln6980"> </a>
<a name="ln6981">#endif</a>
<a name="ln6982"> </a>
<a name="ln6983">/// &quot;:preserve&quot;.</a>
<a name="ln6984">static void ex_preserve(exarg_T *eap)</a>
<a name="ln6985">{</a>
<a name="ln6986">  curbuf-&gt;b_flags |= BF_PRESERVED;</a>
<a name="ln6987">  ml_preserve(curbuf, true, true);</a>
<a name="ln6988">}</a>
<a name="ln6989"> </a>
<a name="ln6990">/// &quot;:recover&quot;.</a>
<a name="ln6991">static void ex_recover(exarg_T *eap)</a>
<a name="ln6992">{</a>
<a name="ln6993">  // Set recoverymode right away to avoid the ATTENTION prompt.</a>
<a name="ln6994">  recoverymode = true;</a>
<a name="ln6995">  if (!check_changed(curbuf, (p_awa ? CCGD_AW : 0)</a>
<a name="ln6996">          | CCGD_MULTWIN</a>
<a name="ln6997">          | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln6998">          | CCGD_EXCMD)</a>
<a name="ln6999"> </a>
<a name="ln7000">      &amp;&amp; (*eap-&gt;arg == NUL</a>
<a name="ln7001">          || setfname(curbuf, eap-&gt;arg, NULL, true) == OK)) {</a>
<a name="ln7002">    ml_recover(true);</a>
<a name="ln7003">  }</a>
<a name="ln7004">  recoverymode = false;</a>
<a name="ln7005">}</a>
<a name="ln7006"> </a>
<a name="ln7007">/*</a>
<a name="ln7008"> * Command modifier used in a wrong way.</a>
<a name="ln7009"> */</a>
<a name="ln7010">static void ex_wrongmodifier(exarg_T *eap)</a>
<a name="ln7011">{</a>
<a name="ln7012">  eap-&gt;errmsg = e_invcmd;</a>
<a name="ln7013">}</a>
<a name="ln7014"> </a>
<a name="ln7015">/*</a>
<a name="ln7016"> * :sview [+command] file	split window with new file, read-only</a>
<a name="ln7017"> * :split [[+command] file]	split window with current or new file</a>
<a name="ln7018"> * :vsplit [[+command] file]	split window vertically with current or new file</a>
<a name="ln7019"> * :new [[+command] file]	split window with no or new file</a>
<a name="ln7020"> * :vnew [[+command] file]	split vertically window with no or new file</a>
<a name="ln7021"> * :sfind [+command] file	split window with file in 'path'</a>
<a name="ln7022"> *</a>
<a name="ln7023"> * :tabedit			open new Tab page with empty window</a>
<a name="ln7024"> * :tabedit [+command] file	open new Tab page and edit &quot;file&quot;</a>
<a name="ln7025"> * :tabnew [[+command] file]	just like :tabedit</a>
<a name="ln7026"> * :tabfind [+command] file	open new Tab page and find &quot;file&quot;</a>
<a name="ln7027"> */</a>
<a name="ln7028">void ex_splitview(exarg_T *eap)</a>
<a name="ln7029">{</a>
<a name="ln7030">  win_T       *old_curwin = curwin;</a>
<a name="ln7031">  char_u      *fname = NULL;</a>
<a name="ln7032">  const bool use_tab = eap-&gt;cmdidx == CMD_tabedit</a>
<a name="ln7033">    || eap-&gt;cmdidx == CMD_tabfind</a>
<a name="ln7034">    || eap-&gt;cmdidx == CMD_tabnew;</a>
<a name="ln7035"> </a>
<a name="ln7036">  /* A &quot;:split&quot; in the quickfix window works like &quot;:new&quot;.  Don't want two</a>
<a name="ln7037">   * quickfix windows.  But it's OK when doing &quot;:tab split&quot;. */</a>
<a name="ln7038">  if (bt_quickfix(curbuf) &amp;&amp; cmdmod.tab == 0) {</a>
<a name="ln7039">    if (eap-&gt;cmdidx == CMD_split)</a>
<a name="ln7040">      eap-&gt;cmdidx = CMD_new;</a>
<a name="ln7041">    if (eap-&gt;cmdidx == CMD_vsplit)</a>
<a name="ln7042">      eap-&gt;cmdidx = CMD_vnew;</a>
<a name="ln7043">  }</a>
<a name="ln7044"> </a>
<a name="ln7045">  if (eap-&gt;cmdidx == CMD_sfind || eap-&gt;cmdidx == CMD_tabfind) {</a>
<a name="ln7046">    fname = find_file_in_path(eap-&gt;arg, STRLEN(eap-&gt;arg),</a>
<a name="ln7047">                              FNAME_MESS, TRUE, curbuf-&gt;b_ffname);</a>
<a name="ln7048">    if (fname == NULL)</a>
<a name="ln7049">      goto theend;</a>
<a name="ln7050">    eap-&gt;arg = fname;</a>
<a name="ln7051">  }</a>
<a name="ln7052"> </a>
<a name="ln7053">  /*</a>
<a name="ln7054">   * Either open new tab page or split the window.</a>
<a name="ln7055">   */</a>
<a name="ln7056">  if (use_tab) {</a>
<a name="ln7057">    if (win_new_tabpage(cmdmod.tab != 0 ? cmdmod.tab : eap-&gt;addr_count == 0</a>
<a name="ln7058">                        ? 0 : (int)eap-&gt;line2 + 1, eap-&gt;arg) != FAIL) {</a>
<a name="ln7059">      do_exedit(eap, old_curwin);</a>
<a name="ln7060">      apply_autocmds(EVENT_TABNEWENTERED, NULL, NULL, FALSE, curbuf);</a>
<a name="ln7061"> </a>
<a name="ln7062">      /* set the alternate buffer for the window we came from */</a>
<a name="ln7063">      if (curwin != old_curwin</a>
<a name="ln7064">          &amp;&amp; win_valid(old_curwin)</a>
<a name="ln7065">          &amp;&amp; old_curwin-&gt;w_buffer != curbuf</a>
<a name="ln7066">          &amp;&amp; !cmdmod.keepalt)</a>
<a name="ln7067">        old_curwin-&gt;w_alt_fnum = curbuf-&gt;b_fnum;</a>
<a name="ln7068">    }</a>
<a name="ln7069">  } else if (win_split(eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : 0,</a>
<a name="ln7070">                 *eap-&gt;cmd == 'v' ? WSP_VERT : 0) != FAIL) {</a>
<a name="ln7071">    /* Reset 'scrollbind' when editing another file, but keep it when</a>
<a name="ln7072">     * doing &quot;:split&quot; without arguments. */</a>
<a name="ln7073">    if (*eap-&gt;arg != NUL</a>
<a name="ln7074">        ) {</a>
<a name="ln7075">      RESET_BINDING(curwin);</a>
<a name="ln7076">    } else {</a>
<a name="ln7077">      do_check_scrollbind(false);</a>
<a name="ln7078">    }</a>
<a name="ln7079">    do_exedit(eap, old_curwin);</a>
<a name="ln7080">  }</a>
<a name="ln7081"> </a>
<a name="ln7082"> </a>
<a name="ln7083">theend:</a>
<a name="ln7084">  xfree(fname);</a>
<a name="ln7085">}</a>
<a name="ln7086"> </a>
<a name="ln7087">/*</a>
<a name="ln7088"> * Open a new tab page.</a>
<a name="ln7089"> */</a>
<a name="ln7090">void tabpage_new(void)</a>
<a name="ln7091">{</a>
<a name="ln7092">  exarg_T ea;</a>
<a name="ln7093"> </a>
<a name="ln7094">  memset(&amp;ea, 0, sizeof(ea));</a>
<a name="ln7095">  ea.cmdidx = CMD_tabnew;</a>
<a name="ln7096">  ea.cmd = (char_u *)&quot;tabn&quot;;</a>
<a name="ln7097">  ea.arg = (char_u *)&quot;&quot;;</a>
<a name="ln7098">  ex_splitview(&amp;ea);</a>
<a name="ln7099">}</a>
<a name="ln7100"> </a>
<a name="ln7101">/*</a>
<a name="ln7102"> * :tabnext command</a>
<a name="ln7103"> */</a>
<a name="ln7104">static void ex_tabnext(exarg_T *eap)</a>
<a name="ln7105">{</a>
<a name="ln7106">  int tab_number;</a>
<a name="ln7107"> </a>
<a name="ln7108">  switch (eap-&gt;cmdidx) {</a>
<a name="ln7109">  case CMD_tabfirst:</a>
<a name="ln7110">  case CMD_tabrewind:</a>
<a name="ln7111">    goto_tabpage(1);</a>
<a name="ln7112">    break;</a>
<a name="ln7113">  case CMD_tablast:</a>
<a name="ln7114">    goto_tabpage(9999);</a>
<a name="ln7115">    break;</a>
<a name="ln7116">  case CMD_tabprevious:</a>
<a name="ln7117">  case CMD_tabNext:</a>
<a name="ln7118">    if (eap-&gt;arg &amp;&amp; *eap-&gt;arg != NUL) {</a>
<a name="ln7119">      char_u *p = eap-&gt;arg;</a>
<a name="ln7120">      char_u *p_save = p;</a>
<a name="ln7121">      tab_number = getdigits(&amp;p, false, 0);</a>
<a name="ln7122">      if (p == p_save || *p_save == '-' || *p_save == '+' || *p != NUL</a>
<a name="ln7123">          || tab_number == 0) {</a>
<a name="ln7124">        // No numbers as argument.</a>
<a name="ln7125">        eap-&gt;errmsg = e_invarg;</a>
<a name="ln7126">        return;</a>
<a name="ln7127">      }</a>
<a name="ln7128">    } else {</a>
<a name="ln7129">      if (eap-&gt;addr_count == 0) {</a>
<a name="ln7130">        tab_number = 1;</a>
<a name="ln7131">      } else {</a>
<a name="ln7132">        tab_number = eap-&gt;line2;</a>
<a name="ln7133">        if (tab_number &lt; 1) {</a>
<a name="ln7134">          eap-&gt;errmsg = e_invrange;</a>
<a name="ln7135">          return;</a>
<a name="ln7136">        }</a>
<a name="ln7137">      }</a>
<a name="ln7138">    }</a>
<a name="ln7139">    goto_tabpage(-tab_number);</a>
<a name="ln7140">    break;</a>
<a name="ln7141">  default:       // CMD_tabnext</a>
<a name="ln7142">    tab_number = get_tabpage_arg(eap);</a>
<a name="ln7143">    if (eap-&gt;errmsg == NULL) {</a>
<a name="ln7144">      goto_tabpage(tab_number);</a>
<a name="ln7145">    }</a>
<a name="ln7146">    break;</a>
<a name="ln7147">  }</a>
<a name="ln7148">}</a>
<a name="ln7149"> </a>
<a name="ln7150">/*</a>
<a name="ln7151"> * :tabmove command</a>
<a name="ln7152"> */</a>
<a name="ln7153">static void ex_tabmove(exarg_T *eap)</a>
<a name="ln7154">{</a>
<a name="ln7155">  int tab_number = get_tabpage_arg(eap);</a>
<a name="ln7156">  if (eap-&gt;errmsg == NULL) {</a>
<a name="ln7157">    tabpage_move(tab_number);</a>
<a name="ln7158">  }</a>
<a name="ln7159">}</a>
<a name="ln7160"> </a>
<a name="ln7161">/*</a>
<a name="ln7162"> * :tabs command: List tabs and their contents.</a>
<a name="ln7163"> */</a>
<a name="ln7164">static void ex_tabs(exarg_T *eap)</a>
<a name="ln7165">{</a>
<a name="ln7166">  int tabcount = 1;</a>
<a name="ln7167"> </a>
<a name="ln7168">  msg_start();</a>
<a name="ln7169">  msg_scroll = TRUE;</a>
<a name="ln7170"> </a>
<a name="ln7171">  win_T *lastused_win = valid_tabpage(lastused_tabpage)</a>
<a name="ln7172">    ? lastused_tabpage-&gt;tp_curwin</a>
<a name="ln7173">    : NULL;</a>
<a name="ln7174"> </a>
<a name="ln7175">  FOR_ALL_TABS(tp) {</a>
<a name="ln7176">    if (got_int) {</a>
<a name="ln7177">       break;</a>
<a name="ln7178">    }</a>
<a name="ln7179"> </a>
<a name="ln7180">    msg_putchar('\n');</a>
<a name="ln7181">    vim_snprintf((char *)IObuff, IOSIZE, _(&quot;Tab page %d&quot;), tabcount++);</a>
<a name="ln7182">    msg_outtrans_attr(IObuff, HL_ATTR(HLF_T));</a>
<a name="ln7183">    ui_flush();            // output one line at a time</a>
<a name="ln7184">    os_breakcheck();</a>
<a name="ln7185"> </a>
<a name="ln7186">    FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln7187">      if (got_int) {</a>
<a name="ln7188">        break;</a>
<a name="ln7189">      }</a>
<a name="ln7190"> </a>
<a name="ln7191">      msg_putchar('\n');</a>
<a name="ln7192">      msg_putchar(wp == curwin ? '&gt;' : wp == lastused_win ? '#' : ' ');</a>
<a name="ln7193">      msg_putchar(' ');</a>
<a name="ln7194">      msg_putchar(bufIsChanged(wp-&gt;w_buffer) ? '+' : ' ');</a>
<a name="ln7195">      msg_putchar(' ');</a>
<a name="ln7196">      if (buf_spname(wp-&gt;w_buffer) != NULL)</a>
<a name="ln7197">        STRLCPY(IObuff, buf_spname(wp-&gt;w_buffer), IOSIZE);</a>
<a name="ln7198">      else</a>
<a name="ln7199">        home_replace(wp-&gt;w_buffer, wp-&gt;w_buffer-&gt;b_fname,</a>
<a name="ln7200">            IObuff, IOSIZE, TRUE);</a>
<a name="ln7201">      msg_outtrans(IObuff);</a>
<a name="ln7202">      ui_flush();                  /* output one line at a time */</a>
<a name="ln7203">      os_breakcheck();</a>
<a name="ln7204">    }</a>
<a name="ln7205">  }</a>
<a name="ln7206">}</a>
<a name="ln7207"> </a>
<a name="ln7208"> </a>
<a name="ln7209">/*</a>
<a name="ln7210"> * &quot;:mode&quot;:</a>
<a name="ln7211"> * If no argument given, get the screen size and redraw.</a>
<a name="ln7212"> */</a>
<a name="ln7213">static void ex_mode(exarg_T *eap)</a>
<a name="ln7214">{</a>
<a name="ln7215">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln7216">    must_redraw = CLEAR;</a>
<a name="ln7217">    ex_redraw(eap);</a>
<a name="ln7218">  } else {</a>
<a name="ln7219">    EMSG(_(e_screenmode));</a>
<a name="ln7220">  }</a>
<a name="ln7221">}</a>
<a name="ln7222"> </a>
<a name="ln7223">/*</a>
<a name="ln7224"> * &quot;:resize&quot;.</a>
<a name="ln7225"> * set, increment or decrement current window height</a>
<a name="ln7226"> */</a>
<a name="ln7227">static void ex_resize(exarg_T *eap)</a>
<a name="ln7228">{</a>
<a name="ln7229">  int n;</a>
<a name="ln7230">  win_T       *wp = curwin;</a>
<a name="ln7231"> </a>
<a name="ln7232">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln7233">    n = eap-&gt;line2;</a>
<a name="ln7234">    for (wp = firstwin; wp-&gt;w_next != NULL &amp;&amp; --n &gt; 0; wp = wp-&gt;w_next)</a>
<a name="ln7235">      ;</a>
<a name="ln7236">  }</a>
<a name="ln7237"> </a>
<a name="ln7238">  n = atol((char *)eap-&gt;arg);</a>
<a name="ln7239">  if (cmdmod.split &amp; WSP_VERT) {</a>
<a name="ln7240">    if (*eap-&gt;arg == '-' || *eap-&gt;arg == '+') {</a>
<a name="ln7241">      n += wp-&gt;w_width;</a>
<a name="ln7242">    } else if (n == 0 &amp;&amp; eap-&gt;arg[0] == NUL) {  // default is very wide</a>
<a name="ln7243">      n = Columns;</a>
<a name="ln7244">    }</a>
<a name="ln7245">    win_setwidth_win(n, wp);</a>
<a name="ln7246">  } else {</a>
<a name="ln7247">    if (*eap-&gt;arg == '-' || *eap-&gt;arg == '+') {</a>
<a name="ln7248">      n += wp-&gt;w_height;</a>
<a name="ln7249">    } else if (n == 0 &amp;&amp; eap-&gt;arg[0] == NUL) {  // default is very high</a>
<a name="ln7250">      n = Rows-1;</a>
<a name="ln7251">    }</a>
<a name="ln7252">    win_setheight_win(n, wp);</a>
<a name="ln7253">  }</a>
<a name="ln7254">}</a>
<a name="ln7255"> </a>
<a name="ln7256">/*</a>
<a name="ln7257"> * &quot;:find [+command] &lt;file&gt;&quot; command.</a>
<a name="ln7258"> */</a>
<a name="ln7259">static void ex_find(exarg_T *eap)</a>
<a name="ln7260">{</a>
<a name="ln7261">  char_u      *fname;</a>
<a name="ln7262">  int count;</a>
<a name="ln7263"> </a>
<a name="ln7264">  fname = find_file_in_path(eap-&gt;arg, STRLEN(eap-&gt;arg),</a>
<a name="ln7265">                            FNAME_MESS, TRUE, curbuf-&gt;b_ffname);</a>
<a name="ln7266">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln7267">    /* Repeat finding the file &quot;count&quot; times.  This matters when it</a>
<a name="ln7268">     * appears several times in the path. */</a>
<a name="ln7269">    count = eap-&gt;line2;</a>
<a name="ln7270">    while (fname != NULL &amp;&amp; --count &gt; 0) {</a>
<a name="ln7271">      xfree(fname);</a>
<a name="ln7272">      fname = find_file_in_path(NULL, 0, FNAME_MESS, FALSE, curbuf-&gt;b_ffname);</a>
<a name="ln7273">    }</a>
<a name="ln7274">  }</a>
<a name="ln7275"> </a>
<a name="ln7276">  if (fname != NULL) {</a>
<a name="ln7277">    eap-&gt;arg = fname;</a>
<a name="ln7278">    do_exedit(eap, NULL);</a>
<a name="ln7279">    xfree(fname);</a>
<a name="ln7280">  }</a>
<a name="ln7281">}</a>
<a name="ln7282"> </a>
<a name="ln7283">/// &quot;:edit&quot;, &quot;:badd&quot;, &quot;:balt&quot;, &quot;:visual&quot;.</a>
<a name="ln7284">static void ex_edit(exarg_T *eap)</a>
<a name="ln7285">{</a>
<a name="ln7286">  do_exedit(eap, NULL);</a>
<a name="ln7287">}</a>
<a name="ln7288"> </a>
<a name="ln7289">/*</a>
<a name="ln7290"> * &quot;:edit &lt;file&gt;&quot; command and alikes.</a>
<a name="ln7291"> */</a>
<a name="ln7292">void</a>
<a name="ln7293">do_exedit(</a>
<a name="ln7294">    exarg_T *eap,</a>
<a name="ln7295">    win_T *old_curwin            /* curwin before doing a split or NULL */</a>
<a name="ln7296">)</a>
<a name="ln7297">{</a>
<a name="ln7298">  int n;</a>
<a name="ln7299">  int need_hide;</a>
<a name="ln7300"> </a>
<a name="ln7301">  /*</a>
<a name="ln7302">   * &quot;:vi&quot; command ends Ex mode.</a>
<a name="ln7303">   */</a>
<a name="ln7304">  if (exmode_active &amp;&amp; (eap-&gt;cmdidx == CMD_visual</a>
<a name="ln7305">                        || eap-&gt;cmdidx == CMD_view)) {</a>
<a name="ln7306">    exmode_active = FALSE;</a>
<a name="ln7307">    if (*eap-&gt;arg == NUL) {</a>
<a name="ln7308">      /* Special case:  &quot;:global/pat/visual\NLvi-commands&quot; */</a>
<a name="ln7309">      if (global_busy) {</a>
<a name="ln7310">        int rd = RedrawingDisabled;</a>
<a name="ln7311">        int nwr = no_wait_return;</a>
<a name="ln7312">        int ms = msg_scroll;</a>
<a name="ln7313"> </a>
<a name="ln7314">        if (eap-&gt;nextcmd != NULL) {</a>
<a name="ln7315">          stuffReadbuff((const char *)eap-&gt;nextcmd);</a>
<a name="ln7316">          eap-&gt;nextcmd = NULL;</a>
<a name="ln7317">        }</a>
<a name="ln7318"> </a>
<a name="ln7319">        RedrawingDisabled = 0;</a>
<a name="ln7320">        no_wait_return = 0;</a>
<a name="ln7321">        need_wait_return = FALSE;</a>
<a name="ln7322">        msg_scroll = 0;</a>
<a name="ln7323">        redraw_all_later(NOT_VALID);</a>
<a name="ln7324"> </a>
<a name="ln7325">        normal_enter(false, true);</a>
<a name="ln7326"> </a>
<a name="ln7327">        RedrawingDisabled = rd;</a>
<a name="ln7328">        no_wait_return = nwr;</a>
<a name="ln7329">        msg_scroll = ms;</a>
<a name="ln7330">      }</a>
<a name="ln7331">      return;</a>
<a name="ln7332">    }</a>
<a name="ln7333">  }</a>
<a name="ln7334"> </a>
<a name="ln7335">  if ((eap-&gt;cmdidx == CMD_new</a>
<a name="ln7336">       || eap-&gt;cmdidx == CMD_tabnew</a>
<a name="ln7337">       || eap-&gt;cmdidx == CMD_tabedit</a>
<a name="ln7338">       || eap-&gt;cmdidx == CMD_vnew</a>
<a name="ln7339">       ) &amp;&amp; *eap-&gt;arg == NUL) {</a>
<a name="ln7340">    /* &quot;:new&quot; or &quot;:tabnew&quot; without argument: edit an new empty buffer */</a>
<a name="ln7341">    setpcmark();</a>
<a name="ln7342">    (void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,</a>
<a name="ln7343">        ECMD_HIDE + (eap-&gt;forceit ? ECMD_FORCEIT : 0),</a>
<a name="ln7344">        old_curwin == NULL ? curwin : NULL);</a>
<a name="ln7345">  } else if ((eap-&gt;cmdidx != CMD_split &amp;&amp; eap-&gt;cmdidx != CMD_vsplit)</a>
<a name="ln7346">             || *eap-&gt;arg != NUL) {</a>
<a name="ln7347">    /* Can't edit another file when &quot;curbuf_lock&quot; is set.  Only &quot;:edit&quot;</a>
<a name="ln7348">     * can bring us here, others are stopped earlier. */</a>
<a name="ln7349">    if (*eap-&gt;arg != NUL &amp;&amp; curbuf_locked())</a>
<a name="ln7350">      return;</a>
<a name="ln7351">    n = readonlymode;</a>
<a name="ln7352">    if (eap-&gt;cmdidx == CMD_view || eap-&gt;cmdidx == CMD_sview)</a>
<a name="ln7353">      readonlymode = TRUE;</a>
<a name="ln7354">    else if (eap-&gt;cmdidx == CMD_enew)</a>
<a name="ln7355">      readonlymode = FALSE;         /* 'readonly' doesn't make sense in an</a>
<a name="ln7356">                                       empty buffer */</a>
<a name="ln7357">    if (eap-&gt;cmdidx != CMD_balt &amp;&amp; eap-&gt;cmdidx != CMD_badd) {</a>
<a name="ln7358">      setpcmark();</a>
<a name="ln7359">    }</a>
<a name="ln7360">    if (do_ecmd(0, (eap-&gt;cmdidx == CMD_enew ? NULL : eap-&gt;arg),</a>
<a name="ln7361">                NULL, eap, eap-&gt;do_ecmd_lnum,</a>
<a name="ln7362">                (buf_hide(curbuf) ? ECMD_HIDE : 0)</a>
<a name="ln7363">                + (eap-&gt;forceit ? ECMD_FORCEIT : 0)</a>
<a name="ln7364">                // After a split we can use an existing buffer.</a>
<a name="ln7365">                + (old_curwin != NULL ? ECMD_OLDBUF : 0)</a>
<a name="ln7366">                + (eap-&gt;cmdidx == CMD_badd ? ECMD_ADDBUF : 0)</a>
<a name="ln7367">                + (eap-&gt;cmdidx == CMD_balt ? ECMD_ALTBUF : 0)</a>
<a name="ln7368">                , old_curwin == NULL ? curwin : NULL) == FAIL) {</a>
<a name="ln7369">      // Editing the file failed.  If the window was split, close it.</a>
<a name="ln7370">      if (old_curwin != NULL) {</a>
<a name="ln7371">        need_hide = (curbufIsChanged() &amp;&amp; curbuf-&gt;b_nwindows &lt;= 1);</a>
<a name="ln7372">        if (!need_hide || buf_hide(curbuf)) {</a>
<a name="ln7373">          cleanup_T cs;</a>
<a name="ln7374"> </a>
<a name="ln7375">          /* Reset the error/interrupt/exception state here so that</a>
<a name="ln7376">           * aborting() returns FALSE when closing a window. */</a>
<a name="ln7377">          enter_cleanup(&amp;cs);</a>
<a name="ln7378">          win_close(curwin, !need_hide &amp;&amp; !buf_hide(curbuf));</a>
<a name="ln7379"> </a>
<a name="ln7380">          /* Restore the error/interrupt/exception state if not</a>
<a name="ln7381">           * discarded by a new aborting error, interrupt, or</a>
<a name="ln7382">           * uncaught exception. */</a>
<a name="ln7383">          leave_cleanup(&amp;cs);</a>
<a name="ln7384">        }</a>
<a name="ln7385">      }</a>
<a name="ln7386">    } else if (readonlymode &amp;&amp; curbuf-&gt;b_nwindows == 1) {</a>
<a name="ln7387">      /* When editing an already visited buffer, 'readonly' won't be set</a>
<a name="ln7388">       * but the previous value is kept.  With &quot;:view&quot; and &quot;:sview&quot; we</a>
<a name="ln7389">       * want the  file to be readonly, except when another window is</a>
<a name="ln7390">       * editing the same buffer. */</a>
<a name="ln7391">      curbuf-&gt;b_p_ro = TRUE;</a>
<a name="ln7392">    }</a>
<a name="ln7393">    readonlymode = n;</a>
<a name="ln7394">  } else {</a>
<a name="ln7395">    if (eap-&gt;do_ecmd_cmd != NULL)</a>
<a name="ln7396">      do_cmdline_cmd((char *)eap-&gt;do_ecmd_cmd);</a>
<a name="ln7397">    n = curwin-&gt;w_arg_idx_invalid;</a>
<a name="ln7398">    check_arg_idx(curwin);</a>
<a name="ln7399">    if (n != curwin-&gt;w_arg_idx_invalid)</a>
<a name="ln7400">      maketitle();</a>
<a name="ln7401">  }</a>
<a name="ln7402"> </a>
<a name="ln7403">  /*</a>
<a name="ln7404">   * if &quot;:split file&quot; worked, set alternate file name in old window to new</a>
<a name="ln7405">   * file</a>
<a name="ln7406">   */</a>
<a name="ln7407">  if (old_curwin != NULL</a>
<a name="ln7408">      &amp;&amp; *eap-&gt;arg != NUL</a>
<a name="ln7409">      &amp;&amp; curwin != old_curwin</a>
<a name="ln7410">      &amp;&amp; win_valid(old_curwin)</a>
<a name="ln7411">      &amp;&amp; old_curwin-&gt;w_buffer != curbuf</a>
<a name="ln7412">      &amp;&amp; !cmdmod.keepalt)</a>
<a name="ln7413">    old_curwin-&gt;w_alt_fnum = curbuf-&gt;b_fnum;</a>
<a name="ln7414"> </a>
<a name="ln7415">  ex_no_reprint = TRUE;</a>
<a name="ln7416">}</a>
<a name="ln7417"> </a>
<a name="ln7418">/// &quot;:gui&quot; and &quot;:gvim&quot; when there is no GUI.</a>
<a name="ln7419">static void ex_nogui(exarg_T *eap)</a>
<a name="ln7420">{</a>
<a name="ln7421">  eap-&gt;errmsg = (char_u *)N_(&quot;E25: Nvim does not have a built-in GUI&quot;);</a>
<a name="ln7422">}</a>
<a name="ln7423"> </a>
<a name="ln7424"> </a>
<a name="ln7425"> </a>
<a name="ln7426">static void ex_swapname(exarg_T *eap)</a>
<a name="ln7427">{</a>
<a name="ln7428">  if (curbuf-&gt;b_ml.ml_mfp == NULL || curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname == NULL)</a>
<a name="ln7429">    MSG(_(&quot;No swap file&quot;));</a>
<a name="ln7430">  else</a>
<a name="ln7431">    msg(curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname);</a>
<a name="ln7432">}</a>
<a name="ln7433"> </a>
<a name="ln7434">/*</a>
<a name="ln7435"> * &quot;:syncbind&quot; forces all 'scrollbind' windows to have the same relative</a>
<a name="ln7436"> * offset.</a>
<a name="ln7437"> * (1998-11-02 16:21:01  R. Edward Ralston &lt;eralston@computer.org&gt;)</a>
<a name="ln7438"> */</a>
<a name="ln7439">static void ex_syncbind(exarg_T *eap)</a>
<a name="ln7440">{</a>
<a name="ln7441">  win_T       *save_curwin = curwin;</a>
<a name="ln7442">  buf_T       *save_curbuf = curbuf;</a>
<a name="ln7443">  long topline;</a>
<a name="ln7444">  long y;</a>
<a name="ln7445">  linenr_T old_linenr = curwin-&gt;w_cursor.lnum;</a>
<a name="ln7446"> </a>
<a name="ln7447">  setpcmark();</a>
<a name="ln7448"> </a>
<a name="ln7449">  /*</a>
<a name="ln7450">   * determine max topline</a>
<a name="ln7451">   */</a>
<a name="ln7452">  if (curwin-&gt;w_p_scb) {</a>
<a name="ln7453">    topline = curwin-&gt;w_topline;</a>
<a name="ln7454">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln7455">      if (wp-&gt;w_p_scb &amp;&amp; wp-&gt;w_buffer) {</a>
<a name="ln7456">        y = wp-&gt;w_buffer-&gt;b_ml.ml_line_count - get_scrolloff_value(curwin);</a>
<a name="ln7457">        if (topline &gt; y) {</a>
<a name="ln7458">          topline = y;</a>
<a name="ln7459">        }</a>
<a name="ln7460">      }</a>
<a name="ln7461">    }</a>
<a name="ln7462">    if (topline &lt; 1) {</a>
<a name="ln7463">      topline = 1;</a>
<a name="ln7464">    }</a>
<a name="ln7465">  } else {</a>
<a name="ln7466">    topline = 1;</a>
<a name="ln7467">  }</a>
<a name="ln7468"> </a>
<a name="ln7469"> </a>
<a name="ln7470">  /*</a>
<a name="ln7471">   * Set all scrollbind windows to the same topline.</a>
<a name="ln7472">   */</a>
<a name="ln7473">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln7474">    curwin = wp;</a>
<a name="ln7475">    if (curwin-&gt;w_p_scb) {</a>
<a name="ln7476">      curbuf = curwin-&gt;w_buffer;</a>
<a name="ln7477">      y = topline - curwin-&gt;w_topline;</a>
<a name="ln7478">      if (y &gt; 0)</a>
<a name="ln7479">        scrollup(y, TRUE);</a>
<a name="ln7480">      else</a>
<a name="ln7481">        scrolldown(-y, TRUE);</a>
<a name="ln7482">      curwin-&gt;w_scbind_pos = topline;</a>
<a name="ln7483">      redraw_later(curwin, VALID);</a>
<a name="ln7484">      cursor_correct();</a>
<a name="ln7485">      curwin-&gt;w_redr_status = TRUE;</a>
<a name="ln7486">    }</a>
<a name="ln7487">  }</a>
<a name="ln7488">  curwin = save_curwin;</a>
<a name="ln7489">  curbuf = save_curbuf;</a>
<a name="ln7490">  if (curwin-&gt;w_p_scb) {</a>
<a name="ln7491">    did_syncbind = TRUE;</a>
<a name="ln7492">    checkpcmark();</a>
<a name="ln7493">    if (old_linenr != curwin-&gt;w_cursor.lnum) {</a>
<a name="ln7494">      char_u ctrl_o[2];</a>
<a name="ln7495"> </a>
<a name="ln7496">      ctrl_o[0] = Ctrl_O;</a>
<a name="ln7497">      ctrl_o[1] = 0;</a>
<a name="ln7498">      ins_typebuf(ctrl_o, REMAP_NONE, 0, true, false);</a>
<a name="ln7499">    }</a>
<a name="ln7500">  }</a>
<a name="ln7501">}</a>
<a name="ln7502"> </a>
<a name="ln7503"> </a>
<a name="ln7504">static void ex_read(exarg_T *eap)</a>
<a name="ln7505">{</a>
<a name="ln7506">  int i;</a>
<a name="ln7507">  int empty = (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY);</a>
<a name="ln7508">  linenr_T lnum;</a>
<a name="ln7509"> </a>
<a name="ln7510">  if (eap-&gt;usefilter) {  // :r!cmd</a>
<a name="ln7511">    do_bang(1, eap, false, false, true);</a>
<a name="ln7512">  } else {</a>
<a name="ln7513">    if (u_save(eap-&gt;line2, (linenr_T)(eap-&gt;line2 + 1)) == FAIL) {</a>
<a name="ln7514">      return;</a>
<a name="ln7515">    }</a>
<a name="ln7516"> </a>
<a name="ln7517">    if (*eap-&gt;arg == NUL) {</a>
<a name="ln7518">      if (check_fname() == FAIL) {       // check for no file name</a>
<a name="ln7519">        return;</a>
<a name="ln7520">      }</a>
<a name="ln7521">      i = readfile(curbuf-&gt;b_ffname, curbuf-&gt;b_fname,</a>
<a name="ln7522">          eap-&gt;line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);</a>
<a name="ln7523">    } else {</a>
<a name="ln7524">      if (vim_strchr(p_cpo, CPO_ALTREAD) != NULL)</a>
<a name="ln7525">        (void)setaltfname(eap-&gt;arg, eap-&gt;arg, (linenr_T)1);</a>
<a name="ln7526">      i = readfile(eap-&gt;arg, NULL,</a>
<a name="ln7527">          eap-&gt;line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);</a>
<a name="ln7528"> </a>
<a name="ln7529">    }</a>
<a name="ln7530">    if (i != OK) {</a>
<a name="ln7531">      if (!aborting()) {</a>
<a name="ln7532">        EMSG2(_(e_notopen), eap-&gt;arg);</a>
<a name="ln7533">      }</a>
<a name="ln7534">    } else {</a>
<a name="ln7535">      if (empty &amp;&amp; exmode_active) {</a>
<a name="ln7536">        /* Delete the empty line that remains.  Historically ex does</a>
<a name="ln7537">         * this but vi doesn't. */</a>
<a name="ln7538">        if (eap-&gt;line2 == 0)</a>
<a name="ln7539">          lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln7540">        else</a>
<a name="ln7541">          lnum = 1;</a>
<a name="ln7542">        if (*ml_get(lnum) == NUL &amp;&amp; u_savedel(lnum, 1L) == OK) {</a>
<a name="ln7543">          ml_delete(lnum, false);</a>
<a name="ln7544">          if (curwin-&gt;w_cursor.lnum &gt; 1</a>
<a name="ln7545">              &amp;&amp; curwin-&gt;w_cursor.lnum &gt;= lnum) {</a>
<a name="ln7546">            curwin-&gt;w_cursor.lnum--;</a>
<a name="ln7547">          }</a>
<a name="ln7548">          deleted_lines_mark(lnum, 1L);</a>
<a name="ln7549">        }</a>
<a name="ln7550">      }</a>
<a name="ln7551">      redraw_curbuf_later(VALID);</a>
<a name="ln7552">    }</a>
<a name="ln7553">  }</a>
<a name="ln7554">}</a>
<a name="ln7555"> </a>
<a name="ln7556">static char_u   *prev_dir = NULL;</a>
<a name="ln7557"> </a>
<a name="ln7558">#if defined(EXITFREE)</a>
<a name="ln7559">void free_cd_dir(void)</a>
<a name="ln7560">{</a>
<a name="ln7561">  XFREE_CLEAR(prev_dir);</a>
<a name="ln7562">  XFREE_CLEAR(globaldir);</a>
<a name="ln7563">}</a>
<a name="ln7564"> </a>
<a name="ln7565">#endif</a>
<a name="ln7566"> </a>
<a name="ln7567">/// Deal with the side effects of changing the current directory.</a>
<a name="ln7568">///</a>
<a name="ln7569">/// @param scope  Scope of the function call (global, tab or window).</a>
<a name="ln7570">void post_chdir(CdScope scope, bool trigger_dirchanged)</a>
<a name="ln7571">{</a>
<a name="ln7572">  // Always overwrite the window-local CWD.</a>
<a name="ln7573">  XFREE_CLEAR(curwin-&gt;w_localdir);</a>
<a name="ln7574"> </a>
<a name="ln7575">  // Overwrite the tab-local CWD for :cd, :tcd.</a>
<a name="ln7576">  if (scope &gt;= kCdScopeTab) {</a>
<a name="ln7577">    XFREE_CLEAR(curtab-&gt;tp_localdir);</a>
<a name="ln7578">  }</a>
<a name="ln7579"> </a>
<a name="ln7580">  if (scope &lt; kCdScopeGlobal) {</a>
<a name="ln7581">    // If still in global directory, set CWD as the global directory.</a>
<a name="ln7582">    if (globaldir == NULL &amp;&amp; prev_dir != NULL) {</a>
<a name="ln7583">      globaldir = vim_strsave(prev_dir);</a>
<a name="ln7584">    }</a>
<a name="ln7585">  }</a>
<a name="ln7586"> </a>
<a name="ln7587">  char cwd[MAXPATHL];</a>
<a name="ln7588">  if (os_dirname((char_u *)cwd, MAXPATHL) != OK) {</a>
<a name="ln7589">    return;</a>
<a name="ln7590">  }</a>
<a name="ln7591">  switch (scope) {</a>
<a name="ln7592">  case kCdScopeGlobal:</a>
<a name="ln7593">    // We are now in the global directory, no need to remember its name.</a>
<a name="ln7594">    XFREE_CLEAR(globaldir);</a>
<a name="ln7595">    break;</a>
<a name="ln7596">  case kCdScopeTab:</a>
<a name="ln7597">    curtab-&gt;tp_localdir = (char_u *)xstrdup(cwd);</a>
<a name="ln7598">    break;</a>
<a name="ln7599">  case kCdScopeWindow:</a>
<a name="ln7600">    curwin-&gt;w_localdir = (char_u *)xstrdup(cwd);</a>
<a name="ln7601">    break;</a>
<a name="ln7602">  case kCdScopeInvalid:</a>
<a name="ln7603">    abort();</a>
<a name="ln7604">  }</a>
<a name="ln7605"> </a>
<a name="ln7606">  shorten_fnames(true);</a>
<a name="ln7607"> </a>
<a name="ln7608">  if (trigger_dirchanged) {</a>
<a name="ln7609">    do_autocmd_dirchanged(cwd, scope, false);</a>
<a name="ln7610">  }</a>
<a name="ln7611">}</a>
<a name="ln7612"> </a>
<a name="ln7613">/// `:cd`, `:tcd`, `:lcd`, `:chdir`, `:tchdir` and `:lchdir`.</a>
<a name="ln7614">void ex_cd(exarg_T *eap)</a>
<a name="ln7615">{</a>
<a name="ln7616">  char_u              *new_dir;</a>
<a name="ln7617">  char_u              *tofree;</a>
<a name="ln7618"> </a>
<a name="ln7619">  new_dir = eap-&gt;arg;</a>
<a name="ln7620">#if !defined(UNIX)</a>
<a name="ln7621">  /* for non-UNIX &quot;:cd&quot; means: print current directory */</a>
<a name="ln7622">  if (*new_dir == NUL)</a>
<a name="ln7623">    ex_pwd(NULL);</a>
<a name="ln7624">  else</a>
<a name="ln7625">#endif</a>
<a name="ln7626">  {</a>
<a name="ln7627">    if (allbuf_locked())</a>
<a name="ln7628">      return;</a>
<a name="ln7629"> </a>
<a name="ln7630">    /* &quot;:cd -&quot;: Change to previous directory */</a>
<a name="ln7631">    if (STRCMP(new_dir, &quot;-&quot;) == 0) {</a>
<a name="ln7632">      if (prev_dir == NULL) {</a>
<a name="ln7633">        EMSG(_(&quot;E186: No previous directory&quot;));</a>
<a name="ln7634">        return;</a>
<a name="ln7635">      }</a>
<a name="ln7636">      new_dir = prev_dir;</a>
<a name="ln7637">    }</a>
<a name="ln7638"> </a>
<a name="ln7639">    /* Save current directory for next &quot;:cd -&quot; */</a>
<a name="ln7640">    tofree = prev_dir;</a>
<a name="ln7641">    if (os_dirname(NameBuff, MAXPATHL) == OK)</a>
<a name="ln7642">      prev_dir = vim_strsave(NameBuff);</a>
<a name="ln7643">    else</a>
<a name="ln7644">      prev_dir = NULL;</a>
<a name="ln7645"> </a>
<a name="ln7646">#if defined(UNIX)</a>
<a name="ln7647">    // On Unix &quot;:cd&quot; means: go to home directory.</a>
<a name="ln7648">    if (*new_dir == NUL) {</a>
<a name="ln7649">      // Use NameBuff for home directory name.</a>
<a name="ln7650">      expand_env((char_u *)&quot;$HOME&quot;, NameBuff, MAXPATHL);</a>
<a name="ln7651">      new_dir = NameBuff;</a>
<a name="ln7652">    }</a>
<a name="ln7653">#endif</a>
<a name="ln7654">    CdScope scope = kCdScopeGlobal;  // Depends on command invoked</a>
<a name="ln7655"> </a>
<a name="ln7656">    switch (eap-&gt;cmdidx) {</a>
<a name="ln7657">    case CMD_tcd:</a>
<a name="ln7658">    case CMD_tchdir:</a>
<a name="ln7659">      scope = kCdScopeTab;</a>
<a name="ln7660">      break;</a>
<a name="ln7661">    case CMD_lcd:</a>
<a name="ln7662">    case CMD_lchdir:</a>
<a name="ln7663">      scope = kCdScopeWindow;</a>
<a name="ln7664">      break;</a>
<a name="ln7665">    default:</a>
<a name="ln7666">      break;</a>
<a name="ln7667">    }</a>
<a name="ln7668"> </a>
<a name="ln7669">    if (vim_chdir(new_dir)) {</a>
<a name="ln7670">      EMSG(_(e_failed));</a>
<a name="ln7671">    } else {</a>
<a name="ln7672">      post_chdir(scope, true);</a>
<a name="ln7673">      // Echo the new current directory if the command was typed.</a>
<a name="ln7674">      if (KeyTyped || p_verbose &gt;= 5) {</a>
<a name="ln7675">        ex_pwd(eap);</a>
<a name="ln7676">      }</a>
<a name="ln7677">    }</a>
<a name="ln7678"> </a>
<a name="ln7679">    xfree(tofree);</a>
<a name="ln7680">  }</a>
<a name="ln7681">}</a>
<a name="ln7682"> </a>
<a name="ln7683">/*</a>
<a name="ln7684"> * &quot;:pwd&quot;.</a>
<a name="ln7685"> */</a>
<a name="ln7686">static void ex_pwd(exarg_T *eap)</a>
<a name="ln7687">{</a>
<a name="ln7688">  if (os_dirname(NameBuff, MAXPATHL) == OK) {</a>
<a name="ln7689">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln7690">    slash_adjust(NameBuff);</a>
<a name="ln7691">#endif</a>
<a name="ln7692">    msg(NameBuff);</a>
<a name="ln7693">  } else</a>
<a name="ln7694">    EMSG(_(&quot;E187: Unknown&quot;));</a>
<a name="ln7695">}</a>
<a name="ln7696"> </a>
<a name="ln7697">/*</a>
<a name="ln7698"> * &quot;:=&quot;.</a>
<a name="ln7699"> */</a>
<a name="ln7700">static void ex_equal(exarg_T *eap)</a>
<a name="ln7701">{</a>
<a name="ln7702">  smsg(&quot;%&quot; PRId64, (int64_t)eap-&gt;line2);</a>
<a name="ln7703">  ex_may_print(eap);</a>
<a name="ln7704">}</a>
<a name="ln7705"> </a>
<a name="ln7706">static void ex_sleep(exarg_T *eap)</a>
<a name="ln7707">{</a>
<a name="ln7708">  int n;</a>
<a name="ln7709">  long len;</a>
<a name="ln7710"> </a>
<a name="ln7711">  if (cursor_valid()) {</a>
<a name="ln7712">    n = curwin-&gt;w_winrow + curwin-&gt;w_wrow - msg_scrolled;</a>
<a name="ln7713">    if (n &gt;= 0)</a>
<a name="ln7714">      ui_cursor_goto(n, curwin-&gt;w_wincol + curwin-&gt;w_wcol);</a>
<a name="ln7715">  }</a>
<a name="ln7716"> </a>
<a name="ln7717">  len = eap-&gt;line2;</a>
<a name="ln7718">  switch (*eap-&gt;arg) {</a>
<a name="ln7719">  case 'm': break;</a>
<a name="ln7720">  case NUL: len *= 1000L; break;</a>
<a name="ln7721">  default: EMSG2(_(e_invarg2), eap-&gt;arg); return;</a>
<a name="ln7722">  }</a>
<a name="ln7723">  do_sleep(len);</a>
<a name="ln7724">}</a>
<a name="ln7725"> </a>
<a name="ln7726">/*</a>
<a name="ln7727"> * Sleep for &quot;msec&quot; milliseconds, but keep checking for a CTRL-C every second.</a>
<a name="ln7728"> */</a>
<a name="ln7729">void do_sleep(long msec)</a>
<a name="ln7730">{</a>
<a name="ln7731">  ui_flush();  // flush before waiting</a>
<a name="ln7732">  for (long left = msec; !got_int &amp;&amp; left &gt; 0; left -= 1000L) {</a>
<a name="ln7733">    int next = left &gt; 1000l ? 1000 : (int)left;</a>
<a name="ln7734">    LOOP_PROCESS_EVENTS_UNTIL(&amp;main_loop, main_loop.events, (int)next, got_int);</a>
<a name="ln7735">    os_breakcheck();</a>
<a name="ln7736">  }</a>
<a name="ln7737"> </a>
<a name="ln7738">  // If CTRL-C was typed to interrupt the sleep, drop the CTRL-C from the</a>
<a name="ln7739">  // input buffer, otherwise a following call to input() fails.</a>
<a name="ln7740">  if (got_int) {</a>
<a name="ln7741">    (void)vpeekc();</a>
<a name="ln7742">  }</a>
<a name="ln7743">}</a>
<a name="ln7744"> </a>
<a name="ln7745">static void do_exmap(exarg_T *eap, int isabbrev)</a>
<a name="ln7746">{</a>
<a name="ln7747">  int mode;</a>
<a name="ln7748">  char_u  *cmdp;</a>
<a name="ln7749"> </a>
<a name="ln7750">  cmdp = eap-&gt;cmd;</a>
<a name="ln7751">  mode = get_map_mode(&amp;cmdp, eap-&gt;forceit || isabbrev);</a>
<a name="ln7752"> </a>
<a name="ln7753">  switch (do_map((*cmdp == 'n') ? 2 : (*cmdp == 'u'),</a>
<a name="ln7754">              eap-&gt;arg, mode, isabbrev)) {</a>
<a name="ln7755">  case 1: EMSG(_(e_invarg));</a>
<a name="ln7756">    break;</a>
<a name="ln7757">  case 2: EMSG(isabbrev ? _(e_noabbr) : _(e_nomap));</a>
<a name="ln7758">    break;</a>
<a name="ln7759">  }</a>
<a name="ln7760">}</a>
<a name="ln7761"> </a>
<a name="ln7762">/*</a>
<a name="ln7763"> * &quot;:winsize&quot; command (obsolete).</a>
<a name="ln7764"> */</a>
<a name="ln7765">static void ex_winsize(exarg_T *eap)</a>
<a name="ln7766">{</a>
<a name="ln7767">  char_u *arg = eap-&gt;arg;</a>
<a name="ln7768"> </a>
<a name="ln7769">  if (!ascii_isdigit(*arg)) {</a>
<a name="ln7770">    EMSG2(_(e_invarg2), arg);</a>
<a name="ln7771">    return;</a>
<a name="ln7772">  }</a>
<a name="ln7773">  int w = getdigits_int(&amp;arg, false, 10);</a>
<a name="ln7774">  arg = skipwhite(arg);</a>
<a name="ln7775">  char_u *p = arg;</a>
<a name="ln7776">  int h = getdigits_int(&amp;arg, false, 10);</a>
<a name="ln7777">  if (*p != NUL &amp;&amp; *arg == NUL) {</a>
<a name="ln7778">    screen_resize(w, h);</a>
<a name="ln7779">  } else {</a>
<a name="ln7780">    EMSG(_(&quot;E465: :winsize requires two number arguments&quot;));</a>
<a name="ln7781">  }</a>
<a name="ln7782">}</a>
<a name="ln7783"> </a>
<a name="ln7784">static void ex_wincmd(exarg_T *eap)</a>
<a name="ln7785">{</a>
<a name="ln7786">  int xchar = NUL;</a>
<a name="ln7787">  char_u      *p;</a>
<a name="ln7788"> </a>
<a name="ln7789">  if (*eap-&gt;arg == 'g' || *eap-&gt;arg == Ctrl_G) {</a>
<a name="ln7790">    /* CTRL-W g and CTRL-W CTRL-G  have an extra command character */</a>
<a name="ln7791">    if (eap-&gt;arg[1] == NUL) {</a>
<a name="ln7792">      EMSG(_(e_invarg));</a>
<a name="ln7793">      return;</a>
<a name="ln7794">    }</a>
<a name="ln7795">    xchar = eap-&gt;arg[1];</a>
<a name="ln7796">    p = eap-&gt;arg + 2;</a>
<a name="ln7797">  } else</a>
<a name="ln7798">    p = eap-&gt;arg + 1;</a>
<a name="ln7799"> </a>
<a name="ln7800">  eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln7801">  p = skipwhite(p);</a>
<a name="ln7802">  if (*p != NUL &amp;&amp; *p != '&quot;' &amp;&amp; eap-&gt;nextcmd == NULL)</a>
<a name="ln7803">    EMSG(_(e_invarg));</a>
<a name="ln7804">  else if (!eap-&gt;skip) {</a>
<a name="ln7805">    /* Pass flags on for &quot;:vertical wincmd ]&quot;. */</a>
<a name="ln7806">    postponed_split_flags = cmdmod.split;</a>
<a name="ln7807">    postponed_split_tab = cmdmod.tab;</a>
<a name="ln7808">    do_window(*eap-&gt;arg, eap-&gt;addr_count &gt; 0 ? eap-&gt;line2 : 0L, xchar);</a>
<a name="ln7809">    postponed_split_flags = 0;</a>
<a name="ln7810">    postponed_split_tab = 0;</a>
<a name="ln7811">  }</a>
<a name="ln7812">}</a>
<a name="ln7813"> </a>
<a name="ln7814">/*</a>
<a name="ln7815"> * Handle command that work like operators: &quot;:delete&quot;, &quot;:yank&quot;, &quot;:&gt;&quot; and &quot;:&lt;&quot;.</a>
<a name="ln7816"> */</a>
<a name="ln7817">static void ex_operators(exarg_T *eap)</a>
<a name="ln7818">{</a>
<a name="ln7819">  oparg_T oa;</a>
<a name="ln7820"> </a>
<a name="ln7821">  clear_oparg(&amp;oa);</a>
<a name="ln7822">  oa.regname = eap-&gt;regname;</a>
<a name="ln7823">  oa.start.lnum = eap-&gt;line1;</a>
<a name="ln7824">  oa.end.lnum = eap-&gt;line2;</a>
<a name="ln7825">  oa.line_count = eap-&gt;line2 - eap-&gt;line1 + 1;</a>
<a name="ln7826">  oa.motion_type = kMTLineWise;</a>
<a name="ln7827">  virtual_op = kFalse;</a>
<a name="ln7828">  if (eap-&gt;cmdidx != CMD_yank) {  // position cursor for undo</a>
<a name="ln7829">    setpcmark();</a>
<a name="ln7830">    curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln7831">    beginline(BL_SOL | BL_FIX);</a>
<a name="ln7832">  }</a>
<a name="ln7833"> </a>
<a name="ln7834">  if (VIsual_active)</a>
<a name="ln7835">    end_visual_mode();</a>
<a name="ln7836"> </a>
<a name="ln7837">  switch (eap-&gt;cmdidx) {</a>
<a name="ln7838">  case CMD_delete:</a>
<a name="ln7839">    oa.op_type = OP_DELETE;</a>
<a name="ln7840">    op_delete(&amp;oa);</a>
<a name="ln7841">    break;</a>
<a name="ln7842"> </a>
<a name="ln7843">  case CMD_yank:</a>
<a name="ln7844">    oa.op_type = OP_YANK;</a>
<a name="ln7845">    (void)op_yank(&amp;oa, true, false);</a>
<a name="ln7846">    break;</a>
<a name="ln7847"> </a>
<a name="ln7848">  default:          /* CMD_rshift or CMD_lshift */</a>
<a name="ln7849">    if (</a>
<a name="ln7850">      (eap-&gt;cmdidx == CMD_rshift) ^ curwin-&gt;w_p_rl</a>
<a name="ln7851">      )</a>
<a name="ln7852">      oa.op_type = OP_RSHIFT;</a>
<a name="ln7853">    else</a>
<a name="ln7854">      oa.op_type = OP_LSHIFT;</a>
<a name="ln7855">    op_shift(&amp;oa, FALSE, eap-&gt;amount);</a>
<a name="ln7856">    break;</a>
<a name="ln7857">  }</a>
<a name="ln7858">  virtual_op = kNone;</a>
<a name="ln7859">  ex_may_print(eap);</a>
<a name="ln7860">}</a>
<a name="ln7861"> </a>
<a name="ln7862">/*</a>
<a name="ln7863"> * &quot;:put&quot;.</a>
<a name="ln7864"> */</a>
<a name="ln7865">static void ex_put(exarg_T *eap)</a>
<a name="ln7866">{</a>
<a name="ln7867">  /* &quot;:0put&quot; works like &quot;:1put!&quot;. */</a>
<a name="ln7868">  if (eap-&gt;line2 == 0) {</a>
<a name="ln7869">    eap-&gt;line2 = 1;</a>
<a name="ln7870">    eap-&gt;forceit = TRUE;</a>
<a name="ln7871">  }</a>
<a name="ln7872">  curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln7873">  do_put(eap-&gt;regname, NULL, eap-&gt;forceit ? BACKWARD : FORWARD, 1,</a>
<a name="ln7874">         PUT_LINE|PUT_CURSLINE);</a>
<a name="ln7875">}</a>
<a name="ln7876"> </a>
<a name="ln7877">/*</a>
<a name="ln7878"> * Handle &quot;:copy&quot; and &quot;:move&quot;.</a>
<a name="ln7879"> */</a>
<a name="ln7880">static void ex_copymove(exarg_T *eap)</a>
<a name="ln7881">{</a>
<a name="ln7882">  long n = get_address(eap, &amp;eap-&gt;arg, eap-&gt;addr_type, false, false, false, 1);</a>
<a name="ln7883">  if (eap-&gt;arg == NULL) {  // error detected</a>
<a name="ln7884">    eap-&gt;nextcmd = NULL;</a>
<a name="ln7885">    return;</a>
<a name="ln7886">  }</a>
<a name="ln7887">  get_flags(eap);</a>
<a name="ln7888"> </a>
<a name="ln7889">  /*</a>
<a name="ln7890">   * move or copy lines from 'eap-&gt;line1'-'eap-&gt;line2' to below line 'n'</a>
<a name="ln7891">   */</a>
<a name="ln7892">  if (n == MAXLNUM || n &lt; 0 || n &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln7893">    EMSG(_(e_invrange));</a>
<a name="ln7894">    return;</a>
<a name="ln7895">  }</a>
<a name="ln7896"> </a>
<a name="ln7897">  if (eap-&gt;cmdidx == CMD_move) {</a>
<a name="ln7898">    if (do_move(eap-&gt;line1, eap-&gt;line2, n) == FAIL)</a>
<a name="ln7899">      return;</a>
<a name="ln7900">  } else</a>
<a name="ln7901">    ex_copy(eap-&gt;line1, eap-&gt;line2, n);</a>
<a name="ln7902">  u_clearline();</a>
<a name="ln7903">  beginline(BL_SOL | BL_FIX);</a>
<a name="ln7904">  ex_may_print(eap);</a>
<a name="ln7905">}</a>
<a name="ln7906"> </a>
<a name="ln7907">/*</a>
<a name="ln7908"> * Print the current line if flags were given to the Ex command.</a>
<a name="ln7909"> */</a>
<a name="ln7910">void ex_may_print(exarg_T *eap)</a>
<a name="ln7911">{</a>
<a name="ln7912">  if (eap-&gt;flags != 0) {</a>
<a name="ln7913">    print_line(curwin-&gt;w_cursor.lnum, (eap-&gt;flags &amp; EXFLAG_NR),</a>
<a name="ln7914">        (eap-&gt;flags &amp; EXFLAG_LIST));</a>
<a name="ln7915">    ex_no_reprint = TRUE;</a>
<a name="ln7916">  }</a>
<a name="ln7917">}</a>
<a name="ln7918"> </a>
<a name="ln7919">/// &quot;:smagic&quot; and &quot;:snomagic&quot;.</a>
<a name="ln7920">static void ex_submagic(exarg_T *eap)</a>
<a name="ln7921">{</a>
<a name="ln7922">  int magic_save = p_magic;</a>
<a name="ln7923"> </a>
<a name="ln7924">  p_magic = (eap-&gt;cmdidx == CMD_smagic);</a>
<a name="ln7925">  ex_substitute(eap);</a>
<a name="ln7926">  p_magic = magic_save;</a>
<a name="ln7927">}</a>
<a name="ln7928"> </a>
<a name="ln7929">/*</a>
<a name="ln7930"> * &quot;:join&quot;.</a>
<a name="ln7931"> */</a>
<a name="ln7932">static void ex_join(exarg_T *eap)</a>
<a name="ln7933">{</a>
<a name="ln7934">  curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln7935">  if (eap-&gt;line1 == eap-&gt;line2) {</a>
<a name="ln7936">    if (eap-&gt;addr_count &gt;= 2)       /* :2,2join does nothing */</a>
<a name="ln7937">      return;</a>
<a name="ln7938">    if (eap-&gt;line2 == curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln7939">      beep_flush();</a>
<a name="ln7940">      return;</a>
<a name="ln7941">    }</a>
<a name="ln7942">    ++eap-&gt;line2;</a>
<a name="ln7943">  }</a>
<a name="ln7944">  do_join(eap-&gt;line2 - eap-&gt;line1 + 1, !eap-&gt;forceit, TRUE, TRUE, true);</a>
<a name="ln7945">  beginline(BL_WHITE | BL_FIX);</a>
<a name="ln7946">  ex_may_print(eap);</a>
<a name="ln7947">}</a>
<a name="ln7948"> </a>
<a name="ln7949">/*</a>
<a name="ln7950"> * &quot;:[addr]@r&quot;: execute register</a>
<a name="ln7951"> */</a>
<a name="ln7952">static void ex_at(exarg_T *eap)</a>
<a name="ln7953">{</a>
<a name="ln7954">  int prev_len = typebuf.tb_len;</a>
<a name="ln7955"> </a>
<a name="ln7956">  curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln7957">  check_cursor_col();</a>
<a name="ln7958"> </a>
<a name="ln7959">  // Get the register name. No name means use the previous one.</a>
<a name="ln7960">  int c = *eap-&gt;arg;</a>
<a name="ln7961">  if (c == NUL) {</a>
<a name="ln7962">    c = '@';</a>
<a name="ln7963">  }</a>
<a name="ln7964"> </a>
<a name="ln7965">  /* Put the register in the typeahead buffer with the &quot;silent&quot; flag. */</a>
<a name="ln7966">  if (do_execreg(c, TRUE, vim_strchr(p_cpo, CPO_EXECBUF) != NULL, TRUE)</a>
<a name="ln7967">      == FAIL) {</a>
<a name="ln7968">    beep_flush();</a>
<a name="ln7969">  } else {</a>
<a name="ln7970">    int save_efr = exec_from_reg;</a>
<a name="ln7971"> </a>
<a name="ln7972">    exec_from_reg = TRUE;</a>
<a name="ln7973"> </a>
<a name="ln7974">    /*</a>
<a name="ln7975">     * Execute from the typeahead buffer.</a>
<a name="ln7976">     * Continue until the stuff buffer is empty and all added characters</a>
<a name="ln7977">     * have been consumed.</a>
<a name="ln7978">     */</a>
<a name="ln7979">    while (!stuff_empty() || typebuf.tb_len &gt; prev_len)</a>
<a name="ln7980">      (void)do_cmdline(NULL, getexline, NULL, DOCMD_NOWAIT|DOCMD_VERBOSE);</a>
<a name="ln7981"> </a>
<a name="ln7982">    exec_from_reg = save_efr;</a>
<a name="ln7983">  }</a>
<a name="ln7984">}</a>
<a name="ln7985"> </a>
<a name="ln7986">/*</a>
<a name="ln7987"> * &quot;:!&quot;.</a>
<a name="ln7988"> */</a>
<a name="ln7989">static void ex_bang(exarg_T *eap)</a>
<a name="ln7990">{</a>
<a name="ln7991">  do_bang(eap-&gt;addr_count, eap, eap-&gt;forceit, true, true);</a>
<a name="ln7992">}</a>
<a name="ln7993"> </a>
<a name="ln7994">/*</a>
<a name="ln7995"> * &quot;:undo&quot;.</a>
<a name="ln7996"> */</a>
<a name="ln7997">static void ex_undo(exarg_T *eap)</a>
<a name="ln7998">{</a>
<a name="ln7999">  if (eap-&gt;addr_count == 1) {       // :undo 123</a>
<a name="ln8000">    undo_time(eap-&gt;line2, false, false, true);</a>
<a name="ln8001">  } else {</a>
<a name="ln8002">    u_undo(1);</a>
<a name="ln8003">  }</a>
<a name="ln8004">}</a>
<a name="ln8005"> </a>
<a name="ln8006">static void ex_wundo(exarg_T *eap)</a>
<a name="ln8007">{</a>
<a name="ln8008">  char_u hash[UNDO_HASH_SIZE];</a>
<a name="ln8009"> </a>
<a name="ln8010">  u_compute_hash(hash);</a>
<a name="ln8011">  u_write_undo((char *) eap-&gt;arg, eap-&gt;forceit, curbuf, hash);</a>
<a name="ln8012">}</a>
<a name="ln8013"> </a>
<a name="ln8014">static void ex_rundo(exarg_T *eap)</a>
<a name="ln8015">{</a>
<a name="ln8016">  char_u hash[UNDO_HASH_SIZE];</a>
<a name="ln8017"> </a>
<a name="ln8018">  u_compute_hash(hash);</a>
<a name="ln8019">  u_read_undo((char *) eap-&gt;arg, hash, NULL);</a>
<a name="ln8020">}</a>
<a name="ln8021"> </a>
<a name="ln8022">/// &quot;:redo&quot;.</a>
<a name="ln8023">static void ex_redo(exarg_T *eap)</a>
<a name="ln8024">{</a>
<a name="ln8025">  u_redo(1);</a>
<a name="ln8026">}</a>
<a name="ln8027"> </a>
<a name="ln8028">/// &quot;:earlier&quot; and &quot;:later&quot;.</a>
<a name="ln8029">static void ex_later(exarg_T *eap)</a>
<a name="ln8030">{</a>
<a name="ln8031">  long count = 0;</a>
<a name="ln8032">  bool sec = false;</a>
<a name="ln8033">  bool file = false;</a>
<a name="ln8034">  char_u      *p = eap-&gt;arg;</a>
<a name="ln8035"> </a>
<a name="ln8036">  if (*p == NUL) {</a>
<a name="ln8037">    count = 1;</a>
<a name="ln8038">  } else if (isdigit(*p)) {</a>
<a name="ln8039">    count = getdigits_long(&amp;p, false, 0);</a>
<a name="ln8040">    switch (*p) {</a>
<a name="ln8041">    case 's': ++p; sec = true; break;</a>
<a name="ln8042">    case 'm': ++p; sec = true; count *= 60; break;</a>
<a name="ln8043">    case 'h': ++p; sec = true; count *= 60 * 60; break;</a>
<a name="ln8044">    case 'd': ++p; sec = true; count *= 24 * 60 * 60; break;</a>
<a name="ln8045">    case 'f': ++p; file = true; break;</a>
<a name="ln8046">    }</a>
<a name="ln8047">  }</a>
<a name="ln8048"> </a>
<a name="ln8049">  if (*p != NUL) {</a>
<a name="ln8050">    EMSG2(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln8051">  } else {</a>
<a name="ln8052">    undo_time(eap-&gt;cmdidx == CMD_earlier ? -count : count,</a>
<a name="ln8053">              sec, file, false);</a>
<a name="ln8054">  }</a>
<a name="ln8055">}</a>
<a name="ln8056"> </a>
<a name="ln8057">/*</a>
<a name="ln8058"> * &quot;:redir&quot;: start/stop redirection.</a>
<a name="ln8059"> */</a>
<a name="ln8060">static void ex_redir(exarg_T *eap)</a>
<a name="ln8061">{</a>
<a name="ln8062">  char        *mode;</a>
<a name="ln8063">  char_u      *fname;</a>
<a name="ln8064">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln8065"> </a>
<a name="ln8066">  if (STRICMP(eap-&gt;arg, &quot;END&quot;) == 0)</a>
<a name="ln8067">    close_redir();</a>
<a name="ln8068">  else {</a>
<a name="ln8069">    if (*arg == '&gt;') {</a>
<a name="ln8070">      ++arg;</a>
<a name="ln8071">      if (*arg == '&gt;') {</a>
<a name="ln8072">        ++arg;</a>
<a name="ln8073">        mode = &quot;a&quot;;</a>
<a name="ln8074">      } else</a>
<a name="ln8075">        mode = &quot;w&quot;;</a>
<a name="ln8076">      arg = skipwhite(arg);</a>
<a name="ln8077"> </a>
<a name="ln8078">      close_redir();</a>
<a name="ln8079"> </a>
<a name="ln8080">      /* Expand environment variables and &quot;~/&quot;. */</a>
<a name="ln8081">      fname = expand_env_save(arg);</a>
<a name="ln8082">      if (fname == NULL)</a>
<a name="ln8083">        return;</a>
<a name="ln8084"> </a>
<a name="ln8085">      redir_fd = open_exfile(fname, eap-&gt;forceit, mode);</a>
<a name="ln8086">      xfree(fname);</a>
<a name="ln8087">    } else if (*arg == '@') {</a>
<a name="ln8088">      /* redirect to a register a-z (resp. A-Z for appending) */</a>
<a name="ln8089">      close_redir();</a>
<a name="ln8090">      ++arg;</a>
<a name="ln8091">      if (valid_yank_reg(*arg, true) &amp;&amp; *arg != '_') {</a>
<a name="ln8092">        redir_reg = *arg++;</a>
<a name="ln8093">        if (*arg == '&gt;' &amp;&amp; arg[1] == '&gt;')          /* append */</a>
<a name="ln8094">          arg += 2;</a>
<a name="ln8095">        else {</a>
<a name="ln8096">          /* Can use both &quot;@a&quot; and &quot;@a&gt;&quot;. */</a>
<a name="ln8097">          if (*arg == '&gt;')</a>
<a name="ln8098">            arg++;</a>
<a name="ln8099">          // Make register empty when not using @A-@Z and the</a>
<a name="ln8100">          // command is valid.</a>
<a name="ln8101">          if (*arg == NUL &amp;&amp; !isupper(redir_reg)) {</a>
<a name="ln8102">            write_reg_contents(redir_reg, (char_u *)&quot;&quot;, 0, false);</a>
<a name="ln8103">          }</a>
<a name="ln8104">        }</a>
<a name="ln8105">      }</a>
<a name="ln8106">      if (*arg != NUL) {</a>
<a name="ln8107">        redir_reg = 0;</a>
<a name="ln8108">        EMSG2(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln8109">      }</a>
<a name="ln8110">    } else if (*arg == '=' &amp;&amp; arg[1] == '&gt;') {</a>
<a name="ln8111">      int append;</a>
<a name="ln8112"> </a>
<a name="ln8113">      /* redirect to a variable */</a>
<a name="ln8114">      close_redir();</a>
<a name="ln8115">      arg += 2;</a>
<a name="ln8116"> </a>
<a name="ln8117">      if (*arg == '&gt;') {</a>
<a name="ln8118">        ++arg;</a>
<a name="ln8119">        append = TRUE;</a>
<a name="ln8120">      } else</a>
<a name="ln8121">        append = FALSE;</a>
<a name="ln8122"> </a>
<a name="ln8123">      if (var_redir_start(skipwhite(arg), append) == OK)</a>
<a name="ln8124">        redir_vname = 1;</a>
<a name="ln8125">    }</a>
<a name="ln8126">    /* TODO: redirect to a buffer */</a>
<a name="ln8127">    else</a>
<a name="ln8128">      EMSG2(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln8129">  }</a>
<a name="ln8130"> </a>
<a name="ln8131">  /* Make sure redirection is not off.  Can happen for cmdline completion</a>
<a name="ln8132">   * that indirectly invokes a command to catch its output. */</a>
<a name="ln8133">  if (redir_fd != NULL</a>
<a name="ln8134">      || redir_reg || redir_vname</a>
<a name="ln8135">      )</a>
<a name="ln8136">    redir_off = FALSE;</a>
<a name="ln8137">}</a>
<a name="ln8138"> </a>
<a name="ln8139">/// &quot;:redraw&quot;: force redraw</a>
<a name="ln8140">static void ex_redraw(exarg_T *eap)</a>
<a name="ln8141">{</a>
<a name="ln8142">  if (State &amp; CMDPREVIEW) {</a>
<a name="ln8143">    return;  // Ignore :redraw during 'inccommand' preview. #9777</a>
<a name="ln8144">  }</a>
<a name="ln8145">  int r = RedrawingDisabled;</a>
<a name="ln8146">  int p = p_lz;</a>
<a name="ln8147"> </a>
<a name="ln8148">  RedrawingDisabled = 0;</a>
<a name="ln8149">  p_lz = FALSE;</a>
<a name="ln8150">  validate_cursor();</a>
<a name="ln8151">  update_topline(curwin);</a>
<a name="ln8152">  if (eap-&gt;forceit) {</a>
<a name="ln8153">    redraw_all_later(NOT_VALID);</a>
<a name="ln8154">  }</a>
<a name="ln8155">  update_screen(eap-&gt;forceit ? NOT_VALID</a>
<a name="ln8156">                : VIsual_active ? INVERTED : 0);</a>
<a name="ln8157">  if (need_maketitle) {</a>
<a name="ln8158">    maketitle();</a>
<a name="ln8159">  }</a>
<a name="ln8160">  RedrawingDisabled = r;</a>
<a name="ln8161">  p_lz = p;</a>
<a name="ln8162"> </a>
<a name="ln8163">  /* Reset msg_didout, so that a message that's there is overwritten. */</a>
<a name="ln8164">  msg_didout = FALSE;</a>
<a name="ln8165">  msg_col = 0;</a>
<a name="ln8166"> </a>
<a name="ln8167">  /* No need to wait after an intentional redraw. */</a>
<a name="ln8168">  need_wait_return = FALSE;</a>
<a name="ln8169"> </a>
<a name="ln8170">  ui_flush();</a>
<a name="ln8171">}</a>
<a name="ln8172"> </a>
<a name="ln8173">/// &quot;:redrawstatus&quot;: force redraw of status line(s)</a>
<a name="ln8174">static void ex_redrawstatus(exarg_T *eap)</a>
<a name="ln8175">{</a>
<a name="ln8176">  if (State &amp; CMDPREVIEW) {</a>
<a name="ln8177">    return;  // Ignore :redrawstatus during 'inccommand' preview. #9777</a>
<a name="ln8178">  }</a>
<a name="ln8179">  int r = RedrawingDisabled;</a>
<a name="ln8180">  int p = p_lz;</a>
<a name="ln8181"> </a>
<a name="ln8182">  RedrawingDisabled = 0;</a>
<a name="ln8183">  p_lz = FALSE;</a>
<a name="ln8184">  if (eap-&gt;forceit)</a>
<a name="ln8185">    status_redraw_all();</a>
<a name="ln8186">  else</a>
<a name="ln8187">    status_redraw_curbuf();</a>
<a name="ln8188">  update_screen(</a>
<a name="ln8189">      VIsual_active ? INVERTED :</a>
<a name="ln8190">      0);</a>
<a name="ln8191">  RedrawingDisabled = r;</a>
<a name="ln8192">  p_lz = p;</a>
<a name="ln8193">  ui_flush();</a>
<a name="ln8194">}</a>
<a name="ln8195"> </a>
<a name="ln8196">// &quot;:redrawtabline&quot;: force redraw of the tabline</a>
<a name="ln8197">static void ex_redrawtabline(exarg_T *eap FUNC_ATTR_UNUSED)</a>
<a name="ln8198">{</a>
<a name="ln8199">  const int r = RedrawingDisabled;</a>
<a name="ln8200">  const int p = p_lz;</a>
<a name="ln8201"> </a>
<a name="ln8202">  RedrawingDisabled = 0;</a>
<a name="ln8203">  p_lz = false;</a>
<a name="ln8204"> </a>
<a name="ln8205">  draw_tabline();</a>
<a name="ln8206"> </a>
<a name="ln8207">  RedrawingDisabled = r;</a>
<a name="ln8208">  p_lz = p;</a>
<a name="ln8209">  ui_flush();</a>
<a name="ln8210">}</a>
<a name="ln8211"> </a>
<a name="ln8212">static void close_redir(void)</a>
<a name="ln8213">{</a>
<a name="ln8214">  if (redir_fd != NULL) {</a>
<a name="ln8215">    fclose(redir_fd);</a>
<a name="ln8216">    redir_fd = NULL;</a>
<a name="ln8217">  }</a>
<a name="ln8218">  redir_reg = 0;</a>
<a name="ln8219">  if (redir_vname) {</a>
<a name="ln8220">    var_redir_stop();</a>
<a name="ln8221">    redir_vname = 0;</a>
<a name="ln8222">  }</a>
<a name="ln8223">}</a>
<a name="ln8224"> </a>
<a name="ln8225">/// Try creating a directory, give error message on failure</a>
<a name="ln8226">///</a>
<a name="ln8227">/// @param[in]  name  Directory to create.</a>
<a name="ln8228">/// @param[in]  prot  Directory permissions.</a>
<a name="ln8229">///</a>
<a name="ln8230">/// @return OK in case of success, FAIL otherwise.</a>
<a name="ln8231">int vim_mkdir_emsg(const char *const name, const int prot)</a>
<a name="ln8232">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln8233">{</a>
<a name="ln8234">  int ret;</a>
<a name="ln8235">  if ((ret = os_mkdir(name, prot)) != 0) {</a>
<a name="ln8236">    EMSG3(_(e_mkdir), name, os_strerror(ret));</a>
<a name="ln8237">    return FAIL;</a>
<a name="ln8238">  }</a>
<a name="ln8239">  return OK;</a>
<a name="ln8240">}</a>
<a name="ln8241"> </a>
<a name="ln8242">/*</a>
<a name="ln8243"> * Open a file for writing for an Ex command, with some checks.</a>
<a name="ln8244"> * Return file descriptor, or NULL on failure.</a>
<a name="ln8245"> */</a>
<a name="ln8246">FILE *</a>
<a name="ln8247">open_exfile (</a>
<a name="ln8248">    char_u *fname,</a>
<a name="ln8249">    int forceit,</a>
<a name="ln8250">    char *mode          /* &quot;w&quot; for create new file or &quot;a&quot; for append */</a>
<a name="ln8251">)</a>
<a name="ln8252">{</a>
<a name="ln8253">  FILE        *fd;</a>
<a name="ln8254"> </a>
<a name="ln8255">#ifdef UNIX</a>
<a name="ln8256">  /* with Unix it is possible to open a directory */</a>
<a name="ln8257">  if (os_isdir(fname)) {</a>
<a name="ln8258">    EMSG2(_(e_isadir2), fname);</a>
<a name="ln8259">    return NULL;</a>
<a name="ln8260">  }</a>
<a name="ln8261">#endif</a>
<a name="ln8262">  if (!forceit &amp;&amp; *mode != 'a' &amp;&amp; os_path_exists(fname)) {</a>
<a name="ln8263">    EMSG2(_(&quot;E189: \&quot;%s\&quot; exists (add ! to override)&quot;), fname);</a>
<a name="ln8264">    return NULL;</a>
<a name="ln8265">  }</a>
<a name="ln8266"> </a>
<a name="ln8267">  if ((fd = os_fopen((char *)fname, mode)) == NULL) {</a>
<a name="ln8268">    EMSG2(_(&quot;E190: Cannot open \&quot;%s\&quot; for writing&quot;), fname);</a>
<a name="ln8269">  }</a>
<a name="ln8270"> </a>
<a name="ln8271">  return fd;</a>
<a name="ln8272">}</a>
<a name="ln8273"> </a>
<a name="ln8274">/*</a>
<a name="ln8275"> * &quot;:mark&quot; and &quot;:k&quot;.</a>
<a name="ln8276"> */</a>
<a name="ln8277">static void ex_mark(exarg_T *eap)</a>
<a name="ln8278">{</a>
<a name="ln8279">  pos_T pos;</a>
<a name="ln8280"> </a>
<a name="ln8281">  if (*eap-&gt;arg == NUL)                 /* No argument? */</a>
<a name="ln8282">    EMSG(_(e_argreq));</a>
<a name="ln8283">  else if (eap-&gt;arg[1] != NUL)          /* more than one character? */</a>
<a name="ln8284">    EMSG(_(e_trailing));</a>
<a name="ln8285">  else {</a>
<a name="ln8286">    pos = curwin-&gt;w_cursor;             /* save curwin-&gt;w_cursor */</a>
<a name="ln8287">    curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln8288">    beginline(BL_WHITE | BL_FIX);</a>
<a name="ln8289">    if (setmark(*eap-&gt;arg) == FAIL)     /* set mark */</a>
<a name="ln8290">      EMSG(_(&quot;E191: Argument must be a letter or forward/backward quote&quot;));</a>
<a name="ln8291">    curwin-&gt;w_cursor = pos;             /* restore curwin-&gt;w_cursor */</a>
<a name="ln8292">  }</a>
<a name="ln8293">}</a>
<a name="ln8294"> </a>
<a name="ln8295">/*</a>
<a name="ln8296"> * Update w_topline, w_leftcol and the cursor position.</a>
<a name="ln8297"> */</a>
<a name="ln8298">void update_topline_cursor(void)</a>
<a name="ln8299">{</a>
<a name="ln8300">  check_cursor();               // put cursor on valid line</a>
<a name="ln8301">  update_topline(curwin);</a>
<a name="ln8302">  if (!curwin-&gt;w_p_wrap) {</a>
<a name="ln8303">    validate_cursor();</a>
<a name="ln8304">  }</a>
<a name="ln8305">  update_curswant();</a>
<a name="ln8306">}</a>
<a name="ln8307"> </a>
<a name="ln8308">// Save the current State and go to Normal mode.</a>
<a name="ln8309">// Return true if the typeahead could be saved.</a>
<a name="ln8310">bool save_current_state(save_state_T *sst)</a>
<a name="ln8311">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln8312">{</a>
<a name="ln8313">  sst-&gt;save_msg_scroll = msg_scroll;</a>
<a name="ln8314">  sst-&gt;save_restart_edit = restart_edit;</a>
<a name="ln8315">  sst-&gt;save_msg_didout = msg_didout;</a>
<a name="ln8316">  sst-&gt;save_State = State;</a>
<a name="ln8317">  sst-&gt;save_insertmode = p_im;</a>
<a name="ln8318">  sst-&gt;save_finish_op = finish_op;</a>
<a name="ln8319">  sst-&gt;save_opcount = opcount;</a>
<a name="ln8320">  sst-&gt;save_reg_executing = reg_executing;</a>
<a name="ln8321"> </a>
<a name="ln8322">  msg_scroll = false;   // no msg scrolling in Normal mode</a>
<a name="ln8323">  restart_edit = 0;     // don't go to Insert mode</a>
<a name="ln8324">  p_im = false;         // don't use 'insertmode</a>
<a name="ln8325"> </a>
<a name="ln8326">  // Save the current typeahead.  This is required to allow using &quot;:normal&quot;</a>
<a name="ln8327">  // from an event handler and makes sure we don't hang when the argument</a>
<a name="ln8328">  // ends with half a command.</a>
<a name="ln8329">  save_typeahead(&amp;sst-&gt;tabuf);</a>
<a name="ln8330">  return sst-&gt;tabuf.typebuf_valid;</a>
<a name="ln8331">}</a>
<a name="ln8332"> </a>
<a name="ln8333">void restore_current_state(save_state_T *sst)</a>
<a name="ln8334">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln8335">{</a>
<a name="ln8336">  // Restore the previous typeahead.</a>
<a name="ln8337">  restore_typeahead(&amp;sst-&gt;tabuf);</a>
<a name="ln8338"> </a>
<a name="ln8339">  msg_scroll = sst-&gt;save_msg_scroll;</a>
<a name="ln8340">  if (force_restart_edit) {</a>
<a name="ln8341">    force_restart_edit = false;</a>
<a name="ln8342">  } else {</a>
<a name="ln8343">    // Some function (terminal_enter()) was aware of ex_normal and decided to</a>
<a name="ln8344">    // override the value of restart_edit anyway.</a>
<a name="ln8345">    restart_edit = sst-&gt;save_restart_edit;</a>
<a name="ln8346">  }</a>
<a name="ln8347">  p_im = sst-&gt;save_insertmode;</a>
<a name="ln8348">  finish_op = sst-&gt;save_finish_op;</a>
<a name="ln8349">  opcount = sst-&gt;save_opcount;</a>
<a name="ln8350">  reg_executing = sst-&gt;save_reg_executing;</a>
<a name="ln8351">  msg_didout |= sst-&gt;save_msg_didout;  // don't reset msg_didout now</a>
<a name="ln8352"> </a>
<a name="ln8353">  // Restore the state (needed when called from a function executed for</a>
<a name="ln8354">  // 'indentexpr'). Update the mouse and cursor, they may have changed.</a>
<a name="ln8355">  State = sst-&gt;save_State;</a>
<a name="ln8356">  ui_cursor_shape();  // may show different cursor shape</a>
<a name="ln8357">}</a>
<a name="ln8358"> </a>
<a name="ln8359">/*</a>
<a name="ln8360"> * &quot;:normal[!] {commands}&quot;: Execute normal mode commands.</a>
<a name="ln8361"> */</a>
<a name="ln8362">static void ex_normal(exarg_T *eap)</a>
<a name="ln8363">{</a>
<a name="ln8364">  if (curbuf-&gt;terminal &amp;&amp; State &amp; TERM_FOCUS) {</a>
<a name="ln8365">    EMSG(&quot;Can't re-enter normal mode from terminal mode&quot;);</a>
<a name="ln8366">    return;</a>
<a name="ln8367">  }</a>
<a name="ln8368">  save_state_T save_state;</a>
<a name="ln8369">  char_u      *arg = NULL;</a>
<a name="ln8370">  int l;</a>
<a name="ln8371">  char_u      *p;</a>
<a name="ln8372"> </a>
<a name="ln8373">  if (ex_normal_lock &gt; 0) {</a>
<a name="ln8374">    EMSG(_(e_secure));</a>
<a name="ln8375">    return;</a>
<a name="ln8376">  }</a>
<a name="ln8377">  if (ex_normal_busy &gt;= p_mmd) {</a>
<a name="ln8378">    EMSG(_(&quot;E192: Recursive use of :normal too deep&quot;));</a>
<a name="ln8379">    return;</a>
<a name="ln8380">  }</a>
<a name="ln8381"> </a>
<a name="ln8382">  // vgetc() expects a CSI and K_SPECIAL to have been escaped.  Don't do</a>
<a name="ln8383">  // this for the K_SPECIAL leading byte, otherwise special keys will not</a>
<a name="ln8384">  // work.</a>
<a name="ln8385">  {</a>
<a name="ln8386">    int len = 0;</a>
<a name="ln8387"> </a>
<a name="ln8388">    /* Count the number of characters to be escaped. */</a>
<a name="ln8389">    for (p = eap-&gt;arg; *p != NUL; ++p) {</a>
<a name="ln8390">      for (l = (*mb_ptr2len)(p) - 1; l &gt; 0; --l)</a>
<a name="ln8391">        if (*++p == K_SPECIAL             /* trailbyte K_SPECIAL or CSI */</a>
<a name="ln8392">            )</a>
<a name="ln8393">          len += 2;</a>
<a name="ln8394">    }</a>
<a name="ln8395">    if (len &gt; 0) {</a>
<a name="ln8396">      arg = xmalloc(STRLEN(eap-&gt;arg) + len + 1);</a>
<a name="ln8397">      len = 0;</a>
<a name="ln8398">      for (p = eap-&gt;arg; *p != NUL; ++p) {</a>
<a name="ln8399">        arg[len++] = *p;</a>
<a name="ln8400">        for (l = (*mb_ptr2len)(p) - 1; l &gt; 0; --l) {</a>
<a name="ln8401">          arg[len++] = *++p;</a>
<a name="ln8402">          if (*p == K_SPECIAL) {</a>
<a name="ln8403">            arg[len++] = KS_SPECIAL;</a>
<a name="ln8404">            arg[len++] = KE_FILLER;</a>
<a name="ln8405">          }</a>
<a name="ln8406">        }</a>
<a name="ln8407">        arg[len] = NUL;</a>
<a name="ln8408">      }</a>
<a name="ln8409">    }</a>
<a name="ln8410">  }</a>
<a name="ln8411"> </a>
<a name="ln8412">  ex_normal_busy++;</a>
<a name="ln8413">  if (save_current_state(&amp;save_state)) {</a>
<a name="ln8414">    // Repeat the :normal command for each line in the range.  When no</a>
<a name="ln8415">    // range given, execute it just once, without positioning the cursor</a>
<a name="ln8416">    // first.</a>
<a name="ln8417">    do {</a>
<a name="ln8418">      if (eap-&gt;addr_count != 0) {</a>
<a name="ln8419">        curwin-&gt;w_cursor.lnum = eap-&gt;line1++;</a>
<a name="ln8420">        curwin-&gt;w_cursor.col = 0;</a>
<a name="ln8421">        check_cursor_moved(curwin);</a>
<a name="ln8422">      }</a>
<a name="ln8423"> </a>
<a name="ln8424">      exec_normal_cmd(arg != NULL ? arg : eap-&gt;arg,</a>
<a name="ln8425">                      eap-&gt;forceit ? REMAP_NONE : REMAP_YES, false);</a>
<a name="ln8426">    } while (eap-&gt;addr_count &gt; 0 &amp;&amp; eap-&gt;line1 &lt;= eap-&gt;line2 &amp;&amp; !got_int);</a>
<a name="ln8427">  }</a>
<a name="ln8428"> </a>
<a name="ln8429">  /* Might not return to the main loop when in an event handler. */</a>
<a name="ln8430">  update_topline_cursor();</a>
<a name="ln8431"> </a>
<a name="ln8432">  restore_current_state(&amp;save_state);</a>
<a name="ln8433"> </a>
<a name="ln8434">  ex_normal_busy--;</a>
<a name="ln8435"> </a>
<a name="ln8436">  setmouse();</a>
<a name="ln8437">  ui_cursor_shape();  // may show different cursor shape</a>
<a name="ln8438">  xfree(arg);</a>
<a name="ln8439">}</a>
<a name="ln8440"> </a>
<a name="ln8441">/*</a>
<a name="ln8442"> * &quot;:startinsert&quot;, &quot;:startreplace&quot; and &quot;:startgreplace&quot;</a>
<a name="ln8443"> */</a>
<a name="ln8444">static void ex_startinsert(exarg_T *eap)</a>
<a name="ln8445">{</a>
<a name="ln8446">  if (eap-&gt;forceit) {</a>
<a name="ln8447">    // cursor line can be zero on startup</a>
<a name="ln8448">    if (!curwin-&gt;w_cursor.lnum) {</a>
<a name="ln8449">      curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln8450">    }</a>
<a name="ln8451">    set_cursor_for_append_to_line();</a>
<a name="ln8452">  }</a>
<a name="ln8453"> </a>
<a name="ln8454">  // Ignore the command when already in Insert mode.  Inserting an</a>
<a name="ln8455">  // expression register that invokes a function can do this.</a>
<a name="ln8456">  if (State &amp; INSERT) {</a>
<a name="ln8457">    return;</a>
<a name="ln8458">  }</a>
<a name="ln8459"> </a>
<a name="ln8460">  if (eap-&gt;cmdidx == CMD_startinsert)</a>
<a name="ln8461">    restart_edit = 'a';</a>
<a name="ln8462">  else if (eap-&gt;cmdidx == CMD_startreplace)</a>
<a name="ln8463">    restart_edit = 'R';</a>
<a name="ln8464">  else</a>
<a name="ln8465">    restart_edit = 'V';</a>
<a name="ln8466"> </a>
<a name="ln8467">  if (!eap-&gt;forceit) {</a>
<a name="ln8468">    if (eap-&gt;cmdidx == CMD_startinsert)</a>
<a name="ln8469">      restart_edit = 'i';</a>
<a name="ln8470">    curwin-&gt;w_curswant = 0;  // avoid MAXCOL</a>
<a name="ln8471">  }</a>
<a name="ln8472"> </a>
<a name="ln8473">  if (VIsual_active) {</a>
<a name="ln8474">    showmode();</a>
<a name="ln8475">  }</a>
<a name="ln8476">}</a>
<a name="ln8477"> </a>
<a name="ln8478">/*</a>
<a name="ln8479"> * &quot;:stopinsert&quot;</a>
<a name="ln8480"> */</a>
<a name="ln8481">static void ex_stopinsert(exarg_T *eap)</a>
<a name="ln8482">{</a>
<a name="ln8483">  restart_edit = 0;</a>
<a name="ln8484">  stop_insert_mode = true;</a>
<a name="ln8485">  clearmode();</a>
<a name="ln8486">}</a>
<a name="ln8487"> </a>
<a name="ln8488">/*</a>
<a name="ln8489"> * Execute normal mode command &quot;cmd&quot;.</a>
<a name="ln8490"> * &quot;remap&quot; can be REMAP_NONE or REMAP_YES.</a>
<a name="ln8491"> */</a>
<a name="ln8492">void exec_normal_cmd(char_u *cmd, int remap, bool silent)</a>
<a name="ln8493">{</a>
<a name="ln8494">  // Stuff the argument into the typeahead buffer.</a>
<a name="ln8495">  ins_typebuf(cmd, remap, 0, true, silent);</a>
<a name="ln8496">  exec_normal(false);</a>
<a name="ln8497">}</a>
<a name="ln8498"> </a>
<a name="ln8499">/// Execute normal_cmd() until there is no typeahead left.</a>
<a name="ln8500">///</a>
<a name="ln8501">/// @param was_typed whether or not something was typed</a>
<a name="ln8502">void exec_normal(bool was_typed)</a>
<a name="ln8503">{</a>
<a name="ln8504">  oparg_T oa;</a>
<a name="ln8505"> </a>
<a name="ln8506">  clear_oparg(&amp;oa);</a>
<a name="ln8507">  finish_op = false;</a>
<a name="ln8508">  while ((!stuff_empty()</a>
<a name="ln8509">          || ((was_typed || !typebuf_typed())</a>
<a name="ln8510">              &amp;&amp; typebuf.tb_len &gt; 0))</a>
<a name="ln8511">         &amp;&amp; !got_int) {</a>
<a name="ln8512">    update_topline_cursor();</a>
<a name="ln8513">    normal_cmd(&amp;oa, true);      // execute a Normal mode cmd</a>
<a name="ln8514">  }</a>
<a name="ln8515">}</a>
<a name="ln8516"> </a>
<a name="ln8517">static void ex_checkpath(exarg_T *eap)</a>
<a name="ln8518">{</a>
<a name="ln8519">  find_pattern_in_path(NULL, 0, 0, FALSE, FALSE, CHECK_PATH, 1L,</a>
<a name="ln8520">                       eap-&gt;forceit ? ACTION_SHOW_ALL : ACTION_SHOW,</a>
<a name="ln8521">                       (linenr_T)1, (linenr_T)MAXLNUM);</a>
<a name="ln8522">}</a>
<a name="ln8523"> </a>
<a name="ln8524">/*</a>
<a name="ln8525"> * &quot;:psearch&quot;</a>
<a name="ln8526"> */</a>
<a name="ln8527">static void ex_psearch(exarg_T *eap)</a>
<a name="ln8528">{</a>
<a name="ln8529">  g_do_tagpreview = p_pvh;</a>
<a name="ln8530">  ex_findpat(eap);</a>
<a name="ln8531">  g_do_tagpreview = 0;</a>
<a name="ln8532">}</a>
<a name="ln8533"> </a>
<a name="ln8534">static void ex_findpat(exarg_T *eap)</a>
<a name="ln8535">{</a>
<a name="ln8536">  int whole = TRUE;</a>
<a name="ln8537">  long n;</a>
<a name="ln8538">  char_u      *p;</a>
<a name="ln8539">  int action;</a>
<a name="ln8540"> </a>
<a name="ln8541">  switch (cmdnames[eap-&gt;cmdidx].cmd_name[2]) {</a>
<a name="ln8542">  case 'e':             /* &quot;:psearch&quot;, &quot;:isearch&quot; and &quot;:dsearch&quot; */</a>
<a name="ln8543">    if (cmdnames[eap-&gt;cmdidx].cmd_name[0] == 'p')</a>
<a name="ln8544">      action = ACTION_GOTO;</a>
<a name="ln8545">    else</a>
<a name="ln8546">      action = ACTION_SHOW;</a>
<a name="ln8547">    break;</a>
<a name="ln8548">  case 'i':             /* &quot;:ilist&quot; and &quot;:dlist&quot; */</a>
<a name="ln8549">    action = ACTION_SHOW_ALL;</a>
<a name="ln8550">    break;</a>
<a name="ln8551">  case 'u':             /* &quot;:ijump&quot; and &quot;:djump&quot; */</a>
<a name="ln8552">    action = ACTION_GOTO;</a>
<a name="ln8553">    break;</a>
<a name="ln8554">  default:              /* &quot;:isplit&quot; and &quot;:dsplit&quot; */</a>
<a name="ln8555">    action = ACTION_SPLIT;</a>
<a name="ln8556">    break;</a>
<a name="ln8557">  }</a>
<a name="ln8558"> </a>
<a name="ln8559">  n = 1;</a>
<a name="ln8560">  if (ascii_isdigit(*eap-&gt;arg)) {  // get count</a>
<a name="ln8561">    n = getdigits_long(&amp;eap-&gt;arg, false, 0);</a>
<a name="ln8562">    eap-&gt;arg = skipwhite(eap-&gt;arg);</a>
<a name="ln8563">  }</a>
<a name="ln8564">  if (*eap-&gt;arg == '/') {   // Match regexp, not just whole words</a>
<a name="ln8565">    whole = false;</a>
<a name="ln8566">    eap-&gt;arg++;</a>
<a name="ln8567">    p = skip_regexp(eap-&gt;arg, '/', p_magic, NULL);</a>
<a name="ln8568">    if (*p) {</a>
<a name="ln8569">      *p++ = NUL;</a>
<a name="ln8570">      p = skipwhite(p);</a>
<a name="ln8571"> </a>
<a name="ln8572">      // Check for trailing illegal characters.</a>
<a name="ln8573">      if (!ends_excmd(*p)) {</a>
<a name="ln8574">        eap-&gt;errmsg = e_trailing;</a>
<a name="ln8575">      } else {</a>
<a name="ln8576">        eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln8577">      }</a>
<a name="ln8578">    }</a>
<a name="ln8579">  }</a>
<a name="ln8580">  if (!eap-&gt;skip)</a>
<a name="ln8581">    find_pattern_in_path(eap-&gt;arg, 0, STRLEN(eap-&gt;arg), whole, !eap-&gt;forceit,</a>
<a name="ln8582">                         *eap-&gt;cmd == 'd' ?  FIND_DEFINE : FIND_ANY,</a>
<a name="ln8583">                         n, action, eap-&gt;line1, eap-&gt;line2);</a>
<a name="ln8584">}</a>
<a name="ln8585"> </a>
<a name="ln8586"> </a>
<a name="ln8587">/*</a>
<a name="ln8588"> * &quot;:ptag&quot;, &quot;:ptselect&quot;, &quot;:ptjump&quot;, &quot;:ptnext&quot;, etc.</a>
<a name="ln8589"> */</a>
<a name="ln8590">static void ex_ptag(exarg_T *eap)</a>
<a name="ln8591">{</a>
<a name="ln8592">  g_do_tagpreview = p_pvh;    /* will be reset to 0 in ex_tag_cmd() */</a>
<a name="ln8593">  ex_tag_cmd(eap, cmdnames[eap-&gt;cmdidx].cmd_name + 1);</a>
<a name="ln8594">}</a>
<a name="ln8595"> </a>
<a name="ln8596">/*</a>
<a name="ln8597"> * &quot;:pedit&quot;</a>
<a name="ln8598"> */</a>
<a name="ln8599">static void ex_pedit(exarg_T *eap)</a>
<a name="ln8600">{</a>
<a name="ln8601">  win_T       *curwin_save = curwin;</a>
<a name="ln8602"> </a>
<a name="ln8603">  // Open the preview window or popup and make it the current window.</a>
<a name="ln8604">  g_do_tagpreview = p_pvh;</a>
<a name="ln8605">  prepare_tagpreview(true);</a>
<a name="ln8606"> </a>
<a name="ln8607">  // Edit the file.</a>
<a name="ln8608">  do_exedit(eap, NULL);</a>
<a name="ln8609"> </a>
<a name="ln8610">  if (curwin != curwin_save &amp;&amp; win_valid(curwin_save)) {</a>
<a name="ln8611">    // Return cursor to where we were</a>
<a name="ln8612">    validate_cursor();</a>
<a name="ln8613">    redraw_later(curwin, VALID);</a>
<a name="ln8614">    win_enter(curwin_save, true);</a>
<a name="ln8615">  }</a>
<a name="ln8616">  g_do_tagpreview = 0;</a>
<a name="ln8617">}</a>
<a name="ln8618"> </a>
<a name="ln8619">/*</a>
<a name="ln8620"> * &quot;:stag&quot;, &quot;:stselect&quot; and &quot;:stjump&quot;.</a>
<a name="ln8621"> */</a>
<a name="ln8622">static void ex_stag(exarg_T *eap)</a>
<a name="ln8623">{</a>
<a name="ln8624">  postponed_split = -1;</a>
<a name="ln8625">  postponed_split_flags = cmdmod.split;</a>
<a name="ln8626">  postponed_split_tab = cmdmod.tab;</a>
<a name="ln8627">  ex_tag_cmd(eap, cmdnames[eap-&gt;cmdidx].cmd_name + 1);</a>
<a name="ln8628">  postponed_split_flags = 0;</a>
<a name="ln8629">  postponed_split_tab = 0;</a>
<a name="ln8630">}</a>
<a name="ln8631"> </a>
<a name="ln8632">/*</a>
<a name="ln8633"> * &quot;:tag&quot;, &quot;:tselect&quot;, &quot;:tjump&quot;, &quot;:tnext&quot;, etc.</a>
<a name="ln8634"> */</a>
<a name="ln8635">static void ex_tag(exarg_T *eap)</a>
<a name="ln8636">{</a>
<a name="ln8637">  ex_tag_cmd(eap, cmdnames[eap-&gt;cmdidx].cmd_name);</a>
<a name="ln8638">}</a>
<a name="ln8639"> </a>
<a name="ln8640">static void ex_tag_cmd(exarg_T *eap, char_u *name)</a>
<a name="ln8641">{</a>
<a name="ln8642">  int cmd;</a>
<a name="ln8643"> </a>
<a name="ln8644">  switch (name[1]) {</a>
<a name="ln8645">  case 'j': cmd = DT_JUMP;              // &quot;:tjump&quot;</a>
<a name="ln8646">    break;</a>
<a name="ln8647">  case 's': cmd = DT_SELECT;            // &quot;:tselect&quot;</a>
<a name="ln8648">    break;</a>
<a name="ln8649">  case 'p':                             // &quot;:tprevious&quot;</a>
<a name="ln8650">  case 'N': cmd = DT_PREV;              // &quot;:tNext&quot;</a>
<a name="ln8651">    break;</a>
<a name="ln8652">  case 'n': cmd = DT_NEXT;              // &quot;:tnext&quot;</a>
<a name="ln8653">    break;</a>
<a name="ln8654">  case 'o': cmd = DT_POP;               // &quot;:pop&quot;</a>
<a name="ln8655">    break;</a>
<a name="ln8656">  case 'f':                             // &quot;:tfirst&quot;</a>
<a name="ln8657">  case 'r': cmd = DT_FIRST;             // &quot;:trewind&quot;</a>
<a name="ln8658">    break;</a>
<a name="ln8659">  case 'l': cmd = DT_LAST;              // &quot;:tlast&quot;</a>
<a name="ln8660">    break;</a>
<a name="ln8661">  default:                              // &quot;:tag&quot;</a>
<a name="ln8662">    if (p_cst &amp;&amp; *eap-&gt;arg != NUL) {</a>
<a name="ln8663">      ex_cstag(eap);</a>
<a name="ln8664">      return;</a>
<a name="ln8665">    }</a>
<a name="ln8666">    cmd = DT_TAG;</a>
<a name="ln8667">    break;</a>
<a name="ln8668">  }</a>
<a name="ln8669"> </a>
<a name="ln8670">  if (name[0] == 'l') {</a>
<a name="ln8671">    cmd = DT_LTAG;</a>
<a name="ln8672">  }</a>
<a name="ln8673"> </a>
<a name="ln8674">  do_tag(eap-&gt;arg, cmd, eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : 1,</a>
<a name="ln8675">      eap-&gt;forceit, TRUE);</a>
<a name="ln8676">}</a>
<a name="ln8677"> </a>
<a name="ln8678">enum {</a>
<a name="ln8679">  SPEC_PERC = 0,</a>
<a name="ln8680">  SPEC_HASH,</a>
<a name="ln8681">  SPEC_CWORD,</a>
<a name="ln8682">  SPEC_CCWORD,</a>
<a name="ln8683">  SPEC_CEXPR,</a>
<a name="ln8684">  SPEC_CFILE,</a>
<a name="ln8685">  SPEC_SFILE,</a>
<a name="ln8686">  SPEC_SLNUM,</a>
<a name="ln8687">  SPEC_STACK,</a>
<a name="ln8688">  SPEC_AFILE,</a>
<a name="ln8689">  SPEC_ABUF,</a>
<a name="ln8690">  SPEC_AMATCH,</a>
<a name="ln8691">  SPEC_SFLNUM,</a>
<a name="ln8692">  SPEC_SID,</a>
<a name="ln8693">  // SPEC_CLIENT,</a>
<a name="ln8694">};</a>
<a name="ln8695"> </a>
<a name="ln8696">/*</a>
<a name="ln8697"> * Check &quot;str&quot; for starting with a special cmdline variable.</a>
<a name="ln8698"> * If found return one of the SPEC_ values and set &quot;*usedlen&quot; to the length of</a>
<a name="ln8699"> * the variable.  Otherwise return -1 and &quot;*usedlen&quot; is unchanged.</a>
<a name="ln8700"> */</a>
<a name="ln8701">ssize_t find_cmdline_var(const char_u *src, size_t *usedlen)</a>
<a name="ln8702">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln8703">{</a>
<a name="ln8704">  size_t len;</a>
<a name="ln8705">  static char *(spec_str[]) = {</a>
<a name="ln8706">    [SPEC_PERC] = &quot;%&quot;,</a>
<a name="ln8707">    [SPEC_HASH] = &quot;#&quot;,</a>
<a name="ln8708">    [SPEC_CWORD] = &quot;&lt;cword&gt;&quot;,           // cursor word</a>
<a name="ln8709">    [SPEC_CCWORD] = &quot;&lt;cWORD&gt;&quot;,          // cursor WORD</a>
<a name="ln8710">    [SPEC_CEXPR] = &quot;&lt;cexpr&gt;&quot;,           // expr under cursor</a>
<a name="ln8711">    [SPEC_CFILE] = &quot;&lt;cfile&gt;&quot;,           // cursor path name</a>
<a name="ln8712">    [SPEC_SFILE] = &quot;&lt;sfile&gt;&quot;,           // &quot;:so&quot; file name</a>
<a name="ln8713">    [SPEC_SLNUM] = &quot;&lt;slnum&gt;&quot;,           // &quot;:so&quot; file line number</a>
<a name="ln8714">    [SPEC_STACK] = &quot;&lt;stack&gt;&quot;,           // call stack</a>
<a name="ln8715">    [SPEC_AFILE] = &quot;&lt;afile&gt;&quot;,           // autocommand file name</a>
<a name="ln8716">    [SPEC_ABUF] = &quot;&lt;abuf&gt;&quot;,             // autocommand buffer number</a>
<a name="ln8717">    [SPEC_AMATCH] = &quot;&lt;amatch&gt;&quot;,         // autocommand match name</a>
<a name="ln8718">    [SPEC_SFLNUM] = &quot;&lt;sflnum&gt;&quot;,         // script file line number</a>
<a name="ln8719">    [SPEC_SID] = &quot;&lt;SID&gt;&quot;,               // script ID: &lt;SNR&gt;123_</a>
<a name="ln8720">    // [SPEC_CLIENT] = &quot;&lt;client&gt;&quot;,</a>
<a name="ln8721">  };</a>
<a name="ln8722"> </a>
<a name="ln8723">  for (size_t i = 0; i &lt; ARRAY_SIZE(spec_str); ++i) {</a>
<a name="ln8724">    len = STRLEN(spec_str[i]);</a>
<a name="ln8725">    if (STRNCMP(src, spec_str[i], len) == 0) {</a>
<a name="ln8726">      *usedlen = len;</a>
<a name="ln8727">      assert(i &lt;= SSIZE_MAX);</a>
<a name="ln8728">      return (ssize_t)i;</a>
<a name="ln8729">    }</a>
<a name="ln8730">  }</a>
<a name="ln8731">  return -1;</a>
<a name="ln8732">}</a>
<a name="ln8733"> </a>
<a name="ln8734">/*</a>
<a name="ln8735"> * Evaluate cmdline variables.</a>
<a name="ln8736"> *</a>
<a name="ln8737"> * change '%'	    to curbuf-&gt;b_ffname</a>
<a name="ln8738"> *	  '#'	    to curwin-&gt;w_alt_fnum</a>
<a name="ln8739"> *	  '&lt;cword&gt;' to word under the cursor</a>
<a name="ln8740"> *	  '&lt;cWORD&gt;' to WORD under the cursor</a>
<a name="ln8741"> *	  '&lt;cexpr&gt;' to C-expression under the cursor</a>
<a name="ln8742"> *	  '&lt;cfile&gt;' to path name under the cursor</a>
<a name="ln8743"> *	  '&lt;sfile&gt;' to sourced file name</a>
<a name="ln8744"> *	  '&lt;slnum&gt;' to sourced file line number</a>
<a name="ln8745"> *	  '&lt;afile&gt;' to file name for autocommand</a>
<a name="ln8746"> *	  '&lt;abuf&gt;'  to buffer number for autocommand</a>
<a name="ln8747"> *	  '&lt;amatch&gt;' to matching name for autocommand</a>
<a name="ln8748"> *</a>
<a name="ln8749"> * When an error is detected, &quot;errormsg&quot; is set to a non-NULL pointer (may be</a>
<a name="ln8750"> * &quot;&quot; for error without a message) and NULL is returned.</a>
<a name="ln8751"> * Returns an allocated string if a valid match was found.</a>
<a name="ln8752"> * Returns NULL if no match was found.	&quot;usedlen&quot; then still contains the</a>
<a name="ln8753"> * number of characters to skip.</a>
<a name="ln8754"> */</a>
<a name="ln8755">char_u *</a>
<a name="ln8756">eval_vars (</a>
<a name="ln8757">    char_u *src,               /* pointer into commandline */</a>
<a name="ln8758">    char_u *srcstart,          /* beginning of valid memory for src */</a>
<a name="ln8759">    size_t *usedlen,           /* characters after src that are used */</a>
<a name="ln8760">    linenr_T *lnump,             /* line number for :e command, or NULL */</a>
<a name="ln8761">    char_u **errormsg,         /* pointer to error message */</a>
<a name="ln8762">    int *escaped           /* return value has escaped white space (can</a>
<a name="ln8763">                                 * be NULL) */</a>
<a name="ln8764">)</a>
<a name="ln8765">{</a>
<a name="ln8766">  int i;</a>
<a name="ln8767">  char_u      *s;</a>
<a name="ln8768">  char_u      *result;</a>
<a name="ln8769">  char_u      *resultbuf = NULL;</a>
<a name="ln8770">  size_t resultlen;</a>
<a name="ln8771">  buf_T       *buf;</a>
<a name="ln8772">  int valid = VALID_HEAD | VALID_PATH;  // Assume valid result.</a>
<a name="ln8773">  bool tilde_file = false;</a>
<a name="ln8774">  int skip_mod = false;</a>
<a name="ln8775">  char strbuf[30];</a>
<a name="ln8776"> </a>
<a name="ln8777">  *errormsg = NULL;</a>
<a name="ln8778">  if (escaped != NULL)</a>
<a name="ln8779">    *escaped = FALSE;</a>
<a name="ln8780"> </a>
<a name="ln8781">  /*</a>
<a name="ln8782">   * Check if there is something to do.</a>
<a name="ln8783">   */</a>
<a name="ln8784">  ssize_t spec_idx = find_cmdline_var(src, usedlen);</a>
<a name="ln8785">  if (spec_idx &lt; 0) {   /* no match */</a>
<a name="ln8786">    *usedlen = 1;</a>
<a name="ln8787">    return NULL;</a>
<a name="ln8788">  }</a>
<a name="ln8789"> </a>
<a name="ln8790">  /*</a>
<a name="ln8791">   * Skip when preceded with a backslash &quot;\%&quot; and &quot;\#&quot;.</a>
<a name="ln8792">   * Note: In &quot;\\%&quot; the % is also not recognized!</a>
<a name="ln8793">   */</a>
<a name="ln8794">  if (src &gt; srcstart &amp;&amp; src[-1] == '\\') {</a>
<a name="ln8795">    *usedlen = 0;</a>
<a name="ln8796">    STRMOVE(src - 1, src);      /* remove backslash */</a>
<a name="ln8797">    return NULL;</a>
<a name="ln8798">  }</a>
<a name="ln8799"> </a>
<a name="ln8800">  /*</a>
<a name="ln8801">   * word or WORD under cursor</a>
<a name="ln8802">   */</a>
<a name="ln8803">  if (spec_idx == SPEC_CWORD</a>
<a name="ln8804">      || spec_idx == SPEC_CCWORD</a>
<a name="ln8805">      || spec_idx == SPEC_CEXPR) {</a>
<a name="ln8806">    resultlen = find_ident_under_cursor(</a>
<a name="ln8807">        &amp;result,</a>
<a name="ln8808">        spec_idx == SPEC_CWORD</a>
<a name="ln8809">        ? (FIND_IDENT | FIND_STRING)</a>
<a name="ln8810">        : (spec_idx == SPEC_CEXPR</a>
<a name="ln8811">           ? (FIND_IDENT | FIND_STRING | FIND_EVAL)</a>
<a name="ln8812">           : FIND_STRING));</a>
<a name="ln8813">    if (resultlen == 0) {</a>
<a name="ln8814">      *errormsg = (char_u *)&quot;&quot;;</a>
<a name="ln8815">      return NULL;</a>
<a name="ln8816">    }</a>
<a name="ln8817">  //</a>
<a name="ln8818">  // '#': Alternate file name</a>
<a name="ln8819">  // '%': Current file name</a>
<a name="ln8820">  //        File name under the cursor</a>
<a name="ln8821">  //        File name for autocommand</a>
<a name="ln8822">  //    and following modifiers</a>
<a name="ln8823">  //</a>
<a name="ln8824">  } else {</a>
<a name="ln8825">    switch (spec_idx) {</a>
<a name="ln8826">    case SPEC_PERC:             // '%': current file</a>
<a name="ln8827">      if (curbuf-&gt;b_fname == NULL) {</a>
<a name="ln8828">        result = (char_u *)&quot;&quot;;</a>
<a name="ln8829">        valid = 0;                  // Must have &quot;:p:h&quot; to be valid</a>
<a name="ln8830">      } else {</a>
<a name="ln8831">        result = curbuf-&gt;b_fname;</a>
<a name="ln8832">        tilde_file = STRCMP(result, &quot;~&quot;) == 0;</a>
<a name="ln8833">      }</a>
<a name="ln8834">      break;</a>
<a name="ln8835"> </a>
<a name="ln8836">    case SPEC_HASH:             /* '#' or &quot;#99&quot;: alternate file */</a>
<a name="ln8837">      if (src[1] == '#') {          /* &quot;##&quot;: the argument list */</a>
<a name="ln8838">        result = arg_all();</a>
<a name="ln8839">        resultbuf = result;</a>
<a name="ln8840">        *usedlen = 2;</a>
<a name="ln8841">        if (escaped != NULL)</a>
<a name="ln8842">          *escaped = TRUE;</a>
<a name="ln8843">        skip_mod = TRUE;</a>
<a name="ln8844">        break;</a>
<a name="ln8845">      }</a>
<a name="ln8846">      s = src + 1;</a>
<a name="ln8847">      if (*s == '&lt;') {                  // &quot;#&lt;99&quot; uses v:oldfiles.</a>
<a name="ln8848">        s++;</a>
<a name="ln8849">      }</a>
<a name="ln8850">      i = getdigits_int(&amp;s, false, 0);</a>
<a name="ln8851">      if (s == src + 2 &amp;&amp; src[1] == '-') {</a>
<a name="ln8852">        // just a minus sign, don't skip over it</a>
<a name="ln8853">        s--;</a>
<a name="ln8854">      }</a>
<a name="ln8855">      *usedlen = (size_t)(s - src);           // length of what we expand</a>
<a name="ln8856"> </a>
<a name="ln8857">      if (src[1] == '&lt;' &amp;&amp; i != 0) {</a>
<a name="ln8858">        if (*usedlen &lt; 2) {</a>
<a name="ln8859">          /* Should we give an error message for #&lt;text? */</a>
<a name="ln8860">          *usedlen = 1;</a>
<a name="ln8861">          return NULL;</a>
<a name="ln8862">        }</a>
<a name="ln8863">        result = (char_u *)tv_list_find_str(get_vim_var_list(VV_OLDFILES),</a>
<a name="ln8864">                                            i - 1);</a>
<a name="ln8865">        if (result == NULL) {</a>
<a name="ln8866">          *errormsg = (char_u *)&quot;&quot;;</a>
<a name="ln8867">          return NULL;</a>
<a name="ln8868">        }</a>
<a name="ln8869">      } else {</a>
<a name="ln8870">        if (i == 0 &amp;&amp; src[1] == '&lt;' &amp;&amp; *usedlen &gt; 1) {</a>
<a name="ln8871">          *usedlen = 1;</a>
<a name="ln8872">        }</a>
<a name="ln8873">        buf = buflist_findnr(i);</a>
<a name="ln8874">        if (buf == NULL) {</a>
<a name="ln8875">          *errormsg = (char_u *)_(</a>
<a name="ln8876">              &quot;E194: No alternate file name to substitute for '#'&quot;);</a>
<a name="ln8877">          return NULL;</a>
<a name="ln8878">        }</a>
<a name="ln8879">        if (lnump != NULL)</a>
<a name="ln8880">          *lnump = ECMD_LAST;</a>
<a name="ln8881">        if (buf-&gt;b_fname == NULL) {</a>
<a name="ln8882">          result = (char_u *)&quot;&quot;;</a>
<a name="ln8883">          valid = 0;                        // Must have &quot;:p:h&quot; to be valid</a>
<a name="ln8884">        } else {</a>
<a name="ln8885">          result = buf-&gt;b_fname;</a>
<a name="ln8886">          tilde_file = STRCMP(result, &quot;~&quot;) == 0;</a>
<a name="ln8887">        }</a>
<a name="ln8888">      }</a>
<a name="ln8889">      break;</a>
<a name="ln8890"> </a>
<a name="ln8891">    case SPEC_CFILE:            /* file name under cursor */</a>
<a name="ln8892">      result = file_name_at_cursor(FNAME_MESS|FNAME_HYP, 1L, NULL);</a>
<a name="ln8893">      if (result == NULL) {</a>
<a name="ln8894">        *errormsg = (char_u *)&quot;&quot;;</a>
<a name="ln8895">        return NULL;</a>
<a name="ln8896">      }</a>
<a name="ln8897">      resultbuf = result;                   /* remember allocated string */</a>
<a name="ln8898">      break;</a>
<a name="ln8899"> </a>
<a name="ln8900">    case SPEC_AFILE:  // file name for autocommand</a>
<a name="ln8901">      if (autocmd_fname != NULL</a>
<a name="ln8902">          &amp;&amp; !path_is_absolute(autocmd_fname)</a>
<a name="ln8903">          // For CmdlineEnter and related events, &lt;afile&gt; is not a path! #9348</a>
<a name="ln8904">          &amp;&amp; !strequal(&quot;/&quot;, (char *)autocmd_fname)) {</a>
<a name="ln8905">        // Still need to turn the fname into a full path.  It was</a>
<a name="ln8906">        // postponed to avoid a delay when &lt;afile&gt; is not used.</a>
<a name="ln8907">        result = (char_u *)FullName_save((char *)autocmd_fname, false);</a>
<a name="ln8908">        // Copy into `autocmd_fname`, don't reassign it. #8165</a>
<a name="ln8909">        xstrlcpy((char *)autocmd_fname, (char *)result, MAXPATHL);</a>
<a name="ln8910">        xfree(result);</a>
<a name="ln8911">      }</a>
<a name="ln8912">      result = autocmd_fname;</a>
<a name="ln8913">      if (result == NULL) {</a>
<a name="ln8914">        *errormsg = (char_u *)_(</a>
<a name="ln8915">            &quot;E495: no autocommand file name to substitute for \&quot;&lt;afile&gt;\&quot;&quot;);</a>
<a name="ln8916">        return NULL;</a>
<a name="ln8917">      }</a>
<a name="ln8918">      result = path_try_shorten_fname(result);</a>
<a name="ln8919">      break;</a>
<a name="ln8920"> </a>
<a name="ln8921">    case SPEC_ABUF:             /* buffer number for autocommand */</a>
<a name="ln8922">      if (autocmd_bufnr &lt;= 0) {</a>
<a name="ln8923">        *errormsg = (char_u *)_(</a>
<a name="ln8924">            &quot;E496: no autocommand buffer number to substitute for \&quot;&lt;abuf&gt;\&quot;&quot;);</a>
<a name="ln8925">        return NULL;</a>
<a name="ln8926">      }</a>
<a name="ln8927">      snprintf(strbuf, sizeof(strbuf), &quot;%d&quot;, autocmd_bufnr);</a>
<a name="ln8928">      result = (char_u *)strbuf;</a>
<a name="ln8929">      break;</a>
<a name="ln8930"> </a>
<a name="ln8931">    case SPEC_AMATCH:           /* match name for autocommand */</a>
<a name="ln8932">      result = autocmd_match;</a>
<a name="ln8933">      if (result == NULL) {</a>
<a name="ln8934">        *errormsg = (char_u *)_(</a>
<a name="ln8935">            &quot;E497: no autocommand match name to substitute for \&quot;&lt;amatch&gt;\&quot;&quot;);</a>
<a name="ln8936">        return NULL;</a>
<a name="ln8937">      }</a>
<a name="ln8938">      break;</a>
<a name="ln8939"> </a>
<a name="ln8940">    case SPEC_SFILE:            /* file name for &quot;:so&quot; command */</a>
<a name="ln8941">      result = sourcing_name;</a>
<a name="ln8942">      if (result == NULL) {</a>
<a name="ln8943">        *errormsg = (char_u *)_(</a>
<a name="ln8944">            &quot;E498: no :source file name to substitute for \&quot;&lt;sfile&gt;\&quot;&quot;);</a>
<a name="ln8945">        return NULL;</a>
<a name="ln8946">      }</a>
<a name="ln8947">      break;</a>
<a name="ln8948"> </a>
<a name="ln8949">    case SPEC_SLNUM:            // line in file for &quot;:so&quot; command</a>
<a name="ln8950">      if (sourcing_name == NULL || sourcing_lnum == 0) {</a>
<a name="ln8951">        *errormsg = (char_u *)_(&quot;E842: no line number to use for \&quot;&lt;slnum&gt;\&quot;&quot;);</a>
<a name="ln8952">        return NULL;</a>
<a name="ln8953">      }</a>
<a name="ln8954">      snprintf(strbuf, sizeof(strbuf), &quot;%&quot; PRIdLINENR, sourcing_lnum);</a>
<a name="ln8955">      result = (char_u *)strbuf;</a>
<a name="ln8956">      break;</a>
<a name="ln8957"> </a>
<a name="ln8958">    case SPEC_SFLNUM:  // line in script file</a>
<a name="ln8959">      if (current_sctx.sc_lnum + sourcing_lnum == 0) {</a>
<a name="ln8960">        *errormsg = (char_u *)_(&quot;E961: no line number to use for \&quot;&lt;sflnum&gt;\&quot;&quot;);</a>
<a name="ln8961">        return NULL;</a>
<a name="ln8962">      }</a>
<a name="ln8963">      snprintf((char *)strbuf, sizeof(strbuf), &quot;%&quot; PRIdLINENR,</a>
<a name="ln8964">               current_sctx.sc_lnum + sourcing_lnum);</a>
<a name="ln8965">      result = (char_u *)strbuf;</a>
<a name="ln8966">      break;</a>
<a name="ln8967"> </a>
<a name="ln8968">    case SPEC_SID:</a>
<a name="ln8969">      if (current_sctx.sc_sid &lt;= 0) {</a>
<a name="ln8970">        *errormsg = (char_u *)_(e_usingsid);</a>
<a name="ln8971">        return NULL;</a>
<a name="ln8972">      }</a>
<a name="ln8973">      snprintf(strbuf, sizeof(strbuf), &quot;&lt;SNR&gt;%&quot; PRIdSCID &quot;_&quot;,</a>
<a name="ln8974">               current_sctx.sc_sid);</a>
<a name="ln8975">      result = (char_u *)strbuf;</a>
<a name="ln8976">      break;</a>
<a name="ln8977"> </a>
<a name="ln8978">    default:</a>
<a name="ln8979">      // should not happen</a>
<a name="ln8980">      *errormsg = (char_u *)&quot;&quot;;</a>
<a name="ln8981">      result = (char_u *)&quot;&quot;;    // avoid gcc warning</a>
<a name="ln8982">      break;</a>
<a name="ln8983">    }</a>
<a name="ln8984"> </a>
<a name="ln8985">    // Length of new string.</a>
<a name="ln8986">    resultlen = STRLEN(result);</a>
<a name="ln8987">    // Remove the file name extension.</a>
<a name="ln8988">    if (src[*usedlen] == '&lt;') {</a>
<a name="ln8989">      (*usedlen)++;</a>
<a name="ln8990">      if ((s = STRRCHR(result, '.')) != NULL &amp;&amp; s &gt;= path_tail(result)) {</a>
<a name="ln8991">        resultlen = (size_t)(s - result);</a>
<a name="ln8992">      }</a>
<a name="ln8993">    } else if (!skip_mod) {</a>
<a name="ln8994">      valid |= modify_fname(src, tilde_file, usedlen, &amp;result,</a>
<a name="ln8995">                            &amp;resultbuf, &amp;resultlen);</a>
<a name="ln8996">      if (result == NULL) {</a>
<a name="ln8997">        *errormsg = (char_u *)&quot;&quot;;</a>
<a name="ln8998">        return NULL;</a>
<a name="ln8999">      }</a>
<a name="ln9000">    }</a>
<a name="ln9001">  }</a>
<a name="ln9002"> </a>
<a name="ln9003">  if (resultlen == 0 || valid != VALID_HEAD + VALID_PATH) {</a>
<a name="ln9004">    if (valid != VALID_HEAD + VALID_PATH)</a>
<a name="ln9005">      /* xgettext:no-c-format */</a>
<a name="ln9006">      *errormsg = (char_u *)_(</a>
<a name="ln9007">          &quot;E499: Empty file name for '%' or '#', only works with \&quot;:p:h\&quot;&quot;);</a>
<a name="ln9008">    else</a>
<a name="ln9009">      *errormsg = (char_u *)_(&quot;E500: Evaluates to an empty string&quot;);</a>
<a name="ln9010">    result = NULL;</a>
<a name="ln9011">  } else</a>
<a name="ln9012">    result = vim_strnsave(result, resultlen);</a>
<a name="ln9013">  xfree(resultbuf);</a>
<a name="ln9014">  return result;</a>
<a name="ln9015">}</a>
<a name="ln9016"> </a>
<a name="ln9017">/*</a>
<a name="ln9018"> * Concatenate all files in the argument list, separated by spaces, and return</a>
<a name="ln9019"> * it in one allocated string.</a>
<a name="ln9020"> * Spaces and backslashes in the file names are escaped with a backslash.</a>
<a name="ln9021"> */</a>
<a name="ln9022">static char_u *arg_all(void)</a>
<a name="ln9023">{</a>
<a name="ln9024">  int len;</a>
<a name="ln9025">  int idx;</a>
<a name="ln9026">  char_u      *retval = NULL;</a>
<a name="ln9027">  char_u      *p;</a>
<a name="ln9028"> </a>
<a name="ln9029">  /*</a>
<a name="ln9030">   * Do this loop two times:</a>
<a name="ln9031">   * first time: compute the total length</a>
<a name="ln9032">   * second time: concatenate the names</a>
<a name="ln9033">   */</a>
<a name="ln9034">  for (;; ) {</a>
<a name="ln9035">    len = 0;</a>
<a name="ln9036">    for (idx = 0; idx &lt; ARGCOUNT; ++idx) {</a>
<a name="ln9037">      p = alist_name(&amp;ARGLIST[idx]);</a>
<a name="ln9038">      if (p == NULL) {</a>
<a name="ln9039">        continue;</a>
<a name="ln9040">      }</a>
<a name="ln9041">      if (len &gt; 0) {</a>
<a name="ln9042">        /* insert a space in between names */</a>
<a name="ln9043">        if (retval != NULL)</a>
<a name="ln9044">          retval[len] = ' ';</a>
<a name="ln9045">        ++len;</a>
<a name="ln9046">      }</a>
<a name="ln9047">      for (; *p != NUL; p++) {</a>
<a name="ln9048">        if (*p == ' '</a>
<a name="ln9049">#ifndef BACKSLASH_IN_FILENAME</a>
<a name="ln9050">            || *p == '\\'</a>
<a name="ln9051">#endif</a>
<a name="ln9052">            || *p == '`') {</a>
<a name="ln9053">          // insert a backslash</a>
<a name="ln9054">          if (retval != NULL) {</a>
<a name="ln9055">            retval[len] = '\\';</a>
<a name="ln9056">          }</a>
<a name="ln9057">          len++;</a>
<a name="ln9058">        }</a>
<a name="ln9059">        if (retval != NULL) {</a>
<a name="ln9060">          retval[len] = *p;</a>
<a name="ln9061">        }</a>
<a name="ln9062">        len++;</a>
<a name="ln9063">      }</a>
<a name="ln9064">    }</a>
<a name="ln9065"> </a>
<a name="ln9066">    /* second time: break here */</a>
<a name="ln9067">    if (retval != NULL) {</a>
<a name="ln9068">      retval[len] = NUL;</a>
<a name="ln9069">      break;</a>
<a name="ln9070">    }</a>
<a name="ln9071"> </a>
<a name="ln9072">    /* allocate memory */</a>
<a name="ln9073">    retval = xmalloc(len + 1);</a>
<a name="ln9074">  }</a>
<a name="ln9075"> </a>
<a name="ln9076">  return retval;</a>
<a name="ln9077">}</a>
<a name="ln9078"> </a>
<a name="ln9079">/*</a>
<a name="ln9080"> * Expand the &lt;sfile&gt; string in &quot;arg&quot;.</a>
<a name="ln9081"> *</a>
<a name="ln9082"> * Returns an allocated string, or NULL for any error.</a>
<a name="ln9083"> */</a>
<a name="ln9084">char_u *expand_sfile(char_u *arg)</a>
<a name="ln9085">{</a>
<a name="ln9086">  char_u      *errormsg;</a>
<a name="ln9087">  size_t len;</a>
<a name="ln9088">  char_u      *result;</a>
<a name="ln9089">  char_u      *newres;</a>
<a name="ln9090">  char_u      *repl;</a>
<a name="ln9091">  size_t srclen;</a>
<a name="ln9092">  char_u      *p;</a>
<a name="ln9093"> </a>
<a name="ln9094">  result = vim_strsave(arg);</a>
<a name="ln9095"> </a>
<a name="ln9096">  for (p = result; *p; ) {</a>
<a name="ln9097">    if (STRNCMP(p, &quot;&lt;sfile&gt;&quot;, 7) != 0)</a>
<a name="ln9098">      ++p;</a>
<a name="ln9099">    else {</a>
<a name="ln9100">      /* replace &quot;&lt;sfile&gt;&quot; with the sourced file name, and do &quot;:&quot; stuff */</a>
<a name="ln9101">      repl = eval_vars(p, result, &amp;srclen, NULL, &amp;errormsg, NULL);</a>
<a name="ln9102">      if (errormsg != NULL) {</a>
<a name="ln9103">        if (*errormsg)</a>
<a name="ln9104">          emsg(errormsg);</a>
<a name="ln9105">        xfree(result);</a>
<a name="ln9106">        return NULL;</a>
<a name="ln9107">      }</a>
<a name="ln9108">      if (repl == NULL) {               /* no match (cannot happen) */</a>
<a name="ln9109">        p += srclen;</a>
<a name="ln9110">        continue;</a>
<a name="ln9111">      }</a>
<a name="ln9112">      len = STRLEN(result) - srclen + STRLEN(repl) + 1;</a>
<a name="ln9113">      newres = xmalloc(len);</a>
<a name="ln9114">      memmove(newres, result, (size_t)(p - result));</a>
<a name="ln9115">      STRCPY(newres + (p - result), repl);</a>
<a name="ln9116">      len = STRLEN(newres);</a>
<a name="ln9117">      STRCAT(newres, p + srclen);</a>
<a name="ln9118">      xfree(repl);</a>
<a name="ln9119">      xfree(result);</a>
<a name="ln9120">      result = newres;</a>
<a name="ln9121">      p = newres + len;                 /* continue after the match */</a>
<a name="ln9122">    }</a>
<a name="ln9123">  }</a>
<a name="ln9124"> </a>
<a name="ln9125">  return result;</a>
<a name="ln9126">}</a>
<a name="ln9127"> </a>
<a name="ln9128">/*</a>
<a name="ln9129"> * &quot;:rshada&quot; and &quot;:wshada&quot;.</a>
<a name="ln9130"> */</a>
<a name="ln9131">static void ex_shada(exarg_T *eap)</a>
<a name="ln9132">{</a>
<a name="ln9133">  char_u      *save_shada;</a>
<a name="ln9134"> </a>
<a name="ln9135">  save_shada = p_shada;</a>
<a name="ln9136">  if (*p_shada == NUL)</a>
<a name="ln9137">    p_shada = (char_u *)&quot;'100&quot;;</a>
<a name="ln9138">  if (eap-&gt;cmdidx == CMD_rviminfo || eap-&gt;cmdidx == CMD_rshada) {</a>
<a name="ln9139">    (void) shada_read_everything((char *) eap-&gt;arg, eap-&gt;forceit, false);</a>
<a name="ln9140">  } else {</a>
<a name="ln9141">    shada_write_file((char *) eap-&gt;arg, eap-&gt;forceit);</a>
<a name="ln9142">  }</a>
<a name="ln9143">  p_shada = save_shada;</a>
<a name="ln9144">}</a>
<a name="ln9145"> </a>
<a name="ln9146">/*</a>
<a name="ln9147"> * Make a dialog message in &quot;buff[DIALOG_MSG_SIZE]&quot;.</a>
<a name="ln9148"> * &quot;format&quot; must contain &quot;%s&quot;.</a>
<a name="ln9149"> */</a>
<a name="ln9150">void dialog_msg(char_u *buff, char *format, char_u *fname)</a>
<a name="ln9151">{</a>
<a name="ln9152">  if (fname == NULL)</a>
<a name="ln9153">    fname = (char_u *)_(&quot;Untitled&quot;);</a>
<a name="ln9154">  vim_snprintf((char *)buff, DIALOG_MSG_SIZE, format, fname);</a>
<a name="ln9155">}</a>
<a name="ln9156"> </a>
<a name="ln9157">/*</a>
<a name="ln9158"> * &quot;:behave {mswin,xterm}&quot;</a>
<a name="ln9159"> */</a>
<a name="ln9160">static void ex_behave(exarg_T *eap)</a>
<a name="ln9161">{</a>
<a name="ln9162">  if (STRCMP(eap-&gt;arg, &quot;mswin&quot;) == 0) {</a>
<a name="ln9163">    set_option_value(&quot;selection&quot;, 0L, &quot;exclusive&quot;, 0);</a>
<a name="ln9164">    set_option_value(&quot;selectmode&quot;, 0L, &quot;mouse,key&quot;, 0);</a>
<a name="ln9165">    set_option_value(&quot;mousemodel&quot;, 0L, &quot;popup&quot;, 0);</a>
<a name="ln9166">    set_option_value(&quot;keymodel&quot;, 0L, &quot;startsel,stopsel&quot;, 0);</a>
<a name="ln9167">  } else if (STRCMP(eap-&gt;arg, &quot;xterm&quot;) == 0) {</a>
<a name="ln9168">    set_option_value(&quot;selection&quot;, 0L, &quot;inclusive&quot;, 0);</a>
<a name="ln9169">    set_option_value(&quot;selectmode&quot;, 0L, &quot;&quot;, 0);</a>
<a name="ln9170">    set_option_value(&quot;mousemodel&quot;, 0L, &quot;extend&quot;, 0);</a>
<a name="ln9171">    set_option_value(&quot;keymodel&quot;, 0L, &quot;&quot;, 0);</a>
<a name="ln9172">  } else {</a>
<a name="ln9173">    EMSG2(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln9174">  }</a>
<a name="ln9175">}</a>
<a name="ln9176"> </a>
<a name="ln9177">/*</a>
<a name="ln9178"> * Function given to ExpandGeneric() to obtain the possible arguments of the</a>
<a name="ln9179"> * &quot;:behave {mswin,xterm}&quot; command.</a>
<a name="ln9180"> */</a>
<a name="ln9181">char_u *get_behave_arg(expand_T *xp, int idx)</a>
<a name="ln9182">{</a>
<a name="ln9183">  if (idx == 0)</a>
<a name="ln9184">    return (char_u *)&quot;mswin&quot;;</a>
<a name="ln9185">  if (idx == 1)</a>
<a name="ln9186">    return (char_u *)&quot;xterm&quot;;</a>
<a name="ln9187">  return NULL;</a>
<a name="ln9188">}</a>
<a name="ln9189"> </a>
<a name="ln9190">// Function given to ExpandGeneric() to obtain the possible arguments of the</a>
<a name="ln9191">// &quot;:messages {clear}&quot; command.</a>
<a name="ln9192">char_u *get_messages_arg(expand_T *xp FUNC_ATTR_UNUSED, int idx)</a>
<a name="ln9193">{</a>
<a name="ln9194">  if (idx == 0) {</a>
<a name="ln9195">    return (char_u *)&quot;clear&quot;;</a>
<a name="ln9196">  }</a>
<a name="ln9197">  return NULL;</a>
<a name="ln9198">}</a>
<a name="ln9199"> </a>
<a name="ln9200">char_u *get_mapclear_arg(expand_T *xp FUNC_ATTR_UNUSED, int idx)</a>
<a name="ln9201">{</a>
<a name="ln9202">  if (idx == 0) {</a>
<a name="ln9203">    return (char_u *)&quot;&lt;buffer&gt;&quot;;</a>
<a name="ln9204">  }</a>
<a name="ln9205">  return NULL;</a>
<a name="ln9206">}</a>
<a name="ln9207"> </a>
<a name="ln9208">static TriState filetype_detect = kNone;</a>
<a name="ln9209">static TriState filetype_plugin = kNone;</a>
<a name="ln9210">static TriState filetype_indent = kNone;</a>
<a name="ln9211"> </a>
<a name="ln9212">/*</a>
<a name="ln9213"> * &quot;:filetype [plugin] [indent] {on,off,detect}&quot;</a>
<a name="ln9214"> * on: Load the filetype.vim file to install autocommands for file types.</a>
<a name="ln9215"> * off: Load the ftoff.vim file to remove all autocommands for file types.</a>
<a name="ln9216"> * plugin on: load filetype.vim and ftplugin.vim</a>
<a name="ln9217"> * plugin off: load ftplugof.vim</a>
<a name="ln9218"> * indent on: load filetype.vim and indent.vim</a>
<a name="ln9219"> * indent off: load indoff.vim</a>
<a name="ln9220"> */</a>
<a name="ln9221">static void ex_filetype(exarg_T *eap)</a>
<a name="ln9222">{</a>
<a name="ln9223">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln9224">  bool plugin = false;</a>
<a name="ln9225">  bool indent = false;</a>
<a name="ln9226"> </a>
<a name="ln9227">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln9228">    /* Print current status. */</a>
<a name="ln9229">    smsg(&quot;filetype detection:%s  plugin:%s  indent:%s&quot;,</a>
<a name="ln9230">         filetype_detect == kTrue ? &quot;ON&quot; : &quot;OFF&quot;,</a>
<a name="ln9231">         filetype_plugin == kTrue ? (filetype_detect == kTrue ? &quot;ON&quot; : &quot;(on)&quot;) : &quot;OFF&quot;,   // NOLINT(whitespace/line_length)</a>
<a name="ln9232">         filetype_indent == kTrue ? (filetype_detect == kTrue ? &quot;ON&quot; : &quot;(on)&quot;) : &quot;OFF&quot;);  // NOLINT(whitespace/line_length)</a>
<a name="ln9233">    return;</a>
<a name="ln9234">  }</a>
<a name="ln9235"> </a>
<a name="ln9236">  /* Accept &quot;plugin&quot; and &quot;indent&quot; in any order. */</a>
<a name="ln9237">  for (;; ) {</a>
<a name="ln9238">    if (STRNCMP(arg, &quot;plugin&quot;, 6) == 0) {</a>
<a name="ln9239">      plugin = true;</a>
<a name="ln9240">      arg = skipwhite(arg + 6);</a>
<a name="ln9241">      continue;</a>
<a name="ln9242">    }</a>
<a name="ln9243">    if (STRNCMP(arg, &quot;indent&quot;, 6) == 0) {</a>
<a name="ln9244">      indent = true;</a>
<a name="ln9245">      arg = skipwhite(arg + 6);</a>
<a name="ln9246">      continue;</a>
<a name="ln9247">    }</a>
<a name="ln9248">    break;</a>
<a name="ln9249">  }</a>
<a name="ln9250">  if (STRCMP(arg, &quot;on&quot;) == 0 || STRCMP(arg, &quot;detect&quot;) == 0) {</a>
<a name="ln9251">    if (*arg == 'o' || !filetype_detect) {</a>
<a name="ln9252">      source_runtime((char_u *)FILETYPE_FILE, DIP_ALL);</a>
<a name="ln9253">      filetype_detect = kTrue;</a>
<a name="ln9254">      if (plugin) {</a>
<a name="ln9255">        source_runtime((char_u *)FTPLUGIN_FILE, DIP_ALL);</a>
<a name="ln9256">        filetype_plugin = kTrue;</a>
<a name="ln9257">      }</a>
<a name="ln9258">      if (indent) {</a>
<a name="ln9259">        source_runtime((char_u *)INDENT_FILE, DIP_ALL);</a>
<a name="ln9260">        filetype_indent = kTrue;</a>
<a name="ln9261">      }</a>
<a name="ln9262">    }</a>
<a name="ln9263">    if (*arg == 'd') {</a>
<a name="ln9264">      (void)do_doautocmd((char_u *)&quot;filetypedetect BufRead&quot;, true, NULL);</a>
<a name="ln9265">      do_modelines(0);</a>
<a name="ln9266">    }</a>
<a name="ln9267">  } else if (STRCMP(arg, &quot;off&quot;) == 0) {</a>
<a name="ln9268">    if (plugin || indent) {</a>
<a name="ln9269">      if (plugin) {</a>
<a name="ln9270">        source_runtime((char_u *)FTPLUGOF_FILE, DIP_ALL);</a>
<a name="ln9271">        filetype_plugin = kFalse;</a>
<a name="ln9272">      }</a>
<a name="ln9273">      if (indent) {</a>
<a name="ln9274">        source_runtime((char_u *)INDOFF_FILE, DIP_ALL);</a>
<a name="ln9275">        filetype_indent = kFalse;</a>
<a name="ln9276">      }</a>
<a name="ln9277">    } else {</a>
<a name="ln9278">      source_runtime((char_u *)FTOFF_FILE, DIP_ALL);</a>
<a name="ln9279">      filetype_detect = kFalse;</a>
<a name="ln9280">    }</a>
<a name="ln9281">  } else</a>
<a name="ln9282">    EMSG2(_(e_invarg2), arg);</a>
<a name="ln9283">}</a>
<a name="ln9284"> </a>
<a name="ln9285">/// Set all :filetype options ON if user did not explicitly set any to OFF.</a>
<a name="ln9286">void filetype_maybe_enable(void)</a>
<a name="ln9287">{</a>
<a name="ln9288">  if (filetype_detect == kNone) {</a>
<a name="ln9289">    source_runtime((char_u *)FILETYPE_FILE, true);</a>
<a name="ln9290">    filetype_detect = kTrue;</a>
<a name="ln9291">  }</a>
<a name="ln9292">  if (filetype_plugin == kNone) {</a>
<a name="ln9293">    source_runtime((char_u *)FTPLUGIN_FILE, true);</a>
<a name="ln9294">    filetype_plugin = kTrue;</a>
<a name="ln9295">  }</a>
<a name="ln9296">  if (filetype_indent == kNone) {</a>
<a name="ln9297">    source_runtime((char_u *)INDENT_FILE, true);</a>
<a name="ln9298">    filetype_indent = kTrue;</a>
<a name="ln9299">  }</a>
<a name="ln9300">}</a>
<a name="ln9301"> </a>
<a name="ln9302">/// &quot;:setfiletype [FALLBACK] {name}&quot;</a>
<a name="ln9303">static void ex_setfiletype(exarg_T *eap)</a>
<a name="ln9304">{</a>
<a name="ln9305">  if (!did_filetype) {</a>
<a name="ln9306">    char_u *arg = eap-&gt;arg;</a>
<a name="ln9307"> </a>
<a name="ln9308">    if (STRNCMP(arg, &quot;FALLBACK &quot;, 9) == 0) {</a>
<a name="ln9309">      arg += 9;</a>
<a name="ln9310">    }</a>
<a name="ln9311"> </a>
<a name="ln9312">    set_option_value(&quot;filetype&quot;, 0L, (char *)arg, OPT_LOCAL);</a>
<a name="ln9313">    if (arg != eap-&gt;arg) {</a>
<a name="ln9314">      did_filetype = false;</a>
<a name="ln9315">    }</a>
<a name="ln9316">  }</a>
<a name="ln9317">}</a>
<a name="ln9318"> </a>
<a name="ln9319">static void ex_digraphs(exarg_T *eap)</a>
<a name="ln9320">{</a>
<a name="ln9321">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln9322">    putdigraph(eap-&gt;arg);</a>
<a name="ln9323">  } else {</a>
<a name="ln9324">    listdigraphs(eap-&gt;forceit);</a>
<a name="ln9325">  }</a>
<a name="ln9326">}</a>
<a name="ln9327"> </a>
<a name="ln9328">static void ex_set(exarg_T *eap)</a>
<a name="ln9329">{</a>
<a name="ln9330">  int flags = 0;</a>
<a name="ln9331"> </a>
<a name="ln9332">  if (eap-&gt;cmdidx == CMD_setlocal)</a>
<a name="ln9333">    flags = OPT_LOCAL;</a>
<a name="ln9334">  else if (eap-&gt;cmdidx == CMD_setglobal)</a>
<a name="ln9335">    flags = OPT_GLOBAL;</a>
<a name="ln9336">  (void)do_set(eap-&gt;arg, flags);</a>
<a name="ln9337">}</a>
<a name="ln9338"> </a>
<a name="ln9339">void set_no_hlsearch(bool flag)</a>
<a name="ln9340">{</a>
<a name="ln9341">  no_hlsearch = flag;</a>
<a name="ln9342">  set_vim_var_nr(VV_HLSEARCH, !no_hlsearch &amp;&amp; p_hls);</a>
<a name="ln9343">}</a>
<a name="ln9344"> </a>
<a name="ln9345">/*</a>
<a name="ln9346"> * &quot;:nohlsearch&quot;</a>
<a name="ln9347"> */</a>
<a name="ln9348">static void ex_nohlsearch(exarg_T *eap)</a>
<a name="ln9349">{</a>
<a name="ln9350">  set_no_hlsearch(true);</a>
<a name="ln9351">  redraw_all_later(SOME_VALID);</a>
<a name="ln9352">}</a>
<a name="ln9353"> </a>
<a name="ln9354">// &quot;:[N]match {group} {pattern}&quot;</a>
<a name="ln9355">// Sets nextcmd to the start of the next command, if any.  Also called when</a>
<a name="ln9356">// skipping commands to find the next command.</a>
<a name="ln9357">static void ex_match(exarg_T *eap)</a>
<a name="ln9358">{</a>
<a name="ln9359">  char_u *p;</a>
<a name="ln9360">  char_u *g = NULL;</a>
<a name="ln9361">  char_u *end;</a>
<a name="ln9362">  int c;</a>
<a name="ln9363">  int id;</a>
<a name="ln9364"> </a>
<a name="ln9365">  if (eap-&gt;line2 &lt;= 3) {</a>
<a name="ln9366">    id = eap-&gt;line2;</a>
<a name="ln9367">  } else {</a>
<a name="ln9368">    EMSG(e_invcmd);</a>
<a name="ln9369">    return;</a>
<a name="ln9370">  }</a>
<a name="ln9371"> </a>
<a name="ln9372">  // First clear any old pattern.</a>
<a name="ln9373">  if (!eap-&gt;skip) {</a>
<a name="ln9374">    match_delete(curwin, id, false);</a>
<a name="ln9375">  }</a>
<a name="ln9376"> </a>
<a name="ln9377">  if (ends_excmd(*eap-&gt;arg)) {</a>
<a name="ln9378">    end = eap-&gt;arg;</a>
<a name="ln9379">  } else if ((STRNICMP(eap-&gt;arg, &quot;none&quot;, 4) == 0</a>
<a name="ln9380">              &amp;&amp; (ascii_iswhite(eap-&gt;arg[4]) || ends_excmd(eap-&gt;arg[4])))) {</a>
<a name="ln9381">    end = eap-&gt;arg + 4;</a>
<a name="ln9382">  } else {</a>
<a name="ln9383">    p = skiptowhite(eap-&gt;arg);</a>
<a name="ln9384">    if (!eap-&gt;skip) {</a>
<a name="ln9385">      g = vim_strnsave(eap-&gt;arg, p - eap-&gt;arg);</a>
<a name="ln9386">    }</a>
<a name="ln9387">    p = skipwhite(p);</a>
<a name="ln9388">    if (*p == NUL) {</a>
<a name="ln9389">      // There must be two arguments.</a>
<a name="ln9390">      xfree(g);</a>
<a name="ln9391">      EMSG2(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln9392">      return;</a>
<a name="ln9393">    }</a>
<a name="ln9394">    end = skip_regexp(p + 1, *p, true, NULL);</a>
<a name="ln9395">    if (!eap-&gt;skip) {</a>
<a name="ln9396">      if (*end != NUL &amp;&amp; !ends_excmd(*skipwhite(end + 1))) {</a>
<a name="ln9397">        xfree(g);</a>
<a name="ln9398">        eap-&gt;errmsg = e_trailing;</a>
<a name="ln9399">        return;</a>
<a name="ln9400">      }</a>
<a name="ln9401">      if (*end != *p) {</a>
<a name="ln9402">        xfree(g);</a>
<a name="ln9403">        EMSG2(_(e_invarg2), p);</a>
<a name="ln9404">        return;</a>
<a name="ln9405">      }</a>
<a name="ln9406"> </a>
<a name="ln9407">      c = *end;</a>
<a name="ln9408">      *end = NUL;</a>
<a name="ln9409">      match_add(curwin, (const char *)g, (const char *)p + 1, 10, id,</a>
<a name="ln9410">                NULL, NULL);</a>
<a name="ln9411">      xfree(g);</a>
<a name="ln9412">      *end = c;</a>
<a name="ln9413">    }</a>
<a name="ln9414">  }</a>
<a name="ln9415">  eap-&gt;nextcmd = find_nextcmd(end);</a>
<a name="ln9416">}</a>
<a name="ln9417"> </a>
<a name="ln9418">static void ex_fold(exarg_T *eap)</a>
<a name="ln9419">{</a>
<a name="ln9420">  if (foldManualAllowed(true)) {</a>
<a name="ln9421">    pos_T start = { eap-&gt;line1, 1, 0 };</a>
<a name="ln9422">    pos_T end = { eap-&gt;line2, 1, 0 };</a>
<a name="ln9423">    foldCreate(curwin, start, end);</a>
<a name="ln9424">  }</a>
<a name="ln9425">}</a>
<a name="ln9426"> </a>
<a name="ln9427">static void ex_foldopen(exarg_T *eap)</a>
<a name="ln9428">{</a>
<a name="ln9429">  pos_T start = { eap-&gt;line1, 1, 0 };</a>
<a name="ln9430">  pos_T end = { eap-&gt;line2, 1, 0 };</a>
<a name="ln9431">  opFoldRange(start, end, eap-&gt;cmdidx == CMD_foldopen, eap-&gt;forceit, false);</a>
<a name="ln9432">}</a>
<a name="ln9433"> </a>
<a name="ln9434">static void ex_folddo(exarg_T *eap)</a>
<a name="ln9435">{</a>
<a name="ln9436">  // First set the marks for all lines closed/open.</a>
<a name="ln9437">  for (linenr_T lnum = eap-&gt;line1; lnum &lt;= eap-&gt;line2; ++lnum) {</a>
<a name="ln9438">    if (hasFolding(lnum, NULL, NULL) == (eap-&gt;cmdidx == CMD_folddoclosed)) {</a>
<a name="ln9439">      ml_setmarked(lnum);</a>
<a name="ln9440">    }</a>
<a name="ln9441">  }</a>
<a name="ln9442"> </a>
<a name="ln9443">  global_exe(eap-&gt;arg);  // Execute the command on the marked lines.</a>
<a name="ln9444">  ml_clearmarked();      // clear rest of the marks</a>
<a name="ln9445">}</a>
<a name="ln9446"> </a>
<a name="ln9447">// Returns true if the supplied Ex cmdidx is for a location list command</a>
<a name="ln9448">// instead of a quickfix command.</a>
<a name="ln9449">bool is_loclist_cmd(int cmdidx)</a>
<a name="ln9450">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln9451">{</a>
<a name="ln9452">  if (cmdidx &lt; 0 || cmdidx &gt;= CMD_SIZE) {</a>
<a name="ln9453">    return false;</a>
<a name="ln9454">  }</a>
<a name="ln9455">  return cmdnames[cmdidx].cmd_name[0] == 'l';</a>
<a name="ln9456">}</a>
<a name="ln9457"> </a>
<a name="ln9458">bool get_pressedreturn(void)</a>
<a name="ln9459">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln9460">{</a>
<a name="ln9461">  return ex_pressedreturn;</a>
<a name="ln9462">}</a>
<a name="ln9463"> </a>
<a name="ln9464">void set_pressedreturn(bool val)</a>
<a name="ln9465">{</a>
<a name="ln9466">  ex_pressedreturn = val;</a>
<a name="ln9467">}</a>
<a name="ln9468"> </a>
<a name="ln9469">static void ex_terminal(exarg_T *eap)</a>
<a name="ln9470">{</a>
<a name="ln9471">  char ex_cmd[1024];</a>
<a name="ln9472"> </a>
<a name="ln9473">  if (*eap-&gt;arg != NUL) {  // Run {cmd} in 'shell'.</a>
<a name="ln9474">    char *name = (char *)vim_strsave_escaped(eap-&gt;arg, (char_u *)&quot;\&quot;\\&quot;);</a>
<a name="ln9475">    snprintf(ex_cmd, sizeof(ex_cmd),</a>
<a name="ln9476">             &quot;:enew%s | call termopen(\&quot;%s\&quot;)&quot;,</a>
<a name="ln9477">             eap-&gt;forceit ? &quot;!&quot; : &quot;&quot;, name);</a>
<a name="ln9478">    xfree(name);</a>
<a name="ln9479">  } else {  // No {cmd}: run the job with tokenized 'shell'.</a>
<a name="ln9480">    if (*p_sh == NUL) {</a>
<a name="ln9481">      EMSG(_(e_shellempty));</a>
<a name="ln9482">      return;</a>
<a name="ln9483">    }</a>
<a name="ln9484"> </a>
<a name="ln9485">    char **argv = shell_build_argv(NULL, NULL);</a>
<a name="ln9486">    char **p = argv;</a>
<a name="ln9487">    char tempstring[512];</a>
<a name="ln9488">    char shell_argv[512] = { 0 };</a>
<a name="ln9489"> </a>
<a name="ln9490">    while (*p != NULL) {</a>
<a name="ln9491">      snprintf(tempstring, sizeof(tempstring), &quot;,\&quot;%s\&quot;&quot;, *p);</a>
<a name="ln9492">      xstrlcat(shell_argv, tempstring, sizeof(shell_argv));</a>
<a name="ln9493">      p++;</a>
<a name="ln9494">    }</a>
<a name="ln9495">    shell_free_argv(argv);</a>
<a name="ln9496"> </a>
<a name="ln9497">    snprintf(ex_cmd, sizeof(ex_cmd),</a>
<a name="ln9498">             &quot;:enew%s | call termopen([%s])&quot;,</a>
<a name="ln9499">             eap-&gt;forceit ? &quot;!&quot; : &quot;&quot;, shell_argv + 1);</a>
<a name="ln9500">  }</a>
<a name="ln9501"> </a>
<a name="ln9502">  do_cmdline_cmd(ex_cmd);</a>
<a name="ln9503">}</a>
<a name="ln9504"> </a>
<a name="ln9505">/// Checks if `cmd` is &quot;previewable&quot; (i.e. supported by 'inccommand').</a>
<a name="ln9506">///</a>
<a name="ln9507">/// @param[in] cmd Commandline to check. May start with a range or modifier.</a>
<a name="ln9508">///</a>
<a name="ln9509">/// @return true if `cmd` is previewable</a>
<a name="ln9510">bool cmd_can_preview(char_u *cmd)</a>
<a name="ln9511">{</a>
<a name="ln9512">  if (cmd == NULL) {</a>
<a name="ln9513">    return false;</a>
<a name="ln9514">  }</a>
<a name="ln9515"> </a>
<a name="ln9516">  // Ignore additional colons at the start...</a>
<a name="ln9517">  cmd = skip_colon_white(cmd, true);</a>
<a name="ln9518"> </a>
<a name="ln9519">  // Ignore any leading modifiers (:keeppatterns, :verbose, etc.)</a>
<a name="ln9520">  for (int len = modifier_len(cmd); len != 0; len = modifier_len(cmd)) {</a>
<a name="ln9521">    cmd += len;</a>
<a name="ln9522">    cmd = skip_colon_white(cmd, true);</a>
<a name="ln9523">  }</a>
<a name="ln9524"> </a>
<a name="ln9525">  exarg_T ea;</a>
<a name="ln9526">  memset(&amp;ea, 0, sizeof(ea));</a>
<a name="ln9527">  // parse the command line</a>
<a name="ln9528">  ea.cmd = skip_range(cmd, NULL);</a>
<a name="ln9529">  if (*ea.cmd == '*') {</a>
<a name="ln9530">    ea.cmd = skipwhite(ea.cmd + 1);</a>
<a name="ln9531">  }</a>
<a name="ln9532">  char_u *end = find_command(&amp;ea, NULL);</a>
<a name="ln9533"> </a>
<a name="ln9534">  switch (ea.cmdidx) {</a>
<a name="ln9535">    case CMD_substitute:</a>
<a name="ln9536">    case CMD_smagic:</a>
<a name="ln9537">    case CMD_snomagic:</a>
<a name="ln9538">      // Only preview once the pattern delimiter has been typed</a>
<a name="ln9539">      if (*end &amp;&amp; !ASCII_ISALNUM(*end)) {</a>
<a name="ln9540">        return true;</a>
<a name="ln9541">      }</a>
<a name="ln9542">      break;</a>
<a name="ln9543">    default:</a>
<a name="ln9544">      break;</a>
<a name="ln9545">  }</a>
<a name="ln9546"> </a>
<a name="ln9547">  return false;</a>
<a name="ln9548">}</a>
<a name="ln9549"> </a>
<a name="ln9550">/// Gets a map of maps describing user-commands defined for buffer `buf` or</a>
<a name="ln9551">/// defined globally if `buf` is NULL.</a>
<a name="ln9552">///</a>
<a name="ln9553">/// @param buf  Buffer to inspect, or NULL to get global commands.</a>
<a name="ln9554">///</a>
<a name="ln9555">/// @return Map of maps describing commands</a>
<a name="ln9556">Dictionary commands_array(buf_T *buf)</a>
<a name="ln9557">{</a>
<a name="ln9558">  Dictionary rv = ARRAY_DICT_INIT;</a>
<a name="ln9559">  char str[20];</a>
<a name="ln9560">  garray_T *gap = (buf == NULL) ? &amp;ucmds : &amp;buf-&gt;b_ucmds;</a>
<a name="ln9561"> </a>
<a name="ln9562">  for (int i = 0; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln9563">    char arg[2] = { 0, 0 };</a>
<a name="ln9564">    Dictionary d = ARRAY_DICT_INIT;</a>
<a name="ln9565">    ucmd_T *cmd = USER_CMD_GA(gap, i);</a>
<a name="ln9566"> </a>
<a name="ln9567">    PUT(d, &quot;name&quot;, STRING_OBJ(cstr_to_string((char *)cmd-&gt;uc_name)));</a>
<a name="ln9568">    PUT(d, &quot;definition&quot;, STRING_OBJ(cstr_to_string((char *)cmd-&gt;uc_rep)));</a>
<a name="ln9569">    PUT(d, &quot;script_id&quot;, INTEGER_OBJ(cmd-&gt;uc_script_ctx.sc_sid));</a>
<a name="ln9570">    PUT(d, &quot;bang&quot;, BOOLEAN_OBJ(!!(cmd-&gt;uc_argt &amp; EX_BANG)));</a>
<a name="ln9571">    PUT(d, &quot;bar&quot;, BOOLEAN_OBJ(!!(cmd-&gt;uc_argt &amp; EX_TRLBAR)));</a>
<a name="ln9572">    PUT(d, &quot;register&quot;, BOOLEAN_OBJ(!!(cmd-&gt;uc_argt &amp; EX_REGSTR)));</a>
<a name="ln9573"> </a>
<a name="ln9574">    switch (cmd-&gt;uc_argt &amp; (EX_EXTRA | EX_NOSPC | EX_NEEDARG)) {</a>
<a name="ln9575">      case 0:                                 arg[0] = '0'; break;</a>
<a name="ln9576">      case(EX_EXTRA):                         arg[0] = '*'; break;</a>
<a name="ln9577">      case(EX_EXTRA | EX_NOSPC):              arg[0] = '?'; break;</a>
<a name="ln9578">      case(EX_EXTRA | EX_NEEDARG):            arg[0] = '+'; break;</a>
<a name="ln9579">      case(EX_EXTRA | EX_NOSPC | EX_NEEDARG): arg[0] = '1'; break;</a>
<a name="ln9580">    }</a>
<a name="ln9581">    PUT(d, &quot;nargs&quot;, STRING_OBJ(cstr_to_string(arg)));</a>
<a name="ln9582"> </a>
<a name="ln9583">    char *cmd_compl = get_command_complete(cmd-&gt;uc_compl);</a>
<a name="ln9584">    PUT(d, &quot;complete&quot;, (cmd_compl == NULL</a>
<a name="ln9585">                        ? NIL : STRING_OBJ(cstr_to_string(cmd_compl))));</a>
<a name="ln9586">    PUT(d, &quot;complete_arg&quot;, cmd-&gt;uc_compl_arg == NULL</a>
<a name="ln9587">        ? NIL : STRING_OBJ(cstr_to_string((char *)cmd-&gt;uc_compl_arg)));</a>
<a name="ln9588"> </a>
<a name="ln9589">    Object obj = NIL;</a>
<a name="ln9590">    if (cmd-&gt;uc_argt &amp; EX_COUNT) {</a>
<a name="ln9591">      if (cmd-&gt;uc_def &gt;= 0) {</a>
<a name="ln9592">        snprintf(str, sizeof(str), &quot;%&quot; PRId64, (int64_t)cmd-&gt;uc_def);</a>
<a name="ln9593">        obj = STRING_OBJ(cstr_to_string(str));    // -count=N</a>
<a name="ln9594">      } else {</a>
<a name="ln9595">        obj = STRING_OBJ(cstr_to_string(&quot;0&quot;));    // -count</a>
<a name="ln9596">      }</a>
<a name="ln9597">    }</a>
<a name="ln9598">    PUT(d, &quot;count&quot;, obj);</a>
<a name="ln9599"> </a>
<a name="ln9600">    obj = NIL;</a>
<a name="ln9601">    if (cmd-&gt;uc_argt &amp; EX_RANGE) {</a>
<a name="ln9602">      if (cmd-&gt;uc_argt &amp; EX_DFLALL) {</a>
<a name="ln9603">        obj = STRING_OBJ(cstr_to_string(&quot;%&quot;));    // -range=%</a>
<a name="ln9604">      } else if (cmd-&gt;uc_def &gt;= 0) {</a>
<a name="ln9605">        snprintf(str, sizeof(str), &quot;%&quot; PRId64, (int64_t)cmd-&gt;uc_def);</a>
<a name="ln9606">        obj = STRING_OBJ(cstr_to_string(str));    // -range=N</a>
<a name="ln9607">      } else {</a>
<a name="ln9608">        obj = STRING_OBJ(cstr_to_string(&quot;.&quot;));    // -range</a>
<a name="ln9609">      }</a>
<a name="ln9610">    }</a>
<a name="ln9611">    PUT(d, &quot;range&quot;, obj);</a>
<a name="ln9612"> </a>
<a name="ln9613">    obj = NIL;</a>
<a name="ln9614">    for (int j = 0; addr_type_complete[j].expand != ADDR_NONE; j++) {</a>
<a name="ln9615">      if (addr_type_complete[j].expand != ADDR_LINES</a>
<a name="ln9616">          &amp;&amp; addr_type_complete[j].expand == cmd-&gt;uc_addr_type) {</a>
<a name="ln9617">        obj = STRING_OBJ(cstr_to_string(addr_type_complete[j].name));</a>
<a name="ln9618">        break;</a>
<a name="ln9619">      }</a>
<a name="ln9620">    }</a>
<a name="ln9621">    PUT(d, &quot;addr&quot;, obj);</a>
<a name="ln9622"> </a>
<a name="ln9623">    PUT(rv, (char *)cmd-&gt;uc_name, DICTIONARY_OBJ(d));</a>
<a name="ln9624">  }</a>
<a name="ln9625">  return rv;</a>
<a name="ln9626">}</a>

</code></pre>
<div class="balloon" rel="4183"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'eap->line2 < 0' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
