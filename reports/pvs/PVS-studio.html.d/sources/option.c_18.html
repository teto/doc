
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>option.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// User-settable options. Checklist for adding a new option:</a>
<a name="ln5">// - Put it in options.lua</a>
<a name="ln6">// - For a global option: Add a variable for it in option_defs.h.</a>
<a name="ln7">// - For a buffer or window local option:</a>
<a name="ln8">//   - Add a BV_XX or WV_XX entry to option_defs.h</a>
<a name="ln9">//   - Add a variable to the window or buffer struct in buffer_defs.h.</a>
<a name="ln10">//   - For a window option, add some code to copy_winopt().</a>
<a name="ln11">//   - For a window string option, add code to check_winopt()</a>
<a name="ln12">//     and clear_winopt(). If setting the option needs parsing,</a>
<a name="ln13">//     add some code to didset_window_options().</a>
<a name="ln14">//   - For a buffer option, add some code to buf_copy_options().</a>
<a name="ln15">//   - For a buffer string option, add code to check_buf_options().</a>
<a name="ln16">// - If it's a numeric option, add any necessary bounds checks to</a>
<a name="ln17">//   set_num_option().</a>
<a name="ln18">// - If it's a list of flags, add some code in do_set(), search for WW_ALL.</a>
<a name="ln19">// - When adding an option with expansion (P_EXPAND), but with a different</a>
<a name="ln20">//   default for Vi and Vim (no P_VI_DEF), add some code at VIMEXP.</a>
<a name="ln21">// - Add documentation! doc/options.txt, and any other related places.</a>
<a name="ln22">// - Add an entry in runtime/optwin.vim.</a>
<a name="ln23"> </a>
<a name="ln24">#define IN_OPTION_C</a>
<a name="ln25">#include &lt;assert.h&gt;</a>
<a name="ln26">#include &lt;inttypes.h&gt;</a>
<a name="ln27">#include &lt;stdbool.h&gt;</a>
<a name="ln28">#include &lt;string.h&gt;</a>
<a name="ln29">#include &lt;stdlib.h&gt;</a>
<a name="ln30">#include &lt;limits.h&gt;</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;nvim/vim.h&quot;</a>
<a name="ln33">#include &quot;nvim/macros.h&quot;</a>
<a name="ln34">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln35">#include &quot;nvim/edit.h&quot;</a>
<a name="ln36">#include &quot;nvim/option.h&quot;</a>
<a name="ln37">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln38">#include &quot;nvim/charset.h&quot;</a>
<a name="ln39">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln40">#include &quot;nvim/diff.h&quot;</a>
<a name="ln41">#include &quot;nvim/digraph.h&quot;</a>
<a name="ln42">#include &quot;nvim/eval.h&quot;</a>
<a name="ln43">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln44">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln45">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln46">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln47">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln48">#include &quot;nvim/fold.h&quot;</a>
<a name="ln49">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln50">#include &quot;nvim/hardcopy.h&quot;</a>
<a name="ln51">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln52">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln53">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln54">#include &quot;nvim/memfile.h&quot;</a>
<a name="ln55">#include &quot;nvim/memline.h&quot;</a>
<a name="ln56">#include &quot;nvim/memory.h&quot;</a>
<a name="ln57">#include &quot;nvim/message.h&quot;</a>
<a name="ln58">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln59">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln60">#include &quot;nvim/keymap.h&quot;</a>
<a name="ln61">#include &quot;nvim/garray.h&quot;</a>
<a name="ln62">#include &quot;nvim/cursor_shape.h&quot;</a>
<a name="ln63">#include &quot;nvim/move.h&quot;</a>
<a name="ln64">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln65">#include &quot;nvim/normal.h&quot;</a>
<a name="ln66">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln67">#include &quot;nvim/path.h&quot;</a>
<a name="ln68">#include &quot;nvim/popupmnu.h&quot;</a>
<a name="ln69">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln70">#include &quot;nvim/ex_session.h&quot;</a>
<a name="ln71">#include &quot;nvim/screen.h&quot;</a>
<a name="ln72">#include &quot;nvim/spell.h&quot;</a>
<a name="ln73">#include &quot;nvim/spellfile.h&quot;</a>
<a name="ln74">#include &quot;nvim/strings.h&quot;</a>
<a name="ln75">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln76">#include &quot;nvim/ui.h&quot;</a>
<a name="ln77">#include &quot;nvim/ui_compositor.h&quot;</a>
<a name="ln78">#include &quot;nvim/undo.h&quot;</a>
<a name="ln79">#include &quot;nvim/window.h&quot;</a>
<a name="ln80">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln81">#ifdef WIN32</a>
<a name="ln82"># include &quot;nvim/os/pty_conpty_win.h&quot;</a>
<a name="ln83">#endif</a>
<a name="ln84">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln85">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln86">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln87">#include &quot;nvim/os/lang.h&quot;</a>
<a name="ln88"> </a>
<a name="ln89">/*</a>
<a name="ln90"> * The options that are local to a window or buffer have &quot;indir&quot; set to one of</a>
<a name="ln91"> * these values.  Special values:</a>
<a name="ln92"> * PV_NONE: global option.</a>
<a name="ln93"> * PV_WIN is added: window-local option</a>
<a name="ln94"> * PV_BUF is added: buffer-local option</a>
<a name="ln95"> * PV_BOTH is added: global option which also has a local value.</a>
<a name="ln96"> */</a>
<a name="ln97">#define PV_BOTH 0x1000</a>
<a name="ln98">#define PV_WIN  0x2000</a>
<a name="ln99">#define PV_BUF  0x4000</a>
<a name="ln100">#define PV_MASK 0x0fff</a>
<a name="ln101">#define OPT_WIN(x)  (idopt_T)(PV_WIN + (int)(x))</a>
<a name="ln102">#define OPT_BUF(x)  (idopt_T)(PV_BUF + (int)(x))</a>
<a name="ln103">#define OPT_BOTH(x) (idopt_T)(PV_BOTH + (int)(x))</a>
<a name="ln104"> </a>
<a name="ln105"> </a>
<a name="ln106">// WV_ and BV_ values get typecasted to this for the &quot;indir&quot; field</a>
<a name="ln107">typedef enum {</a>
<a name="ln108">  PV_NONE = 0,</a>
<a name="ln109">  PV_MAXVAL = 0xffff      // to avoid warnings for value out of range</a>
<a name="ln110">} idopt_T;</a>
<a name="ln111"> </a>
<a name="ln112">/*</a>
<a name="ln113"> * Options local to a window have a value local to a buffer and global to all</a>
<a name="ln114"> * buffers.  Indicate this by setting &quot;var&quot; to VAR_WIN.</a>
<a name="ln115"> */</a>
<a name="ln116">#define VAR_WIN ((char_u *)-1)</a>
<a name="ln117"> </a>
<a name="ln118">static char *p_term = NULL;</a>
<a name="ln119">static char *p_ttytype = NULL;</a>
<a name="ln120"> </a>
<a name="ln121">/*</a>
<a name="ln122"> * These are the global values for options which are also local to a buffer.</a>
<a name="ln123"> * Only to be used in option.c!</a>
<a name="ln124"> */</a>
<a name="ln125">static int p_ai;</a>
<a name="ln126">static int p_bin;</a>
<a name="ln127">static int p_bomb;</a>
<a name="ln128">static char_u   *p_bh;</a>
<a name="ln129">static char_u   *p_bt;</a>
<a name="ln130">static int p_bl;</a>
<a name="ln131">static long p_channel;</a>
<a name="ln132">static int p_ci;</a>
<a name="ln133">static int p_cin;</a>
<a name="ln134">static char_u   *p_cink;</a>
<a name="ln135">static char_u   *p_cino;</a>
<a name="ln136">static char_u   *p_cinw;</a>
<a name="ln137">static char_u   *p_com;</a>
<a name="ln138">static char_u   *p_cms;</a>
<a name="ln139">static char_u   *p_cpt;</a>
<a name="ln140">static char_u   *p_cfu;</a>
<a name="ln141">static char_u   *p_ofu;</a>
<a name="ln142">static char_u   *p_tfu;</a>
<a name="ln143">static int p_eol;</a>
<a name="ln144">static int p_fixeol;</a>
<a name="ln145">static int p_et;</a>
<a name="ln146">static char_u   *p_fenc;</a>
<a name="ln147">static char_u   *p_ff;</a>
<a name="ln148">static char_u   *p_fo;</a>
<a name="ln149">static char_u   *p_flp;</a>
<a name="ln150">static char_u   *p_ft;</a>
<a name="ln151">static long p_iminsert;</a>
<a name="ln152">static long p_imsearch;</a>
<a name="ln153">static char_u   *p_inex;</a>
<a name="ln154">static char_u   *p_inde;</a>
<a name="ln155">static char_u   *p_indk;</a>
<a name="ln156">static char_u   *p_fex;</a>
<a name="ln157">static int p_inf;</a>
<a name="ln158">static char_u   *p_isk;</a>
<a name="ln159">static int p_lisp;</a>
<a name="ln160">static int p_ml;</a>
<a name="ln161">static int p_ma;</a>
<a name="ln162">static int p_mod;</a>
<a name="ln163">static char_u   *p_mps;</a>
<a name="ln164">static char_u   *p_nf;</a>
<a name="ln165">static int p_pi;</a>
<a name="ln166">static char_u   *p_qe;</a>
<a name="ln167">static int p_ro;</a>
<a name="ln168">static int p_si;</a>
<a name="ln169">static long p_sts;</a>
<a name="ln170">static char_u   *p_sua;</a>
<a name="ln171">static long p_sw;</a>
<a name="ln172">static int p_swf;</a>
<a name="ln173">static long p_smc;</a>
<a name="ln174">static char_u   *p_syn;</a>
<a name="ln175">static char_u   *p_spc;</a>
<a name="ln176">static char_u   *p_spf;</a>
<a name="ln177">static char_u   *p_spl;</a>
<a name="ln178">static char_u   *p_spo;</a>
<a name="ln179">static long p_ts;</a>
<a name="ln180">static long p_tw;</a>
<a name="ln181">static int p_udf;</a>
<a name="ln182">static long p_wm;</a>
<a name="ln183">static char_u *p_vsts;</a>
<a name="ln184">static char_u *p_vts;</a>
<a name="ln185">static char_u   *p_keymap;</a>
<a name="ln186"> </a>
<a name="ln187">// Saved values for when 'bin' is set.</a>
<a name="ln188">static int p_et_nobin;</a>
<a name="ln189">static int p_ml_nobin;</a>
<a name="ln190">static long p_tw_nobin;</a>
<a name="ln191">static long p_wm_nobin;</a>
<a name="ln192"> </a>
<a name="ln193">// Saved values for when 'paste' is set.</a>
<a name="ln194">static int p_ai_nopaste;</a>
<a name="ln195">static int p_et_nopaste;</a>
<a name="ln196">static long p_sts_nopaste;</a>
<a name="ln197">static long p_tw_nopaste;</a>
<a name="ln198">static long p_wm_nopaste;</a>
<a name="ln199">static char_u *p_vsts_nopaste;</a>
<a name="ln200"> </a>
<a name="ln201">typedef struct vimoption {</a>
<a name="ln202">  char        *fullname;        // full option name</a>
<a name="ln203">  char        *shortname;       // permissible abbreviation</a>
<a name="ln204">  uint32_t flags;               // see below</a>
<a name="ln205">  char_u      *var;             // global option: pointer to variable;</a>
<a name="ln206">                                // window-local option: VAR_WIN;</a>
<a name="ln207">                                // buffer-local option: global value</a>
<a name="ln208">  idopt_T indir;                // global option: PV_NONE;</a>
<a name="ln209">                                // local option: indirect option index</a>
<a name="ln210">  char_u      *def_val[2];      // default values for variable (vi and vim)</a>
<a name="ln211">  LastSet last_set;             // script in which the option was last set</a>
<a name="ln212">} vimoption_T;</a>
<a name="ln213"> </a>
<a name="ln214">#define VI_DEFAULT  0       // def_val[VI_DEFAULT] is Vi default value</a>
<a name="ln215">#define VIM_DEFAULT 1       // def_val[VIM_DEFAULT] is Vim default value</a>
<a name="ln216"> </a>
<a name="ln217">/*</a>
<a name="ln218"> * Flags</a>
<a name="ln219"> */</a>
<a name="ln220">#define P_BOOL          0x01U    // the option is boolean</a>
<a name="ln221">#define P_NUM           0x02U    // the option is numeric</a>
<a name="ln222">#define P_STRING        0x04U    // the option is a string</a>
<a name="ln223">#define P_ALLOCED       0x08U    // the string option is in allocated memory,</a>
<a name="ln224">                                 // must use free_string_option() when</a>
<a name="ln225">                                 // assigning new value. Not set if default is</a>
<a name="ln226">                                 // the same.</a>
<a name="ln227">#define P_EXPAND        0x10U    // environment expansion.  NOTE: P_EXPAND can</a>
<a name="ln228">                                 // never be used for local or hidden options</a>
<a name="ln229">#define P_NODEFAULT     0x40U    // don't set to default value</a>
<a name="ln230">#define P_DEF_ALLOCED   0x80U    // default value is in allocated memory, must</a>
<a name="ln231">                                 // use free() when assigning new value</a>
<a name="ln232">#define P_WAS_SET       0x100U   // option has been set/reset</a>
<a name="ln233">#define P_NO_MKRC       0x200U   // don't include in :mkvimrc output</a>
<a name="ln234">#define P_VI_DEF        0x400U   // Use Vi default for Vim</a>
<a name="ln235">#define P_VIM           0x800U   // Vim option</a>
<a name="ln236"> </a>
<a name="ln237">// when option changed, what to display:</a>
<a name="ln238">#define P_RSTAT         0x1000U  ///&lt; redraw status lines</a>
<a name="ln239">#define P_RWIN          0x2000U  ///&lt; redraw current window and recompute text</a>
<a name="ln240">#define P_RBUF          0x4000U  ///&lt; redraw current buffer and recompute text</a>
<a name="ln241">#define P_RALL          0x6000U  ///&lt; redraw all windows</a>
<a name="ln242">#define P_RCLR          0x7000U  ///&lt; clear and redraw all</a>
<a name="ln243"> </a>
<a name="ln244">#define P_COMMA         0x8000U    ///&lt; comma separated list</a>
<a name="ln245">#define P_ONECOMMA      0x18000U   ///&lt; P_COMMA and cannot have two consecutive</a>
<a name="ln246">                                   ///&lt; commas</a>
<a name="ln247">#define P_NODUP         0x20000U   ///&lt; don't allow duplicate strings</a>
<a name="ln248">#define P_FLAGLIST      0x40000U   ///&lt; list of single-char flags</a>
<a name="ln249"> </a>
<a name="ln250">#define P_SECURE        0x80000U   ///&lt; cannot change in modeline or secure mode</a>
<a name="ln251">#define P_GETTEXT       0x100000U  ///&lt; expand default value with _()</a>
<a name="ln252">#define P_NOGLOB        0x200000U  ///&lt; do not use local value for global vimrc</a>
<a name="ln253">#define P_NFNAME        0x400000U  ///&lt; only normal file name chars allowed</a>
<a name="ln254">#define P_INSECURE      0x800000U  ///&lt; option was set from a modeline</a>
<a name="ln255">#define P_PRI_MKRC     0x1000000U  ///&lt; priority for :mkvimrc (setting option</a>
<a name="ln256">                                   ///&lt; has side effects)</a>
<a name="ln257">#define P_NO_ML        0x2000000U  ///&lt; not allowed in modeline</a>
<a name="ln258">#define P_CURSWANT     0x4000000U  ///&lt; update curswant required; not needed</a>
<a name="ln259">                                   ///&lt; when there is a redraw flag</a>
<a name="ln260">#define P_NO_DEF_EXP   0x8000000U  ///&lt; Do not expand default value.</a>
<a name="ln261"> </a>
<a name="ln262">#define P_RWINONLY     0x10000000U  ///&lt; only redraw current window</a>
<a name="ln263">#define P_NDNAME       0x20000000U  ///&lt; only normal dir name chars allowed</a>
<a name="ln264">#define P_UI_OPTION    0x40000000U  ///&lt; send option to remote ui</a>
<a name="ln265">#define P_MLE          0x80000000U  ///&lt; under control of 'modelineexpr'</a>
<a name="ln266"> </a>
<a name="ln267">#define HIGHLIGHT_INIT \</a>
<a name="ln268">  &quot;8:SpecialKey,~:EndOfBuffer,z:TermCursor,Z:TermCursorNC,@:NonText,&quot; \</a>
<a name="ln269">  &quot;d:Directory,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,&quot; \</a>
<a name="ln270">  &quot;N:CursorLineNr,r:Question,s:StatusLine,S:StatusLineNC,c:VertSplit,t:Title,&quot; \</a>
<a name="ln271">  &quot;v:Visual,V:VisualNOS,w:WarningMsg,W:WildMenu,f:Folded,F:FoldColumn,&quot; \</a>
<a name="ln272">  &quot;A:DiffAdd,C:DiffChange,D:DiffDelete,T:DiffText,&gt;:SignColumn,-:Conceal,&quot; \</a>
<a name="ln273">  &quot;B:SpellBad,P:SpellCap,R:SpellRare,L:SpellLocal,+:Pmenu,=:PmenuSel,&quot; \</a>
<a name="ln274">  &quot;x:PmenuSbar,X:PmenuThumb,*:TabLine,#:TabLineSel,_:TabLineFill,&quot; \</a>
<a name="ln275">  &quot;!:CursorColumn,.:CursorLine,o:ColorColumn,q:QuickFixLine,&quot; \</a>
<a name="ln276">  &quot;0:Whitespace,I:NormalNC&quot;</a>
<a name="ln277"> </a>
<a name="ln278">/*</a>
<a name="ln279"> * options[] is initialized here.</a>
<a name="ln280"> * The order of the options MUST be alphabetic for &quot;:set all&quot; and findoption().</a>
<a name="ln281"> * All option names MUST start with a lowercase letter (for findoption()).</a>
<a name="ln282"> * Exception: &quot;t_&quot; options are at the end.</a>
<a name="ln283"> * The options with a NULL variable are 'hidden': a set command for them is</a>
<a name="ln284"> * ignored and they are not printed.</a>
<a name="ln285"> */</a>
<a name="ln286"> </a>
<a name="ln287">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln288"># include &quot;options.generated.h&quot;</a>
<a name="ln289">#endif</a>
<a name="ln290"> </a>
<a name="ln291">#define PARAM_COUNT ARRAY_SIZE(options)</a>
<a name="ln292"> </a>
<a name="ln293">static char *(p_ambw_values[]) =      { &quot;single&quot;, &quot;double&quot;, NULL };</a>
<a name="ln294">static char *(p_bg_values[]) =        { &quot;light&quot;, &quot;dark&quot;, NULL };</a>
<a name="ln295">static char *(p_nf_values[]) =        { &quot;bin&quot;, &quot;octal&quot;, &quot;hex&quot;, &quot;alpha&quot;, NULL };</a>
<a name="ln296">static char *(p_ff_values[]) =        { FF_UNIX, FF_DOS, FF_MAC, NULL };</a>
<a name="ln297">static char *(p_wak_values[]) =       { &quot;yes&quot;, &quot;menu&quot;, &quot;no&quot;, NULL };</a>
<a name="ln298">static char *(p_mousem_values[]) =    { &quot;extend&quot;, &quot;popup&quot;, &quot;popup_setpos&quot;,</a>
<a name="ln299">                                        &quot;mac&quot;, NULL };</a>
<a name="ln300">static char *(p_sel_values[]) =       { &quot;inclusive&quot;, &quot;exclusive&quot;, &quot;old&quot;, NULL };</a>
<a name="ln301">static char *(p_slm_values[]) =       { &quot;mouse&quot;, &quot;key&quot;, &quot;cmd&quot;, NULL };</a>
<a name="ln302">static char *(p_km_values[]) =        { &quot;startsel&quot;, &quot;stopsel&quot;, NULL };</a>
<a name="ln303">static char *(p_scbopt_values[]) =    { &quot;ver&quot;, &quot;hor&quot;, &quot;jump&quot;, NULL };</a>
<a name="ln304">static char *(p_debug_values[]) =     { &quot;msg&quot;, &quot;throw&quot;, &quot;beep&quot;, NULL };</a>
<a name="ln305">static char *(p_ead_values[]) =       { &quot;both&quot;, &quot;ver&quot;, &quot;hor&quot;, NULL };</a>
<a name="ln306">static char *(p_buftype_values[]) =   { &quot;nofile&quot;, &quot;nowrite&quot;, &quot;quickfix&quot;,</a>
<a name="ln307">                                        &quot;help&quot;, &quot;acwrite&quot;, &quot;terminal&quot;,</a>
<a name="ln308">                                        &quot;prompt&quot;, NULL };</a>
<a name="ln309"> </a>
<a name="ln310">static char *(p_bufhidden_values[]) = { &quot;hide&quot;, &quot;unload&quot;, &quot;delete&quot;,</a>
<a name="ln311">                                        &quot;wipe&quot;, NULL };</a>
<a name="ln312">static char *(p_bs_values[]) = { &quot;indent&quot;, &quot;eol&quot;, &quot;start&quot;, &quot;nostop&quot;, NULL };</a>
<a name="ln313">static char *(p_fdm_values[]) =       { &quot;manual&quot;, &quot;expr&quot;, &quot;marker&quot;, &quot;indent&quot;,</a>
<a name="ln314">                                        &quot;syntax&quot;,  &quot;diff&quot;, NULL };</a>
<a name="ln315">static char *(p_fcl_values[]) =       { &quot;all&quot;, NULL };</a>
<a name="ln316">static char *(p_cot_values[]) =       { &quot;menu&quot;, &quot;menuone&quot;, &quot;longest&quot;, &quot;preview&quot;,</a>
<a name="ln317">                                        &quot;noinsert&quot;, &quot;noselect&quot;, NULL };</a>
<a name="ln318">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln319">static char *(p_csl_values[]) =       { &quot;slash&quot;, &quot;backslash&quot;, NULL };</a>
<a name="ln320">#endif</a>
<a name="ln321">static char *(p_icm_values[]) =       { &quot;nosplit&quot;, &quot;split&quot;, NULL };</a>
<a name="ln322">static char *(p_scl_values[]) =       { &quot;yes&quot;, &quot;no&quot;, &quot;auto&quot;, &quot;auto:1&quot;, &quot;auto:2&quot;,</a>
<a name="ln323">  &quot;auto:3&quot;, &quot;auto:4&quot;, &quot;auto:5&quot;, &quot;auto:6&quot;, &quot;auto:7&quot;, &quot;auto:8&quot;, &quot;auto:9&quot;,</a>
<a name="ln324">  &quot;yes:1&quot;, &quot;yes:2&quot;, &quot;yes:3&quot;, &quot;yes:4&quot;, &quot;yes:5&quot;, &quot;yes:6&quot;, &quot;yes:7&quot;, &quot;yes:8&quot;,</a>
<a name="ln325">  &quot;yes:9&quot;, &quot;number&quot;, NULL };</a>
<a name="ln326">static char *(p_fdc_values[]) =       { &quot;auto&quot;, &quot;auto:1&quot;, &quot;auto:2&quot;,</a>
<a name="ln327">  &quot;auto:3&quot;, &quot;auto:4&quot;, &quot;auto:5&quot;, &quot;auto:6&quot;, &quot;auto:7&quot;, &quot;auto:8&quot;, &quot;auto:9&quot;,</a>
<a name="ln328">  &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, NULL };</a>
<a name="ln329"> </a>
<a name="ln330">/// All possible flags for 'shm'.</a>
<a name="ln331">static char_u SHM_ALL[] = {</a>
<a name="ln332">  SHM_RO, SHM_MOD, SHM_FILE, SHM_LAST, SHM_TEXT, SHM_LINES, SHM_NEW, SHM_WRI,</a>
<a name="ln333">  SHM_ABBREVIATIONS, SHM_WRITE, SHM_TRUNC, SHM_TRUNCALL, SHM_OVER,</a>
<a name="ln334">  SHM_OVERALL, SHM_SEARCH, SHM_ATTENTION, SHM_INTRO, SHM_COMPLETIONMENU,</a>
<a name="ln335">  SHM_RECORDING, SHM_FILEINFO, SHM_SEARCHCOUNT,</a>
<a name="ln336">  0,</a>
<a name="ln337">};</a>
<a name="ln338"> </a>
<a name="ln339">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln340"># include &quot;option.c.generated.h&quot;</a>
<a name="ln341">#endif</a>
<a name="ln342"> </a>
<a name="ln343">/// Initialize the options, first part.</a>
<a name="ln344">///</a>
<a name="ln345">/// Called only once from main(), just after creating the first buffer.</a>
<a name="ln346">/// If &quot;clean_arg&quot; is true, Nvim was started with --clean.</a>
<a name="ln347">///</a>
<a name="ln348">/// NOTE: ELOG() etc calls are not allowed here, as log location depends on</a>
<a name="ln349">/// env var expansion which depends on expression evaluation and other</a>
<a name="ln350">/// editor state initialized here. Do logging in set_init_2 or later.</a>
<a name="ln351">void set_init_1(bool clean_arg)</a>
<a name="ln352">{</a>
<a name="ln353">  int opt_idx;</a>
<a name="ln354"> </a>
<a name="ln355">  langmap_init();</a>
<a name="ln356"> </a>
<a name="ln357">  /*</a>
<a name="ln358">   * Find default value for 'shell' option.</a>
<a name="ln359">   * Don't use it if it is empty.</a>
<a name="ln360">   */</a>
<a name="ln361">  {</a>
<a name="ln362">    const char *shell = os_getenv(&quot;SHELL&quot;);</a>
<a name="ln363">    if (shell != NULL) {</a>
<a name="ln364">      if (vim_strchr((const char_u *)shell, ' ') != NULL) {</a>
<a name="ln365">        const size_t len = strlen(shell) + 3;  // two quotes and a trailing NUL</a>
<a name="ln366">        char *const cmd = xmalloc(len);</a>
<a name="ln367">        snprintf(cmd, len, &quot;\&quot;%s\&quot;&quot;, shell);</a>
<a name="ln368">        set_string_default(&quot;sh&quot;, cmd, true);</a>
<a name="ln369">      } else {</a>
<a name="ln370">        set_string_default(&quot;sh&quot;, (char *)shell, false);</a>
<a name="ln371">      }</a>
<a name="ln372">    }</a>
<a name="ln373">  }</a>
<a name="ln374"> </a>
<a name="ln375">  /*</a>
<a name="ln376">   * Set the default for 'backupskip' to include environment variables for</a>
<a name="ln377">   * temp files.</a>
<a name="ln378">   */</a>
<a name="ln379">  {</a>
<a name="ln380"># ifdef UNIX</a>
<a name="ln381">    static char     *(names[4]) = {&quot;&quot;, &quot;TMPDIR&quot;, &quot;TEMP&quot;, &quot;TMP&quot;};</a>
<a name="ln382"># else</a>
<a name="ln383">    static char     *(names[3]) = {&quot;TMPDIR&quot;, &quot;TEMP&quot;, &quot;TMP&quot;};</a>
<a name="ln384"># endif</a>
<a name="ln385">    garray_T ga;</a>
<a name="ln386">    opt_idx = findoption(&quot;backupskip&quot;);</a>
<a name="ln387"> </a>
<a name="ln388">    ga_init(&amp;ga, 1, 100);</a>
<a name="ln389">    for (size_t n = 0; n &lt; ARRAY_SIZE(names); n++) {</a>
<a name="ln390">      bool mustfree = true;</a>
<a name="ln391">      char *p;</a>
<a name="ln392"># ifdef UNIX</a>
<a name="ln393">      if (*names[n] == NUL) {</a>
<a name="ln394">#  ifdef __APPLE__</a>
<a name="ln395">        p = &quot;/private/tmp&quot;;</a>
<a name="ln396">#  else</a>
<a name="ln397">        p = &quot;/tmp&quot;;</a>
<a name="ln398">#  endif</a>
<a name="ln399">        mustfree = false;</a>
<a name="ln400">      } else</a>
<a name="ln401"># endif</a>
<a name="ln402">      {</a>
<a name="ln403">        p = vim_getenv(names[n]);</a>
<a name="ln404">      }</a>
<a name="ln405">      if (p != NULL &amp;&amp; *p != NUL) {</a>
<a name="ln406">        // First time count the NUL, otherwise count the ','.</a>
<a name="ln407">        const size_t len = strlen(p) + 3;</a>
<a name="ln408">        char *item = xmalloc(len);</a>
<a name="ln409">        xstrlcpy(item, p, len);</a>
<a name="ln410">        add_pathsep(item);</a>
<a name="ln411">        xstrlcat(item, &quot;*&quot;, len);</a>
<a name="ln412">        if (find_dup_item(ga.ga_data, (char_u *)item, options[opt_idx].flags)</a>
<a name="ln413">            == NULL) {</a>
<a name="ln414">          ga_grow(&amp;ga, (int)len);</a>
<a name="ln415">          if (!GA_EMPTY(&amp;ga)) {</a>
<a name="ln416">            STRCAT(ga.ga_data, &quot;,&quot;);</a>
<a name="ln417">          }</a>
<a name="ln418">          STRCAT(ga.ga_data, p);</a>
<a name="ln419">          add_pathsep(ga.ga_data);</a>
<a name="ln420">          STRCAT(ga.ga_data, &quot;*&quot;);</a>
<a name="ln421">          ga.ga_len += (int)len;</a>
<a name="ln422">        }</a>
<a name="ln423">        xfree(item);</a>
<a name="ln424">      }</a>
<a name="ln425">      if(mustfree) {</a>
<a name="ln426">        xfree(p);</a>
<a name="ln427">      }</a>
<a name="ln428">    }</a>
<a name="ln429">    if (ga.ga_data != NULL) {</a>
<a name="ln430">      set_string_default(&quot;bsk&quot;, ga.ga_data, true);</a>
<a name="ln431">    }</a>
<a name="ln432">  }</a>
<a name="ln433"> </a>
<a name="ln434">  {</a>
<a name="ln435">    char_u  *cdpath;</a>
<a name="ln436">    char_u  *buf;</a>
<a name="ln437">    int i;</a>
<a name="ln438">    int j;</a>
<a name="ln439"> </a>
<a name="ln440">    // Initialize the 'cdpath' option's default value.</a>
<a name="ln441">    cdpath = (char_u *)vim_getenv(&quot;CDPATH&quot;);</a>
<a name="ln442">    if (cdpath != NULL) {</a>
<a name="ln443">      buf = xmalloc(2 * STRLEN(cdpath) + 2);</a>
<a name="ln444">      {</a>
<a name="ln445">        buf[0] = ',';               // start with &quot;,&quot;, current dir first</a>
<a name="ln446">        j = 1;</a>
<a name="ln447">        for (i = 0; cdpath[i] != NUL; i++) {</a>
<a name="ln448">          if (vim_ispathlistsep(cdpath[i])) {</a>
<a name="ln449">            buf[j++] = ',';</a>
<a name="ln450">          } else {</a>
<a name="ln451">            if (cdpath[i] == ' ' || cdpath[i] == ',') {</a>
<a name="ln452">              buf[j++] = '\\';</a>
<a name="ln453">            }</a>
<a name="ln454">            buf[j++] = cdpath[i];</a>
<a name="ln455">          }</a>
<a name="ln456">        }</a>
<a name="ln457">        buf[j] = NUL;</a>
<a name="ln458">        opt_idx = findoption(&quot;cdpath&quot;);</a>
<a name="ln459">        if (opt_idx &gt;= 0) {</a>
<a name="ln460">          options[opt_idx].def_val[VI_DEFAULT] = buf;</a>
<a name="ln461">          options[opt_idx].flags |= P_DEF_ALLOCED;</a>
<a name="ln462">        } else {</a>
<a name="ln463">          xfree(buf);           // cannot happen</a>
<a name="ln464">        }</a>
<a name="ln465">      }</a>
<a name="ln466">      xfree(cdpath);</a>
<a name="ln467">    }</a>
<a name="ln468">  }</a>
<a name="ln469"> </a>
<a name="ln470">#if defined(MSWIN) || defined(MAC)</a>
<a name="ln471">  // Set print encoding on platforms that don't default to latin1</a>
<a name="ln472">  set_string_default(&quot;printencoding&quot;, &quot;hp-roman8&quot;, false);</a>
<a name="ln473">#endif</a>
<a name="ln474"> </a>
<a name="ln475">  // 'printexpr' must be allocated to be able to evaluate it.</a>
<a name="ln476">  set_string_default(&quot;printexpr&quot;,</a>
<a name="ln477">#ifdef UNIX</a>
<a name="ln478">                     &quot;system(['lpr'] &quot;</a>
<a name="ln479">                            &quot;+ (empty(&amp;printdevice)?[]:['-P', &amp;printdevice]) &quot;</a>
<a name="ln480">                            &quot;+ [v:fname_in])&quot;</a>
<a name="ln481">                     &quot;. delete(v:fname_in)&quot;</a>
<a name="ln482">                     &quot;+ v:shell_error&quot;,</a>
<a name="ln483">#elif defined(MSWIN)</a>
<a name="ln484">                     &quot;system(['copy', v:fname_in, &quot;</a>
<a name="ln485">                             &quot;empty(&amp;printdevice)?'LPT1':&amp;printdevice])&quot;</a>
<a name="ln486">                     &quot;. delete(v:fname_in)&quot;,</a>
<a name="ln487">#else</a>
<a name="ln488">                     &quot;&quot;,</a>
<a name="ln489">#endif</a>
<a name="ln490">                     false);</a>
<a name="ln491"> </a>
<a name="ln492">  char *backupdir = stdpaths_user_data_subpath(&quot;backup&quot;, 0, true);</a>
<a name="ln493">  const size_t backupdir_len = strlen(backupdir);</a>
<a name="ln494">  backupdir = xrealloc(backupdir, backupdir_len + 3);</a>
<a name="ln495">  memmove(backupdir + 2, backupdir, backupdir_len + 1);</a>
<a name="ln496">  memmove(backupdir, &quot;.,&quot;, 2);</a>
<a name="ln497">  set_string_default(&quot;viewdir&quot;, stdpaths_user_data_subpath(&quot;view&quot;, 0, true),</a>
<a name="ln498">                     true);</a>
<a name="ln499">  set_string_default(&quot;backupdir&quot;, backupdir, true);</a>
<a name="ln500">  set_string_default(&quot;directory&quot;, stdpaths_user_data_subpath(&quot;swap&quot;, 2, true),</a>
<a name="ln501">                     true);</a>
<a name="ln502">  set_string_default(&quot;undodir&quot;, stdpaths_user_data_subpath(&quot;undo&quot;, 0, true),</a>
<a name="ln503">                     true);</a>
<a name="ln504">  // Set default for &amp;runtimepath. All necessary expansions are performed in</a>
<a name="ln505">  // this function.</a>
<a name="ln506">  char *rtp = runtimepath_default(clean_arg);</a>
<a name="ln507">  if (rtp) {</a>
<a name="ln508">    set_string_default(&quot;runtimepath&quot;, rtp, true);</a>
<a name="ln509">    // Make a copy of 'rtp' for 'packpath'</a>
<a name="ln510">    set_string_default(&quot;packpath&quot;, rtp, false);</a>
<a name="ln511">    rtp = NULL;  // ownership taken</a>
<a name="ln512">  }</a>
<a name="ln513"> </a>
<a name="ln514">  /*</a>
<a name="ln515">   * Set all the options (except the terminal options) to their default</a>
<a name="ln516">   * value.  Also set the global value for local options.</a>
<a name="ln517">   */</a>
<a name="ln518">  set_options_default(0);</a>
<a name="ln519"> </a>
<a name="ln520"> </a>
<a name="ln521">  curbuf-&gt;b_p_initialized = true;</a>
<a name="ln522">  curbuf-&gt;b_p_ar = -1;          // no local 'autoread' value</a>
<a name="ln523">  curbuf-&gt;b_p_ul = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln524">  check_buf_options(curbuf);</a>
<a name="ln525">  check_win_options(curwin);</a>
<a name="ln526">  check_options();</a>
<a name="ln527"> </a>
<a name="ln528">  // Set all options to their Vim default</a>
<a name="ln529">  set_options_default(OPT_FREE);</a>
<a name="ln530"> </a>
<a name="ln531">  // set 'laststatus'</a>
<a name="ln532">  last_status(false);</a>
<a name="ln533"> </a>
<a name="ln534">  // Must be before option_expand(), because that one needs vim_isIDc()</a>
<a name="ln535">  didset_options();</a>
<a name="ln536"> </a>
<a name="ln537">  // Use the current chartab for the generic chartab. This is not in</a>
<a name="ln538">  // didset_options() because it only depends on 'encoding'.</a>
<a name="ln539">  init_spell_chartab();</a>
<a name="ln540"> </a>
<a name="ln541">  /*</a>
<a name="ln542">   * Expand environment variables and things like &quot;~&quot; for the defaults.</a>
<a name="ln543">   * If option_expand() returns non-NULL the variable is expanded.  This can</a>
<a name="ln544">   * only happen for non-indirect options.</a>
<a name="ln545">   * Also set the default to the expanded value, so &quot;:set&quot; does not list</a>
<a name="ln546">   * them.</a>
<a name="ln547">   * Don't set the P_ALLOCED flag, because we don't want to free the</a>
<a name="ln548">   * default.</a>
<a name="ln549">   */</a>
<a name="ln550">  for (opt_idx = 0; options[opt_idx].fullname; opt_idx++) {</a>
<a name="ln551">    if (options[opt_idx].flags &amp; P_NO_DEF_EXP) {</a>
<a name="ln552">      continue;</a>
<a name="ln553">    }</a>
<a name="ln554">    char *p;</a>
<a name="ln555">    if ((options[opt_idx].flags &amp; P_GETTEXT)</a>
<a name="ln556">        &amp;&amp; options[opt_idx].var != NULL) {</a>
<a name="ln557">      p = _(*(char **)options[opt_idx].var);</a>
<a name="ln558">    } else {</a>
<a name="ln559">      p = (char *) option_expand(opt_idx, NULL);</a>
<a name="ln560">    }</a>
<a name="ln561">    if (p != NULL) {</a>
<a name="ln562">      p = xstrdup(p);</a>
<a name="ln563">      *(char **)options[opt_idx].var = p;</a>
<a name="ln564">      /* VIMEXP</a>
<a name="ln565">       * Defaults for all expanded options are currently the same for Vi</a>
<a name="ln566">       * and Vim.  When this changes, add some code here!  Also need to</a>
<a name="ln567">       * split P_DEF_ALLOCED in two.</a>
<a name="ln568">       */</a>
<a name="ln569">      if (options[opt_idx].flags &amp; P_DEF_ALLOCED) {</a>
<a name="ln570">        xfree(options[opt_idx].def_val[VI_DEFAULT]);</a>
<a name="ln571">      }</a>
<a name="ln572">      options[opt_idx].def_val[VI_DEFAULT] = (char_u *)p;</a>
<a name="ln573">      options[opt_idx].flags |= P_DEF_ALLOCED;</a>
<a name="ln574">    }</a>
<a name="ln575">  }</a>
<a name="ln576"> </a>
<a name="ln577">  save_file_ff(curbuf);         // Buffer is unchanged</a>
<a name="ln578"> </a>
<a name="ln579">  /* Detect use of mlterm.</a>
<a name="ln580">   * Mlterm is a terminal emulator akin to xterm that has some special</a>
<a name="ln581">   * abilities (bidi namely).</a>
<a name="ln582">   * NOTE: mlterm's author is being asked to 'set' a variable</a>
<a name="ln583">   *       instead of an environment variable due to inheritance.</a>
<a name="ln584">   */</a>
<a name="ln585">  if (os_env_exists(&quot;MLTERM&quot;)) {</a>
<a name="ln586">    set_option_value(&quot;tbidi&quot;, 1L, NULL, 0);</a>
<a name="ln587">  }</a>
<a name="ln588"> </a>
<a name="ln589">  didset_options2();</a>
<a name="ln590"> </a>
<a name="ln591">  lang_init();</a>
<a name="ln592"> </a>
<a name="ln593">  // enc_locale() will try to find the encoding of the current locale.</a>
<a name="ln594">  // This will be used when 'default' is used as encoding specifier</a>
<a name="ln595">  // in 'fileencodings'</a>
<a name="ln596">  char_u *p = enc_locale();</a>
<a name="ln597">  if (p == NULL) {</a>
<a name="ln598">      // use utf-8 as 'default' if locale encoding can't be detected.</a>
<a name="ln599">      p = (char_u *)xmemdupz(S_LEN(&quot;utf-8&quot;));</a>
<a name="ln600">  }</a>
<a name="ln601">  fenc_default = p;</a>
<a name="ln602"> </a>
<a name="ln603">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln604">  // GNU gettext 0.10.37 supports this feature: set the codeset used for</a>
<a name="ln605">  // translated messages independently from the current locale.</a>
<a name="ln606">  (void)bind_textdomain_codeset(PROJECT_NAME, (char *)p_enc);</a>
<a name="ln607">#endif</a>
<a name="ln608"> </a>
<a name="ln609">  // Set the default for 'helplang'.</a>
<a name="ln610">  set_helplang_default(get_mess_lang());</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">/// Set an option to its default value.</a>
<a name="ln614">/// This does not take care of side effects!</a>
<a name="ln615">static void</a>
<a name="ln616">set_option_default(</a>
<a name="ln617">    int opt_idx,</a>
<a name="ln618">    int opt_flags,              // OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln619">    int compatible              // use Vi default value</a>
<a name="ln620">)</a>
<a name="ln621">{</a>
<a name="ln622">  char_u      *varp;            // pointer to variable for current option</a>
<a name="ln623">  int dvi;                      // index in def_val[]</a>
<a name="ln624">  int both = (opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0;</a>
<a name="ln625"> </a>
<a name="ln626">  varp = get_varp_scope(&amp;(options[opt_idx]), both ? OPT_LOCAL : opt_flags);</a>
<a name="ln627">  uint32_t flags = options[opt_idx].flags;</a>
<a name="ln628">  if (varp != NULL) {       // skip hidden option, nothing to do for it</a>
<a name="ln629">    dvi = ((flags &amp; P_VI_DEF) || compatible) ? VI_DEFAULT : VIM_DEFAULT;</a>
<a name="ln630">    if (flags &amp; P_STRING) {</a>
<a name="ln631">      /* Use set_string_option_direct() for local options to handle</a>
<a name="ln632">       * freeing and allocating the value. */</a>
<a name="ln633">      if (options[opt_idx].indir != PV_NONE) {</a>
<a name="ln634">        set_string_option_direct(NULL, opt_idx,</a>
<a name="ln635">                                 options[opt_idx].def_val[dvi], opt_flags, 0);</a>
<a name="ln636">      } else {</a>
<a name="ln637">        if ((opt_flags &amp; OPT_FREE) &amp;&amp; (flags &amp; P_ALLOCED)) {</a>
<a name="ln638">          free_string_option(*(char_u **)(varp));</a>
<a name="ln639">        }</a>
<a name="ln640">        *(char_u **)varp = options[opt_idx].def_val[dvi];</a>
<a name="ln641">        options[opt_idx].flags &amp;= ~P_ALLOCED;</a>
<a name="ln642">      }</a>
<a name="ln643">    } else if (flags &amp; P_NUM)   {</a>
<a name="ln644">      if (options[opt_idx].indir == PV_SCROLL) {</a>
<a name="ln645">        win_comp_scroll(curwin);</a>
<a name="ln646">      } else {</a>
<a name="ln647">        long def_val = (long)options[opt_idx].def_val[dvi];</a>
<a name="ln648">        if ((long *)varp == &amp;curwin-&gt;w_p_so</a>
<a name="ln649">            || (long *)varp == &amp;curwin-&gt;w_p_siso) {</a>
<a name="ln650">          // 'scrolloff' and 'sidescrolloff' local values have a</a>
<a name="ln651">          // different default value than the global default.</a>
<a name="ln652">          *(long *)varp = -1;</a>
<a name="ln653">        } else {</a>
<a name="ln654">          *(long *)varp = def_val;</a>
<a name="ln655">        }</a>
<a name="ln656">        // May also set global value for local option.</a>
<a name="ln657">        if (both) {</a>
<a name="ln658">          *(long *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL) =</a>
<a name="ln659">            def_val;</a>
<a name="ln660">        }</a>
<a name="ln661">      }</a>
<a name="ln662">    } else {  // P_BOOL</a>
<a name="ln663">      *(int *)varp = (int)(intptr_t)options[opt_idx].def_val[dvi];</a>
<a name="ln664">#ifdef UNIX</a>
<a name="ln665">      // 'modeline' defaults to off for root</a>
<a name="ln666">      if (options[opt_idx].indir == PV_ML &amp;&amp; getuid() == ROOT_UID) {</a>
<a name="ln667">        *(int *)varp = false;</a>
<a name="ln668">      }</a>
<a name="ln669">#endif</a>
<a name="ln670">      // May also set global value for local option.</a>
<a name="ln671">      if (both) {</a>
<a name="ln672">        *(int *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL) =</a>
<a name="ln673">          *(int *)varp;</a>
<a name="ln674">      }</a>
<a name="ln675">    }</a>
<a name="ln676"> </a>
<a name="ln677">    // The default value is not insecure.</a>
<a name="ln678">    uint32_t *flagsp = insecure_flag(curwin, opt_idx, opt_flags);</a>
<a name="ln679">    *flagsp = *flagsp &amp; ~P_INSECURE;</a>
<a name="ln680">  }</a>
<a name="ln681"> </a>
<a name="ln682">  set_option_sctx_idx(opt_idx, opt_flags, current_sctx);</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685">/// Set all options (except terminal options) to their default value.</a>
<a name="ln686">static void</a>
<a name="ln687">set_options_default(</a>
<a name="ln688">    int opt_flags               // OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln689">)</a>
<a name="ln690">{</a>
<a name="ln691">  for (int i = 0; options[i].fullname; i++) {</a>
<a name="ln692">    if (!(options[i].flags &amp; P_NODEFAULT)) {</a>
<a name="ln693">      set_option_default(i, opt_flags, false);</a>
<a name="ln694">    }</a>
<a name="ln695">  }</a>
<a name="ln696"> </a>
<a name="ln697">  // The 'scroll' option must be computed for all windows.</a>
<a name="ln698">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln699">    win_comp_scroll(wp);</a>
<a name="ln700">  }</a>
<a name="ln701"> </a>
<a name="ln702">  parse_cino(curbuf);</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705">/// Set the Vi-default value of a string option.</a>
<a name="ln706">/// Used for 'sh', 'backupskip' and 'term'.</a>
<a name="ln707">///</a>
<a name="ln708">/// @param name The name of the option</a>
<a name="ln709">/// @param val The value of the option</a>
<a name="ln710">/// @param allocated If true, do not copy default as it was already allocated.</a>
<a name="ln711">static void set_string_default(const char *name, char *val, bool allocated)</a>
<a name="ln712">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln713">{</a>
<a name="ln714">  int opt_idx = findoption(name);</a>
<a name="ln715">  if (opt_idx &gt;= 0) {</a>
<a name="ln716">    if (options[opt_idx].flags &amp; P_DEF_ALLOCED) {</a>
<a name="ln717">      xfree(options[opt_idx].def_val[VI_DEFAULT]);</a>
<a name="ln718">    }</a>
<a name="ln719"> </a>
<a name="ln720">    options[opt_idx].def_val[VI_DEFAULT] = allocated</a>
<a name="ln721">        ? (char_u *)val</a>
<a name="ln722">        : (char_u *)xstrdup(val);</a>
<a name="ln723">    options[opt_idx].flags |= P_DEF_ALLOCED;</a>
<a name="ln724">  }</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">// For an option value that contains comma separated items, find &quot;newval&quot; in</a>
<a name="ln728">// &quot;origval&quot;.  Return NULL if not found.</a>
<a name="ln729">static char_u *find_dup_item(char_u *origval, const char_u *newval,</a>
<a name="ln730">                             uint32_t flags)</a>
<a name="ln731">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln732">{</a>
<a name="ln733">  int bs = 0;</a>
<a name="ln734"> </a>
<a name="ln735">  if (origval == NULL) {</a>
<a name="ln736">    return NULL;</a>
<a name="ln737">  }</a>
<a name="ln738"> </a>
<a name="ln739">  const size_t newlen = STRLEN(newval);</a>
<a name="ln740">  for (char_u *s = origval; *s != NUL; s++) {</a>
<a name="ln741">    if ((!(flags &amp; P_COMMA) || s == origval || (s[-1] == ',' &amp;&amp; !(bs &amp; 1)))</a>
<a name="ln742">        &amp;&amp; STRNCMP(s, newval, newlen) == 0</a>
<a name="ln743">        &amp;&amp; (!(flags &amp; P_COMMA) || s[newlen] == ',' || s[newlen] == NUL)) {</a>
<a name="ln744">      return s;</a>
<a name="ln745">    }</a>
<a name="ln746">    // Count backslashes.  Only a comma with an even number of backslashes</a>
<a name="ln747">    // or a single backslash preceded by a comma before it is recognized as</a>
<a name="ln748">    // a separator.</a>
<a name="ln749">    if ((s &gt; origval + 1 &amp;&amp; s[-1] == '\\' &amp;&amp; s[-2] != ',')</a>
<a name="ln750">        || (s == origval + 1 &amp;&amp; s[-1] == '\\')) {</a>
<a name="ln751">      bs++;</a>
<a name="ln752">    } else {</a>
<a name="ln753">      bs = 0;</a>
<a name="ln754">    }</a>
<a name="ln755">  }</a>
<a name="ln756">  return NULL;</a>
<a name="ln757">}</a>
<a name="ln758"> </a>
<a name="ln759">/// Set the Vi-default value of a number option.</a>
<a name="ln760">/// Used for 'lines' and 'columns'.</a>
<a name="ln761">void set_number_default(char *name, long val)</a>
<a name="ln762">{</a>
<a name="ln763">  int opt_idx;</a>
<a name="ln764"> </a>
<a name="ln765">  opt_idx = findoption(name);</a>
<a name="ln766">  if (opt_idx &gt;= 0) {</a>
<a name="ln767">    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)(intptr_t)val;</a>
<a name="ln768">  }</a>
<a name="ln769">}</a>
<a name="ln770"> </a>
<a name="ln771">#if defined(EXITFREE)</a>
<a name="ln772">/// Free all options.</a>
<a name="ln773">void free_all_options(void)</a>
<a name="ln774">{</a>
<a name="ln775">  for (int i = 0; options[i].fullname; i++) {</a>
<a name="ln776">    if (options[i].indir == PV_NONE) {</a>
<a name="ln777">      // global option: free value and default value.</a>
<a name="ln778">      if ((options[i].flags &amp; P_ALLOCED) &amp;&amp; options[i].var != NULL) {</a>
<a name="ln779">        free_string_option(*(char_u **)options[i].var);</a>
<a name="ln780">      }</a>
<a name="ln781">      if (options[i].flags &amp; P_DEF_ALLOCED) {</a>
<a name="ln782">        free_string_option(options[i].def_val[VI_DEFAULT]);</a>
<a name="ln783">      }</a>
<a name="ln784">    } else if (options[i].var != VAR_WIN &amp;&amp; (options[i].flags &amp; P_STRING)) {</a>
<a name="ln785">      // buffer-local option: free global value</a>
<a name="ln786">      free_string_option(*(char_u **)options[i].var);</a>
<a name="ln787">    }</a>
<a name="ln788">  }</a>
<a name="ln789">}</a>
<a name="ln790">#endif</a>
<a name="ln791"> </a>
<a name="ln792"> </a>
<a name="ln793">/// Initialize the options, part two: After getting Rows and Columns.</a>
<a name="ln794">void set_init_2(bool headless)</a>
<a name="ln795">{</a>
<a name="ln796">  // set in set_init_1 but logging is not allowed there</a>
<a name="ln797">  ILOG(&quot;startup runtimepath/packpath value: %s&quot;, p_rtp);</a>
<a name="ln798"> </a>
<a name="ln799">  int idx;</a>
<a name="ln800"> </a>
<a name="ln801">  // 'scroll' defaults to half the window height. The stored default is zero,</a>
<a name="ln802">  // which results in the actual value computed from the window height.</a>
<a name="ln803">  idx = findoption(&quot;scroll&quot;);</a>
<a name="ln804">  if (idx &gt;= 0 &amp;&amp; !(options[idx].flags &amp; P_WAS_SET)) {</a>
<a name="ln805">    set_option_default(idx, OPT_LOCAL, false);</a>
<a name="ln806">  }</a>
<a name="ln807">  comp_col();</a>
<a name="ln808"> </a>
<a name="ln809">  /*</a>
<a name="ln810">   * 'window' is only for backwards compatibility with Vi.</a>
<a name="ln811">   * Default is Rows - 1.</a>
<a name="ln812">   */</a>
<a name="ln813">  if (!option_was_set(&quot;window&quot;)) {</a>
<a name="ln814">    p_window = Rows - 1;</a>
<a name="ln815">  }</a>
<a name="ln816">  set_number_default(&quot;window&quot;, Rows - 1);</a>
<a name="ln817">  (void)parse_printoptions();      // parse 'printoptions' default value</a>
<a name="ln818">}</a>
<a name="ln819"> </a>
<a name="ln820">/// Initialize the options, part three: After reading the .vimrc</a>
<a name="ln821">void set_init_3(void)</a>
<a name="ln822">{</a>
<a name="ln823">  parse_shape_opt(SHAPE_CURSOR);   // set cursor shapes from 'guicursor'</a>
<a name="ln824"> </a>
<a name="ln825">  // Set 'shellpipe' and 'shellredir', depending on the 'shell' option.</a>
<a name="ln826">  // This is done after other initializations, where 'shell' might have been</a>
<a name="ln827">  // set, but only if they have not been set before.</a>
<a name="ln828">  int idx_srr = findoption(&quot;srr&quot;);</a>
<a name="ln829">  int do_srr = (idx_srr &lt; 0)</a>
<a name="ln830">    ? false</a>
<a name="ln831">    : !(options[idx_srr].flags &amp; P_WAS_SET);</a>
<a name="ln832">  int idx_sp = findoption(&quot;sp&quot;);</a>
<a name="ln833">  int do_sp = (idx_sp &lt; 0)</a>
<a name="ln834">    ? false</a>
<a name="ln835">    : !(options[idx_sp].flags &amp; P_WAS_SET);</a>
<a name="ln836"> </a>
<a name="ln837">  size_t len = 0;</a>
<a name="ln838">  char_u *p = (char_u *)invocation_path_tail(p_sh, &amp;len);</a>
<a name="ln839">  p = vim_strnsave(p, len);</a>
<a name="ln840"> </a>
<a name="ln841">  {</a>
<a name="ln842">    //</a>
<a name="ln843">    // Default for p_sp is &quot;| tee&quot;, for p_srr is &quot;&gt;&quot;.</a>
<a name="ln844">    // For known shells it is changed here to include stderr.</a>
<a name="ln845">    //</a>
<a name="ln846">    if (       fnamecmp(p, &quot;csh&quot;) == 0</a>
<a name="ln847">               || fnamecmp(p, &quot;tcsh&quot;) == 0</a>
<a name="ln848">               ) {</a>
<a name="ln849">      if (do_sp) {</a>
<a name="ln850">        p_sp = (char_u *)&quot;|&amp; tee&quot;;</a>
<a name="ln851">        options[idx_sp].def_val[VI_DEFAULT] = p_sp;</a>
<a name="ln852">      }</a>
<a name="ln853">      if (do_srr) {</a>
<a name="ln854">        p_srr = (char_u *)&quot;&gt;&amp;&quot;;</a>
<a name="ln855">        options[idx_srr].def_val[VI_DEFAULT] = p_srr;</a>
<a name="ln856">      }</a>
<a name="ln857">    } else if (       fnamecmp(p, &quot;sh&quot;) == 0</a>
<a name="ln858">                      || fnamecmp(p, &quot;ksh&quot;) == 0</a>
<a name="ln859">                      || fnamecmp(p, &quot;mksh&quot;) == 0</a>
<a name="ln860">                      || fnamecmp(p, &quot;pdksh&quot;) == 0</a>
<a name="ln861">                      || fnamecmp(p, &quot;zsh&quot;) == 0</a>
<a name="ln862">                      || fnamecmp(p, &quot;zsh-beta&quot;) == 0</a>
<a name="ln863">                      || fnamecmp(p, &quot;bash&quot;) == 0</a>
<a name="ln864">                      || fnamecmp(p, &quot;fish&quot;) == 0</a>
<a name="ln865">                      ) {</a>
<a name="ln866">      if (do_sp) {</a>
<a name="ln867">        p_sp = (char_u *)&quot;2&gt;&amp;1| tee&quot;;</a>
<a name="ln868">        options[idx_sp].def_val[VI_DEFAULT] = p_sp;</a>
<a name="ln869">      }</a>
<a name="ln870">      if (do_srr) {</a>
<a name="ln871">        p_srr = (char_u *)&quot;&gt;%s 2&gt;&amp;1&quot;;</a>
<a name="ln872">        options[idx_srr].def_val[VI_DEFAULT] = p_srr;</a>
<a name="ln873">      }</a>
<a name="ln874">    }</a>
<a name="ln875">    xfree(p);</a>
<a name="ln876">  }</a>
<a name="ln877"> </a>
<a name="ln878">  if (BUFEMPTY()) {</a>
<a name="ln879">    int idx_ffs = findoption_len(S_LEN(&quot;ffs&quot;));</a>
<a name="ln880"> </a>
<a name="ln881">    // Apply the first entry of 'fileformats' to the initial buffer.</a>
<a name="ln882">    if (idx_ffs &gt;= 0 &amp;&amp; (options[idx_ffs].flags &amp; P_WAS_SET)) {</a>
<a name="ln883">      set_fileformat(default_fileformat(), OPT_LOCAL);</a>
<a name="ln884">    }</a>
<a name="ln885">  }</a>
<a name="ln886"> </a>
<a name="ln887">  set_title_defaults();  // 'title', 'icon'</a>
<a name="ln888">}</a>
<a name="ln889"> </a>
<a name="ln890">/// When 'helplang' is still at its default value, set it to &quot;lang&quot;.</a>
<a name="ln891">/// Only the first two characters of &quot;lang&quot; are used.</a>
<a name="ln892">void set_helplang_default(const char *lang)</a>
<a name="ln893">{</a>
<a name="ln894">  if (lang == NULL) {</a>
<a name="ln895">    return;</a>
<a name="ln896">  }</a>
<a name="ln897"> </a>
<a name="ln898">  const size_t lang_len = strlen(lang);</a>
<a name="ln899">  if (lang_len &lt; 2) {  // safety check</a>
<a name="ln900">    return;</a>
<a name="ln901">  }</a>
<a name="ln902">  int idx = findoption(&quot;hlg&quot;);</a>
<a name="ln903">  if (idx &gt;= 0 &amp;&amp; !(options[idx].flags &amp; P_WAS_SET)) {</a>
<a name="ln904">    if (options[idx].flags &amp; P_ALLOCED) {</a>
<a name="ln905">      free_string_option(p_hlg);</a>
<a name="ln906">    }</a>
<a name="ln907">    p_hlg = (char_u *)xmemdupz(lang, lang_len);</a>
<a name="ln908">    // zh_CN becomes &quot;cn&quot;, zh_TW becomes &quot;tw&quot;.</a>
<a name="ln909">    if (STRNICMP(p_hlg, &quot;zh_&quot;, 3) == 0 &amp;&amp; STRLEN(p_hlg) &gt;= 5) {</a>
<a name="ln910">      p_hlg[0] = (char_u)TOLOWER_ASC(p_hlg[3]);</a>
<a name="ln911">      p_hlg[1] = (char_u)TOLOWER_ASC(p_hlg[4]);</a>
<a name="ln912">    } else if (STRLEN(p_hlg) &gt;= 1 &amp;&amp; *p_hlg == 'C') {</a>
<a name="ln913">      // any C like setting, such as C.UTF-8, becomes &quot;en&quot;</a>
<a name="ln914">      p_hlg[0] = 'e';</a>
<a name="ln915">      p_hlg[1] = 'n';</a>
<a name="ln916">    }</a>
<a name="ln917">    p_hlg[2] = NUL;</a>
<a name="ln918">    options[idx].flags |= P_ALLOCED;</a>
<a name="ln919">  }</a>
<a name="ln920">}</a>
<a name="ln921"> </a>
<a name="ln922"> </a>
<a name="ln923">/// 'title' and 'icon' only default to true if they have not been set or reset</a>
<a name="ln924">/// in .vimrc and we can read the old value.</a>
<a name="ln925">/// When 'title' and 'icon' have been reset in .vimrc, we won't even check if</a>
<a name="ln926">/// they can be reset.  This reduces startup time when using X on a remote</a>
<a name="ln927">/// machine.</a>
<a name="ln928">void set_title_defaults(void)</a>
<a name="ln929">{</a>
<a name="ln930">  int idx1;</a>
<a name="ln931"> </a>
<a name="ln932">  /*</a>
<a name="ln933">   * If GUI is (going to be) used, we can always set the window title and</a>
<a name="ln934">   * icon name.  Saves a bit of time, because the X11 display server does</a>
<a name="ln935">   * not need to be contacted.</a>
<a name="ln936">   */</a>
<a name="ln937">  idx1 = findoption(&quot;title&quot;);</a>
<a name="ln938">  if (idx1 &gt;= 0 &amp;&amp; !(options[idx1].flags &amp; P_WAS_SET)) {</a>
<a name="ln939">    options[idx1].def_val[VI_DEFAULT] = (char_u *)(intptr_t)0;</a>
<a name="ln940">    p_title = 0;</a>
<a name="ln941">  }</a>
<a name="ln942">  idx1 = findoption(&quot;icon&quot;);</a>
<a name="ln943">  if (idx1 &gt;= 0 &amp;&amp; !(options[idx1].flags &amp; P_WAS_SET)) {</a>
<a name="ln944">    options[idx1].def_val[VI_DEFAULT] = (char_u *)(intptr_t)0;</a>
<a name="ln945">    p_icon = 0;</a>
<a name="ln946">  }</a>
<a name="ln947">}</a>
<a name="ln948"> </a>
<a name="ln949">// Parse 'arg' for option settings.</a>
<a name="ln950">//</a>
<a name="ln951">// 'arg' may be IObuff, but only when no errors can be present and option</a>
<a name="ln952">// does not need to be expanded with option_expand().</a>
<a name="ln953">// &quot;opt_flags&quot;:</a>
<a name="ln954">// 0 for &quot;:set&quot;</a>
<a name="ln955">// OPT_GLOBAL   for &quot;:setglobal&quot;</a>
<a name="ln956">// OPT_LOCAL    for &quot;:setlocal&quot; and a modeline</a>
<a name="ln957">// OPT_MODELINE for a modeline</a>
<a name="ln958">// OPT_WINONLY  to only set window-local options</a>
<a name="ln959">// OPT_NOWIN    to skip setting window-local options</a>
<a name="ln960">//</a>
<a name="ln961">// returns FAIL if an error is detected, OK otherwise</a>
<a name="ln962">int do_set(</a>
<a name="ln963">    char_u *arg,               // option string (may be written to!)</a>
<a name="ln964">    int opt_flags</a>
<a name="ln965">)</a>
<a name="ln966">{</a>
<a name="ln967">  int opt_idx;</a>
<a name="ln968">  char_u      *errmsg;</a>
<a name="ln969">  char_u errbuf[80];</a>
<a name="ln970">  char_u      *startarg;</a>
<a name="ln971">  int prefix;           // 1: nothing, 0: &quot;no&quot;, 2: &quot;inv&quot; in front of name</a>
<a name="ln972">  char_u nextchar;                  // next non-white char after option name</a>
<a name="ln973">  int afterchar;                    // character just after option name</a>
<a name="ln974">  int len;</a>
<a name="ln975">  int i;</a>
<a name="ln976">  varnumber_T value;</a>
<a name="ln977">  int key;</a>
<a name="ln978">  uint32_t flags;                   // flags for current option</a>
<a name="ln979">  char_u      *varp = NULL;         // pointer to variable for current option</a>
<a name="ln980">  int did_show = false;             // already showed one value</a>
<a name="ln981">  int adding;                       // &quot;opt+=arg&quot;</a>
<a name="ln982">  int prepending;                   // &quot;opt^=arg&quot;</a>
<a name="ln983">  int removing;                     // &quot;opt-=arg&quot;</a>
<a name="ln984">  int cp_val = 0;</a>
<a name="ln985"> </a>
<a name="ln986">  if (*arg == NUL) {</a>
<a name="ln987">    showoptions(0, opt_flags);</a>
<a name="ln988">    did_show = true;</a>
<a name="ln989">    goto theend;</a>
<a name="ln990">  }</a>
<a name="ln991"> </a>
<a name="ln992">  while (*arg != NUL) {         // loop to process all options</a>
<a name="ln993">    errmsg = NULL;</a>
<a name="ln994">    startarg = arg;             // remember for error message</a>
<a name="ln995"> </a>
<a name="ln996">    if (STRNCMP(arg, &quot;all&quot;, 3) == 0 &amp;&amp; !isalpha(arg[3])</a>
<a name="ln997">        &amp;&amp; !(opt_flags &amp; OPT_MODELINE)) {</a>
<a name="ln998">      /*</a>
<a name="ln999">       * &quot;:set all&quot;  show all options.</a>
<a name="ln1000">       * &quot;:set all&amp;&quot; set all options to their default value.</a>
<a name="ln1001">       */</a>
<a name="ln1002">      arg += 3;</a>
<a name="ln1003">      if (*arg == '&amp;') {</a>
<a name="ln1004">        arg++;</a>
<a name="ln1005">        // Only for :set command set global value of local options.</a>
<a name="ln1006">        set_options_default(OPT_FREE | opt_flags);</a>
<a name="ln1007">        didset_options();</a>
<a name="ln1008">        didset_options2();</a>
<a name="ln1009">        ui_refresh_options();</a>
<a name="ln1010">        redraw_all_later(CLEAR);</a>
<a name="ln1011">      } else {</a>
<a name="ln1012">        showoptions(1, opt_flags);</a>
<a name="ln1013">        did_show = true;</a>
<a name="ln1014">      }</a>
<a name="ln1015">    } else {</a>
<a name="ln1016">      prefix = 1;</a>
<a name="ln1017">      if (STRNCMP(arg, &quot;no&quot;, 2) == 0) {</a>
<a name="ln1018">        prefix = 0;</a>
<a name="ln1019">        arg += 2;</a>
<a name="ln1020">      } else if (STRNCMP(arg, &quot;inv&quot;, 3) == 0) {</a>
<a name="ln1021">        prefix = 2;</a>
<a name="ln1022">        arg += 3;</a>
<a name="ln1023">      }</a>
<a name="ln1024"> </a>
<a name="ln1025">      // find end of name</a>
<a name="ln1026">      key = 0;</a>
<a name="ln1027">      if (*arg == '&lt;') {</a>
<a name="ln1028">        opt_idx = -1;</a>
<a name="ln1029">        // look out for &lt;t_&gt;;&gt;</a>
<a name="ln1030">        if (arg[1] == 't' &amp;&amp; arg[2] == '_' &amp;&amp; arg[3] &amp;&amp; arg[4]) {</a>
<a name="ln1031">          len = 5;</a>
<a name="ln1032">        } else {</a>
<a name="ln1033">          len = 1;</a>
<a name="ln1034">          while (arg[len] != NUL &amp;&amp; arg[len] != '&gt;') {</a>
<a name="ln1035">            len++;</a>
<a name="ln1036">          }</a>
<a name="ln1037">        }</a>
<a name="ln1038">        if (arg[len] != '&gt;') {</a>
<a name="ln1039">          errmsg = e_invarg;</a>
<a name="ln1040">          goto skip;</a>
<a name="ln1041">        }</a>
<a name="ln1042">        if (arg[1] == 't' &amp;&amp; arg[2] == '_') {  // could be term code</a>
<a name="ln1043">          opt_idx = findoption_len((const char *)arg + 1, (size_t)(len - 1));</a>
<a name="ln1044">        }</a>
<a name="ln1045">        len++;</a>
<a name="ln1046">        if (opt_idx == -1) {</a>
<a name="ln1047">          key = find_key_option(arg + 1, true);</a>
<a name="ln1048">        }</a>
<a name="ln1049">      } else {</a>
<a name="ln1050">        len = 0;</a>
<a name="ln1051">        // The two characters after &quot;t_&quot; may not be alphanumeric.</a>
<a name="ln1052">        if (arg[0] == 't' &amp;&amp; arg[1] == '_' &amp;&amp; arg[2] &amp;&amp; arg[3]) {</a>
<a name="ln1053">          len = 4;</a>
<a name="ln1054">        } else {</a>
<a name="ln1055">          while (ASCII_ISALNUM(arg[len]) || arg[len] == '_') {</a>
<a name="ln1056">            len++;</a>
<a name="ln1057">          }</a>
<a name="ln1058">        }</a>
<a name="ln1059">        opt_idx = findoption_len((const char *)arg, (size_t)len);</a>
<a name="ln1060">        if (opt_idx == -1) {</a>
<a name="ln1061">          key = find_key_option(arg, false);</a>
<a name="ln1062">        }</a>
<a name="ln1063">      }</a>
<a name="ln1064"> </a>
<a name="ln1065">      // remember character after option name</a>
<a name="ln1066">      afterchar = arg[len];</a>
<a name="ln1067"> </a>
<a name="ln1068">      // skip white space, allow &quot;:set ai  ?&quot;</a>
<a name="ln1069">      while (ascii_iswhite(arg[len])) {</a>
<a name="ln1070">        len++;</a>
<a name="ln1071">      }</a>
<a name="ln1072"> </a>
<a name="ln1073">      adding = false;</a>
<a name="ln1074">      prepending = false;</a>
<a name="ln1075">      removing = false;</a>
<a name="ln1076">      if (arg[len] != NUL &amp;&amp; arg[len + 1] == '=') {</a>
<a name="ln1077">        if (arg[len] == '+') {</a>
<a name="ln1078">          adding = true;                        // &quot;+=&quot;</a>
<a name="ln1079">          len++;</a>
<a name="ln1080">        } else if (arg[len] == '^') {</a>
<a name="ln1081">          prepending = true;                    // &quot;^=&quot;</a>
<a name="ln1082">          len++;</a>
<a name="ln1083">        } else if (arg[len] == '-') {</a>
<a name="ln1084">          removing = true;                      // &quot;-=&quot;</a>
<a name="ln1085">          len++;</a>
<a name="ln1086">        }</a>
<a name="ln1087">      }</a>
<a name="ln1088">      nextchar = arg[len];</a>
<a name="ln1089"> </a>
<a name="ln1090">      if (opt_idx == -1 &amp;&amp; key == 0) {          // found a mismatch: skip</a>
<a name="ln1091">        errmsg = (char_u *)N_(&quot;E518: Unknown option&quot;);</a>
<a name="ln1092">        goto skip;</a>
<a name="ln1093">      }</a>
<a name="ln1094"> </a>
<a name="ln1095">      if (opt_idx &gt;= 0) {</a>
<a name="ln1096">        if (options[opt_idx].var == NULL) {         // hidden option: skip</a>
<a name="ln1097">          // Only give an error message when requesting the value of</a>
<a name="ln1098">          // a hidden option, ignore setting it.</a>
<a name="ln1099">          if (vim_strchr((char_u *)&quot;=:!&amp;&lt;&quot;, nextchar) == NULL</a>
<a name="ln1100">              &amp;&amp; (!(options[opt_idx].flags &amp; P_BOOL)</a>
<a name="ln1101">                  || nextchar == '?')) {</a>
<a name="ln1102">            errmsg = (char_u *)_(e_unsupportedoption);</a>
<a name="ln1103">          }</a>
<a name="ln1104">          goto skip;</a>
<a name="ln1105">        }</a>
<a name="ln1106"> </a>
<a name="ln1107">        flags = options[opt_idx].flags;</a>
<a name="ln1108">        varp = get_varp_scope(&amp;(options[opt_idx]), opt_flags);</a>
<a name="ln1109">      } else {</a>
<a name="ln1110">        flags = P_STRING;</a>
<a name="ln1111">      }</a>
<a name="ln1112"> </a>
<a name="ln1113">      /* Skip all options that are not window-local (used when showing</a>
<a name="ln1114">       * an already loaded buffer in a window). */</a>
<a name="ln1115">      if ((opt_flags &amp; OPT_WINONLY)</a>
<a name="ln1116">          &amp;&amp; (opt_idx &lt; 0 || options[opt_idx].var != VAR_WIN))</a>
<a name="ln1117">        goto skip;</a>
<a name="ln1118"> </a>
<a name="ln1119">      // Skip all options that are window-local (used for :vimgrep).</a>
<a name="ln1120">      if ((opt_flags &amp; OPT_NOWIN) &amp;&amp; opt_idx &gt;= 0</a>
<a name="ln1121">          &amp;&amp; options[opt_idx].var == VAR_WIN) {</a>
<a name="ln1122">        goto skip;</a>
<a name="ln1123">      }</a>
<a name="ln1124"> </a>
<a name="ln1125">      // Disallow changing some options from modelines.</a>
<a name="ln1126">      if (opt_flags &amp; OPT_MODELINE) {</a>
<a name="ln1127">        if (flags &amp; (P_SECURE | P_NO_ML)) {</a>
<a name="ln1128">          errmsg = (char_u *)N_(&quot;E520: Not allowed in a modeline&quot;);</a>
<a name="ln1129">          goto skip;</a>
<a name="ln1130">        }</a>
<a name="ln1131">        if ((flags &amp; P_MLE) &amp;&amp; !p_mle) {</a>
<a name="ln1132">          errmsg = (char_u *)N_(</a>
<a name="ln1133">              &quot;E992: Not allowed in a modeline when 'modelineexpr' is off&quot;);</a>
<a name="ln1134">          goto skip;</a>
<a name="ln1135">        }</a>
<a name="ln1136">        // In diff mode some options are overruled.  This avoids that</a>
<a name="ln1137">        // 'foldmethod' becomes &quot;marker&quot; instead of &quot;diff&quot; and that</a>
<a name="ln1138">        // &quot;wrap&quot; gets set.</a>
<a name="ln1139">        if (curwin-&gt;w_p_diff</a>
<a name="ln1140">            &amp;&amp; opt_idx &gt;= 0              // shut up coverity warning</a>
<a name="ln1141">            &amp;&amp; (options[opt_idx].indir == PV_FDM</a>
<a name="ln1142">                || options[opt_idx].indir == PV_WRAP)) {</a>
<a name="ln1143">          goto skip;</a>
<a name="ln1144">        }</a>
<a name="ln1145">      }</a>
<a name="ln1146"> </a>
<a name="ln1147">      // Disallow changing some options in the sandbox</a>
<a name="ln1148">      if (sandbox != 0 &amp;&amp; (flags &amp; P_SECURE)) {</a>
<a name="ln1149">        errmsg = e_sandbox;</a>
<a name="ln1150">        goto skip;</a>
<a name="ln1151">      }</a>
<a name="ln1152"> </a>
<a name="ln1153">      if (vim_strchr((char_u *)&quot;?=:!&amp;&lt;&quot;, nextchar) != NULL) {</a>
<a name="ln1154">        arg += len;</a>
<a name="ln1155">        cp_val = false;</a>
<a name="ln1156">        if (nextchar == '&amp;' &amp;&amp; arg[1] == 'v' &amp;&amp; arg[2] == 'i') {</a>
<a name="ln1157">          if (arg[3] == 'm') {          // &quot;opt&amp;vim&quot;: set to Vim default</a>
<a name="ln1158">            cp_val = false;</a>
<a name="ln1159">            arg += 3;</a>
<a name="ln1160">          } else {                    // &quot;opt&amp;vi&quot;: set to Vi default</a>
<a name="ln1161">            cp_val = true;</a>
<a name="ln1162">            arg += 2;</a>
<a name="ln1163">          }</a>
<a name="ln1164">        }</a>
<a name="ln1165">        if (vim_strchr((char_u *)&quot;?!&amp;&lt;&quot;, nextchar) != NULL</a>
<a name="ln1166">            &amp;&amp; arg[1] != NUL &amp;&amp; !ascii_iswhite(arg[1])) {</a>
<a name="ln1167">          errmsg = e_trailing;</a>
<a name="ln1168">          goto skip;</a>
<a name="ln1169">        }</a>
<a name="ln1170">      }</a>
<a name="ln1171"> </a>
<a name="ln1172">      /*</a>
<a name="ln1173">       * allow '=' and ':' as MSDOS command.com allows only one</a>
<a name="ln1174">       * '=' character per &quot;set&quot; command line. grrr. (jw)</a>
<a name="ln1175">       */</a>
<a name="ln1176">      if (nextchar == '?'</a>
<a name="ln1177">          || (prefix == 1</a>
<a name="ln1178">              &amp;&amp; vim_strchr((char_u *)&quot;=:&amp;&lt;&quot;, nextchar) == NULL</a>
<a name="ln1179">              &amp;&amp; !(flags &amp; P_BOOL))) {</a>
<a name="ln1180">        /*</a>
<a name="ln1181">         * print value</a>
<a name="ln1182">         */</a>
<a name="ln1183">        if (did_show) {</a>
<a name="ln1184">          msg_putchar('\n');                // cursor below last one</a>
<a name="ln1185">        } else {</a>
<a name="ln1186">          gotocmdline(true);                // cursor at status line</a>
<a name="ln1187">          did_show = true;                  // remember that we did a line</a>
<a name="ln1188">        }</a>
<a name="ln1189">        if (opt_idx &gt;= 0) {</a>
<a name="ln1190">          showoneopt(&amp;options[opt_idx], opt_flags);</a>
<a name="ln1191">          if (p_verbose &gt; 0) {</a>
<a name="ln1192">            // Mention where the option was last set.</a>
<a name="ln1193">            if (varp == options[opt_idx].var) {</a>
<a name="ln1194">              option_last_set_msg(options[opt_idx].last_set);</a>
<a name="ln1195">            } else if ((int)options[opt_idx].indir &amp; PV_WIN) {</a>
<a name="ln1196">              option_last_set_msg(curwin-&gt;w_p_script_ctx[</a>
<a name="ln1197">                  (int)options[opt_idx].indir &amp; PV_MASK]);</a>
<a name="ln1198">            } else if ((int)options[opt_idx].indir &amp; PV_BUF) {</a>
<a name="ln1199">              option_last_set_msg(curbuf-&gt;b_p_script_ctx[</a>
<a name="ln1200">                  (int)options[opt_idx].indir &amp; PV_MASK]);</a>
<a name="ln1201">            }</a>
<a name="ln1202">          }</a>
<a name="ln1203">        } else {</a>
<a name="ln1204">          errmsg = (char_u *)N_(&quot;E846: Key code not set&quot;);</a>
<a name="ln1205">          goto skip;</a>
<a name="ln1206">        }</a>
<a name="ln1207">        if (nextchar != '?'</a>
<a name="ln1208">            &amp;&amp; nextchar != NUL &amp;&amp; !ascii_iswhite(afterchar))</a>
<a name="ln1209">          errmsg = e_trailing;</a>
<a name="ln1210">      } else {</a>
<a name="ln1211">        int value_is_replaced = !prepending &amp;&amp; !adding &amp;&amp; !removing;</a>
<a name="ln1212">        int value_checked = false;</a>
<a name="ln1213"> </a>
<a name="ln1214">        if (flags &amp; P_BOOL) {                       // boolean</a>
<a name="ln1215">          if (nextchar == '=' || nextchar == ':') {</a>
<a name="ln1216">            errmsg = e_invarg;</a>
<a name="ln1217">            goto skip;</a>
<a name="ln1218">          }</a>
<a name="ln1219"> </a>
<a name="ln1220">          /*</a>
<a name="ln1221">           * &quot;:set opt!&quot;: invert</a>
<a name="ln1222">           * &quot;:set opt&amp;&quot;: reset to default value</a>
<a name="ln1223">           * &quot;:set opt&lt;&quot;: reset to global value</a>
<a name="ln1224">           */</a>
<a name="ln1225">          if (nextchar == '!') {</a>
<a name="ln1226">            value = *(int *)(varp) ^ 1;</a>
<a name="ln1227">          } else if (nextchar == '&amp;') {</a>
<a name="ln1228">            value = (int)(intptr_t)options[opt_idx].def_val[</a>
<a name="ln1229">                ((flags &amp; P_VI_DEF) || cp_val)</a>
<a name="ln1230">                ?  VI_DEFAULT : VIM_DEFAULT];</a>
<a name="ln1231">          } else if (nextchar == '&lt;') {</a>
<a name="ln1232">            // For 'autoread' -1 means to use global value.</a>
<a name="ln1233">            if ((int *)varp == &amp;curbuf-&gt;b_p_ar</a>
<a name="ln1234">                &amp;&amp; opt_flags == OPT_LOCAL) {</a>
<a name="ln1235">              value = -1;</a>
<a name="ln1236">            } else {</a>
<a name="ln1237">              value = *(int *)get_varp_scope(&amp;(options[opt_idx]),</a>
<a name="ln1238">                                             OPT_GLOBAL);</a>
<a name="ln1239">            }</a>
<a name="ln1240">          } else {</a>
<a name="ln1241">            /*</a>
<a name="ln1242">             * &quot;:set invopt&quot;: invert</a>
<a name="ln1243">             * &quot;:set opt&quot; or &quot;:set noopt&quot;: set or reset</a>
<a name="ln1244">             */</a>
<a name="ln1245">            if (nextchar != NUL &amp;&amp; !ascii_iswhite(afterchar)) {</a>
<a name="ln1246">              errmsg = e_trailing;</a>
<a name="ln1247">              goto skip;</a>
<a name="ln1248">            }</a>
<a name="ln1249">            if (prefix == 2) {                  // inv</a>
<a name="ln1250">              value = *(int *)(varp) ^ 1;</a>
<a name="ln1251">            } else {</a>
<a name="ln1252">              value = prefix;</a>
<a name="ln1253">            }</a>
<a name="ln1254">          }</a>
<a name="ln1255"> </a>
<a name="ln1256">          errmsg = (char_u *)set_bool_option(opt_idx, varp, (int)value,</a>
<a name="ln1257">                                             opt_flags);</a>
<a name="ln1258">        } else {  // Numeric or string.</a>
<a name="ln1259">          if (vim_strchr((const char_u *)&quot;=:&amp;&lt;&quot;, nextchar) == NULL</a>
<a name="ln1260">              || prefix != 1) {</a>
<a name="ln1261">            errmsg = e_invarg;</a>
<a name="ln1262">            goto skip;</a>
<a name="ln1263">          }</a>
<a name="ln1264"> </a>
<a name="ln1265">          if (flags &amp; P_NUM) {                      // numeric</a>
<a name="ln1266">            // Different ways to set a number option:</a>
<a name="ln1267">            // &amp;            set to default value</a>
<a name="ln1268">            // &lt;            set to global value</a>
<a name="ln1269">            // &lt;xx&gt;         accept special key codes for 'wildchar'</a>
<a name="ln1270">            // c            accept any non-digit for 'wildchar'</a>
<a name="ln1271">            // [-]0-9       set number</a>
<a name="ln1272">            // other        error</a>
<a name="ln1273">            arg++;</a>
<a name="ln1274">            if (nextchar == '&amp;') {</a>
<a name="ln1275">              value = (long)(intptr_t)options[opt_idx].def_val[</a>
<a name="ln1276">                  ((flags &amp; P_VI_DEF) || cp_val) ? VI_DEFAULT : VIM_DEFAULT];</a>
<a name="ln1277">            } else if (nextchar == '&lt;') {</a>
<a name="ln1278">              // For 'undolevels' NO_LOCAL_UNDOLEVEL means to</a>
<a name="ln1279">              // use the global value.</a>
<a name="ln1280">              if ((long *)varp == &amp;curbuf-&gt;b_p_ul &amp;&amp; opt_flags == OPT_LOCAL) {</a>
<a name="ln1281">                value = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln1282">              } else {</a>
<a name="ln1283">                value = *(long *)get_varp_scope(</a>
<a name="ln1284">                    &amp;(options[opt_idx]), OPT_GLOBAL);</a>
<a name="ln1285">              }</a>
<a name="ln1286">            } else if (((long *)varp == &amp;p_wc</a>
<a name="ln1287">                        || (long *)varp == &amp;p_wcm)</a>
<a name="ln1288">                       &amp;&amp; (*arg == '&lt;'</a>
<a name="ln1289">                           || *arg == '^'</a>
<a name="ln1290">                           || (*arg != NUL &amp;&amp; (!arg[1] || ascii_iswhite(arg[1]))</a>
<a name="ln1291">                               &amp;&amp; !ascii_isdigit(*arg)))) {</a>
<a name="ln1292">              value = string_to_key(arg);</a>
<a name="ln1293">              if (value == 0 &amp;&amp; (long *)varp != &amp;p_wcm) {</a>
<a name="ln1294">                errmsg = e_invarg;</a>
<a name="ln1295">                goto skip;</a>
<a name="ln1296">              }</a>
<a name="ln1297">            } else if (*arg == '-' || ascii_isdigit(*arg)) {</a>
<a name="ln1298">              // Allow negative, octal and hex numbers.</a>
<a name="ln1299">              vim_str2nr(arg, NULL, &amp;i, STR2NR_ALL, &amp;value, NULL, 0);</a>
<a name="ln1300">              if (arg[i] != NUL &amp;&amp; !ascii_iswhite(arg[i])) {</a>
<a name="ln1301">                errmsg = e_invarg;</a>
<a name="ln1302">                goto skip;</a>
<a name="ln1303">              }</a>
<a name="ln1304">            } else {</a>
<a name="ln1305">              errmsg = (char_u *)N_(&quot;E521: Number required after =&quot;);</a>
<a name="ln1306">              goto skip;</a>
<a name="ln1307">            }</a>
<a name="ln1308"> </a>
<a name="ln1309">            if (adding) {</a>
<a name="ln1310">              value = *(long *)varp + value;</a>
<a name="ln1311">            }</a>
<a name="ln1312">            if (prepending) {</a>
<a name="ln1313">              value = *(long *)varp * value;</a>
<a name="ln1314">            }</a>
<a name="ln1315">            if (removing) {</a>
<a name="ln1316">              value = *(long *)varp - value;</a>
<a name="ln1317">            }</a>
<a name="ln1318">            errmsg = (char_u *)set_num_option(opt_idx, varp, (long)value,</a>
<a name="ln1319">                                              errbuf, sizeof(errbuf),</a>
<a name="ln1320">                                              opt_flags);</a>
<a name="ln1321">          } else if (opt_idx &gt;= 0) {  // String.</a>
<a name="ln1322">            char_u      *save_arg = NULL;</a>
<a name="ln1323">            char_u      *s = NULL;</a>
<a name="ln1324">            char_u      *oldval = NULL;         // previous value if *varp</a>
<a name="ln1325">            char_u      *newval;</a>
<a name="ln1326">            char_u      *origval = NULL;</a>
<a name="ln1327">            char *saved_origval = NULL;</a>
<a name="ln1328">            char *saved_newval = NULL;</a>
<a name="ln1329">            unsigned newlen;</a>
<a name="ln1330">            int comma;</a>
<a name="ln1331">            bool new_value_alloced = false;  // new string option was allocated</a>
<a name="ln1332"> </a>
<a name="ln1333">            /* When using &quot;:set opt=val&quot; for a global option</a>
<a name="ln1334">             * with a local value the local value will be</a>
<a name="ln1335">             * reset, use the global value here. */</a>
<a name="ln1336">            if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0</a>
<a name="ln1337">                &amp;&amp; ((int)options[opt_idx].indir &amp; PV_BOTH))</a>
<a name="ln1338">              varp = options[opt_idx].var;</a>
<a name="ln1339"> </a>
<a name="ln1340">            /* The old value is kept until we are sure that the</a>
<a name="ln1341">             * new value is valid. */</a>
<a name="ln1342">            oldval = *(char_u **)varp;</a>
<a name="ln1343"> </a>
<a name="ln1344">            // When setting the local value of a global</a>
<a name="ln1345">            // option, the old value may be the global value.</a>
<a name="ln1346">            if (((int)options[opt_idx].indir &amp; PV_BOTH) &amp;&amp; (opt_flags</a>
<a name="ln1347">                                                            &amp; OPT_LOCAL)) {</a>
<a name="ln1348">              origval = *(char_u **)get_varp(&amp;options[opt_idx]);</a>
<a name="ln1349">            } else {</a>
<a name="ln1350">              origval = oldval;</a>
<a name="ln1351">            }</a>
<a name="ln1352"> </a>
<a name="ln1353">            if (nextchar == '&amp;') {              // set to default val</a>
<a name="ln1354">              newval = options[opt_idx].def_val[</a>
<a name="ln1355">                ((flags &amp; P_VI_DEF) || cp_val)</a>
<a name="ln1356">                ?  VI_DEFAULT : VIM_DEFAULT];</a>
<a name="ln1357">              /* expand environment variables and ~ (since the</a>
<a name="ln1358">               * default value was already expanded, only</a>
<a name="ln1359">               * required when an environment variable was set</a>
<a name="ln1360">               * later */</a>
<a name="ln1361">              new_value_alloced = true;</a>
<a name="ln1362">              if (newval == NULL) {</a>
<a name="ln1363">                newval = empty_option;</a>
<a name="ln1364">              } else if (!(options[opt_idx].flags &amp; P_NO_DEF_EXP)) {</a>
<a name="ln1365">                s = option_expand(opt_idx, newval);</a>
<a name="ln1366">                if (s == NULL) {</a>
<a name="ln1367">                  s = newval;</a>
<a name="ln1368">                }</a>
<a name="ln1369">                newval = vim_strsave(s);</a>
<a name="ln1370">              } else {</a>
<a name="ln1371">                newval = (char_u *)xstrdup((char *)newval);</a>
<a name="ln1372">              }</a>
<a name="ln1373">            } else if (nextchar == '&lt;') {  // set to global val</a>
<a name="ln1374">              newval = vim_strsave(*(char_u **)get_varp_scope(</a>
<a name="ln1375">                  &amp;(options[opt_idx]), OPT_GLOBAL));</a>
<a name="ln1376">              new_value_alloced = true;</a>
<a name="ln1377">            } else {</a>
<a name="ln1378">              arg++;                    // jump to after the '=' or ':'</a>
<a name="ln1379"> </a>
<a name="ln1380">              /*</a>
<a name="ln1381">               * Set 'keywordprg' to &quot;:help&quot; if an empty</a>
<a name="ln1382">               * value was passed to :set by the user.</a>
<a name="ln1383">               * Misuse errbuf[] for the resulting string.</a>
<a name="ln1384">               */</a>
<a name="ln1385">              if (varp == (char_u *)&amp;p_kp</a>
<a name="ln1386">                  &amp;&amp; (*arg == NUL || *arg == ' ')) {</a>
<a name="ln1387">                STRCPY(errbuf, &quot;:help&quot;);</a>
<a name="ln1388">                save_arg = arg;</a>
<a name="ln1389">                arg = errbuf;</a>
<a name="ln1390">              }</a>
<a name="ln1391">              /*</a>
<a name="ln1392">               * Convert 'backspace' number to string, for</a>
<a name="ln1393">               * adding, prepending and removing string.</a>
<a name="ln1394">               */</a>
<a name="ln1395">              else if (varp == (char_u *)&amp;p_bs</a>
<a name="ln1396">                       &amp;&amp; ascii_isdigit(**(char_u **)varp)) {</a>
<a name="ln1397">                i = getdigits_int((char_u **)varp, true, 0);</a>
<a name="ln1398">                switch (i) {</a>
<a name="ln1399">                case 0:</a>
<a name="ln1400">                  *(char_u **)varp = empty_option;</a>
<a name="ln1401">                  break;</a>
<a name="ln1402">                case 1:</a>
<a name="ln1403">                  *(char_u **)varp = vim_strsave(</a>
<a name="ln1404">                      (char_u *)&quot;indent,eol&quot;);</a>
<a name="ln1405">                  break;</a>
<a name="ln1406">                case 2:</a>
<a name="ln1407">                  *(char_u **)varp = vim_strsave(</a>
<a name="ln1408">                      (char_u *)&quot;indent,eol,start&quot;);</a>
<a name="ln1409">                  break;</a>
<a name="ln1410">                case 3:</a>
<a name="ln1411">                  *(char_u **)varp = vim_strsave(</a>
<a name="ln1412">                      (char_u *)&quot;indent,eol,nostop&quot;);</a>
<a name="ln1413">                  break;</a>
<a name="ln1414">                }</a>
<a name="ln1415">                xfree(oldval);</a>
<a name="ln1416">                if (origval == oldval) {</a>
<a name="ln1417">                  origval = *(char_u **)varp;</a>
<a name="ln1418">                }</a>
<a name="ln1419">                oldval = *(char_u **)varp;</a>
<a name="ln1420">              }</a>
<a name="ln1421">              /*</a>
<a name="ln1422">               * Convert 'whichwrap' number to string, for</a>
<a name="ln1423">               * backwards compatibility with Vim 3.0.</a>
<a name="ln1424">               * Misuse errbuf[] for the resulting string.</a>
<a name="ln1425">               */</a>
<a name="ln1426">              else if (varp == (char_u *)&amp;p_ww</a>
<a name="ln1427">                       &amp;&amp; ascii_isdigit(*arg)) {</a>
<a name="ln1428">                *errbuf = NUL;</a>
<a name="ln1429">                i = getdigits_int(&amp;arg, true, 0);</a>
<a name="ln1430">                if (i &amp; 1) {</a>
<a name="ln1431">                  STRCAT(errbuf, &quot;b,&quot;);</a>
<a name="ln1432">                }</a>
<a name="ln1433">                if (i &amp; 2) {</a>
<a name="ln1434">                  STRCAT(errbuf, &quot;s,&quot;);</a>
<a name="ln1435">                }</a>
<a name="ln1436">                if (i &amp; 4) {</a>
<a name="ln1437">                  STRCAT(errbuf, &quot;h,l,&quot;);</a>
<a name="ln1438">                }</a>
<a name="ln1439">                if (i &amp; 8) {</a>
<a name="ln1440">                  STRCAT(errbuf, &quot;&lt;,&gt;,&quot;);</a>
<a name="ln1441">                }</a>
<a name="ln1442">                if (i &amp; 16) {</a>
<a name="ln1443">                  STRCAT(errbuf, &quot;[,],&quot;);</a>
<a name="ln1444">                }</a>
<a name="ln1445">                if (*errbuf != NUL) {                   // remove trailing ,</a>
<a name="ln1446">                  errbuf[STRLEN(errbuf) - 1] = NUL;</a>
<a name="ln1447">                }</a>
<a name="ln1448">                save_arg = arg;</a>
<a name="ln1449">                arg = errbuf;</a>
<a name="ln1450">              }</a>
<a name="ln1451">              /*</a>
<a name="ln1452">               * Remove '&gt;' before 'dir' and 'bdir', for</a>
<a name="ln1453">               * backwards compatibility with version 3.0</a>
<a name="ln1454">               */</a>
<a name="ln1455">              else if (  *arg == '&gt;'</a>
<a name="ln1456">                         &amp;&amp; (varp == (char_u *)&amp;p_dir</a>
<a name="ln1457">                             || varp == (char_u *)&amp;p_bdir)) {</a>
<a name="ln1458">                arg++;</a>
<a name="ln1459">              }</a>
<a name="ln1460"> </a>
<a name="ln1461">              /*</a>
<a name="ln1462">               * Copy the new string into allocated memory.</a>
<a name="ln1463">               * Can't use set_string_option_direct(), because</a>
<a name="ln1464">               * we need to remove the backslashes.</a>
<a name="ln1465">               */</a>
<a name="ln1466">              // get a bit too much</a>
<a name="ln1467">              newlen = (unsigned)STRLEN(arg) + 1;</a>
<a name="ln1468">              if (adding || prepending || removing) {</a>
<a name="ln1469">                newlen += (unsigned)STRLEN(origval) + 1;</a>
<a name="ln1470">              }</a>
<a name="ln1471">              newval = xmalloc(newlen);</a>
<a name="ln1472">              s = newval;</a>
<a name="ln1473"> </a>
<a name="ln1474">              /*</a>
<a name="ln1475">               * Copy the string, skip over escaped chars.</a>
<a name="ln1476">               * For WIN32 backslashes before normal</a>
<a name="ln1477">               * file name characters are not removed, and keep</a>
<a name="ln1478">               * backslash at start, for &quot;\\machine\path&quot;, but</a>
<a name="ln1479">               * do remove it for &quot;\\\\machine\\path&quot;.</a>
<a name="ln1480">               * The reverse is found in ExpandOldSetting().</a>
<a name="ln1481">               */</a>
<a name="ln1482">              while (*arg &amp;&amp; !ascii_iswhite(*arg)) {</a>
<a name="ln1483">                if (*arg == '\\' &amp;&amp; arg[1] != NUL</a>
<a name="ln1484">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln1485">                    &amp;&amp; !((flags &amp; P_EXPAND)</a>
<a name="ln1486">                         &amp;&amp; vim_isfilec(arg[1])</a>
<a name="ln1487">                         &amp;&amp; !ascii_iswhite(arg[1])</a>
<a name="ln1488">                         &amp;&amp; (arg[1] != '\\'</a>
<a name="ln1489">                             || (s == newval</a>
<a name="ln1490">                                 &amp;&amp; arg[2] != '\\')))</a>
<a name="ln1491">#endif</a>
<a name="ln1492">                    )</a>
<a name="ln1493">                  arg++;                        // remove backslash</a>
<a name="ln1494">                i = utfc_ptr2len(arg);</a>
<a name="ln1495">                if (i &gt; 1) {</a>
<a name="ln1496">                  // copy multibyte char</a>
<a name="ln1497">                  memmove(s, arg, (size_t)i);</a>
<a name="ln1498">                  arg += i;</a>
<a name="ln1499">                  s += i;</a>
<a name="ln1500">                } else {</a>
<a name="ln1501">                  *s++ = *arg++;</a>
<a name="ln1502">                }</a>
<a name="ln1503">              }</a>
<a name="ln1504">              *s = NUL;</a>
<a name="ln1505"> </a>
<a name="ln1506">              /*</a>
<a name="ln1507">               * Expand environment variables and ~.</a>
<a name="ln1508">               * Don't do it when adding without inserting a</a>
<a name="ln1509">               * comma.</a>
<a name="ln1510">               */</a>
<a name="ln1511">              if (!(adding || prepending || removing)</a>
<a name="ln1512">                  || (flags &amp; P_COMMA)) {</a>
<a name="ln1513">                s = option_expand(opt_idx, newval);</a>
<a name="ln1514">                if (s != NULL) {</a>
<a name="ln1515">                  xfree(newval);</a>
<a name="ln1516">                  newlen = (unsigned)STRLEN(s) + 1;</a>
<a name="ln1517">                  if (adding || prepending || removing) {</a>
<a name="ln1518">                    newlen += (unsigned)STRLEN(origval) + 1;</a>
<a name="ln1519">                  }</a>
<a name="ln1520">                  newval = xmalloc(newlen);</a>
<a name="ln1521">                  STRCPY(newval, s);</a>
<a name="ln1522">                }</a>
<a name="ln1523">              }</a>
<a name="ln1524"> </a>
<a name="ln1525">              /* locate newval[] in origval[] when removing it</a>
<a name="ln1526">               * and when adding to avoid duplicates */</a>
<a name="ln1527">              i = 0;                    // init for GCC</a>
<a name="ln1528">              if (removing || (flags &amp; P_NODUP)) {</a>
<a name="ln1529">                i = (int)STRLEN(newval);</a>
<a name="ln1530">                s = find_dup_item(origval, newval, flags);</a>
<a name="ln1531"> </a>
<a name="ln1532">                // do not add if already there</a>
<a name="ln1533">                if ((adding || prepending) &amp;&amp; s != NULL) {</a>
<a name="ln1534">                  prepending = false;</a>
<a name="ln1535">                  adding = false;</a>
<a name="ln1536">                  STRCPY(newval, origval);</a>
<a name="ln1537">                }</a>
<a name="ln1538"> </a>
<a name="ln1539">                // if no duplicate, move pointer to end of</a>
<a name="ln1540">                // original value</a>
<a name="ln1541">                if (s == NULL) {</a>
<a name="ln1542">                  s = origval + (int)STRLEN(origval);</a>
<a name="ln1543">                }</a>
<a name="ln1544">              }</a>
<a name="ln1545"> </a>
<a name="ln1546">              /* concatenate the two strings; add a ',' if</a>
<a name="ln1547">               * needed */</a>
<a name="ln1548">              if (adding || prepending) {</a>
<a name="ln1549">                comma = ((flags &amp; P_COMMA) &amp;&amp; *origval != NUL</a>
<a name="ln1550">                         &amp;&amp; *newval != NUL);</a>
<a name="ln1551">                if (adding) {</a>
<a name="ln1552">                  i = (int)STRLEN(origval);</a>
<a name="ln1553">                  // Strip a trailing comma, would get 2.</a>
<a name="ln1554">                  if (comma &amp;&amp; i &gt; 1</a>
<a name="ln1555">                      &amp;&amp; (flags &amp; P_ONECOMMA) == P_ONECOMMA</a>
<a name="ln1556">                      &amp;&amp; origval[i - 1] == ','</a>
<a name="ln1557">                      &amp;&amp; origval[i - 2] != '\\') {</a>
<a name="ln1558">                    i--;</a>
<a name="ln1559">                  }</a>
<a name="ln1560">                  memmove(newval + i + comma, newval,</a>
<a name="ln1561">                      STRLEN(newval) + 1);</a>
<a name="ln1562">                  memmove(newval, origval, (size_t)i);</a>
<a name="ln1563">                } else {</a>
<a name="ln1564">                  i = (int)STRLEN(newval);</a>
<a name="ln1565">                  STRMOVE(newval + i + comma, origval);</a>
<a name="ln1566">                }</a>
<a name="ln1567">                if (comma) {</a>
<a name="ln1568">                  newval[i] = ',';</a>
<a name="ln1569">                }</a>
<a name="ln1570">              }</a>
<a name="ln1571"> </a>
<a name="ln1572">              /* Remove newval[] from origval[]. (Note: &quot;i&quot; has</a>
<a name="ln1573">               * been set above and is used here). */</a>
<a name="ln1574">              if (removing) {</a>
<a name="ln1575">                STRCPY(newval, origval);</a>
<a name="ln1576">                if (*s) {</a>
<a name="ln1577">                  // may need to remove a comma</a>
<a name="ln1578">                  if (flags &amp; P_COMMA) {</a>
<a name="ln1579">                    if (s == origval) {</a>
<a name="ln1580">                      // include comma after string</a>
<a name="ln1581">                      if (s[i] == ',') {</a>
<a name="ln1582">                        i++;</a>
<a name="ln1583">                      }</a>
<a name="ln1584">                    } else {</a>
<a name="ln1585">                      // include comma before string</a>
<a name="ln1586">                      s--;</a>
<a name="ln1587">                      i++;</a>
<a name="ln1588">                    }</a>
<a name="ln1589">                  }</a>
<a name="ln1590">                  STRMOVE(newval + (s - origval), s + i);</a>
<a name="ln1591">                }</a>
<a name="ln1592">              }</a>
<a name="ln1593"> </a>
<a name="ln1594">              if (flags &amp; P_FLAGLIST) {</a>
<a name="ln1595">                // Remove flags that appear twice.</a>
<a name="ln1596">                for (s = newval; *s;) {</a>
<a name="ln1597">                  // if options have P_FLAGLIST and P_ONECOMMA such as</a>
<a name="ln1598">                  // 'whichwrap'</a>
<a name="ln1599">                  if (flags &amp; P_ONECOMMA) {</a>
<a name="ln1600">                    if (*s != ',' &amp;&amp; *(s + 1) == ','</a>
<a name="ln1601">                        &amp;&amp; vim_strchr(s + 2, *s) != NULL) {</a>
<a name="ln1602">                      // Remove the duplicated value and the next comma.</a>
<a name="ln1603">                      STRMOVE(s, s + 2);</a>
<a name="ln1604">                      continue;</a>
<a name="ln1605">                    }</a>
<a name="ln1606">                  } else {</a>
<a name="ln1607">                    if ((!(flags &amp; P_COMMA) || *s != ',')</a>
<a name="ln1608">                        &amp;&amp; vim_strchr(s + 1, *s) != NULL) {</a>
<a name="ln1609">                      STRMOVE(s, s + 1);</a>
<a name="ln1610">                      continue;</a>
<a name="ln1611">                    }</a>
<a name="ln1612">                  }</a>
<a name="ln1613">                  s++;</a>
<a name="ln1614">                }</a>
<a name="ln1615">              }</a>
<a name="ln1616"> </a>
<a name="ln1617">              if (save_arg != NULL) {               // number for 'whichwrap'</a>
<a name="ln1618">                arg = save_arg;</a>
<a name="ln1619">              }</a>
<a name="ln1620">              new_value_alloced = true;</a>
<a name="ln1621">            }</a>
<a name="ln1622"> </a>
<a name="ln1623">            // Set the new value.</a>
<a name="ln1624">            *(char_u **)(varp) = newval;</a>
<a name="ln1625"> </a>
<a name="ln1626">            // origval may be freed by</a>
<a name="ln1627">            // did_set_string_option(), make a copy.</a>
<a name="ln1628">            saved_origval = (origval != NULL) ? xstrdup((char *)origval) : 0;</a>
<a name="ln1629"> </a>
<a name="ln1630">            // newval (and varp) may become invalid if the</a>
<a name="ln1631">            // buffer is closed by autocommands.</a>
<a name="ln1632">            saved_newval = (newval != NULL) ? xstrdup((char *)newval) : 0;</a>
<a name="ln1633"> </a>
<a name="ln1634">            {</a>
<a name="ln1635">              uint32_t *p = insecure_flag(curwin, opt_idx, opt_flags);</a>
<a name="ln1636">              const int secure_saved = secure;</a>
<a name="ln1637"> </a>
<a name="ln1638">              // When an option is set in the sandbox, from a</a>
<a name="ln1639">              // modeline or in secure mode, then deal with side</a>
<a name="ln1640">              // effects in secure mode.  Also when the value was</a>
<a name="ln1641">              // set with the P_INSECURE flag and is not</a>
<a name="ln1642">              // completely replaced.</a>
<a name="ln1643">              if ((opt_flags &amp; OPT_MODELINE)</a>
<a name="ln1644">                  || sandbox != 0</a>
<a name="ln1645">                  || (!value_is_replaced &amp;&amp; (*p &amp; P_INSECURE))) {</a>
<a name="ln1646">                secure = 1;</a>
<a name="ln1647">              }</a>
<a name="ln1648"> </a>
<a name="ln1649">              // Handle side effects, and set the global value</a>
<a name="ln1650">              // for &quot;:set&quot; on local options. Note: when setting</a>
<a name="ln1651">              // 'syntax' or 'filetype' autocommands may be</a>
<a name="ln1652">              // triggered that can cause havoc.</a>
<a name="ln1653">              errmsg = did_set_string_option(opt_idx, (char_u **)varp,</a>
<a name="ln1654">                                             new_value_alloced, oldval,</a>
<a name="ln1655">                                             errbuf, sizeof(errbuf),</a>
<a name="ln1656">                                             opt_flags, &amp;value_checked);</a>
<a name="ln1657"> </a>
<a name="ln1658">              secure = secure_saved;</a>
<a name="ln1659">            }</a>
<a name="ln1660"> </a>
<a name="ln1661">            if (errmsg == NULL) {</a>
<a name="ln1662">              if (!starting) {</a>
<a name="ln1663">                trigger_optionsset_string(opt_idx, opt_flags, saved_origval,</a>
<a name="ln1664">                                          saved_newval);</a>
<a name="ln1665">              }</a>
<a name="ln1666">              if (options[opt_idx].flags &amp; P_UI_OPTION) {</a>
<a name="ln1667">                ui_call_option_set(cstr_as_string(options[opt_idx].fullname),</a>
<a name="ln1668">                                   STRING_OBJ(cstr_as_string(saved_newval)));</a>
<a name="ln1669">              }</a>
<a name="ln1670">            }</a>
<a name="ln1671">            xfree(saved_origval);</a>
<a name="ln1672">            xfree(saved_newval);</a>
<a name="ln1673"> </a>
<a name="ln1674">            // If error detected, print the error message.</a>
<a name="ln1675">            if (errmsg != NULL) {</a>
<a name="ln1676">              goto skip;</a>
<a name="ln1677">            }</a>
<a name="ln1678"> </a>
<a name="ln1679">          } else {</a>
<a name="ln1680">            // key code option(FIXME(tarruda): Show a warning or something</a>
<a name="ln1681">            // similar)</a>
<a name="ln1682">          }</a>
<a name="ln1683">        }</a>
<a name="ln1684"> </a>
<a name="ln1685">        if (opt_idx &gt;= 0) {</a>
<a name="ln1686">          did_set_option(opt_idx, opt_flags, value_is_replaced, value_checked);</a>
<a name="ln1687">        }</a>
<a name="ln1688">      }</a>
<a name="ln1689"> </a>
<a name="ln1690">skip:</a>
<a name="ln1691">      /*</a>
<a name="ln1692">       * Advance to next argument.</a>
<a name="ln1693">       * - skip until a blank found, taking care of backslashes</a>
<a name="ln1694">       * - skip blanks</a>
<a name="ln1695">       * - skip one &quot;=val&quot; argument (for hidden options &quot;:set gfn =xx&quot;)</a>
<a name="ln1696">       */</a>
<a name="ln1697">      for (i = 0; i &lt; 2; i++) {</a>
<a name="ln1698">        while (*arg != NUL &amp;&amp; !ascii_iswhite(*arg)) {</a>
<a name="ln1699">          if (*arg++ == '\\' &amp;&amp; *arg != NUL) {</a>
<a name="ln1700">            arg++;</a>
<a name="ln1701">          }</a>
<a name="ln1702">        }</a>
<a name="ln1703">        arg = skipwhite(arg);</a>
<a name="ln1704">        if (*arg != '=') {</a>
<a name="ln1705">          break;</a>
<a name="ln1706">        }</a>
<a name="ln1707">      }</a>
<a name="ln1708">    }</a>
<a name="ln1709"> </a>
<a name="ln1710">    if (errmsg != NULL) {</a>
<a name="ln1711">      STRLCPY(IObuff, _(errmsg), IOSIZE);</a>
<a name="ln1712">      i = (int)STRLEN(IObuff) + 2;</a>
<a name="ln1713">      if (i + (arg - startarg) &lt; IOSIZE) {</a>
<a name="ln1714">        // append the argument with the error</a>
<a name="ln1715">        STRCAT(IObuff, &quot;: &quot;);</a>
<a name="ln1716">        assert(arg &gt;= startarg);</a>
<a name="ln1717">        memmove(IObuff + i, startarg, (size_t)(arg - startarg));</a>
<a name="ln1718">        IObuff[i + (arg - startarg)] = NUL;</a>
<a name="ln1719">      }</a>
<a name="ln1720">      // make sure all characters are printable</a>
<a name="ln1721">      trans_characters(IObuff, IOSIZE);</a>
<a name="ln1722"> </a>
<a name="ln1723">      no_wait_return++;         // wait_return done later</a>
<a name="ln1724">      emsg(IObuff);             // show error highlighted</a>
<a name="ln1725">      no_wait_return--;</a>
<a name="ln1726"> </a>
<a name="ln1727">      return FAIL;</a>
<a name="ln1728">    }</a>
<a name="ln1729"> </a>
<a name="ln1730">    arg = skipwhite(arg);</a>
<a name="ln1731">  }</a>
<a name="ln1732"> </a>
<a name="ln1733">theend:</a>
<a name="ln1734">  if (silent_mode &amp;&amp; did_show) {</a>
<a name="ln1735">    // After displaying option values in silent mode.</a>
<a name="ln1736">    silent_mode = false;</a>
<a name="ln1737">    info_message = true;        // use mch_msg(), not mch_errmsg()</a>
<a name="ln1738">    msg_putchar('\n');</a>
<a name="ln1739">    ui_flush();</a>
<a name="ln1740">    silent_mode = true;</a>
<a name="ln1741">    info_message = false;       // use mch_msg(), not mch_errmsg()</a>
<a name="ln1742">  }</a>
<a name="ln1743"> </a>
<a name="ln1744">  return OK;</a>
<a name="ln1745">}</a>
<a name="ln1746"> </a>
<a name="ln1747">// Call this when an option has been given a new value through a user command.</a>
<a name="ln1748">// Sets the P_WAS_SET flag and takes care of the P_INSECURE flag.</a>
<a name="ln1749">static void did_set_option(</a>
<a name="ln1750">    int opt_idx,</a>
<a name="ln1751">    int opt_flags,              // possibly with OPT_MODELINE</a>
<a name="ln1752">    int new_value,              // value was replaced completely</a>
<a name="ln1753">    int value_checked           // value was checked to be safe, no need to</a>
<a name="ln1754">                                // set P_INSECURE</a>
<a name="ln1755">)</a>
<a name="ln1756">{</a>
<a name="ln1757">  options[opt_idx].flags |= P_WAS_SET;</a>
<a name="ln1758"> </a>
<a name="ln1759">  /* When an option is set in the sandbox, from a modeline or in secure mode</a>
<a name="ln1760">   * set the P_INSECURE flag.  Otherwise, if a new value is stored reset the</a>
<a name="ln1761">   * flag. */</a>
<a name="ln1762">  uint32_t *p = insecure_flag(curwin, opt_idx, opt_flags);</a>
<a name="ln1763">  if (!value_checked &amp;&amp; (secure</a>
<a name="ln1764">                         || sandbox != 0</a>
<a name="ln1765">                         || (opt_flags &amp; OPT_MODELINE))) {</a>
<a name="ln1766">    *p = *p | P_INSECURE;</a>
<a name="ln1767">  } else if (new_value) {</a>
<a name="ln1768">    *p = *p &amp; ~P_INSECURE;</a>
<a name="ln1769">  }</a>
<a name="ln1770">}</a>
<a name="ln1771"> </a>
<a name="ln1772">static char_u *illegal_char(char_u *errbuf, size_t errbuflen, int c)</a>
<a name="ln1773">{</a>
<a name="ln1774">  if (errbuf == NULL) {</a>
<a name="ln1775">    return (char_u *)&quot;&quot;;</a>
<a name="ln1776">  }</a>
<a name="ln1777">  vim_snprintf((char *)errbuf, errbuflen, _(&quot;E539: Illegal character &lt;%s&gt;&quot;),</a>
<a name="ln1778">               (char *)transchar(c));</a>
<a name="ln1779">  return errbuf;</a>
<a name="ln1780">}</a>
<a name="ln1781"> </a>
<a name="ln1782">/// Convert a key name or string into a key value.</a>
<a name="ln1783">/// Used for 'wildchar' and 'cedit' options.</a>
<a name="ln1784">static int string_to_key(char_u *arg)</a>
<a name="ln1785">{</a>
<a name="ln1786">  if (*arg == '&lt;') {</a>
<a name="ln1787">    return find_key_option(arg + 1, true);</a>
<a name="ln1788">  }</a>
<a name="ln1789">  if (*arg == '^') {</a>
<a name="ln1790">    return Ctrl_chr(arg[1]);</a>
<a name="ln1791">  }</a>
<a name="ln1792">  return *arg;</a>
<a name="ln1793">}</a>
<a name="ln1794"> </a>
<a name="ln1795">/// Check value of 'cedit' and set cedit_key.</a>
<a name="ln1796">/// Returns NULL if value is OK, error message otherwise.</a>
<a name="ln1797">static char_u *check_cedit(void)</a>
<a name="ln1798">{</a>
<a name="ln1799">  int n;</a>
<a name="ln1800"> </a>
<a name="ln1801">  if (*p_cedit == NUL) {</a>
<a name="ln1802">    cedit_key = -1;</a>
<a name="ln1803">  } else {</a>
<a name="ln1804">    n = string_to_key(p_cedit);</a>
<a name="ln1805">    if (vim_isprintc(n)) {</a>
<a name="ln1806">      return e_invarg;</a>
<a name="ln1807">    }</a>
<a name="ln1808">    cedit_key = n;</a>
<a name="ln1809">  }</a>
<a name="ln1810">  return NULL;</a>
<a name="ln1811">}</a>
<a name="ln1812"> </a>
<a name="ln1813">// When changing 'title', 'titlestring', 'icon' or 'iconstring', call</a>
<a name="ln1814">// maketitle() to create and display it.</a>
<a name="ln1815">// When switching the title or icon off, call ui_set_{icon,title}(NULL) to get</a>
<a name="ln1816">// the old value back.</a>
<a name="ln1817">static void did_set_title(void)</a>
<a name="ln1818">{</a>
<a name="ln1819">  if (starting != NO_SCREEN) {</a>
<a name="ln1820">    maketitle();</a>
<a name="ln1821">  }</a>
<a name="ln1822">}</a>
<a name="ln1823"> </a>
<a name="ln1824">// set_options_bin -  called when 'bin' changes value.</a>
<a name="ln1825">void set_options_bin(</a>
<a name="ln1826">    int oldval,</a>
<a name="ln1827">    int newval,</a>
<a name="ln1828">    int opt_flags                  // OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln1829">)</a>
<a name="ln1830">{</a>
<a name="ln1831">  /*</a>
<a name="ln1832">   * The option values that are changed when 'bin' changes are</a>
<a name="ln1833">   * copied when 'bin is set and restored when 'bin' is reset.</a>
<a name="ln1834">   */</a>
<a name="ln1835">  if (newval) {</a>
<a name="ln1836">    if (!oldval) {              // switched on</a>
<a name="ln1837">      if (!(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln1838">        curbuf-&gt;b_p_tw_nobin = curbuf-&gt;b_p_tw;</a>
<a name="ln1839">        curbuf-&gt;b_p_wm_nobin = curbuf-&gt;b_p_wm;</a>
<a name="ln1840">        curbuf-&gt;b_p_ml_nobin = curbuf-&gt;b_p_ml;</a>
<a name="ln1841">        curbuf-&gt;b_p_et_nobin = curbuf-&gt;b_p_et;</a>
<a name="ln1842">      }</a>
<a name="ln1843">      if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln1844">        p_tw_nobin = p_tw;</a>
<a name="ln1845">        p_wm_nobin = p_wm;</a>
<a name="ln1846">        p_ml_nobin = p_ml;</a>
<a name="ln1847">        p_et_nobin = p_et;</a>
<a name="ln1848">      }</a>
<a name="ln1849">    }</a>
<a name="ln1850"> </a>
<a name="ln1851">    if (!(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln1852">      curbuf-&gt;b_p_tw = 0;       // no automatic line wrap</a>
<a name="ln1853">      curbuf-&gt;b_p_wm = 0;       // no automatic line wrap</a>
<a name="ln1854">      curbuf-&gt;b_p_ml = 0;       // no modelines</a>
<a name="ln1855">      curbuf-&gt;b_p_et = 0;       // no expandtab</a>
<a name="ln1856">    }</a>
<a name="ln1857">    if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln1858">      p_tw = 0;</a>
<a name="ln1859">      p_wm = 0;</a>
<a name="ln1860">      p_ml = false;</a>
<a name="ln1861">      p_et = false;</a>
<a name="ln1862">      p_bin = true;             // needed when called for the &quot;-b&quot; argument</a>
<a name="ln1863">    }</a>
<a name="ln1864">  } else if (oldval) {        // switched off</a>
<a name="ln1865">    if (!(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln1866">      curbuf-&gt;b_p_tw = curbuf-&gt;b_p_tw_nobin;</a>
<a name="ln1867">      curbuf-&gt;b_p_wm = curbuf-&gt;b_p_wm_nobin;</a>
<a name="ln1868">      curbuf-&gt;b_p_ml = curbuf-&gt;b_p_ml_nobin;</a>
<a name="ln1869">      curbuf-&gt;b_p_et = curbuf-&gt;b_p_et_nobin;</a>
<a name="ln1870">    }</a>
<a name="ln1871">    if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln1872">      p_tw = p_tw_nobin;</a>
<a name="ln1873">      p_wm = p_wm_nobin;</a>
<a name="ln1874">      p_ml = p_ml_nobin;</a>
<a name="ln1875">      p_et = p_et_nobin;</a>
<a name="ln1876">    }</a>
<a name="ln1877">  }</a>
<a name="ln1878">}</a>
<a name="ln1879"> </a>
<a name="ln1880">/// Find the parameter represented by the given character (eg ', :, &quot;, or /),</a>
<a name="ln1881">/// and return its associated value in the 'shada' string.</a>
<a name="ln1882">/// Only works for number parameters, not for 'r' or 'n'.</a>
<a name="ln1883">/// If the parameter is not specified in the string or there is no following</a>
<a name="ln1884">/// number, return -1.</a>
<a name="ln1885">int get_shada_parameter(int type)</a>
<a name="ln1886">{</a>
<a name="ln1887">  char_u  *p;</a>
<a name="ln1888"> </a>
<a name="ln1889">  p = find_shada_parameter(type);</a>
<a name="ln1890">  if (p != NULL &amp;&amp; ascii_isdigit(*p)) {</a>
<a name="ln1891">    return atoi((char *)p);</a>
<a name="ln1892">  }</a>
<a name="ln1893">  return -1;</a>
<a name="ln1894">}</a>
<a name="ln1895"> </a>
<a name="ln1896">/// Find the parameter represented by the given character (eg ''', ':', '&quot;', or</a>
<a name="ln1897">/// '/') in the 'shada' option and return a pointer to the string after it.</a>
<a name="ln1898">/// Return NULL if the parameter is not specified in the string.</a>
<a name="ln1899">char_u *find_shada_parameter(int type)</a>
<a name="ln1900">{</a>
<a name="ln1901">  char_u  *p;</a>
<a name="ln1902"> </a>
<a name="ln1903">  for (p = p_shada; *p; p++) {</a>
<a name="ln1904">    if (*p == type) {</a>
<a name="ln1905">      return p + 1;</a>
<a name="ln1906">    }</a>
<a name="ln1907">    if (*p == 'n') {                // 'n' is always the last one</a>
<a name="ln1908">      break;</a>
<a name="ln1909">    }</a>
<a name="ln1910">    p = vim_strchr(p, ',');         // skip until next ','</a>
<a name="ln1911">    if (p == NULL) {                // hit the end without finding parameter</a>
<a name="ln1912">      break;</a>
<a name="ln1913">    }</a>
<a name="ln1914">  }</a>
<a name="ln1915">  return NULL;</a>
<a name="ln1916">}</a>
<a name="ln1917"> </a>
<a name="ln1918">/// Expand environment variables for some string options.</a>
<a name="ln1919">/// These string options cannot be indirect!</a>
<a name="ln1920">/// If &quot;val&quot; is NULL expand the current value of the option.</a>
<a name="ln1921">/// Return pointer to NameBuff, or NULL when not expanded.</a>
<a name="ln1922">static char_u *option_expand(int opt_idx, char_u *val)</a>
<a name="ln1923">{</a>
<a name="ln1924">  // if option doesn't need expansion nothing to do</a>
<a name="ln1925">  if (!(options[opt_idx].flags &amp; P_EXPAND) || options[opt_idx].var == NULL) {</a>
<a name="ln1926">    return NULL;</a>
<a name="ln1927">  }</a>
<a name="ln1928"> </a>
<a name="ln1929">  if (val == NULL) {</a>
<a name="ln1930">    val = *(char_u **)options[opt_idx].var;</a>
<a name="ln1931">  }</a>
<a name="ln1932"> </a>
<a name="ln1933">  // If val is longer than MAXPATHL no meaningful expansion can be done,</a>
<a name="ln1934">  // expand_env() would truncate the string.</a>
<a name="ln1935">  if (val == NULL || STRLEN(val) &gt; MAXPATHL) {</a>
<a name="ln1936">    return NULL;</a>
<a name="ln1937">  }</a>
<a name="ln1938"> </a>
<a name="ln1939">  /*</a>
<a name="ln1940">   * Expanding this with NameBuff, expand_env() must not be passed IObuff.</a>
<a name="ln1941">   * Escape spaces when expanding 'tags', they are used to separate file</a>
<a name="ln1942">   * names.</a>
<a name="ln1943">   * For 'spellsuggest' expand after &quot;file:&quot;.</a>
<a name="ln1944">   */</a>
<a name="ln1945">  expand_env_esc(val, NameBuff, MAXPATHL,</a>
<a name="ln1946">                 (char_u **)options[opt_idx].var == &amp;p_tags, false,</a>
<a name="ln1947">                 (char_u **)options[opt_idx].var == &amp;p_sps ? (char_u *)&quot;file:&quot; :</a>
<a name="ln1948">                 NULL);</a>
<a name="ln1949">  if (STRCMP(NameBuff, val) == 0) {   // they are the same</a>
<a name="ln1950">    return NULL;</a>
<a name="ln1951">  }</a>
<a name="ln1952"> </a>
<a name="ln1953">  return NameBuff;</a>
<a name="ln1954">}</a>
<a name="ln1955"> </a>
<a name="ln1956">// After setting various option values: recompute variables that depend on</a>
<a name="ln1957">// option values.</a>
<a name="ln1958">static void didset_options(void)</a>
<a name="ln1959">{</a>
<a name="ln1960">  // initialize the table for 'iskeyword' et.al.</a>
<a name="ln1961">  (void)init_chartab();</a>
<a name="ln1962"> </a>
<a name="ln1963">  (void)opt_strings_flags(p_cmp, p_cmp_values, &amp;cmp_flags, true);</a>
<a name="ln1964">  (void)opt_strings_flags(p_bkc, p_bkc_values, &amp;bkc_flags, true);</a>
<a name="ln1965">  (void)opt_strings_flags(p_bo, p_bo_values, &amp;bo_flags, true);</a>
<a name="ln1966">  (void)opt_strings_flags(p_ssop, p_ssop_values, &amp;ssop_flags, true);</a>
<a name="ln1967">  (void)opt_strings_flags(p_vop, p_ssop_values, &amp;vop_flags, true);</a>
<a name="ln1968">  (void)opt_strings_flags(p_fdo, p_fdo_values, &amp;fdo_flags, true);</a>
<a name="ln1969">  (void)opt_strings_flags(p_dy, p_dy_values, &amp;dy_flags, true);</a>
<a name="ln1970">  (void)opt_strings_flags(p_rdb, p_rdb_values, &amp;rdb_flags, true);</a>
<a name="ln1971">  (void)opt_strings_flags(p_tc, p_tc_values, &amp;tc_flags, false);</a>
<a name="ln1972">  (void)opt_strings_flags(p_tpf, p_tpf_values, &amp;tpf_flags, true);</a>
<a name="ln1973">  (void)opt_strings_flags(p_ve, p_ve_values, &amp;ve_flags, true);</a>
<a name="ln1974">  (void)opt_strings_flags(p_wop, p_wop_values, &amp;wop_flags, true);</a>
<a name="ln1975">  (void)opt_strings_flags(p_jop, p_jop_values, &amp;jop_flags, true);</a>
<a name="ln1976">  (void)spell_check_msm();</a>
<a name="ln1977">  (void)spell_check_sps();</a>
<a name="ln1978">  (void)compile_cap_prog(curwin-&gt;w_s);</a>
<a name="ln1979">  (void)did_set_spell_option(true);</a>
<a name="ln1980">  // set cedit_key</a>
<a name="ln1981">  (void)check_cedit();</a>
<a name="ln1982">  briopt_check(curwin);</a>
<a name="ln1983">  // initialize the table for 'breakat'.</a>
<a name="ln1984">  fill_breakat_flags();</a>
<a name="ln1985">}</a>
<a name="ln1986"> </a>
<a name="ln1987">// More side effects of setting options.</a>
<a name="ln1988">static void didset_options2(void)</a>
<a name="ln1989">{</a>
<a name="ln1990">  // Initialize the highlight_attr[] table.</a>
<a name="ln1991">  highlight_changed();</a>
<a name="ln1992"> </a>
<a name="ln1993">  // Parse default for 'clipboard'.</a>
<a name="ln1994">  (void)opt_strings_flags(p_cb, p_cb_values, &amp;cb_flags, true);</a>
<a name="ln1995"> </a>
<a name="ln1996">  // Parse default for 'fillchars'.</a>
<a name="ln1997">  (void)set_chars_option(curwin, &amp;curwin-&gt;w_p_fcs, true);</a>
<a name="ln1998"> </a>
<a name="ln1999">  // Parse default for 'listchars'.</a>
<a name="ln2000">  (void)set_chars_option(curwin, &amp;curwin-&gt;w_p_lcs, true);</a>
<a name="ln2001"> </a>
<a name="ln2002">  // Parse default for 'wildmode'.</a>
<a name="ln2003">  check_opt_wim();</a>
<a name="ln2004">  xfree(curbuf-&gt;b_p_vsts_array);</a>
<a name="ln2005">  tabstop_set(curbuf-&gt;b_p_vsts, &amp;curbuf-&gt;b_p_vsts_array);</a>
<a name="ln2006">  xfree(curbuf-&gt;b_p_vts_array);</a>
<a name="ln2007">  tabstop_set(curbuf-&gt;b_p_vts,  &amp;curbuf-&gt;b_p_vts_array);</a>
<a name="ln2008">}</a>
<a name="ln2009"> </a>
<a name="ln2010">/// Check for string options that are NULL (normally only termcap options).</a>
<a name="ln2011">void check_options(void)</a>
<a name="ln2012">{</a>
<a name="ln2013">  int opt_idx;</a>
<a name="ln2014"> </a>
<a name="ln2015">  for (opt_idx = 0; options[opt_idx].fullname != NULL; opt_idx++) {</a>
<a name="ln2016">    if ((options[opt_idx].flags &amp; P_STRING) &amp;&amp; options[opt_idx].var != NULL) {</a>
<a name="ln2017">      check_string_option((char_u **)get_varp(&amp;(options[opt_idx])));</a>
<a name="ln2018">    }</a>
<a name="ln2019">  }</a>
<a name="ln2020">}</a>
<a name="ln2021"> </a>
<a name="ln2022">/// Check string options in a buffer for NULL value.</a>
<a name="ln2023">void check_buf_options(buf_T *buf)</a>
<a name="ln2024">{</a>
<a name="ln2025">  check_string_option(&amp;buf-&gt;b_p_bh);</a>
<a name="ln2026">  check_string_option(&amp;buf-&gt;b_p_bt);</a>
<a name="ln2027">  check_string_option(&amp;buf-&gt;b_p_fenc);</a>
<a name="ln2028">  check_string_option(&amp;buf-&gt;b_p_ff);</a>
<a name="ln2029">  check_string_option(&amp;buf-&gt;b_p_def);</a>
<a name="ln2030">  check_string_option(&amp;buf-&gt;b_p_inc);</a>
<a name="ln2031">  check_string_option(&amp;buf-&gt;b_p_inex);</a>
<a name="ln2032">  check_string_option(&amp;buf-&gt;b_p_inde);</a>
<a name="ln2033">  check_string_option(&amp;buf-&gt;b_p_indk);</a>
<a name="ln2034">  check_string_option(&amp;buf-&gt;b_p_fp);</a>
<a name="ln2035">  check_string_option(&amp;buf-&gt;b_p_fex);</a>
<a name="ln2036">  check_string_option(&amp;buf-&gt;b_p_kp);</a>
<a name="ln2037">  check_string_option(&amp;buf-&gt;b_p_mps);</a>
<a name="ln2038">  check_string_option(&amp;buf-&gt;b_p_fo);</a>
<a name="ln2039">  check_string_option(&amp;buf-&gt;b_p_flp);</a>
<a name="ln2040">  check_string_option(&amp;buf-&gt;b_p_isk);</a>
<a name="ln2041">  check_string_option(&amp;buf-&gt;b_p_com);</a>
<a name="ln2042">  check_string_option(&amp;buf-&gt;b_p_cms);</a>
<a name="ln2043">  check_string_option(&amp;buf-&gt;b_p_nf);</a>
<a name="ln2044">  check_string_option(&amp;buf-&gt;b_p_qe);</a>
<a name="ln2045">  check_string_option(&amp;buf-&gt;b_p_syn);</a>
<a name="ln2046">  check_string_option(&amp;buf-&gt;b_s.b_syn_isk);</a>
<a name="ln2047">  check_string_option(&amp;buf-&gt;b_s.b_p_spc);</a>
<a name="ln2048">  check_string_option(&amp;buf-&gt;b_s.b_p_spf);</a>
<a name="ln2049">  check_string_option(&amp;buf-&gt;b_s.b_p_spl);</a>
<a name="ln2050">  check_string_option(&amp;buf-&gt;b_s.b_p_spo);</a>
<a name="ln2051">  check_string_option(&amp;buf-&gt;b_p_sua);</a>
<a name="ln2052">  check_string_option(&amp;buf-&gt;b_p_cink);</a>
<a name="ln2053">  check_string_option(&amp;buf-&gt;b_p_cino);</a>
<a name="ln2054">  parse_cino(buf);</a>
<a name="ln2055">  check_string_option(&amp;buf-&gt;b_p_ft);</a>
<a name="ln2056">  check_string_option(&amp;buf-&gt;b_p_cinw);</a>
<a name="ln2057">  check_string_option(&amp;buf-&gt;b_p_cpt);</a>
<a name="ln2058">  check_string_option(&amp;buf-&gt;b_p_cfu);</a>
<a name="ln2059">  check_string_option(&amp;buf-&gt;b_p_ofu);</a>
<a name="ln2060">  check_string_option(&amp;buf-&gt;b_p_keymap);</a>
<a name="ln2061">  check_string_option(&amp;buf-&gt;b_p_gp);</a>
<a name="ln2062">  check_string_option(&amp;buf-&gt;b_p_mp);</a>
<a name="ln2063">  check_string_option(&amp;buf-&gt;b_p_efm);</a>
<a name="ln2064">  check_string_option(&amp;buf-&gt;b_p_ep);</a>
<a name="ln2065">  check_string_option(&amp;buf-&gt;b_p_path);</a>
<a name="ln2066">  check_string_option(&amp;buf-&gt;b_p_tags);</a>
<a name="ln2067">  check_string_option(&amp;buf-&gt;b_p_tfu);</a>
<a name="ln2068">  check_string_option(&amp;buf-&gt;b_p_tc);</a>
<a name="ln2069">  check_string_option(&amp;buf-&gt;b_p_dict);</a>
<a name="ln2070">  check_string_option(&amp;buf-&gt;b_p_tsr);</a>
<a name="ln2071">  check_string_option(&amp;buf-&gt;b_p_lw);</a>
<a name="ln2072">  check_string_option(&amp;buf-&gt;b_p_bkc);</a>
<a name="ln2073">  check_string_option(&amp;buf-&gt;b_p_menc);</a>
<a name="ln2074">  check_string_option(&amp;buf-&gt;b_p_vsts);</a>
<a name="ln2075">  check_string_option(&amp;buf-&gt;b_p_vts);</a>
<a name="ln2076">}</a>
<a name="ln2077"> </a>
<a name="ln2078">/// Free the string allocated for an option.</a>
<a name="ln2079">/// Checks for the string being empty_option. This may happen if we're out of</a>
<a name="ln2080">/// memory, vim_strsave() returned NULL, which was replaced by empty_option by</a>
<a name="ln2081">/// check_options().</a>
<a name="ln2082">/// Does NOT check for P_ALLOCED flag!</a>
<a name="ln2083">void free_string_option(char_u *p)</a>
<a name="ln2084">{</a>
<a name="ln2085">  if (p != empty_option) {</a>
<a name="ln2086">    xfree(p);</a>
<a name="ln2087">  }</a>
<a name="ln2088">}</a>
<a name="ln2089"> </a>
<a name="ln2090">void clear_string_option(char_u **pp)</a>
<a name="ln2091">{</a>
<a name="ln2092">  if (*pp != empty_option) {</a>
<a name="ln2093">    xfree(*pp);</a>
<a name="ln2094">  }</a>
<a name="ln2095">  *pp = empty_option;</a>
<a name="ln2096">}</a>
<a name="ln2097"> </a>
<a name="ln2098">static void check_string_option(char_u **pp)</a>
<a name="ln2099">{</a>
<a name="ln2100">  if (*pp == NULL) {</a>
<a name="ln2101">    *pp = empty_option;</a>
<a name="ln2102">  }</a>
<a name="ln2103">}</a>
<a name="ln2104"> </a>
<a name="ln2105">/// Return true when option &quot;opt&quot; was set from a modeline or in secure mode.</a>
<a name="ln2106">/// Return false when it wasn't.</a>
<a name="ln2107">/// Return -1 for an unknown option.</a>
<a name="ln2108">int was_set_insecurely(win_T *const wp, char_u *opt, int opt_flags)</a>
<a name="ln2109">{</a>
<a name="ln2110">  int idx = findoption((const char *)opt);</a>
<a name="ln2111"> </a>
<a name="ln2112">  if (idx &gt;= 0) {</a>
<a name="ln2113">    uint32_t *flagp = insecure_flag(wp, idx, opt_flags);</a>
<a name="ln2114">    return (*flagp &amp; P_INSECURE) != 0;</a>
<a name="ln2115">  }</a>
<a name="ln2116">  internal_error(&quot;was_set_insecurely()&quot;);</a>
<a name="ln2117">  return -1;</a>
<a name="ln2118">}</a>
<a name="ln2119"> </a>
<a name="ln2120">/// Get a pointer to the flags used for the P_INSECURE flag of option</a>
<a name="ln2121">/// &quot;opt_idx&quot;.  For some local options a local flags field is used.</a>
<a name="ln2122">/// NOTE: Caller must make sure that &quot;wp&quot; is set to the window from which</a>
<a name="ln2123">/// the option is used.</a>
<a name="ln2124">static uint32_t *insecure_flag(win_T *const wp, int opt_idx, int opt_flags)</a>
<a name="ln2125">{</a>
<a name="ln2126">  if (opt_flags &amp; OPT_LOCAL) {</a>
<a name="ln2127">    assert(wp != NULL);</a>
<a name="ln2128">    switch ((int)options[opt_idx].indir) {</a>
<a name="ln2129">    case PV_STL:        return &amp;wp-&gt;w_p_stl_flags;</a>
<a name="ln2130">    case PV_FDE:        return &amp;wp-&gt;w_p_fde_flags;</a>
<a name="ln2131">    case PV_FDT:        return &amp;wp-&gt;w_p_fdt_flags;</a>
<a name="ln2132">    case PV_INDE:       return &amp;wp-&gt;w_buffer-&gt;b_p_inde_flags;</a>
<a name="ln2133">    case PV_FEX:        return &amp;wp-&gt;w_buffer-&gt;b_p_fex_flags;</a>
<a name="ln2134">    case PV_INEX:       return &amp;wp-&gt;w_buffer-&gt;b_p_inex_flags;</a>
<a name="ln2135">    }</a>
<a name="ln2136">  }</a>
<a name="ln2137"> </a>
<a name="ln2138">  // Nothing special, return global flags field.</a>
<a name="ln2139">  return &amp;options[opt_idx].flags;</a>
<a name="ln2140">}</a>
<a name="ln2141"> </a>
<a name="ln2142"> </a>
<a name="ln2143">/// Redraw the window title and/or tab page text later.</a>
<a name="ln2144">static void redraw_titles(void)</a>
<a name="ln2145">{</a>
<a name="ln2146">  need_maketitle = true;</a>
<a name="ln2147">  redraw_tabline = true;</a>
<a name="ln2148">}</a>
<a name="ln2149"> </a>
<a name="ln2150">static int shada_idx = -1;</a>
<a name="ln2151"> </a>
<a name="ln2152">// Set a string option to a new value (without checking the effect).</a>
<a name="ln2153">// The string is copied into allocated memory.</a>
<a name="ln2154">// if (&quot;opt_idx&quot; == -1) &quot;name&quot; is used, otherwise &quot;opt_idx&quot; is used.</a>
<a name="ln2155">// When &quot;set_sid&quot; is zero set the scriptID to current_sctx.sc_sid.  When</a>
<a name="ln2156">// &quot;set_sid&quot; is SID_NONE don't set the scriptID.  Otherwise set the scriptID to</a>
<a name="ln2157">// &quot;set_sid&quot;.</a>
<a name="ln2158">void</a>
<a name="ln2159">set_string_option_direct(</a>
<a name="ln2160">    const char *name,</a>
<a name="ln2161">    int opt_idx,</a>
<a name="ln2162">    const char_u *val,</a>
<a name="ln2163">    int opt_flags,                  // OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln2164">    int set_sid</a>
<a name="ln2165">)</a>
<a name="ln2166">{</a>
<a name="ln2167">  char_u      *s;</a>
<a name="ln2168">  char_u      **varp;</a>
<a name="ln2169">  int both = (opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0;</a>
<a name="ln2170">  int idx = opt_idx;</a>
<a name="ln2171"> </a>
<a name="ln2172">  if (idx == -1) {  // Use name.</a>
<a name="ln2173">    idx = findoption(name);</a>
<a name="ln2174">    if (idx &lt; 0) {  // Not found (should not happen).</a>
<a name="ln2175">      internal_error(&quot;set_string_option_direct()&quot;);</a>
<a name="ln2176">      IEMSG2(_(&quot;For option %s&quot;), name);</a>
<a name="ln2177">      return;</a>
<a name="ln2178">    }</a>
<a name="ln2179">  }</a>
<a name="ln2180"> </a>
<a name="ln2181">  if (options[idx].var == NULL) {       // can't set hidden option</a>
<a name="ln2182">    return;</a>
<a name="ln2183">  }</a>
<a name="ln2184"> </a>
<a name="ln2185">  assert((void *) options[idx].var != (void *) &amp;p_shada);</a>
<a name="ln2186"> </a>
<a name="ln2187">  s = vim_strsave(val);</a>
<a name="ln2188">  {</a>
<a name="ln2189">    varp = (char_u **)get_varp_scope(&amp;(options[idx]),</a>
<a name="ln2190">                                     both ? OPT_LOCAL : opt_flags);</a>
<a name="ln2191">    if ((opt_flags &amp; OPT_FREE) &amp;&amp; (options[idx].flags &amp; P_ALLOCED)) {</a>
<a name="ln2192">      free_string_option(*varp);</a>
<a name="ln2193">    }</a>
<a name="ln2194">    *varp = s;</a>
<a name="ln2195"> </a>
<a name="ln2196">    // For buffer/window local option may also set the global value.</a>
<a name="ln2197">    if (both) {</a>
<a name="ln2198">      set_string_option_global(idx, varp);</a>
<a name="ln2199">    }</a>
<a name="ln2200"> </a>
<a name="ln2201">    options[idx].flags |= P_ALLOCED;</a>
<a name="ln2202"> </a>
<a name="ln2203">    /* When setting both values of a global option with a local value,</a>
<a name="ln2204">    * make the local value empty, so that the global value is used. */</a>
<a name="ln2205">    if (((int)options[idx].indir &amp; PV_BOTH) &amp;&amp; both) {</a>
<a name="ln2206">      free_string_option(*varp);</a>
<a name="ln2207">      *varp = empty_option;</a>
<a name="ln2208">    }</a>
<a name="ln2209">    if (set_sid != SID_NONE) {</a>
<a name="ln2210">      sctx_T script_ctx;</a>
<a name="ln2211"> </a>
<a name="ln2212">      if (set_sid == 0) {</a>
<a name="ln2213">        script_ctx = current_sctx;</a>
<a name="ln2214">      } else {</a>
<a name="ln2215">        script_ctx.sc_sid = set_sid;</a>
<a name="ln2216">        script_ctx.sc_seq = 0;</a>
<a name="ln2217">        script_ctx.sc_lnum = 0;</a>
<a name="ln2218">      }</a>
<a name="ln2219">      set_option_sctx_idx(idx, opt_flags, script_ctx);</a>
<a name="ln2220">    }</a>
<a name="ln2221">  }</a>
<a name="ln2222">}</a>
<a name="ln2223"> </a>
<a name="ln2224">/// Set global value for string option when it's a local option.</a>
<a name="ln2225">static void</a>
<a name="ln2226">set_string_option_global(</a>
<a name="ln2227">    int opt_idx,                    // option index</a>
<a name="ln2228">    char_u **varp             // pointer to option variable</a>
<a name="ln2229">)</a>
<a name="ln2230">{</a>
<a name="ln2231">  char_u      **p, *s;</a>
<a name="ln2232"> </a>
<a name="ln2233">  // the global value is always allocated</a>
<a name="ln2234">  if (options[opt_idx].var == VAR_WIN) {</a>
<a name="ln2235">    p = (char_u **)GLOBAL_WO(varp);</a>
<a name="ln2236">  } else {</a>
<a name="ln2237">    p = (char_u **)options[opt_idx].var;</a>
<a name="ln2238">  }</a>
<a name="ln2239">  if (options[opt_idx].indir != PV_NONE &amp;&amp; p != varp) {</a>
<a name="ln2240">    s = vim_strsave(*varp);</a>
<a name="ln2241">    free_string_option(*p);</a>
<a name="ln2242">    *p = s;</a>
<a name="ln2243">  }</a>
<a name="ln2244">}</a>
<a name="ln2245"> </a>
<a name="ln2246">/// Set a string option to a new value, handling the effects</a>
<a name="ln2247">///</a>
<a name="ln2248">/// @param[in]  opt_idx  Option to set.</a>
<a name="ln2249">/// @param[in]  value  New value.</a>
<a name="ln2250">/// @param[in]  opt_flags  Option flags: expected to contain #OPT_LOCAL and/or</a>
<a name="ln2251">///                        #OPT_GLOBAL.</a>
<a name="ln2252">///</a>
<a name="ln2253">/// @return NULL on success, error message on error.</a>
<a name="ln2254">static char *set_string_option(const int opt_idx, const char *const value,</a>
<a name="ln2255">                               const int opt_flags)</a>
<a name="ln2256">  FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2257">{</a>
<a name="ln2258">  if (options[opt_idx].var == NULL) {  // don't set hidden option</a>
<a name="ln2259">    return NULL;</a>
<a name="ln2260">  }</a>
<a name="ln2261"> </a>
<a name="ln2262">  char *const s = xstrdup(value);</a>
<a name="ln2263">  char **const varp = (char **)get_varp_scope(</a>
<a name="ln2264">      &amp;(options[opt_idx]),</a>
<a name="ln2265">      ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0</a>
<a name="ln2266">       ? (((int)options[opt_idx].indir &amp; PV_BOTH)</a>
<a name="ln2267">          ? OPT_GLOBAL : OPT_LOCAL)</a>
<a name="ln2268">       : opt_flags));</a>
<a name="ln2269">  char *const oldval = *varp;</a>
<a name="ln2270">  *varp = s;</a>
<a name="ln2271"> </a>
<a name="ln2272">  char *const saved_oldval = xstrdup(oldval);</a>
<a name="ln2273">  char *const saved_newval = xstrdup(s);</a>
<a name="ln2274"> </a>
<a name="ln2275">  int value_checked = false;</a>
<a name="ln2276">  char *const r = (char *)did_set_string_option(</a>
<a name="ln2277">      opt_idx, (char_u **)varp, (int)true, (char_u *)oldval,</a>
<a name="ln2278">      NULL, 0, opt_flags, &amp;value_checked);</a>
<a name="ln2279">  if (r == NULL) {</a>
<a name="ln2280">    did_set_option(opt_idx, opt_flags, true, value_checked);</a>
<a name="ln2281">  }</a>
<a name="ln2282"> </a>
<a name="ln2283">  // call autocommand after handling side effects</a>
<a name="ln2284">  if (r == NULL) {</a>
<a name="ln2285">    if (!starting) {</a>
<a name="ln2286">      trigger_optionsset_string(opt_idx, opt_flags, saved_oldval, saved_newval);</a>
<a name="ln2287">    }</a>
<a name="ln2288">    if (options[opt_idx].flags &amp; P_UI_OPTION) {</a>
<a name="ln2289">      ui_call_option_set(cstr_as_string(options[opt_idx].fullname),</a>
<a name="ln2290">                         STRING_OBJ(cstr_as_string(saved_newval)));</a>
<a name="ln2291">    }</a>
<a name="ln2292">  }</a>
<a name="ln2293">  xfree(saved_oldval);</a>
<a name="ln2294">  xfree(saved_newval);</a>
<a name="ln2295"> </a>
<a name="ln2296">  return r;</a>
<a name="ln2297">}</a>
<a name="ln2298"> </a>
<a name="ln2299">/// Return true if &quot;val&quot; is a valid name: only consists of alphanumeric ASCII</a>
<a name="ln2300">/// characters or characters in &quot;allowed&quot;.</a>
<a name="ln2301">static bool valid_name(const char_u *val, const char *allowed)</a>
<a name="ln2302">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2303">{</a>
<a name="ln2304">  for (const char_u *s = val; *s != NUL; s++) {</a>
<a name="ln2305">    if (!ASCII_ISALNUM(*s)</a>
<a name="ln2306">        &amp;&amp; vim_strchr((const char_u *)allowed, *s) == NULL) {</a>
<a name="ln2307">      return false;</a>
<a name="ln2308">    }</a>
<a name="ln2309">  }</a>
<a name="ln2310">  return true;</a>
<a name="ln2311">}</a>
<a name="ln2312"> </a>
<a name="ln2313">/// Return true if &quot;val&quot; is a valid 'filetype' name.</a>
<a name="ln2314">/// Also used for 'syntax' and 'keymap'.</a>
<a name="ln2315">static bool valid_filetype(const char_u *val)</a>
<a name="ln2316">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2317">{</a>
<a name="ln2318">  return valid_name(val, &quot;.-_&quot;);</a>
<a name="ln2319">}</a>
<a name="ln2320"> </a>
<a name="ln2321">/// Return true if &quot;val&quot; is a valid 'spelllang' value.</a>
<a name="ln2322">bool valid_spelllang(const char_u *val)</a>
<a name="ln2323">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2324">{</a>
<a name="ln2325">  return valid_name(val, &quot;.-_,@&quot;);</a>
<a name="ln2326">}</a>
<a name="ln2327"> </a>
<a name="ln2328">/// Return true if &quot;val&quot; is a valid 'spellfile' value.</a>
<a name="ln2329">static bool valid_spellfile(const char_u *val)</a>
<a name="ln2330">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2331">{</a>
<a name="ln2332">  for (const char_u *s = val; *s != NUL; s++) {</a>
<a name="ln2333">    if (!vim_isfilec(*s) &amp;&amp; *s != ',' &amp;&amp; *s != ' ') {</a>
<a name="ln2334">      return false;</a>
<a name="ln2335">    }</a>
<a name="ln2336">  }</a>
<a name="ln2337">  return true;</a>
<a name="ln2338">}</a>
<a name="ln2339"> </a>
<a name="ln2340">/// Handle string options that need some action to perform when changed.</a>
<a name="ln2341">/// Returns NULL for success, or an error message for an error.</a>
<a name="ln2342">static char_u *</a>
<a name="ln2343">did_set_string_option(</a>
<a name="ln2344">    int opt_idx,                       // index in options[] table</a>
<a name="ln2345">    char_u **varp,                     // pointer to the option variable</a>
<a name="ln2346">    bool new_value_alloced,            // new value was allocated</a>
<a name="ln2347">    char_u *oldval,                    // previous value of the option</a>
<a name="ln2348">    char_u *errbuf,                    // buffer for errors, or NULL</a>
<a name="ln2349">    size_t errbuflen,                  // length of errors buffer</a>
<a name="ln2350">    int opt_flags,                     // OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln2351">    int *value_checked                 // value was checked to be safe, no</a>
<a name="ln2352">                                       // need to set P_INSECURE</a>
<a name="ln2353">)</a>
<a name="ln2354">{</a>
<a name="ln2355">  char_u      *errmsg = NULL;</a>
<a name="ln2356">  char_u      *s, *p;</a>
<a name="ln2357">  int did_chartab = false;</a>
<a name="ln2358">  char_u      **gvarp;</a>
<a name="ln2359">  bool free_oldval = (options[opt_idx].flags &amp; P_ALLOCED);</a>
<a name="ln2360">  bool value_changed = false;</a>
<a name="ln2361"> </a>
<a name="ln2362">  /* Get the global option to compare with, otherwise we would have to check</a>
<a name="ln2363">   * two values for all local options. */</a>
<a name="ln2364">  gvarp = (char_u **)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL);</a>
<a name="ln2365"> </a>
<a name="ln2366">  // Disallow changing some options from secure mode</a>
<a name="ln2367">  if ((secure || sandbox != 0)</a>
<a name="ln2368">      &amp;&amp; (options[opt_idx].flags &amp; P_SECURE)) {</a>
<a name="ln2369">    errmsg = e_secure;</a>
<a name="ln2370">  } else if (((options[opt_idx].flags &amp; P_NFNAME)</a>
<a name="ln2371">              &amp;&amp; vim_strpbrk(*varp, (char_u *)(secure ? &quot;/\\*?[|;&amp;&lt;&gt;\r\n&quot;</a>
<a name="ln2372">                                               : &quot;/\\*?[&lt;&gt;\r\n&quot;)) != NULL)</a>
<a name="ln2373">             || ((options[opt_idx].flags &amp; P_NDNAME)</a>
<a name="ln2374">                 &amp;&amp; vim_strpbrk(*varp, (char_u *)&quot;*?[|;&amp;&lt;&gt;\r\n&quot;) != NULL)) {</a>
<a name="ln2375">    // Check for a &quot;normal&quot; directory or file name in some options.  Disallow a</a>
<a name="ln2376">    // path separator (slash and/or backslash), wildcards and characters that</a>
<a name="ln2377">    // are often illegal in a file name. Be more permissive if &quot;secure&quot; is off.</a>
<a name="ln2378">    errmsg = e_invarg;</a>
<a name="ln2379">  } else if (gvarp == &amp;p_bkc) {  // 'backupcopy'</a>
<a name="ln2380">    char_u       *bkc   = p_bkc;</a>
<a name="ln2381">    unsigned int *flags = &amp;bkc_flags;</a>
<a name="ln2382"> </a>
<a name="ln2383">    if (opt_flags &amp; OPT_LOCAL) {</a>
<a name="ln2384">      bkc   = curbuf-&gt;b_p_bkc;</a>
<a name="ln2385">      flags = &amp;curbuf-&gt;b_bkc_flags;</a>
<a name="ln2386">    }</a>
<a name="ln2387"> </a>
<a name="ln2388">    if ((opt_flags &amp; OPT_LOCAL) &amp;&amp; *bkc == NUL) {</a>
<a name="ln2389">      // make the local value empty: use the global value</a>
<a name="ln2390">      *flags = 0;</a>
<a name="ln2391">    } else {</a>
<a name="ln2392">      if (opt_strings_flags(bkc, p_bkc_values, flags, true) != OK) {</a>
<a name="ln2393">        errmsg = e_invarg;</a>
<a name="ln2394">      }</a>
<a name="ln2395"> </a>
<a name="ln2396">      if (((*flags &amp; BKC_AUTO) != 0)</a>
<a name="ln2397">          + ((*flags &amp; BKC_YES) != 0)</a>
<a name="ln2398">          + ((*flags &amp; BKC_NO) != 0) != 1) {</a>
<a name="ln2399">        // Must have exactly one of &quot;auto&quot;, &quot;yes&quot;  and &quot;no&quot;.</a>
<a name="ln2400">        (void)opt_strings_flags(oldval, p_bkc_values, flags, true);</a>
<a name="ln2401">        errmsg = e_invarg;</a>
<a name="ln2402">      }</a>
<a name="ln2403">    }</a>
<a name="ln2404">  } else if (varp == &amp;p_bex || varp == &amp;p_pm) {  // 'backupext' and 'patchmode'</a>
<a name="ln2405">    if (STRCMP(*p_bex == '.' ? p_bex + 1 : p_bex,</a>
<a name="ln2406">               *p_pm == '.' ? p_pm + 1 : p_pm) == 0) {</a>
<a name="ln2407">      errmsg = (char_u *)N_(&quot;E589: 'backupext' and 'patchmode' are equal&quot;);</a>
<a name="ln2408">    }</a>
<a name="ln2409">  } else if (varp == &amp;curwin-&gt;w_p_briopt) {  // 'breakindentopt'</a>
<a name="ln2410">    if (briopt_check(curwin) == FAIL) {</a>
<a name="ln2411">      errmsg = e_invarg;</a>
<a name="ln2412">    }</a>
<a name="ln2413">  } else if (varp == &amp;p_isi</a>
<a name="ln2414">             || varp == &amp;(curbuf-&gt;b_p_isk)</a>
<a name="ln2415">             || varp == &amp;p_isp</a>
<a name="ln2416">             || varp == &amp;p_isf) {</a>
<a name="ln2417">    // 'isident', 'iskeyword', 'isprint or 'isfname' option: refill g_chartab[]</a>
<a name="ln2418">    // If the new option is invalid, use old value.  'lisp' option: refill</a>
<a name="ln2419">    // g_chartab[] for '-' char</a>
<a name="ln2420">    if (init_chartab() == FAIL) {</a>
<a name="ln2421">      did_chartab = true;           // need to restore it below</a>
<a name="ln2422">      errmsg = e_invarg;            // error in value</a>
<a name="ln2423">    }</a>
<a name="ln2424">  } else if (varp == &amp;p_hf) {  // 'helpfile'</a>
<a name="ln2425">    // May compute new values for $VIM and $VIMRUNTIME</a>
<a name="ln2426">    if (didset_vim) {</a>
<a name="ln2427">      os_setenv(&quot;VIM&quot;, &quot;&quot;, 1);</a>
<a name="ln2428">      didset_vim = false;</a>
<a name="ln2429">    }</a>
<a name="ln2430">    if (didset_vimruntime) {</a>
<a name="ln2431">      os_setenv(&quot;VIMRUNTIME&quot;, &quot;&quot;, 1);</a>
<a name="ln2432">      didset_vimruntime = false;</a>
<a name="ln2433">    }</a>
<a name="ln2434">  } else if (varp == &amp;curwin-&gt;w_p_cc) {  // 'colorcolumn'</a>
<a name="ln2435">    errmsg = check_colorcolumn(curwin);</a>
<a name="ln2436">  } else if (varp == &amp;p_hlg) {  // 'helplang'</a>
<a name="ln2437">    // Check for &quot;&quot;, &quot;ab&quot;, &quot;ab,cd&quot;, etc.</a>
<a name="ln2438">    for (s = p_hlg; *s != NUL; s += 3) {</a>
<a name="ln2439">      if (s[1] == NUL || ((s[2] != ',' || s[3] == NUL) &amp;&amp; s[2] != NUL)) {</a>
<a name="ln2440">        errmsg = e_invarg;</a>
<a name="ln2441">        break;</a>
<a name="ln2442">      }</a>
<a name="ln2443">      if (s[2] == NUL) {</a>
<a name="ln2444">        break;</a>
<a name="ln2445">      }</a>
<a name="ln2446">    }</a>
<a name="ln2447">  } else if (varp == &amp;p_hl) {</a>
<a name="ln2448">    // 'highlight'</a>
<a name="ln2449">    if (strcmp((char *)(*varp), HIGHLIGHT_INIT) != 0) {</a>
<a name="ln2450">      errmsg = e_unsupportedoption;</a>
<a name="ln2451">    }</a>
<a name="ln2452">  } else if (varp == &amp;p_jop) {  // 'jumpoptions'</a>
<a name="ln2453">    if (opt_strings_flags(p_jop, p_jop_values, &amp;jop_flags, true) != OK) {</a>
<a name="ln2454">      errmsg = e_invarg;</a>
<a name="ln2455">    }</a>
<a name="ln2456">  } else if (gvarp == &amp;p_nf) {  // 'nrformats'</a>
<a name="ln2457">    if (check_opt_strings(*varp, p_nf_values, true) != OK) {</a>
<a name="ln2458">      errmsg = e_invarg;</a>
<a name="ln2459">    }</a>
<a name="ln2460">  } else if (varp == &amp;p_ssop) {  // 'sessionoptions'</a>
<a name="ln2461">    if (opt_strings_flags(p_ssop, p_ssop_values, &amp;ssop_flags, true) != OK) {</a>
<a name="ln2462">      errmsg = e_invarg;</a>
<a name="ln2463">    }</a>
<a name="ln2464">    if ((ssop_flags &amp; SSOP_CURDIR) &amp;&amp; (ssop_flags &amp; SSOP_SESDIR)) {</a>
<a name="ln2465">      // Don't allow both &quot;sesdir&quot; and &quot;curdir&quot;.</a>
<a name="ln2466">      (void)opt_strings_flags(oldval, p_ssop_values, &amp;ssop_flags, true);</a>
<a name="ln2467">      errmsg = e_invarg;</a>
<a name="ln2468">    }</a>
<a name="ln2469">  } else if (varp == &amp;p_vop) {  // 'viewoptions'</a>
<a name="ln2470">    if (opt_strings_flags(p_vop, p_ssop_values, &amp;vop_flags, true) != OK) {</a>
<a name="ln2471">      errmsg = e_invarg;</a>
<a name="ln2472">    }</a>
<a name="ln2473">  } else if (varp == &amp;p_rdb) {  // 'redrawdebug'</a>
<a name="ln2474">    if (opt_strings_flags(p_rdb, p_rdb_values, &amp;rdb_flags, true) != OK) {</a>
<a name="ln2475">      errmsg = e_invarg;</a>
<a name="ln2476">    }</a>
<a name="ln2477">  } else if (varp == &amp;p_sbo) {  // 'scrollopt'</a>
<a name="ln2478">    if (check_opt_strings(p_sbo, p_scbopt_values, true) != OK) {</a>
<a name="ln2479">      errmsg = e_invarg;</a>
<a name="ln2480">    }</a>
<a name="ln2481">  } else if (varp == &amp;p_ambw || (int *)varp == &amp;p_emoji) {</a>
<a name="ln2482">    // 'ambiwidth'</a>
<a name="ln2483">    if (check_opt_strings(p_ambw, p_ambw_values, false) != OK) {</a>
<a name="ln2484">      errmsg = e_invarg;</a>
<a name="ln2485">    } else {</a>
<a name="ln2486">      FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln2487">        if (set_chars_option(wp, &amp;wp-&gt;w_p_lcs, true) != NULL) {</a>
<a name="ln2488">          errmsg = (char_u *)_(&quot;E834: Conflicts with value of 'listchars'&quot;);</a>
<a name="ln2489">          goto ambw_end;</a>
<a name="ln2490">        }</a>
<a name="ln2491">        if (set_chars_option(wp, &amp;wp-&gt;w_p_fcs, true) != NULL) {</a>
<a name="ln2492">          errmsg = (char_u *)_(&quot;E835: Conflicts with value of 'fillchars'&quot;);</a>
<a name="ln2493">          goto ambw_end;</a>
<a name="ln2494">        }</a>
<a name="ln2495">      }</a>
<a name="ln2496">ambw_end:</a>
<a name="ln2497">      {}  // clint prefers {} over ; as an empty statement</a>
<a name="ln2498">    }</a>
<a name="ln2499">  } else if (varp == &amp;p_bg) {  // 'background'</a>
<a name="ln2500">    if (check_opt_strings(p_bg, p_bg_values, false) == OK) {</a>
<a name="ln2501">      int dark = (*p_bg == 'd');</a>
<a name="ln2502"> </a>
<a name="ln2503">      init_highlight(false, false);</a>
<a name="ln2504"> </a>
<a name="ln2505">      if (dark != (*p_bg == 'd') &amp;&amp; get_var_value(&quot;g:colors_name&quot;) != NULL) {</a>
<a name="ln2506">        // The color scheme must have set 'background' back to another</a>
<a name="ln2507">        // value, that's not what we want here.  Disable the color</a>
<a name="ln2508">        // scheme and set the colors again.</a>
<a name="ln2509">        do_unlet(S_LEN(&quot;g:colors_name&quot;), true);</a>
<a name="ln2510">        free_string_option(p_bg);</a>
<a name="ln2511">        p_bg = vim_strsave((char_u *)(dark ? &quot;dark&quot; : &quot;light&quot;));</a>
<a name="ln2512">        check_string_option(&amp;p_bg);</a>
<a name="ln2513">        init_highlight(false, false);</a>
<a name="ln2514">      }</a>
<a name="ln2515">    } else</a>
<a name="ln2516">      errmsg = e_invarg;</a>
<a name="ln2517">  } else if (varp == &amp;p_wim) {  // 'wildmode'</a>
<a name="ln2518">    if (check_opt_wim() == FAIL) {</a>
<a name="ln2519">      errmsg = e_invarg;</a>
<a name="ln2520">    }</a>
<a name="ln2521">  // 'wildoptions'</a>
<a name="ln2522">  } else if (varp == &amp;p_wop) {</a>
<a name="ln2523">    if (opt_strings_flags(p_wop, p_wop_values, &amp;wop_flags, true) != OK) {</a>
<a name="ln2524">      errmsg = e_invarg;</a>
<a name="ln2525">    }</a>
<a name="ln2526">  } else if (varp == &amp;p_wak) {  // 'winaltkeys'</a>
<a name="ln2527">    if (*p_wak == NUL</a>
<a name="ln2528">        || check_opt_strings(p_wak, p_wak_values, false) != OK) {</a>
<a name="ln2529">      errmsg = e_invarg;</a>
<a name="ln2530">    }</a>
<a name="ln2531">  } else if (varp == &amp;p_ei) {  // 'eventignore'</a>
<a name="ln2532">    if (check_ei() == FAIL) {</a>
<a name="ln2533">      errmsg = e_invarg;</a>
<a name="ln2534">    }</a>
<a name="ln2535">  // 'encoding', 'fileencoding' and 'makeencoding'</a>
<a name="ln2536">  } else if (varp == &amp;p_enc || gvarp == &amp;p_fenc || gvarp == &amp;p_menc) {</a>
<a name="ln2537">    if (gvarp == &amp;p_fenc) {</a>
<a name="ln2538">      if (!MODIFIABLE(curbuf) &amp;&amp; opt_flags != OPT_GLOBAL) {</a>
<a name="ln2539">        errmsg = e_modifiable;</a>
<a name="ln2540">      } else if (vim_strchr(*varp, ',') != NULL) {</a>
<a name="ln2541">        // No comma allowed in 'fileencoding'; catches confusing it</a>
<a name="ln2542">        // with 'fileencodings'.</a>
<a name="ln2543">        errmsg = e_invarg;</a>
<a name="ln2544">      } else {</a>
<a name="ln2545">        // May show a &quot;+&quot; in the title now.</a>
<a name="ln2546">        redraw_titles();</a>
<a name="ln2547">        // Add 'fileencoding' to the swap file.</a>
<a name="ln2548">        ml_setflags(curbuf);</a>
<a name="ln2549">      }</a>
<a name="ln2550">    }</a>
<a name="ln2551"> </a>
<a name="ln2552">    if (errmsg == NULL) {</a>
<a name="ln2553">      // canonize the value, so that STRCMP() can be used on it</a>
<a name="ln2554">      p = enc_canonize(*varp);</a>
<a name="ln2555">      xfree(*varp);</a>
<a name="ln2556">      *varp = p;</a>
<a name="ln2557">      if (varp == &amp;p_enc) {</a>
<a name="ln2558">        // only encoding=utf-8 allowed</a>
<a name="ln2559">        if (STRCMP(p_enc, &quot;utf-8&quot;) != 0) {</a>
<a name="ln2560">          errmsg = e_unsupportedoption;</a>
<a name="ln2561">        }</a>
<a name="ln2562">      }</a>
<a name="ln2563">    }</a>
<a name="ln2564">  } else if (varp == &amp;p_penc) {</a>
<a name="ln2565">    // Canonize printencoding if VIM standard one</a>
<a name="ln2566">    p = enc_canonize(p_penc);</a>
<a name="ln2567">    xfree(p_penc);</a>
<a name="ln2568">    p_penc = p;</a>
<a name="ln2569">  } else if (varp == &amp;curbuf-&gt;b_p_keymap) {</a>
<a name="ln2570">    if (!valid_filetype(*varp)) {</a>
<a name="ln2571">      errmsg = e_invarg;</a>
<a name="ln2572">    } else {</a>
<a name="ln2573">      int secure_save = secure;</a>
<a name="ln2574"> </a>
<a name="ln2575">      // Reset the secure flag, since the value of 'keymap' has</a>
<a name="ln2576">      // been checked to be safe.</a>
<a name="ln2577">      secure = 0;</a>
<a name="ln2578"> </a>
<a name="ln2579">      // load or unload key mapping tables</a>
<a name="ln2580">      errmsg = keymap_init();</a>
<a name="ln2581"> </a>
<a name="ln2582">      secure = secure_save;</a>
<a name="ln2583"> </a>
<a name="ln2584">      // Since we check the value, there is no need to set P_INSECURE,</a>
<a name="ln2585">      // even when the value comes from a modeline.</a>
<a name="ln2586">      *value_checked = true;</a>
<a name="ln2587">    }</a>
<a name="ln2588"> </a>
<a name="ln2589">    if (errmsg == NULL) {</a>
<a name="ln2590">      if (*curbuf-&gt;b_p_keymap != NUL) {</a>
<a name="ln2591">        // Installed a new keymap, switch on using it.</a>
<a name="ln2592">        curbuf-&gt;b_p_iminsert = B_IMODE_LMAP;</a>
<a name="ln2593">        if (curbuf-&gt;b_p_imsearch != B_IMODE_USE_INSERT) {</a>
<a name="ln2594">          curbuf-&gt;b_p_imsearch = B_IMODE_LMAP;</a>
<a name="ln2595">        }</a>
<a name="ln2596">      } else {</a>
<a name="ln2597">        // Cleared the keymap, may reset 'iminsert' and 'imsearch'.</a>
<a name="ln2598">        if (curbuf-&gt;b_p_iminsert == B_IMODE_LMAP) {</a>
<a name="ln2599">          curbuf-&gt;b_p_iminsert = B_IMODE_NONE;</a>
<a name="ln2600">        }</a>
<a name="ln2601">        if (curbuf-&gt;b_p_imsearch == B_IMODE_LMAP) {</a>
<a name="ln2602">          curbuf-&gt;b_p_imsearch = B_IMODE_USE_INSERT;</a>
<a name="ln2603">        }</a>
<a name="ln2604">      }</a>
<a name="ln2605">      if ((opt_flags &amp; OPT_LOCAL) == 0) {</a>
<a name="ln2606">        set_iminsert_global();</a>
<a name="ln2607">        set_imsearch_global();</a>
<a name="ln2608">      }</a>
<a name="ln2609">      status_redraw_curbuf();</a>
<a name="ln2610">    }</a>
<a name="ln2611">  } else if (gvarp == &amp;p_ff) {  // 'fileformat'</a>
<a name="ln2612">    if (!MODIFIABLE(curbuf) &amp;&amp; !(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln2613">      errmsg = e_modifiable;</a>
<a name="ln2614">    } else if (check_opt_strings(*varp, p_ff_values, false) != OK) {</a>
<a name="ln2615">      errmsg = e_invarg;</a>
<a name="ln2616">    } else {</a>
<a name="ln2617">      redraw_titles();</a>
<a name="ln2618">      // update flag in swap file</a>
<a name="ln2619">      ml_setflags(curbuf);</a>
<a name="ln2620">      /* Redraw needed when switching to/from &quot;mac&quot;: a CR in the text</a>
<a name="ln2621">       * will be displayed differently. */</a>
<a name="ln2622">      if (get_fileformat(curbuf) == EOL_MAC || *oldval == 'm') {</a>
<a name="ln2623">        redraw_curbuf_later(NOT_VALID);</a>
<a name="ln2624">      }</a>
<a name="ln2625">    }</a>
<a name="ln2626">  } else if (varp == &amp;p_ffs) {  // 'fileformats'</a>
<a name="ln2627">    if (check_opt_strings(p_ffs, p_ff_values, true) != OK) {</a>
<a name="ln2628">      errmsg = e_invarg;</a>
<a name="ln2629">    }</a>
<a name="ln2630">  } else if (gvarp == &amp;p_mps) {  // 'matchpairs'</a>
<a name="ln2631">    for (p = *varp; *p != NUL; p++) {</a>
<a name="ln2632">      int x2 = -1;</a>
<a name="ln2633">      int x3 = -1;</a>
<a name="ln2634"> </a>
<a name="ln2635">      if (*p != NUL) {</a>
<a name="ln2636">        p += utfc_ptr2len(p);</a>
<a name="ln2637">      }</a>
<a name="ln2638">      if (*p != NUL) {</a>
<a name="ln2639">        x2 = *p++;</a>
<a name="ln2640">      }</a>
<a name="ln2641">      if (*p != NUL) {</a>
<a name="ln2642">        x3 = utf_ptr2char(p);</a>
<a name="ln2643">        p += utfc_ptr2len(p);</a>
<a name="ln2644">      }</a>
<a name="ln2645">      if (x2 != ':' || x3 == -1 || (*p != NUL &amp;&amp; *p != ',')) {</a>
<a name="ln2646">        errmsg = e_invarg;</a>
<a name="ln2647">        break;</a>
<a name="ln2648">      }</a>
<a name="ln2649">      if (*p == NUL) {</a>
<a name="ln2650">        break;</a>
<a name="ln2651">      }</a>
<a name="ln2652">    }</a>
<a name="ln2653">  } else if (gvarp == &amp;p_com) {  // 'comments'</a>
<a name="ln2654">    for (s = *varp; *s; ) {</a>
<a name="ln2655">      while (*s &amp;&amp; *s != ':') {</a>
<a name="ln2656">        if (vim_strchr((char_u *)COM_ALL, *s) == NULL</a>
<a name="ln2657">            &amp;&amp; !ascii_isdigit(*s) &amp;&amp; *s != '-') {</a>
<a name="ln2658">          errmsg = illegal_char(errbuf, errbuflen, *s);</a>
<a name="ln2659">          break;</a>
<a name="ln2660">        }</a>
<a name="ln2661">        s++;</a>
<a name="ln2662">      }</a>
<a name="ln2663">      if (*s++ == NUL) {</a>
<a name="ln2664">        errmsg = (char_u *)N_(&quot;E524: Missing colon&quot;);</a>
<a name="ln2665">      } else if (*s == ',' || *s == NUL) {</a>
<a name="ln2666">        errmsg = (char_u *)N_(&quot;E525: Zero length string&quot;);</a>
<a name="ln2667">      }</a>
<a name="ln2668">      if (errmsg != NULL) {</a>
<a name="ln2669">        break;</a>
<a name="ln2670">      }</a>
<a name="ln2671">      while (*s &amp;&amp; *s != ',') {</a>
<a name="ln2672">        if (*s == '\\' &amp;&amp; s[1] != NUL) {</a>
<a name="ln2673">          s++;</a>
<a name="ln2674">        }</a>
<a name="ln2675">        s++;</a>
<a name="ln2676">      }</a>
<a name="ln2677">      s = skip_to_option_part(s);</a>
<a name="ln2678">    }</a>
<a name="ln2679">  } else if (varp == &amp;p_lcs) {  // 'listchars'</a>
<a name="ln2680">    errmsg = set_chars_option(curwin, varp, false);</a>
<a name="ln2681">    if (!errmsg) {</a>
<a name="ln2682">      FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln2683">        set_chars_option(wp, &amp;wp-&gt;w_p_lcs, true);</a>
<a name="ln2684">      }</a>
<a name="ln2685">    }</a>
<a name="ln2686">    redraw_all_later(NOT_VALID);</a>
<a name="ln2687">  } else if (varp == &amp;curwin-&gt;w_p_lcs) {  // local 'listchars'</a>
<a name="ln2688">    errmsg = set_chars_option(curwin, varp, true);</a>
<a name="ln2689">  } else if (varp == &amp;p_fcs) {  // 'fillchars'</a>
<a name="ln2690">    errmsg = set_chars_option(curwin, varp, false);</a>
<a name="ln2691">    if (!errmsg) {</a>
<a name="ln2692">      FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln2693">        set_chars_option(wp, &amp;wp-&gt;w_p_fcs, true);</a>
<a name="ln2694">      }</a>
<a name="ln2695">    }</a>
<a name="ln2696">    redraw_all_later(NOT_VALID);</a>
<a name="ln2697">  } else if (varp == &amp;curwin-&gt;w_p_fcs) {  // local 'fillchars'</a>
<a name="ln2698">    errmsg = set_chars_option(curwin, varp, true);</a>
<a name="ln2699">  } else if (varp == &amp;p_cedit) {  // 'cedit'</a>
<a name="ln2700">    errmsg = check_cedit();</a>
<a name="ln2701">  } else if (varp == &amp;p_vfile) {  // 'verbosefile'</a>
<a name="ln2702">    verbose_stop();</a>
<a name="ln2703">    if (*p_vfile != NUL &amp;&amp; verbose_open() == FAIL) {</a>
<a name="ln2704">      errmsg = e_invarg;</a>
<a name="ln2705">    }</a>
<a name="ln2706">  // 'shada'</a>
<a name="ln2707">  } else if (varp == &amp;p_shada) {</a>
<a name="ln2708">    // TODO(ZyX-I): Remove this code in the future, alongside with &amp;viminfo</a>
<a name="ln2709">    //              option.</a>
<a name="ln2710">    opt_idx = ((options[opt_idx].fullname[0] == 'v')</a>
<a name="ln2711">               ? (shada_idx == -1</a>
<a name="ln2712">                  ? ((shada_idx = findoption(&quot;shada&quot;)))</a>
<a name="ln2713">                  : shada_idx)</a>
<a name="ln2714">               : opt_idx);</a>
<a name="ln2715">    // Update free_oldval now that we have the opt_idx for 'shada', otherwise</a>
<a name="ln2716">    // there would be a disconnect between the check for P_ALLOCED at the start</a>
<a name="ln2717">    // of the function and the set of P_ALLOCED at the end of the fuction.</a>
<a name="ln2718">    free_oldval = (options[opt_idx].flags &amp; P_ALLOCED);</a>
<a name="ln2719">    for (s = p_shada; *s; ) {</a>
<a name="ln2720">      // Check it's a valid character</a>
<a name="ln2721">      if (vim_strchr((char_u *)&quot;!\&quot;%'/:&lt;@cfhnrs&quot;, *s) == NULL) {</a>
<a name="ln2722">        errmsg = illegal_char(errbuf, errbuflen, *s);</a>
<a name="ln2723">        break;</a>
<a name="ln2724">      }</a>
<a name="ln2725">      if (*s == 'n') {          // name is always last one</a>
<a name="ln2726">        break;</a>
<a name="ln2727">      } else if (*s == 'r') {  // skip until next ','</a>
<a name="ln2728">        while (*++s &amp;&amp; *s != ',') {}</a>
<a name="ln2729">      } else if (*s == '%') {</a>
<a name="ln2730">        // optional number</a>
<a name="ln2731">        while (ascii_isdigit(*++s)) {}</a>
<a name="ln2732">      } else if (*s == '!' || *s == 'h' || *s == 'c') {</a>
<a name="ln2733">        s++;                    // no extra chars</a>
<a name="ln2734">      } else {                    // must have a number</a>
<a name="ln2735">        while (ascii_isdigit(*++s)) {}</a>
<a name="ln2736"> </a>
<a name="ln2737">        if (!ascii_isdigit(*(s - 1))) {</a>
<a name="ln2738">          if (errbuf != NULL) {</a>
<a name="ln2739">            vim_snprintf((char *)errbuf, errbuflen,</a>
<a name="ln2740">                         _(&quot;E526: Missing number after &lt;%s&gt;&quot;),</a>
<a name="ln2741">                         transchar_byte(*(s - 1)));</a>
<a name="ln2742">            errmsg = errbuf;</a>
<a name="ln2743">          } else</a>
<a name="ln2744">            errmsg = (char_u *)&quot;&quot;;</a>
<a name="ln2745">          break;</a>
<a name="ln2746">        }</a>
<a name="ln2747">      }</a>
<a name="ln2748">      if (*s == ',') {</a>
<a name="ln2749">        s++;</a>
<a name="ln2750">      } else if (*s) {</a>
<a name="ln2751">        if (errbuf != NULL) {</a>
<a name="ln2752">          errmsg = (char_u *)N_(&quot;E527: Missing comma&quot;);</a>
<a name="ln2753">        } else {</a>
<a name="ln2754">          errmsg = (char_u *)&quot;&quot;;</a>
<a name="ln2755">        }</a>
<a name="ln2756">        break;</a>
<a name="ln2757">      }</a>
<a name="ln2758">    }</a>
<a name="ln2759">    if (*p_shada &amp;&amp; errmsg == NULL &amp;&amp; get_shada_parameter('\'') &lt; 0) {</a>
<a name="ln2760">      errmsg = (char_u *)N_(&quot;E528: Must specify a ' value&quot;);</a>
<a name="ln2761">    }</a>
<a name="ln2762">  } else if (varp == &amp;p_sbr) {  // 'showbreak'</a>
<a name="ln2763">    for (s = p_sbr; *s; ) {</a>
<a name="ln2764">      if (ptr2cells(s) != 1) {</a>
<a name="ln2765">        errmsg = (char_u *)N_(&quot;E595: contains unprintable or wide character&quot;);</a>
<a name="ln2766">      }</a>
<a name="ln2767">      MB_PTR_ADV(s);</a>
<a name="ln2768">    }</a>
<a name="ln2769">  } else if (varp == &amp;p_guicursor) {  // 'guicursor'</a>
<a name="ln2770">    errmsg = parse_shape_opt(SHAPE_CURSOR);</a>
<a name="ln2771">  } else if (varp == &amp;p_popt) {</a>
<a name="ln2772">    errmsg = parse_printoptions();</a>
<a name="ln2773">  } else if (varp == &amp;p_pmfn) {</a>
<a name="ln2774">    errmsg = parse_printmbfont();</a>
<a name="ln2775">  } else if (varp == &amp;p_langmap) {  // 'langmap'</a>
<a name="ln2776">    langmap_set();</a>
<a name="ln2777">  } else if (varp == &amp;p_breakat) {  // 'breakat'</a>
<a name="ln2778">    fill_breakat_flags();</a>
<a name="ln2779">  } else if (varp == &amp;p_titlestring || varp == &amp;p_iconstring) {</a>
<a name="ln2780">    // 'titlestring' and 'iconstring'</a>
<a name="ln2781">    int flagval = (varp == &amp;p_titlestring) ? STL_IN_TITLE : STL_IN_ICON;</a>
<a name="ln2782"> </a>
<a name="ln2783">    // NULL =&gt; statusline syntax</a>
<a name="ln2784">    if (vim_strchr(*varp, '%') &amp;&amp; check_stl_option(*varp) == NULL) {</a>
<a name="ln2785">      stl_syntax |= flagval;</a>
<a name="ln2786">    } else {</a>
<a name="ln2787">      stl_syntax &amp;= ~flagval;</a>
<a name="ln2788">    }</a>
<a name="ln2789">    did_set_title();</a>
<a name="ln2790"> </a>
<a name="ln2791">  } else if (varp == &amp;p_sel) {  // 'selection'</a>
<a name="ln2792">    if (*p_sel == NUL</a>
<a name="ln2793">        || check_opt_strings(p_sel, p_sel_values, false) != OK) {</a>
<a name="ln2794">      errmsg = e_invarg;</a>
<a name="ln2795">    }</a>
<a name="ln2796">  } else if (varp == &amp;p_slm) {  // 'selectmode'</a>
<a name="ln2797">    if (check_opt_strings(p_slm, p_slm_values, true) != OK) {</a>
<a name="ln2798">      errmsg = e_invarg;</a>
<a name="ln2799">    }</a>
<a name="ln2800">  } else if (varp == &amp;p_km) {  // 'keymodel'</a>
<a name="ln2801">    if (check_opt_strings(p_km, p_km_values, true) != OK) {</a>
<a name="ln2802">      errmsg = e_invarg;</a>
<a name="ln2803">    } else {</a>
<a name="ln2804">      km_stopsel = (vim_strchr(p_km, 'o') != NULL);</a>
<a name="ln2805">      km_startsel = (vim_strchr(p_km, 'a') != NULL);</a>
<a name="ln2806">    }</a>
<a name="ln2807">  } else if (varp == &amp;p_mousem) {  // 'mousemodel'</a>
<a name="ln2808">    if (check_opt_strings(p_mousem, p_mousem_values, false) != OK) {</a>
<a name="ln2809">      errmsg = e_invarg;</a>
<a name="ln2810">    }</a>
<a name="ln2811">  } else if (varp == &amp;p_swb) {  // 'switchbuf'</a>
<a name="ln2812">    if (opt_strings_flags(p_swb, p_swb_values, &amp;swb_flags, true) != OK) {</a>
<a name="ln2813">      errmsg = e_invarg;</a>
<a name="ln2814">    }</a>
<a name="ln2815">  } else if (varp == &amp;p_debug) {  // 'debug'</a>
<a name="ln2816">    if (check_opt_strings(p_debug, p_debug_values, true) != OK) {</a>
<a name="ln2817">      errmsg = e_invarg;</a>
<a name="ln2818">    }</a>
<a name="ln2819">  } else if (varp == &amp;p_dy) {  // 'display'</a>
<a name="ln2820">    if (opt_strings_flags(p_dy, p_dy_values, &amp;dy_flags, true) != OK) {</a>
<a name="ln2821">      errmsg = e_invarg;</a>
<a name="ln2822">    } else {</a>
<a name="ln2823">      (void)init_chartab();</a>
<a name="ln2824">      msg_grid_validate();</a>
<a name="ln2825">    }</a>
<a name="ln2826">  } else if (varp == &amp;p_ead) {  // 'eadirection'</a>
<a name="ln2827">    if (check_opt_strings(p_ead, p_ead_values, false) != OK) {</a>
<a name="ln2828">      errmsg = e_invarg;</a>
<a name="ln2829">    }</a>
<a name="ln2830">  } else if (varp == &amp;p_cb) {  // 'clipboard'</a>
<a name="ln2831">    if (opt_strings_flags(p_cb, p_cb_values, &amp;cb_flags, true) != OK) {</a>
<a name="ln2832">      errmsg = e_invarg;</a>
<a name="ln2833">    }</a>
<a name="ln2834">  } else if (varp == &amp;(curwin-&gt;w_s-&gt;b_p_spl)  // 'spell'</a>
<a name="ln2835">             || varp == &amp;(curwin-&gt;w_s-&gt;b_p_spf)) {</a>
<a name="ln2836">    // When 'spelllang' or 'spellfile' is set and there is a window for this</a>
<a name="ln2837">    // buffer in which 'spell' is set load the wordlists.</a>
<a name="ln2838">    const bool is_spellfile = varp == &amp;(curwin-&gt;w_s-&gt;b_p_spf);</a>
<a name="ln2839"> </a>
<a name="ln2840">    if ((is_spellfile &amp;&amp; !valid_spellfile(*varp))</a>
<a name="ln2841">        || (!is_spellfile &amp;&amp; !valid_spelllang(*varp))) {</a>
<a name="ln2842">      errmsg = e_invarg;</a>
<a name="ln2843">    } else {</a>
<a name="ln2844">      errmsg = did_set_spell_option(is_spellfile);</a>
<a name="ln2845">    }</a>
<a name="ln2846">  } else if (varp == &amp;(curwin-&gt;w_s-&gt;b_p_spc)) {</a>
<a name="ln2847">    // When 'spellcapcheck' is set compile the regexp program.</a>
<a name="ln2848">    errmsg = compile_cap_prog(curwin-&gt;w_s);</a>
<a name="ln2849">  } else if (varp == &amp;(curwin-&gt;w_s-&gt;b_p_spo)) {  // 'spelloptions'</a>
<a name="ln2850">    if (**varp != NUL &amp;&amp; STRCMP(&quot;camel&quot;, *varp) != 0) {</a>
<a name="ln2851">      errmsg = e_invarg;</a>
<a name="ln2852">    }</a>
<a name="ln2853">  } else if (varp == &amp;p_sps) {  // 'spellsuggest'</a>
<a name="ln2854">    if (spell_check_sps() != OK) {</a>
<a name="ln2855">      errmsg = e_invarg;</a>
<a name="ln2856">    }</a>
<a name="ln2857">  } else if (varp == &amp;p_msm) {  // 'mkspellmem'</a>
<a name="ln2858">    if (spell_check_msm() != OK) {</a>
<a name="ln2859">      errmsg = e_invarg;</a>
<a name="ln2860">    }</a>
<a name="ln2861">  } else if (gvarp == &amp;p_bh) {</a>
<a name="ln2862">    // When 'bufhidden' is set, check for valid value.</a>
<a name="ln2863">    if (check_opt_strings(curbuf-&gt;b_p_bh, p_bufhidden_values, false) != OK) {</a>
<a name="ln2864">      errmsg = e_invarg;</a>
<a name="ln2865">    }</a>
<a name="ln2866">  } else if (gvarp == &amp;p_bt) {</a>
<a name="ln2867">    // When 'buftype' is set, check for valid value.</a>
<a name="ln2868">    if ((curbuf-&gt;terminal &amp;&amp; curbuf-&gt;b_p_bt[0] != 't')</a>
<a name="ln2869">        || (!curbuf-&gt;terminal &amp;&amp; curbuf-&gt;b_p_bt[0] == 't')</a>
<a name="ln2870">        || check_opt_strings(curbuf-&gt;b_p_bt, p_buftype_values, false) != OK) {</a>
<a name="ln2871">      errmsg = e_invarg;</a>
<a name="ln2872">    } else {</a>
<a name="ln2873">      if (curwin-&gt;w_status_height) {</a>
<a name="ln2874">        curwin-&gt;w_redr_status = true;</a>
<a name="ln2875">        redraw_later(curwin, VALID);</a>
<a name="ln2876">      }</a>
<a name="ln2877">      curbuf-&gt;b_help = (curbuf-&gt;b_p_bt[0] == 'h');</a>
<a name="ln2878">      redraw_titles();</a>
<a name="ln2879">    }</a>
<a name="ln2880">  } else if (gvarp == &amp;p_stl || varp == &amp;p_ruf) {</a>
<a name="ln2881">    // 'statusline' or 'rulerformat'</a>
<a name="ln2882">    int wid;</a>
<a name="ln2883"> </a>
<a name="ln2884">    if (varp == &amp;p_ruf) {       // reset ru_wid first</a>
<a name="ln2885">      ru_wid = 0;</a>
<a name="ln2886">    }</a>
<a name="ln2887">    s = *varp;</a>
<a name="ln2888">    if (varp == &amp;p_ruf &amp;&amp; *s == '%') {</a>
<a name="ln2889">      // set ru_wid if 'ruf' starts with &quot;%99(&quot;</a>
<a name="ln2890">      if (*++s == '-') {        // ignore a '-'</a>
<a name="ln2891">        s++;</a>
<a name="ln2892">      }</a>
<a name="ln2893">      wid = getdigits_int(&amp;s, true, 0);</a>
<a name="ln2894">      if (wid &amp;&amp; *s == '(' &amp;&amp; (errmsg = check_stl_option(p_ruf)) == NULL) {</a>
<a name="ln2895">        ru_wid = wid;</a>
<a name="ln2896">      } else {</a>
<a name="ln2897">        errmsg = check_stl_option(p_ruf);</a>
<a name="ln2898">      }</a>
<a name="ln2899">    } else if (varp == &amp;p_ruf || s[0] != '%' || s[1] != '!') {</a>
<a name="ln2900">      // check 'statusline' only if it doesn't start with &quot;%!&quot;</a>
<a name="ln2901">      errmsg = check_stl_option(s);</a>
<a name="ln2902">    }</a>
<a name="ln2903">    if (varp == &amp;p_ruf &amp;&amp; errmsg == NULL) {</a>
<a name="ln2904">      comp_col();</a>
<a name="ln2905">    }</a>
<a name="ln2906">  } else if (gvarp == &amp;p_cpt) {</a>
<a name="ln2907">    // check if it is a valid value for 'complete' -- Acevedo</a>
<a name="ln2908">    for (s = *varp; *s; ) {</a>
<a name="ln2909">      while (*s == ',' || *s == ' ')</a>
<a name="ln2910">        s++;</a>
<a name="ln2911">      if (!*s) {</a>
<a name="ln2912">        break;</a>
<a name="ln2913">      }</a>
<a name="ln2914">      if (vim_strchr((char_u *)&quot;.wbuksid]tU&quot;, *s) == NULL) {</a>
<a name="ln2915">        errmsg = illegal_char(errbuf, errbuflen, *s);</a>
<a name="ln2916">        break;</a>
<a name="ln2917">      }</a>
<a name="ln2918">      if (*++s != NUL &amp;&amp; *s != ',' &amp;&amp; *s != ' ') {</a>
<a name="ln2919">        if (s[-1] == 'k' || s[-1] == 's') {</a>
<a name="ln2920">          // skip optional filename after 'k' and 's'</a>
<a name="ln2921">          while (*s &amp;&amp; *s != ',' &amp;&amp; *s != ' ') {</a>
<a name="ln2922">            if (*s == '\\' &amp;&amp; s[1] != NUL) {</a>
<a name="ln2923">              s++;</a>
<a name="ln2924">            }</a>
<a name="ln2925">            s++;</a>
<a name="ln2926">          }</a>
<a name="ln2927">        } else {</a>
<a name="ln2928">          if (errbuf != NULL) {</a>
<a name="ln2929">            vim_snprintf((char *)errbuf, errbuflen,</a>
<a name="ln2930">                         _(&quot;E535: Illegal character after &lt;%c&gt;&quot;),</a>
<a name="ln2931">                         *--s);</a>
<a name="ln2932">            errmsg = errbuf;</a>
<a name="ln2933">          } else</a>
<a name="ln2934">            errmsg = (char_u *)&quot;&quot;;</a>
<a name="ln2935">          break;</a>
<a name="ln2936">        }</a>
<a name="ln2937">      }</a>
<a name="ln2938">    }</a>
<a name="ln2939">  } else if (varp == &amp;p_cot) {  // 'completeopt'</a>
<a name="ln2940">    if (check_opt_strings(p_cot, p_cot_values, true) != OK) {</a>
<a name="ln2941">      errmsg = e_invarg;</a>
<a name="ln2942">    } else {</a>
<a name="ln2943">      completeopt_was_set();</a>
<a name="ln2944">    }</a>
<a name="ln2945">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2946">  } else if (gvarp == &amp;p_csl) {  // 'completeslash'</a>
<a name="ln2947">    if (check_opt_strings(p_csl, p_csl_values, false) != OK</a>
<a name="ln2948">        || check_opt_strings(curbuf-&gt;b_p_csl, p_csl_values, false) != OK) {</a>
<a name="ln2949">      errmsg = e_invarg;</a>
<a name="ln2950">    }</a>
<a name="ln2951">#endif</a>
<a name="ln2952">  } else if (varp == &amp;curwin-&gt;w_p_scl) {</a>
<a name="ln2953">    // 'signcolumn'</a>
<a name="ln2954">    if (check_signcolumn(*varp) != OK) {</a>
<a name="ln2955">      errmsg = e_invarg;</a>
<a name="ln2956">    }</a>
<a name="ln2957">    // When changing the 'signcolumn' to or from 'number', recompute the</a>
<a name="ln2958">    // width of the number column if 'number' or 'relativenumber' is set.</a>
<a name="ln2959">    if (((*oldval == 'n' &amp;&amp; *(oldval + 1) == 'u')</a>
<a name="ln2960">         || (*curwin-&gt;w_p_scl == 'n' &amp;&amp; *(curwin-&gt;w_p_scl + 1) =='u'))</a>
<a name="ln2961">        &amp;&amp; (curwin-&gt;w_p_nu || curwin-&gt;w_p_rnu)) {</a>
<a name="ln2962">      curwin-&gt;w_nrwidth_line_count = 0;</a>
<a name="ln2963">    }</a>
<a name="ln2964">  } else if (varp == &amp;curwin-&gt;w_p_fdc || varp == &amp;curwin-&gt;w_allbuf_opt.wo_fdc) {</a>
<a name="ln2965">    // 'foldcolumn'</a>
<a name="ln2966">    if (check_opt_strings(*varp, p_fdc_values, false) != OK) {</a>
<a name="ln2967">      errmsg = e_invarg;</a>
<a name="ln2968">    }</a>
<a name="ln2969">  } else if (varp == &amp;p_pt) {</a>
<a name="ln2970">    // 'pastetoggle': translate key codes like in a mapping</a>
<a name="ln2971">    if (*p_pt) {</a>
<a name="ln2972">      (void)replace_termcodes(p_pt, STRLEN(p_pt), &amp;p, true, true, true,</a>
<a name="ln2973">                              CPO_TO_CPO_FLAGS);</a>
<a name="ln2974">      if (p != NULL) {</a>
<a name="ln2975">        if (new_value_alloced) {</a>
<a name="ln2976">          free_string_option(p_pt);</a>
<a name="ln2977">        }</a>
<a name="ln2978">        p_pt = p;</a>
<a name="ln2979">        new_value_alloced = true;</a>
<a name="ln2980">      }</a>
<a name="ln2981">    }</a>
<a name="ln2982">  } else if (varp == &amp;p_bs) {  // 'backspace'</a>
<a name="ln2983">    if (ascii_isdigit(*p_bs)) {</a>
<a name="ln2984">      if (*p_bs &gt; '3' || p_bs[1] != NUL) {</a>
<a name="ln2985">        errmsg = e_invarg;</a>
<a name="ln2986">      }</a>
<a name="ln2987">    } else if (check_opt_strings(p_bs, p_bs_values, true) != OK) {</a>
<a name="ln2988">      errmsg = e_invarg;</a>
<a name="ln2989">    }</a>
<a name="ln2990">  } else if (varp == &amp;p_bo) {</a>
<a name="ln2991">    if (opt_strings_flags(p_bo, p_bo_values, &amp;bo_flags, true) != OK) {</a>
<a name="ln2992">      errmsg = e_invarg;</a>
<a name="ln2993">    }</a>
<a name="ln2994">  } else if (gvarp == &amp;p_tc) {  // 'tagcase'</a>
<a name="ln2995">    unsigned int *flags;</a>
<a name="ln2996"> </a>
<a name="ln2997">    if (opt_flags &amp; OPT_LOCAL) {</a>
<a name="ln2998">      p = curbuf-&gt;b_p_tc;</a>
<a name="ln2999">      flags = &amp;curbuf-&gt;b_tc_flags;</a>
<a name="ln3000">    } else {</a>
<a name="ln3001">      p = p_tc;</a>
<a name="ln3002">      flags = &amp;tc_flags;</a>
<a name="ln3003">    }</a>
<a name="ln3004"> </a>
<a name="ln3005">    if ((opt_flags &amp; OPT_LOCAL) &amp;&amp; *p == NUL) {</a>
<a name="ln3006">      // make the local value empty: use the global value</a>
<a name="ln3007">      *flags = 0;</a>
<a name="ln3008">    } else if (*p == NUL</a>
<a name="ln3009">               || opt_strings_flags(p, p_tc_values, flags, false) != OK) {</a>
<a name="ln3010">      errmsg = e_invarg;</a>
<a name="ln3011">    }</a>
<a name="ln3012">  } else if (varp == &amp;p_cmp) {  // 'casemap'</a>
<a name="ln3013">    if (opt_strings_flags(p_cmp, p_cmp_values, &amp;cmp_flags, true) != OK) {</a>
<a name="ln3014">      errmsg = e_invarg;</a>
<a name="ln3015">    }</a>
<a name="ln3016">  } else if (varp == &amp;p_dip) {  // 'diffopt'</a>
<a name="ln3017">    if (diffopt_changed() == FAIL) {</a>
<a name="ln3018">      errmsg = e_invarg;</a>
<a name="ln3019">    }</a>
<a name="ln3020">  } else if (gvarp == &amp;curwin-&gt;w_allbuf_opt.wo_fdm) {  // 'foldmethod'</a>
<a name="ln3021">    if (check_opt_strings(*varp, p_fdm_values, false) != OK</a>
<a name="ln3022">        || *curwin-&gt;w_p_fdm == NUL) {</a>
<a name="ln3023">      errmsg = e_invarg;</a>
<a name="ln3024">    } else {</a>
<a name="ln3025">      foldUpdateAll(curwin);</a>
<a name="ln3026">      if (foldmethodIsDiff(curwin)) {</a>
<a name="ln3027">        newFoldLevel();</a>
<a name="ln3028">      }</a>
<a name="ln3029">    }</a>
<a name="ln3030">  } else if (varp == &amp;curwin-&gt;w_p_fde) {  // 'foldexpr'</a>
<a name="ln3031">    if (foldmethodIsExpr(curwin)) {</a>
<a name="ln3032">      foldUpdateAll(curwin);</a>
<a name="ln3033">    }</a>
<a name="ln3034">  } else if (gvarp == &amp;curwin-&gt;w_allbuf_opt.wo_fmr) {  // 'foldmarker'</a>
<a name="ln3035">    p = vim_strchr(*varp, ',');</a>
<a name="ln3036">    if (p == NULL) {</a>
<a name="ln3037">      errmsg = (char_u *)N_(&quot;E536: comma required&quot;);</a>
<a name="ln3038">    } else if (p == *varp || p[1] == NUL) {</a>
<a name="ln3039">      errmsg = e_invarg;</a>
<a name="ln3040">    } else if (foldmethodIsMarker(curwin)) {</a>
<a name="ln3041">      foldUpdateAll(curwin);</a>
<a name="ln3042">    }</a>
<a name="ln3043">  } else if (gvarp == &amp;p_cms) {  // 'commentstring'</a>
<a name="ln3044">    if (**varp != NUL &amp;&amp; strstr((char *)(*varp), &quot;%s&quot;) == NULL) {</a>
<a name="ln3045">      errmsg = (char_u *)N_(</a>
<a name="ln3046">          &quot;E537: 'commentstring' must be empty or contain %s&quot;);</a>
<a name="ln3047">    }</a>
<a name="ln3048">  } else if (varp == &amp;p_fdo) {  // 'foldopen'</a>
<a name="ln3049">    if (opt_strings_flags(p_fdo, p_fdo_values, &amp;fdo_flags, true) != OK) {</a>
<a name="ln3050">      errmsg = e_invarg;</a>
<a name="ln3051">    }</a>
<a name="ln3052">  } else if (varp == &amp;p_fcl) {  // 'foldclose'</a>
<a name="ln3053">    if (check_opt_strings(p_fcl, p_fcl_values, true) != OK) {</a>
<a name="ln3054">      errmsg = e_invarg;</a>
<a name="ln3055">    }</a>
<a name="ln3056">  } else if (gvarp == &amp;curwin-&gt;w_allbuf_opt.wo_fdi) {  // 'foldignore'</a>
<a name="ln3057">    if (foldmethodIsIndent(curwin)) {</a>
<a name="ln3058">      foldUpdateAll(curwin);</a>
<a name="ln3059">    }</a>
<a name="ln3060">  } else if (varp == &amp;p_ve) {  // 'virtualedit'</a>
<a name="ln3061">    if (opt_strings_flags(p_ve, p_ve_values, &amp;ve_flags, true) != OK) {</a>
<a name="ln3062">      errmsg = e_invarg;</a>
<a name="ln3063">    } else if (STRCMP(p_ve, oldval) != 0) {</a>
<a name="ln3064">      // Recompute cursor position in case the new 've' setting</a>
<a name="ln3065">      // changes something.</a>
<a name="ln3066">      validate_virtcol();</a>
<a name="ln3067">      coladvance(curwin-&gt;w_virtcol);</a>
<a name="ln3068">    }</a>
<a name="ln3069">  } else if (varp == &amp;p_csqf) {</a>
<a name="ln3070">    if (p_csqf != NULL) {</a>
<a name="ln3071">      p = p_csqf;</a>
<a name="ln3072">      while (*p != NUL) {</a>
<a name="ln3073">        if (vim_strchr((char_u *)CSQF_CMDS, *p) == NULL</a>
<a name="ln3074">            || p[1] == NUL</a>
<a name="ln3075">            || vim_strchr((char_u *)CSQF_FLAGS, p[1]) == NULL</a>
<a name="ln3076">            || (p[2] != NUL &amp;&amp; p[2] != ',')) {</a>
<a name="ln3077">          errmsg = e_invarg;</a>
<a name="ln3078">          break;</a>
<a name="ln3079">        } else if (p[2] == NUL) {</a>
<a name="ln3080">          break;</a>
<a name="ln3081">        } else {</a>
<a name="ln3082">          p += 3;</a>
<a name="ln3083">        }</a>
<a name="ln3084">      }</a>
<a name="ln3085">    }</a>
<a name="ln3086">  } else if (gvarp == &amp;p_cino) {  // 'cinoptions'</a>
<a name="ln3087">    // TODO(vim): recognize errors</a>
<a name="ln3088">    parse_cino(curbuf);</a>
<a name="ln3089">  // inccommand</a>
<a name="ln3090">  } else if (varp == &amp;p_icm) {</a>
<a name="ln3091">      if (check_opt_strings(p_icm, p_icm_values, false) != OK) {</a>
<a name="ln3092">        errmsg = e_invarg;</a>
<a name="ln3093">      }</a>
<a name="ln3094">  } else if (gvarp == &amp;p_ft) {</a>
<a name="ln3095">    if (!valid_filetype(*varp)) {</a>
<a name="ln3096">      errmsg = e_invarg;</a>
<a name="ln3097">    } else {</a>
<a name="ln3098">      value_changed = STRCMP(oldval, *varp) != 0;</a>
<a name="ln3099"> </a>
<a name="ln3100">      // Since we check the value, there is no need to set P_INSECURE,</a>
<a name="ln3101">      // even when the value comes from a modeline.</a>
<a name="ln3102">      *value_checked = true;</a>
<a name="ln3103">    }</a>
<a name="ln3104">  } else if (gvarp == &amp;p_syn) {</a>
<a name="ln3105">    if (!valid_filetype(*varp)) {</a>
<a name="ln3106">      errmsg = e_invarg;</a>
<a name="ln3107">    } else {</a>
<a name="ln3108">      value_changed = STRCMP(oldval, *varp) != 0;</a>
<a name="ln3109"> </a>
<a name="ln3110">      // Since we check the value, there is no need to set P_INSECURE,</a>
<a name="ln3111">      // even when the value comes from a modeline.</a>
<a name="ln3112">      *value_checked = true;</a>
<a name="ln3113">    }</a>
<a name="ln3114">  } else if (varp == &amp;curwin-&gt;w_p_winhl) {</a>
<a name="ln3115">    if (!parse_winhl_opt(curwin)) {</a>
<a name="ln3116">      errmsg = e_invarg;</a>
<a name="ln3117">    }</a>
<a name="ln3118">  } else if (varp == &amp;p_tpf) {</a>
<a name="ln3119">    if (opt_strings_flags(p_tpf, p_tpf_values, &amp;tpf_flags, true) != OK) {</a>
<a name="ln3120">      errmsg = e_invarg;</a>
<a name="ln3121">    }</a>
<a name="ln3122">  } else if (varp == &amp;(curbuf-&gt;b_p_vsts)) {  // 'varsofttabstop'</a>
<a name="ln3123">    char_u *cp;</a>
<a name="ln3124"> </a>
<a name="ln3125">    if (!(*varp)[0] || ((*varp)[0] == '0' &amp;&amp; !(*varp)[1])) {</a>
<a name="ln3126">      if (curbuf-&gt;b_p_vsts_array) {</a>
<a name="ln3127">        xfree(curbuf-&gt;b_p_vsts_array);</a>
<a name="ln3128">        curbuf-&gt;b_p_vsts_array = 0;</a>
<a name="ln3129">      }</a>
<a name="ln3130">    } else {</a>
<a name="ln3131">      for (cp = *varp; *cp; cp++) {</a>
<a name="ln3132">        if (ascii_isdigit(*cp)) {</a>
<a name="ln3133">          continue;</a>
<a name="ln3134">        }</a>
<a name="ln3135">        if (*cp == ',' &amp;&amp; cp &gt; *varp &amp;&amp; *(cp - 1) != ',') {</a>
<a name="ln3136">          continue;</a>
<a name="ln3137">        }</a>
<a name="ln3138">        errmsg = e_invarg;</a>
<a name="ln3139">        break;</a>
<a name="ln3140">      }</a>
<a name="ln3141">      if (errmsg == NULL) {</a>
<a name="ln3142">        long *oldarray = curbuf-&gt;b_p_vsts_array;</a>
<a name="ln3143">        if (tabstop_set(*varp, &amp;(curbuf-&gt;b_p_vsts_array))) {</a>
<a name="ln3144">          xfree(oldarray);</a>
<a name="ln3145">        } else {</a>
<a name="ln3146">          errmsg = e_invarg;</a>
<a name="ln3147">        }</a>
<a name="ln3148">      }</a>
<a name="ln3149">    }</a>
<a name="ln3150">  } else if (varp == &amp;(curbuf-&gt;b_p_vts)) {  // 'vartabstop'</a>
<a name="ln3151">    char_u *cp;</a>
<a name="ln3152"> </a>
<a name="ln3153">    if (!(*varp)[0] || ((*varp)[0] == '0' &amp;&amp; !(*varp)[1])) {</a>
<a name="ln3154">      if (curbuf-&gt;b_p_vts_array) {</a>
<a name="ln3155">        xfree(curbuf-&gt;b_p_vts_array);</a>
<a name="ln3156">        curbuf-&gt;b_p_vts_array = NULL;</a>
<a name="ln3157">      }</a>
<a name="ln3158">    } else {</a>
<a name="ln3159">      for (cp = *varp; *cp; cp++) {</a>
<a name="ln3160">        if (ascii_isdigit(*cp)) {</a>
<a name="ln3161">          continue;</a>
<a name="ln3162">        }</a>
<a name="ln3163">        if (*cp == ',' &amp;&amp; cp &gt; *varp &amp;&amp; *(cp - 1) != ',') {</a>
<a name="ln3164">          continue;</a>
<a name="ln3165">        }</a>
<a name="ln3166">        errmsg = e_invarg;</a>
<a name="ln3167">        break;</a>
<a name="ln3168">      }</a>
<a name="ln3169">      if (errmsg == NULL) {</a>
<a name="ln3170">        long *oldarray = curbuf-&gt;b_p_vts_array;</a>
<a name="ln3171">        if (tabstop_set(*varp, &amp;(curbuf-&gt;b_p_vts_array))) {</a>
<a name="ln3172">          xfree(oldarray);</a>
<a name="ln3173">          if (foldmethodIsIndent(curwin)) {</a>
<a name="ln3174">            foldUpdateAll(curwin);</a>
<a name="ln3175">          }</a>
<a name="ln3176">        } else {</a>
<a name="ln3177">          errmsg = e_invarg;</a>
<a name="ln3178">        }</a>
<a name="ln3179">      }</a>
<a name="ln3180">    }</a>
<a name="ln3181">  } else {</a>
<a name="ln3182">    // Options that are a list of flags.</a>
<a name="ln3183">    p = NULL;</a>
<a name="ln3184">    if (varp == &amp;p_ww) {  // 'whichwrap'</a>
<a name="ln3185">      p = (char_u *)WW_ALL;</a>
<a name="ln3186">    }</a>
<a name="ln3187">    if (varp == &amp;p_shm) {  // 'shortmess'</a>
<a name="ln3188">      p = (char_u *)SHM_ALL;</a>
<a name="ln3189">    } else if (varp == &amp;(p_cpo)) {  // 'cpoptions'</a>
<a name="ln3190">      p = (char_u *)CPO_VI;</a>
<a name="ln3191">    } else if (varp == &amp;(curbuf-&gt;b_p_fo)) {  // 'formatoptions'</a>
<a name="ln3192">      p = (char_u *)FO_ALL;</a>
<a name="ln3193">    } else if (varp == &amp;curwin-&gt;w_p_cocu) {  // 'concealcursor'</a>
<a name="ln3194">      p = (char_u *)COCU_ALL;</a>
<a name="ln3195">    } else if (varp == &amp;p_mouse) {  // 'mouse'</a>
<a name="ln3196">      p = (char_u *)MOUSE_ALL;</a>
<a name="ln3197">    }</a>
<a name="ln3198">    if (p != NULL) {</a>
<a name="ln3199">      for (s = *varp; *s; s++) {</a>
<a name="ln3200">        if (vim_strchr(p, *s) == NULL) {</a>
<a name="ln3201">          errmsg = illegal_char(errbuf, errbuflen, *s);</a>
<a name="ln3202">          break;</a>
<a name="ln3203">        }</a>
<a name="ln3204">      }</a>
<a name="ln3205">    }</a>
<a name="ln3206">  }</a>
<a name="ln3207"> </a>
<a name="ln3208">  /*</a>
<a name="ln3209">   * If error detected, restore the previous value.</a>
<a name="ln3210">   */</a>
<a name="ln3211">  if (errmsg != NULL) {</a>
<a name="ln3212">    if (new_value_alloced) {</a>
<a name="ln3213">      free_string_option(*varp);</a>
<a name="ln3214">    }</a>
<a name="ln3215">    *varp = oldval;</a>
<a name="ln3216">    /*</a>
<a name="ln3217">     * When resetting some values, need to act on it.</a>
<a name="ln3218">     */</a>
<a name="ln3219">    if (did_chartab) {</a>
<a name="ln3220">      (void)init_chartab();</a>
<a name="ln3221">    }</a>
<a name="ln3222">  } else {</a>
<a name="ln3223">    // Remember where the option was set.</a>
<a name="ln3224">    set_option_sctx_idx(opt_idx, opt_flags, current_sctx);</a>
<a name="ln3225">    // Free string options that are in allocated memory.</a>
<a name="ln3226">    // Use &quot;free_oldval&quot;, because recursiveness may change the flags under</a>
<a name="ln3227">    // our fingers (esp. init_highlight()).</a>
<a name="ln3228">    if (free_oldval) {</a>
<a name="ln3229">      free_string_option(oldval);</a>
<a name="ln3230">    }</a>
<a name="ln3231">    if (new_value_alloced) {</a>
<a name="ln3232">      options[opt_idx].flags |= P_ALLOCED;</a>
<a name="ln3233">    } else {</a>
<a name="ln3234">      options[opt_idx].flags &amp;= ~P_ALLOCED;</a>
<a name="ln3235">    }</a>
<a name="ln3236"> </a>
<a name="ln3237">    if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0</a>
<a name="ln3238">        &amp;&amp; ((int)options[opt_idx].indir &amp; PV_BOTH)) {</a>
<a name="ln3239">      /* global option with local value set to use global value; free</a>
<a name="ln3240">       * the local value and make it empty */</a>
<a name="ln3241">      p = get_varp_scope(&amp;(options[opt_idx]), OPT_LOCAL);</a>
<a name="ln3242">      free_string_option(*(char_u **)p);</a>
<a name="ln3243">      *(char_u **)p = empty_option;</a>
<a name="ln3244">    } else if (!(opt_flags &amp; OPT_LOCAL) &amp;&amp; opt_flags != OPT_GLOBAL) {</a>
<a name="ln3245">      // May set global value for local option.</a>
<a name="ln3246">      set_string_option_global(opt_idx, varp);</a>
<a name="ln3247">    }</a>
<a name="ln3248"> </a>
<a name="ln3249">    /*</a>
<a name="ln3250">     * Trigger the autocommand only after setting the flags.</a>
<a name="ln3251">     */</a>
<a name="ln3252">    // When 'syntax' is set, load the syntax of that name</a>
<a name="ln3253">    if (varp == &amp;(curbuf-&gt;b_p_syn)) {</a>
<a name="ln3254">      static int syn_recursive = 0;</a>
<a name="ln3255"> </a>
<a name="ln3256">      syn_recursive++;</a>
<a name="ln3257">      // Only pass true for &quot;force&quot; when the value changed or not used</a>
<a name="ln3258">      // recursively, to avoid endless recurrence.</a>
<a name="ln3259">      apply_autocmds(EVENT_SYNTAX, curbuf-&gt;b_p_syn, curbuf-&gt;b_fname,</a>
<a name="ln3260">                     value_changed || syn_recursive == 1, curbuf);</a>
<a name="ln3261">      curbuf-&gt;b_flags |= BF_SYN_SET;</a>
<a name="ln3262">      syn_recursive--;</a>
<a name="ln3263">    } else if (varp == &amp;(curbuf-&gt;b_p_ft)) {</a>
<a name="ln3264">      // 'filetype' is set, trigger the FileType autocommand</a>
<a name="ln3265">      // Skip this when called from a modeline and the filetype was</a>
<a name="ln3266">      // already set to this value.</a>
<a name="ln3267">      if (!(opt_flags &amp; OPT_MODELINE) || value_changed) {</a>
<a name="ln3268">        static int ft_recursive = 0;</a>
<a name="ln3269">        int secure_save = secure;</a>
<a name="ln3270"> </a>
<a name="ln3271">        // Reset the secure flag, since the value of 'filetype' has</a>
<a name="ln3272">        // been checked to be safe.</a>
<a name="ln3273">        secure = 0;</a>
<a name="ln3274"> </a>
<a name="ln3275">        ft_recursive++;</a>
<a name="ln3276">        did_filetype = true;</a>
<a name="ln3277">        // Only pass true for &quot;force&quot; when the value changed or not</a>
<a name="ln3278">        // used recursively, to avoid endless recurrence.</a>
<a name="ln3279">        apply_autocmds(EVENT_FILETYPE, curbuf-&gt;b_p_ft, curbuf-&gt;b_fname,</a>
<a name="ln3280">                       value_changed || ft_recursive == 1, curbuf);</a>
<a name="ln3281">        ft_recursive--;</a>
<a name="ln3282">        // Just in case the old &quot;curbuf&quot; is now invalid</a>
<a name="ln3283">        if (varp != &amp;(curbuf-&gt;b_p_ft)) {</a>
<a name="ln3284">          varp = NULL;</a>
<a name="ln3285">        }</a>
<a name="ln3286">        secure = secure_save;</a>
<a name="ln3287">      }</a>
<a name="ln3288">    }</a>
<a name="ln3289">    if (varp == &amp;(curwin-&gt;w_s-&gt;b_p_spl)) {</a>
<a name="ln3290">      char_u fname[200];</a>
<a name="ln3291">      char_u      *q = curwin-&gt;w_s-&gt;b_p_spl;</a>
<a name="ln3292"> </a>
<a name="ln3293">      // Skip the first name if it is &quot;cjk&quot;.</a>
<a name="ln3294">      if (STRNCMP(q, &quot;cjk,&quot;, 4) == 0) {</a>
<a name="ln3295">        q += 4;</a>
<a name="ln3296">      }</a>
<a name="ln3297"> </a>
<a name="ln3298">      /*</a>
<a name="ln3299">       * Source the spell/LANG.vim in 'runtimepath'.</a>
<a name="ln3300">       * They could set 'spellcapcheck' depending on the language.</a>
<a name="ln3301">       * Use the first name in 'spelllang' up to '_region' or</a>
<a name="ln3302">       * '.encoding'.</a>
<a name="ln3303">       */</a>
<a name="ln3304">      for (p = q; *p != NUL; p++) {</a>
<a name="ln3305">        if (!ASCII_ISALNUM(*p) &amp;&amp; *p != '-') {</a>
<a name="ln3306">          break;</a>
<a name="ln3307">        }</a>
<a name="ln3308">      }</a>
<a name="ln3309">      if (p &gt; q) {</a>
<a name="ln3310">        vim_snprintf((char *)fname, sizeof(fname), &quot;spell/%.*s.vim&quot;,</a>
<a name="ln3311">                     (int)(p - q), q);</a>
<a name="ln3312">        source_runtime(fname, DIP_ALL);</a>
<a name="ln3313">      }</a>
<a name="ln3314">    }</a>
<a name="ln3315">  }</a>
<a name="ln3316"> </a>
<a name="ln3317">  if (varp == &amp;p_mouse) {</a>
<a name="ln3318">    setmouse();  // in case 'mouse' changed</a>
<a name="ln3319">  }</a>
<a name="ln3320"> </a>
<a name="ln3321">  if (curwin-&gt;w_curswant != MAXCOL</a>
<a name="ln3322">      &amp;&amp; (options[opt_idx].flags &amp; (P_CURSWANT | P_RALL)) != 0)</a>
<a name="ln3323">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln3324"> </a>
<a name="ln3325">  check_redraw(options[opt_idx].flags);</a>
<a name="ln3326"> </a>
<a name="ln3327">  return errmsg;</a>
<a name="ln3328">}  // NOLINT(readability/fn_size)</a>
<a name="ln3329"> </a>
<a name="ln3330">/// Simple int comparison function for use with qsort()</a>
<a name="ln3331">static int int_cmp(const void *a, const void *b)</a>
<a name="ln3332">{</a>
<a name="ln3333">  return *(const int *)a - *(const int *)b;</a>
<a name="ln3334">}</a>
<a name="ln3335"> </a>
<a name="ln3336">/// Handle setting 'signcolumn' for value 'val'</a>
<a name="ln3337">///</a>
<a name="ln3338">/// @return OK when the value is valid, FAIL otherwise</a>
<a name="ln3339">int check_signcolumn(char_u *val)</a>
<a name="ln3340">{</a>
<a name="ln3341">  // check for basic match</a>
<a name="ln3342">  if (check_opt_strings(val, p_scl_values, false) == OK) {</a>
<a name="ln3343">    return OK;</a>
<a name="ln3344">  }</a>
<a name="ln3345"> </a>
<a name="ln3346">  // check for 'auto:&lt;NUMBER&gt;-&lt;NUMBER&gt;'</a>
<a name="ln3347">  if (STRLEN(val) == 8</a>
<a name="ln3348">      &amp;&amp; !STRNCMP(val, &quot;auto:&quot;, 5)</a>
<a name="ln3349">      &amp;&amp; ascii_isdigit(val[5])</a>
<a name="ln3350">      &amp;&amp; val[6] == '-'</a>
<a name="ln3351">      &amp;&amp; ascii_isdigit(val[7])</a>
<a name="ln3352">      ) {</a>
<a name="ln3353">    int min = val[5] - '0';</a>
<a name="ln3354">    int max = val[7] - '0';</a>
<a name="ln3355">    if (min &lt; 1 || max &lt; 2 || min &gt; 8 || max &gt; 9 || min &gt;= max) {</a>
<a name="ln3356">      return FAIL;</a>
<a name="ln3357">    }</a>
<a name="ln3358">    return OK;</a>
<a name="ln3359">  }</a>
<a name="ln3360"> </a>
<a name="ln3361">  return FAIL;</a>
<a name="ln3362">}</a>
<a name="ln3363"> </a>
<a name="ln3364">/// Handle setting 'colorcolumn' or 'textwidth' in window &quot;wp&quot;.</a>
<a name="ln3365">///</a>
<a name="ln3366">/// @return error message, NULL if it's OK.</a>
<a name="ln3367">char_u *check_colorcolumn(win_T *wp)</a>
<a name="ln3368">{</a>
<a name="ln3369">  char_u      *s;</a>
<a name="ln3370">  int col;</a>
<a name="ln3371">  unsigned int count = 0;</a>
<a name="ln3372">  int color_cols[256];</a>
<a name="ln3373">  int j = 0;</a>
<a name="ln3374"> </a>
<a name="ln3375">  if (wp-&gt;w_buffer == NULL) {</a>
<a name="ln3376">    return NULL;      // buffer was closed</a>
<a name="ln3377">  }</a>
<a name="ln3378"> </a>
<a name="ln3379">  for (s = wp-&gt;w_p_cc; *s != NUL &amp;&amp; count &lt; 255; ) {</a>
<a name="ln3380">    if (*s == '-' || *s == '+') {</a>
<a name="ln3381">      // -N and +N: add to 'textwidth'</a>
<a name="ln3382">      col = (*s == '-') ? -1 : 1;</a>
<a name="ln3383">      s++;</a>
<a name="ln3384">      if (!ascii_isdigit(*s)) {</a>
<a name="ln3385">        return e_invarg;</a>
<a name="ln3386">      }</a>
<a name="ln3387">      col = col * getdigits_int(&amp;s, true, 0);</a>
<a name="ln3388">      if (wp-&gt;w_buffer-&gt;b_p_tw == 0) {</a>
<a name="ln3389">        goto skip;          // 'textwidth' not set, skip this item</a>
<a name="ln3390">      }</a>
<a name="ln3391">      assert((col &gt;= 0</a>
<a name="ln3392">              &amp;&amp; wp-&gt;w_buffer-&gt;b_p_tw &lt;= INT_MAX - col</a>
<a name="ln3393">              &amp;&amp; wp-&gt;w_buffer-&gt;b_p_tw + col &gt;= INT_MIN)</a>
<a name="ln3394">             || (col &lt; 0</a>
<a name="ln3395">                 &amp;&amp; wp-&gt;w_buffer-&gt;b_p_tw &gt;= INT_MIN - col</a>
<a name="ln3396">                 &amp;&amp; wp-&gt;w_buffer-&gt;b_p_tw + col &lt;= INT_MAX));</a>
<a name="ln3397">      col += (int)wp-&gt;w_buffer-&gt;b_p_tw;</a>
<a name="ln3398">      if (col &lt; 0) {</a>
<a name="ln3399">        goto skip;</a>
<a name="ln3400">      }</a>
<a name="ln3401">    } else if (ascii_isdigit(*s)) {</a>
<a name="ln3402">      col = getdigits_int(&amp;s, true, 0);</a>
<a name="ln3403">    } else {</a>
<a name="ln3404">      return e_invarg;</a>
<a name="ln3405">    }</a>
<a name="ln3406">    color_cols[count++] = col - 1;      // 1-based to 0-based</a>
<a name="ln3407">skip:</a>
<a name="ln3408">    if (*s == NUL) {</a>
<a name="ln3409">      break;</a>
<a name="ln3410">    }</a>
<a name="ln3411">    if (*s != ',') {</a>
<a name="ln3412">      return e_invarg;</a>
<a name="ln3413">    }</a>
<a name="ln3414">    if (*++s == NUL) {</a>
<a name="ln3415">      return e_invarg;        // illegal trailing comma as in &quot;set cc=80,&quot;</a>
<a name="ln3416">    }</a>
<a name="ln3417">  }</a>
<a name="ln3418"> </a>
<a name="ln3419">  xfree(wp-&gt;w_p_cc_cols);</a>
<a name="ln3420">  if (count == 0) {</a>
<a name="ln3421">    wp-&gt;w_p_cc_cols = NULL;</a>
<a name="ln3422">  } else {</a>
<a name="ln3423">    wp-&gt;w_p_cc_cols = xmalloc(sizeof(int) * (count + 1));</a>
<a name="ln3424">    /* sort the columns for faster usage on screen redraw inside</a>
<a name="ln3425">     * win_line() */</a>
<a name="ln3426">    qsort(color_cols, count, sizeof(int), int_cmp);</a>
<a name="ln3427"> </a>
<a name="ln3428">    for (unsigned int i = 0; i &lt; count; i++) {</a>
<a name="ln3429">      // skip duplicates</a>
<a name="ln3430">      if (j == 0 || wp-&gt;w_p_cc_cols[j - 1] != color_cols[i]) {</a>
<a name="ln3431">        wp-&gt;w_p_cc_cols[j++] = color_cols[i];</a>
<a name="ln3432">      }</a>
<a name="ln3433">    }</a>
<a name="ln3434">    wp-&gt;w_p_cc_cols[j] = -1;        // end marker</a>
<a name="ln3435">  }</a>
<a name="ln3436"> </a>
<a name="ln3437">  return NULL;    // no error</a>
<a name="ln3438">}</a>
<a name="ln3439"> </a>
<a name="ln3440">void check_blending(win_T *wp)</a>
<a name="ln3441">{</a>
<a name="ln3442">  wp-&gt;w_grid_alloc.blending =</a>
<a name="ln3443">    wp-&gt;w_p_winbl &gt; 0 || (wp-&gt;w_floating &amp;&amp; wp-&gt;w_float_config.shadow);</a>
<a name="ln3444">}</a>
<a name="ln3445"> </a>
<a name="ln3446"> </a>
<a name="ln3447">/// Handle setting 'listchars' or 'fillchars'.</a>
<a name="ln3448">/// Assume monocell characters</a>
<a name="ln3449">///</a>
<a name="ln3450">/// @param varp either &amp;curwin-&gt;w_p_lcs or &amp;curwin-&gt;w_p_fcs</a>
<a name="ln3451">/// @return error message, NULL if it's OK.</a>
<a name="ln3452">static char_u *set_chars_option(win_T *wp, char_u **varp, bool set)</a>
<a name="ln3453">{</a>
<a name="ln3454">  int round, i, len, entries;</a>
<a name="ln3455">  char_u *p, *s;</a>
<a name="ln3456">  int c1;</a>
<a name="ln3457">  int c2 = 0;</a>
<a name="ln3458">  int c3 = 0;</a>
<a name="ln3459"> </a>
<a name="ln3460">  struct chars_tab {</a>
<a name="ln3461">    int     *cp;    ///&lt; char value</a>
<a name="ln3462">    char    *name;  ///&lt; char id</a>
<a name="ln3463">    int     def;    ///&lt; default value</a>
<a name="ln3464">  };</a>
<a name="ln3465">  struct chars_tab *tab;</a>
<a name="ln3466"> </a>
<a name="ln3467">  struct chars_tab fcs_tab[] = {</a>
<a name="ln3468">    { &amp;wp-&gt;w_p_fcs_chars.stl,     &quot;stl&quot;,      ' '  },</a>
<a name="ln3469">    { &amp;wp-&gt;w_p_fcs_chars.stlnc,   &quot;stlnc&quot;,    ' '  },</a>
<a name="ln3470">    { &amp;wp-&gt;w_p_fcs_chars.vert,    &quot;vert&quot;,     9474 },  // </a>
<a name="ln3471">    { &amp;wp-&gt;w_p_fcs_chars.fold,    &quot;fold&quot;,     183  },  // </a>
<a name="ln3472">    { &amp;wp-&gt;w_p_fcs_chars.foldopen,   &quot;foldopen&quot;,  '-'  },</a>
<a name="ln3473">    { &amp;wp-&gt;w_p_fcs_chars.foldclosed, &quot;foldclose&quot;, '+'  },</a>
<a name="ln3474">    { &amp;wp-&gt;w_p_fcs_chars.foldsep,    &quot;foldsep&quot;,   9474 },  // </a>
<a name="ln3475">    { &amp;wp-&gt;w_p_fcs_chars.diff,    &quot;diff&quot;,     '-'  },</a>
<a name="ln3476">    { &amp;wp-&gt;w_p_fcs_chars.msgsep,  &quot;msgsep&quot;,   ' '  },</a>
<a name="ln3477">    { &amp;wp-&gt;w_p_fcs_chars.eob,     &quot;eob&quot;,      '~'  },</a>
<a name="ln3478">  };</a>
<a name="ln3479">  struct chars_tab lcs_tab[] = {</a>
<a name="ln3480">    { &amp;wp-&gt;w_p_lcs_chars.eol,     &quot;eol&quot;,      NUL  },</a>
<a name="ln3481">    { &amp;wp-&gt;w_p_lcs_chars.ext,     &quot;extends&quot;,  NUL  },</a>
<a name="ln3482">    { &amp;wp-&gt;w_p_lcs_chars.nbsp,    &quot;nbsp&quot;,     NUL  },</a>
<a name="ln3483">    { &amp;wp-&gt;w_p_lcs_chars.prec,    &quot;precedes&quot;, NUL  },</a>
<a name="ln3484">    { &amp;wp-&gt;w_p_lcs_chars.space,   &quot;space&quot;,    NUL  },</a>
<a name="ln3485">    { &amp;wp-&gt;w_p_lcs_chars.tab2,    &quot;tab&quot;,      NUL  },</a>
<a name="ln3486">    { &amp;wp-&gt;w_p_lcs_chars.lead,    &quot;lead&quot;,     NUL  },</a>
<a name="ln3487">    { &amp;wp-&gt;w_p_lcs_chars.trail,   &quot;trail&quot;,    NUL  },</a>
<a name="ln3488">    { &amp;wp-&gt;w_p_lcs_chars.conceal, &quot;conceal&quot;,  NUL  },</a>
<a name="ln3489">  };</a>
<a name="ln3490"> </a>
<a name="ln3491">  if (varp == &amp;p_lcs || varp == &amp;wp-&gt;w_p_lcs) {</a>
<a name="ln3492">    tab = lcs_tab;</a>
<a name="ln3493">    entries = ARRAY_SIZE(lcs_tab);</a>
<a name="ln3494">    if (varp == &amp;wp-&gt;w_p_lcs &amp;&amp; wp-&gt;w_p_lcs[0] == NUL) {</a>
<a name="ln3495">      varp = &amp;p_lcs;</a>
<a name="ln3496">    }</a>
<a name="ln3497">  } else {</a>
<a name="ln3498">    tab = fcs_tab;</a>
<a name="ln3499">    entries = ARRAY_SIZE(fcs_tab);</a>
<a name="ln3500">    if (varp == &amp;wp-&gt;w_p_fcs &amp;&amp; wp-&gt;w_p_fcs[0] == NUL) {</a>
<a name="ln3501">      varp = &amp;p_fcs;</a>
<a name="ln3502">    }</a>
<a name="ln3503">    if (*p_ambw == 'd') {</a>
<a name="ln3504">      // XXX: If ambiwidth=double then &quot;|&quot; and &quot;&quot; take 2 columns, which is</a>
<a name="ln3505">      // forbidden (TUI limitation?). Set old defaults.</a>
<a name="ln3506">      fcs_tab[2].def = '|';</a>
<a name="ln3507">      fcs_tab[6].def = '|';</a>
<a name="ln3508">      fcs_tab[3].def = '-';</a>
<a name="ln3509">    } else {</a>
<a name="ln3510">      fcs_tab[2].def = 9474;  // </a>
<a name="ln3511">      fcs_tab[6].def = 9474;  // </a>
<a name="ln3512">      fcs_tab[3].def = 183;   // </a>
<a name="ln3513">    }</a>
<a name="ln3514">  }</a>
<a name="ln3515"> </a>
<a name="ln3516">  // first round: check for valid value, second round: assign values</a>
<a name="ln3517">  for (round = 0; round &lt;= (set ? 1 : 0); round++) {</a>
<a name="ln3518">    if (round &gt; 0) {</a>
<a name="ln3519">      // After checking that the value is valid: set defaults</a>
<a name="ln3520">      for (i = 0; i &lt; entries; i++) {</a>
<a name="ln3521">        if (tab[i].cp != NULL) {</a>
<a name="ln3522">          *(tab[i].cp) = tab[i].def;</a>
<a name="ln3523">        }</a>
<a name="ln3524">      }</a>
<a name="ln3525">      if (varp == &amp;p_lcs || varp == &amp;wp-&gt;w_p_lcs) {</a>
<a name="ln3526">        wp-&gt;w_p_lcs_chars.tab1 = NUL;</a>
<a name="ln3527">        wp-&gt;w_p_lcs_chars.tab3 = NUL;</a>
<a name="ln3528">      }</a>
<a name="ln3529">    }</a>
<a name="ln3530">    p = *varp;</a>
<a name="ln3531">    while (*p) {</a>
<a name="ln3532">      for (i = 0; i &lt; entries; i++) {</a>
<a name="ln3533">        len = (int)STRLEN(tab[i].name);</a>
<a name="ln3534">        if (STRNCMP(p, tab[i].name, len) == 0</a>
<a name="ln3535">            &amp;&amp; p[len] == ':'</a>
<a name="ln3536">            &amp;&amp; p[len + 1] != NUL) {</a>
<a name="ln3537">          c2 = c3 = 0;</a>
<a name="ln3538">          s = p + len + 1;</a>
<a name="ln3539"> </a>
<a name="ln3540">          // TODO(bfredl): use schar_T representation and utfc_ptr2len</a>
<a name="ln3541">          int c1len = utf_ptr2len(s);</a>
<a name="ln3542">          c1 = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln3543">          if (mb_char2cells(c1) &gt; 1 || (c1len == 1 &amp;&amp; c1 &gt; 127)) {</a>
<a name="ln3544">            continue;</a>
<a name="ln3545">          }</a>
<a name="ln3546">          if (tab[i].cp == &amp;wp-&gt;w_p_lcs_chars.tab2) {</a>
<a name="ln3547">            if (*s == NUL) {</a>
<a name="ln3548">              continue;</a>
<a name="ln3549">            }</a>
<a name="ln3550">            int c2len = utf_ptr2len(s);</a>
<a name="ln3551">            c2 = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln3552">            if (mb_char2cells(c2) &gt; 1 || (c2len == 1 &amp;&amp; c2 &gt; 127)) {</a>
<a name="ln3553">              continue;</a>
<a name="ln3554">            }</a>
<a name="ln3555">            if (!(*s == ',' || *s == NUL)) {</a>
<a name="ln3556">              int c3len = utf_ptr2len(s);</a>
<a name="ln3557">              c3 = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln3558">              if (mb_char2cells(c3) &gt; 1 || (c3len == 1 &amp;&amp; c3 &gt; 127)) {</a>
<a name="ln3559">                continue;</a>
<a name="ln3560">              }</a>
<a name="ln3561">            }</a>
<a name="ln3562">          }</a>
<a name="ln3563">          if (*s == ',' || *s == NUL) {</a>
<a name="ln3564">            if (round) {</a>
<a name="ln3565">              if (tab[i].cp == &amp;wp-&gt;w_p_lcs_chars.tab2) {</a>
<a name="ln3566">                wp-&gt;w_p_lcs_chars.tab1 = c1;</a>
<a name="ln3567">                wp-&gt;w_p_lcs_chars.tab2 = c2;</a>
<a name="ln3568">                wp-&gt;w_p_lcs_chars.tab3 = c3;</a>
<a name="ln3569">              } else if (tab[i].cp != NULL) {</a>
<a name="ln3570">                *(tab[i].cp) = c1;</a>
<a name="ln3571">              }</a>
<a name="ln3572">            }</a>
<a name="ln3573">            p = s;</a>
<a name="ln3574">            break;</a>
<a name="ln3575">          }</a>
<a name="ln3576">        }</a>
<a name="ln3577">      }</a>
<a name="ln3578"> </a>
<a name="ln3579">      if (i == entries) {</a>
<a name="ln3580">        return e_invarg;</a>
<a name="ln3581">      }</a>
<a name="ln3582">      if (*p == ',') {</a>
<a name="ln3583">        p++;</a>
<a name="ln3584">      }</a>
<a name="ln3585">    }</a>
<a name="ln3586">  }</a>
<a name="ln3587"> </a>
<a name="ln3588">  return NULL;          // no error</a>
<a name="ln3589">}</a>
<a name="ln3590"> </a>
<a name="ln3591">/// Check validity of options with the 'statusline' format.</a>
<a name="ln3592">/// Return error message or NULL.</a>
<a name="ln3593">char_u *check_stl_option(char_u *s)</a>
<a name="ln3594">{</a>
<a name="ln3595">  int groupdepth = 0;</a>
<a name="ln3596">  static char_u errbuf[80];</a>
<a name="ln3597"> </a>
<a name="ln3598">  while (*s) {</a>
<a name="ln3599">    // Check for valid keys after % sequences</a>
<a name="ln3600">    while (*s &amp;&amp; *s != '%') {</a>
<a name="ln3601">      s++;</a>
<a name="ln3602">    }</a>
<a name="ln3603">    if (!*s) {</a>
<a name="ln3604">      break;</a>
<a name="ln3605">    }</a>
<a name="ln3606">    s++;</a>
<a name="ln3607">    if (*s == '%' || *s == STL_TRUNCMARK || *s == STL_SEPARATE) {</a>
<a name="ln3608">      s++;</a>
<a name="ln3609">      continue;</a>
<a name="ln3610">    }</a>
<a name="ln3611">    if (*s == ')') {</a>
<a name="ln3612">      s++;</a>
<a name="ln3613">      if (--groupdepth &lt; 0) {</a>
<a name="ln3614">        break;</a>
<a name="ln3615">      }</a>
<a name="ln3616">      continue;</a>
<a name="ln3617">    }</a>
<a name="ln3618">    if (*s == '-') {</a>
<a name="ln3619">      s++;</a>
<a name="ln3620">    }</a>
<a name="ln3621">    while (ascii_isdigit(*s)) {</a>
<a name="ln3622">      s++;</a>
<a name="ln3623">    }</a>
<a name="ln3624">    if (*s == STL_USER_HL) {</a>
<a name="ln3625">      continue;</a>
<a name="ln3626">    }</a>
<a name="ln3627">    if (*s == '.') {</a>
<a name="ln3628">      s++;</a>
<a name="ln3629">      while (*s &amp;&amp; ascii_isdigit(*s))</a>
<a name="ln3630">        s++;</a>
<a name="ln3631">    }</a>
<a name="ln3632">    if (*s == '(') {</a>
<a name="ln3633">      groupdepth++;</a>
<a name="ln3634">      continue;</a>
<a name="ln3635">    }</a>
<a name="ln3636">    if (vim_strchr(STL_ALL, *s) == NULL) {</a>
<a name="ln3637">      return illegal_char(errbuf, sizeof(errbuf), *s);</a>
<a name="ln3638">    }</a>
<a name="ln3639">    if (*s == '{') {</a>
<a name="ln3640">      s++;</a>
<a name="ln3641">      while (*s != '}' &amp;&amp; *s)</a>
<a name="ln3642">        s++;</a>
<a name="ln3643">      if (*s != '}') {</a>
<a name="ln3644">        return (char_u *)N_(&quot;E540: Unclosed expression sequence&quot;);</a>
<a name="ln3645">      }</a>
<a name="ln3646">    }</a>
<a name="ln3647">  }</a>
<a name="ln3648">  if (groupdepth != 0) {</a>
<a name="ln3649">    return (char_u *)N_(&quot;E542: unbalanced groups&quot;);</a>
<a name="ln3650">  }</a>
<a name="ln3651">  return NULL;</a>
<a name="ln3652">}</a>
<a name="ln3653"> </a>
<a name="ln3654">static char_u *did_set_spell_option(bool is_spellfile)</a>
<a name="ln3655">{</a>
<a name="ln3656">  char_u  *errmsg = NULL;</a>
<a name="ln3657"> </a>
<a name="ln3658">  if (is_spellfile) {</a>
<a name="ln3659">    int l = (int)STRLEN(curwin-&gt;w_s-&gt;b_p_spf);</a>
<a name="ln3660">    if (l &gt; 0</a>
<a name="ln3661">        &amp;&amp; (l &lt; 4 || STRCMP(curwin-&gt;w_s-&gt;b_p_spf + l - 4, &quot;.add&quot;) != 0)) {</a>
<a name="ln3662">      errmsg = e_invarg;</a>
<a name="ln3663">    }</a>
<a name="ln3664">  }</a>
<a name="ln3665"> </a>
<a name="ln3666">  if (errmsg == NULL) {</a>
<a name="ln3667">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln3668">      if (wp-&gt;w_buffer == curbuf &amp;&amp; wp-&gt;w_p_spell) {</a>
<a name="ln3669">        errmsg = did_set_spelllang(wp);</a>
<a name="ln3670">        break;</a>
<a name="ln3671">      }</a>
<a name="ln3672">    }</a>
<a name="ln3673">  }</a>
<a name="ln3674"> </a>
<a name="ln3675">  return errmsg;</a>
<a name="ln3676">}</a>
<a name="ln3677"> </a>
<a name="ln3678">/// Set curbuf-&gt;b_cap_prog to the regexp program for 'spellcapcheck'.</a>
<a name="ln3679">/// Return error message when failed, NULL when OK.</a>
<a name="ln3680">static char_u *compile_cap_prog(synblock_T *synblock)</a>
<a name="ln3681">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3682">{</a>
<a name="ln3683">  regprog_T   *rp = synblock-&gt;b_cap_prog;</a>
<a name="ln3684">  char_u      *re;</a>
<a name="ln3685"> </a>
<a name="ln3686">  if (synblock-&gt;b_p_spc == NULL || *synblock-&gt;b_p_spc == NUL) {</a>
<a name="ln3687">    synblock-&gt;b_cap_prog = NULL;</a>
<a name="ln3688">  } else {</a>
<a name="ln3689">    // Prepend a ^ so that we only match at one column</a>
<a name="ln3690">    re = concat_str((char_u *)&quot;^&quot;, synblock-&gt;b_p_spc);</a>
<a name="ln3691">    synblock-&gt;b_cap_prog = vim_regcomp(re, RE_MAGIC);</a>
<a name="ln3692">    xfree(re);</a>
<a name="ln3693">    if (synblock-&gt;b_cap_prog == NULL) {</a>
<a name="ln3694">      synblock-&gt;b_cap_prog = rp;         // restore the previous program</a>
<a name="ln3695">      return e_invarg;</a>
<a name="ln3696">    }</a>
<a name="ln3697">  }</a>
<a name="ln3698"> </a>
<a name="ln3699">  vim_regfree(rp);</a>
<a name="ln3700">  return NULL;</a>
<a name="ln3701">}</a>
<a name="ln3702"> </a>
<a name="ln3703">/// Handle setting `winhighlight' in window &quot;wp&quot;</a>
<a name="ln3704">static bool parse_winhl_opt(win_T *wp)</a>
<a name="ln3705">{</a>
<a name="ln3706">  int w_hl_id_normal = 0;</a>
<a name="ln3707">  int w_hl_ids[HLF_COUNT] = { 0 };</a>
<a name="ln3708">  int hlf;</a>
<a name="ln3709"> </a>
<a name="ln3710">  const char *p = (const char *)wp-&gt;w_p_winhl;</a>
<a name="ln3711">  while (*p) {</a>
<a name="ln3712">    char *colon = strchr(p, ':');</a>
<a name="ln3713">    if (!colon) {</a>
<a name="ln3714">      return false;</a>
<a name="ln3715">    }</a>
<a name="ln3716">    size_t nlen = (size_t)(colon-p);</a>
<a name="ln3717">    char *hi = colon+1;</a>
<a name="ln3718">    char *commap = xstrchrnul(hi, ',');</a>
<a name="ln3719">    int len = (int)(commap-hi);</a>
<a name="ln3720">    int hl_id = len ? syn_check_group((char_u *)hi, len) : -1;</a>
<a name="ln3721"> </a>
<a name="ln3722">    if (strncmp(&quot;Normal&quot;, p, nlen) == 0) {</a>
<a name="ln3723">      w_hl_id_normal = hl_id;</a>
<a name="ln3724">    } else {</a>
<a name="ln3725">      for (hlf = 0; hlf &lt; (int)HLF_COUNT; hlf++) {</a>
<a name="ln3726">        if (strlen(hlf_names[hlf]) == nlen</a>
<a name="ln3727">            &amp;&amp; strncmp(hlf_names[hlf], p, nlen) == 0) {</a>
<a name="ln3728">          w_hl_ids[hlf] = hl_id;</a>
<a name="ln3729">          break;</a>
<a name="ln3730">        }</a>
<a name="ln3731">      }</a>
<a name="ln3732">      if (hlf == HLF_COUNT) {</a>
<a name="ln3733">        return false;</a>
<a name="ln3734">      }</a>
<a name="ln3735">    }</a>
<a name="ln3736"> </a>
<a name="ln3737">    p = *commap ? commap+1 : &quot;&quot;;</a>
<a name="ln3738">  }</a>
<a name="ln3739"> </a>
<a name="ln3740">  wp-&gt;w_hl_id_normal = w_hl_id_normal;</a>
<a name="ln3741">  memcpy(wp-&gt;w_hl_ids, w_hl_ids, sizeof(w_hl_ids));</a>
<a name="ln3742">  wp-&gt;w_hl_needs_update = true;</a>
<a name="ln3743">  return true;</a>
<a name="ln3744">}</a>
<a name="ln3745"> </a>
<a name="ln3746">// Set the script_ctx for an option, taking care of setting the buffer- or</a>
<a name="ln3747">// window-local value.</a>
<a name="ln3748">static void set_option_sctx_idx(int opt_idx, int opt_flags, sctx_T script_ctx)</a>
<a name="ln3749">{</a>
<a name="ln3750">  int both = (opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0;</a>
<a name="ln3751">  int indir = (int)options[opt_idx].indir;</a>
<a name="ln3752">  const LastSet last_set = {</a>
<a name="ln3753">    .script_ctx = {</a>
<a name="ln3754">      script_ctx.sc_sid,</a>
<a name="ln3755">      script_ctx.sc_seq,</a>
<a name="ln3756">      script_ctx.sc_lnum + sourcing_lnum</a>
<a name="ln3757">    },</a>
<a name="ln3758">    current_channel_id</a>
<a name="ln3759">  };</a>
<a name="ln3760"> </a>
<a name="ln3761">  // Remember where the option was set.  For local options need to do that</a>
<a name="ln3762">  // in the buffer or window structure.</a>
<a name="ln3763">  if (both || (opt_flags &amp; OPT_GLOBAL) || (indir &amp; (PV_BUF|PV_WIN)) == 0) {</a>
<a name="ln3764">    options[opt_idx].last_set = last_set;</a>
<a name="ln3765">  }</a>
<a name="ln3766">  if (both || (opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln3767">    if (indir &amp; PV_BUF) {</a>
<a name="ln3768">      curbuf-&gt;b_p_script_ctx[indir &amp; PV_MASK] = last_set;</a>
<a name="ln3769">    } else if (indir &amp; PV_WIN) {</a>
<a name="ln3770">      curwin-&gt;w_p_script_ctx[indir &amp; PV_MASK] = last_set;</a>
<a name="ln3771">    }</a>
<a name="ln3772">  }</a>
<a name="ln3773">}</a>
<a name="ln3774"> </a>
<a name="ln3775">/// Set the value of a boolean option, taking care of side effects</a>
<a name="ln3776">///</a>
<a name="ln3777">/// @param[in]  opt_idx  Option index in options[] table.</a>
<a name="ln3778">/// @param[out]  varp  Pointer to the option variable.</a>
<a name="ln3779">/// @param[in]  value  New value.</a>
<a name="ln3780">/// @param[in]  opt_flags  OPT_LOCAL and/or OPT_GLOBAL.</a>
<a name="ln3781">///</a>
<a name="ln3782">/// @return NULL on success, error message on error.</a>
<a name="ln3783">static char *set_bool_option(const int opt_idx, char_u *const varp,</a>
<a name="ln3784">                             const int value,</a>
<a name="ln3785">                             const int opt_flags)</a>
<a name="ln3786">{</a>
<a name="ln3787">  int old_value = *(int *)varp;</a>
<a name="ln3788"> </a>
<a name="ln3789">  // Disallow changing some options from secure mode</a>
<a name="ln3790">  if ((secure || sandbox != 0)</a>
<a name="ln3791">      &amp;&amp; (options[opt_idx].flags &amp; P_SECURE)) {</a>
<a name="ln3792">    return (char *)e_secure;</a>
<a name="ln3793">  }</a>
<a name="ln3794"> </a>
<a name="ln3795">  *(int *)varp = value;             // set the new value</a>
<a name="ln3796">  // Remember where the option was set.</a>
<a name="ln3797">  set_option_sctx_idx(opt_idx, opt_flags, current_sctx);</a>
<a name="ln3798"> </a>
<a name="ln3799"> </a>
<a name="ln3800">  // May set global value for local option.</a>
<a name="ln3801">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln3802">    *(int *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL) = value;</a>
<a name="ln3803">  }</a>
<a name="ln3804"> </a>
<a name="ln3805">  // Ensure that options set to p_force_on cannot be disabled.</a>
<a name="ln3806">  if ((int *)varp == &amp;p_force_on &amp;&amp; p_force_on == false) {</a>
<a name="ln3807">    p_force_on = true;</a>
<a name="ln3808">    return (char *)e_unsupportedoption;</a>
<a name="ln3809">  // Ensure that options set to p_force_off cannot be enabled.</a>
<a name="ln3810">  } else if ((int *)varp == &amp;p_force_off &amp;&amp; p_force_off == true) {</a>
<a name="ln3811">    p_force_off = false;</a>
<a name="ln3812">    return (char *)e_unsupportedoption;</a>
<a name="ln3813">  } else if ((int *)varp == &amp;p_lrm) {</a>
<a name="ln3814">    // 'langremap' -&gt; !'langnoremap'</a>
<a name="ln3815">    p_lnr = !p_lrm;</a>
<a name="ln3816">  } else if ((int *)varp == &amp;p_lnr) {</a>
<a name="ln3817">    // 'langnoremap' -&gt; !'langremap'</a>
<a name="ln3818">    p_lrm = !p_lnr;</a>
<a name="ln3819">  } else if ((int *)varp == &amp;curwin-&gt;w_p_cul &amp;&amp; !value &amp;&amp; old_value) {</a>
<a name="ln3820">    // 'cursorline'</a>
<a name="ln3821">    reset_cursorline();</a>
<a name="ln3822">  // 'undofile'</a>
<a name="ln3823">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_udf || (int *)varp == &amp;p_udf) {</a>
<a name="ln3824">    // Only take action when the option was set. When reset we do not</a>
<a name="ln3825">    // delete the undo file, the option may be set again without making</a>
<a name="ln3826">    // any changes in between.</a>
<a name="ln3827">    if (curbuf-&gt;b_p_udf || p_udf) {</a>
<a name="ln3828">      char_u hash[UNDO_HASH_SIZE];</a>
<a name="ln3829">      buf_T       *save_curbuf = curbuf;</a>
<a name="ln3830"> </a>
<a name="ln3831">      FOR_ALL_BUFFERS(bp) {</a>
<a name="ln3832">        curbuf = bp;</a>
<a name="ln3833">        // When 'undofile' is set globally: for every buffer, otherwise</a>
<a name="ln3834">        // only for the current buffer: Try to read in the undofile,</a>
<a name="ln3835">        // if one exists, the buffer wasn't changed and the buffer was</a>
<a name="ln3836">        // loaded</a>
<a name="ln3837">        if ((curbuf == save_curbuf</a>
<a name="ln3838">             || (opt_flags &amp; OPT_GLOBAL) || opt_flags == 0)</a>
<a name="ln3839">            &amp;&amp; !curbufIsChanged() &amp;&amp; curbuf-&gt;b_ml.ml_mfp != NULL) {</a>
<a name="ln3840">          u_compute_hash(hash);</a>
<a name="ln3841">          u_read_undo(NULL, hash, curbuf-&gt;b_fname);</a>
<a name="ln3842">        }</a>
<a name="ln3843">      }</a>
<a name="ln3844">      curbuf = save_curbuf;</a>
<a name="ln3845">    }</a>
<a name="ln3846">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_ro) {</a>
<a name="ln3847">    // when 'readonly' is reset globally, also reset readonlymode</a>
<a name="ln3848">    if (!curbuf-&gt;b_p_ro &amp;&amp; (opt_flags &amp; OPT_LOCAL) == 0) {</a>
<a name="ln3849">      readonlymode = false;</a>
<a name="ln3850">    }</a>
<a name="ln3851"> </a>
<a name="ln3852">    // when 'readonly' is set may give W10 again</a>
<a name="ln3853">    if (curbuf-&gt;b_p_ro) {</a>
<a name="ln3854">      curbuf-&gt;b_did_warn = false;</a>
<a name="ln3855">    }</a>
<a name="ln3856"> </a>
<a name="ln3857">    redraw_titles();</a>
<a name="ln3858">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_ma) {</a>
<a name="ln3859">    // when 'modifiable' is changed, redraw the window title</a>
<a name="ln3860">    redraw_titles();</a>
<a name="ln3861">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_eol) {</a>
<a name="ln3862">    // when 'endofline' is changed, redraw the window title</a>
<a name="ln3863">    redraw_titles();</a>
<a name="ln3864">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_fixeol) {</a>
<a name="ln3865">    // when 'fixeol' is changed, redraw the window title</a>
<a name="ln3866">    redraw_titles();</a>
<a name="ln3867">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_bomb) {</a>
<a name="ln3868">    // when 'bomb' is changed, redraw the window title and tab page text</a>
<a name="ln3869">    redraw_titles();</a>
<a name="ln3870">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_bin) {</a>
<a name="ln3871">    // when 'bin' is set also set some other options</a>
<a name="ln3872">    set_options_bin(old_value, curbuf-&gt;b_p_bin, opt_flags);</a>
<a name="ln3873">    redraw_titles();</a>
<a name="ln3874">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_bl &amp;&amp; old_value != curbuf-&gt;b_p_bl) {</a>
<a name="ln3875">    // when 'buflisted' changes, trigger autocommands</a>
<a name="ln3876">    apply_autocmds(curbuf-&gt;b_p_bl ? EVENT_BUFADD : EVENT_BUFDELETE,</a>
<a name="ln3877">                   NULL, NULL, true, curbuf);</a>
<a name="ln3878">  } else if ((int *)varp == (int *)&amp;curbuf-&gt;b_p_swf) {</a>
<a name="ln3879">    // when 'swf' is set, create swapfile, when reset remove swapfile</a>
<a name="ln3880">    if (curbuf-&gt;b_p_swf &amp;&amp; p_uc) {</a>
<a name="ln3881">      ml_open_file(curbuf);                     // create the swap file</a>
<a name="ln3882">    } else {</a>
<a name="ln3883">      // no need to reset curbuf-&gt;b_may_swap, ml_open_file() will check</a>
<a name="ln3884">      // buf-&gt;b_p_swf</a>
<a name="ln3885">      mf_close_file(curbuf, true);              // remove the swap file</a>
<a name="ln3886">    }</a>
<a name="ln3887">  } else if ((int *)varp == &amp;p_terse) {</a>
<a name="ln3888">    // when 'terse' is set change 'shortmess'</a>
<a name="ln3889">    char_u  *p;</a>
<a name="ln3890"> </a>
<a name="ln3891">    p = vim_strchr(p_shm, SHM_SEARCH);</a>
<a name="ln3892"> </a>
<a name="ln3893">    // insert 's' in p_shm</a>
<a name="ln3894">    if (p_terse &amp;&amp; p == NULL) {</a>
<a name="ln3895">      STRCPY(IObuff, p_shm);</a>
<a name="ln3896">      STRCAT(IObuff, &quot;s&quot;);</a>
<a name="ln3897">      set_string_option_direct(&quot;shm&quot;, -1, IObuff, OPT_FREE, 0);</a>
<a name="ln3898">    } else if (!p_terse &amp;&amp; p != NULL) {  // remove 's' from p_shm</a>
<a name="ln3899">      STRMOVE(p, p + 1);</a>
<a name="ln3900">    }</a>
<a name="ln3901">  } else if ((int *)varp == &amp;p_paste) {</a>
<a name="ln3902">    // when 'paste' is set or reset also change other options</a>
<a name="ln3903">    paste_option_changed();</a>
<a name="ln3904">  } else if ((int *)varp == &amp;p_im) {</a>
<a name="ln3905">    // when 'insertmode' is set from an autocommand need to do work here</a>
<a name="ln3906">    if (p_im) {</a>
<a name="ln3907">      if ((State &amp; INSERT) == 0) {</a>
<a name="ln3908">        need_start_insertmode = true;</a>
<a name="ln3909">      }</a>
<a name="ln3910">      stop_insert_mode = false;</a>
<a name="ln3911">    } else if (old_value) {  // only reset if it was set previously</a>
<a name="ln3912">      need_start_insertmode = false;</a>
<a name="ln3913">      stop_insert_mode = true;</a>
<a name="ln3914">      if (restart_edit != 0 &amp;&amp; mode_displayed) {</a>
<a name="ln3915">        clear_cmdline = true;  // remove &quot;(insert)&quot;</a>
<a name="ln3916">      }</a>
<a name="ln3917">      restart_edit = 0;</a>
<a name="ln3918">    }</a>
<a name="ln3919">  } else if ((int *)varp == &amp;p_ic &amp;&amp; p_hls) {</a>
<a name="ln3920">    // when 'ignorecase' is set or reset and 'hlsearch' is set, redraw</a>
<a name="ln3921">    redraw_all_later(SOME_VALID);</a>
<a name="ln3922">  } else if ((int *)varp == &amp;p_hls) {</a>
<a name="ln3923">    // when 'hlsearch' is set or reset: reset no_hlsearch</a>
<a name="ln3924">    set_no_hlsearch(false);</a>
<a name="ln3925">  } else if ((int *)varp == &amp;curwin-&gt;w_p_scb) {</a>
<a name="ln3926">  // when 'scrollbind' is set: snapshot the current position to avoid a jump</a>
<a name="ln3927">  // at the end of normal_cmd()</a>
<a name="ln3928">    if (curwin-&gt;w_p_scb) {</a>
<a name="ln3929">      do_check_scrollbind(false);</a>
<a name="ln3930">      curwin-&gt;w_scbind_pos = curwin-&gt;w_topline;</a>
<a name="ln3931">    }</a>
<a name="ln3932">  } else if ((int *)varp == &amp;curwin-&gt;w_p_pvw) {</a>
<a name="ln3933">    // There can be only one window with 'previewwindow' set.</a>
<a name="ln3934">    if (curwin-&gt;w_p_pvw) {</a>
<a name="ln3935">      FOR_ALL_WINDOWS_IN_TAB(win, curtab) {</a>
<a name="ln3936">        if (win-&gt;w_p_pvw &amp;&amp; win != curwin) {</a>
<a name="ln3937">          curwin-&gt;w_p_pvw = false;</a>
<a name="ln3938">          return N_(&quot;E590: A preview window already exists&quot;);</a>
<a name="ln3939">        }</a>
<a name="ln3940">      }</a>
<a name="ln3941">    }</a>
<a name="ln3942">  } else if (varp == (char_u *)&amp;(curbuf-&gt;b_p_lisp)) {</a>
<a name="ln3943">    // When 'lisp' option changes include/exclude '-' in</a>
<a name="ln3944">    // keyword characters.</a>
<a name="ln3945">    (void)buf_init_chartab(curbuf, false);          // ignore errors</a>
<a name="ln3946">  } else if ((int *)varp == &amp;p_title) {</a>
<a name="ln3947">    // when 'title' changed, may need to change the title; same for 'icon'</a>
<a name="ln3948">    did_set_title();</a>
<a name="ln3949">  } else if ((int *)varp == &amp;p_icon) {</a>
<a name="ln3950">    did_set_title();</a>
<a name="ln3951">  } else if ((int *)varp == &amp;curbuf-&gt;b_changed) {</a>
<a name="ln3952">    if (!value) {</a>
<a name="ln3953">      save_file_ff(curbuf);             // Buffer is unchanged</a>
<a name="ln3954">    }</a>
<a name="ln3955">    redraw_titles();</a>
<a name="ln3956">    modified_was_set = value;</a>
<a name="ln3957">  }</a>
<a name="ln3958"> </a>
<a name="ln3959">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3960">  else if ((int *)varp == &amp;p_ssl) {</a>
<a name="ln3961">    if (p_ssl) {</a>
<a name="ln3962">      psepc = '/';</a>
<a name="ln3963">      psepcN = '\\';</a>
<a name="ln3964">      pseps[0] = '/';</a>
<a name="ln3965">    } else {</a>
<a name="ln3966">      psepc = '\\';</a>
<a name="ln3967">      psepcN = '/';</a>
<a name="ln3968">      pseps[0] = '\\';</a>
<a name="ln3969">    }</a>
<a name="ln3970"> </a>
<a name="ln3971">    // need to adjust the file name arguments and buffer names.</a>
<a name="ln3972">    buflist_slash_adjust();</a>
<a name="ln3973">    alist_slash_adjust();</a>
<a name="ln3974">    scriptnames_slash_adjust();</a>
<a name="ln3975">  }</a>
<a name="ln3976">#endif</a>
<a name="ln3977">  else if ((int *)varp == &amp;curwin-&gt;w_p_wrap) {</a>
<a name="ln3978">    // If 'wrap' is set, set w_leftcol to zero.</a>
<a name="ln3979">    if (curwin-&gt;w_p_wrap) {</a>
<a name="ln3980">      curwin-&gt;w_leftcol = 0;</a>
<a name="ln3981">    }</a>
<a name="ln3982">  } else if ((int *)varp == &amp;p_ea) {</a>
<a name="ln3983">    if (p_ea &amp;&amp; !old_value) {</a>
<a name="ln3984">      win_equal(curwin, false, 0);</a>
<a name="ln3985">    }</a>
<a name="ln3986">  } else if ((int *)varp == &amp;p_acd) {</a>
<a name="ln3987">    // Change directories when the 'acd' option is set now.</a>
<a name="ln3988">    do_autochdir();</a>
<a name="ln3989">  } else if ((int *)varp == &amp;curwin-&gt;w_p_diff) {  // 'diff'</a>
<a name="ln3990">    // May add or remove the buffer from the list of diff buffers.</a>
<a name="ln3991">    diff_buf_adjust(curwin);</a>
<a name="ln3992">    if (foldmethodIsDiff(curwin)) {</a>
<a name="ln3993">      foldUpdateAll(curwin);</a>
<a name="ln3994">    }</a>
<a name="ln3995">  } else if ((int *)varp == &amp;curwin-&gt;w_p_spell) {  // 'spell'</a>
<a name="ln3996">    if (curwin-&gt;w_p_spell) {</a>
<a name="ln3997">      char_u      *errmsg = did_set_spelllang(curwin);</a>
<a name="ln3998">      if (errmsg != NULL) {</a>
<a name="ln3999">        EMSG(_(errmsg));</a>
<a name="ln4000">      }</a>
<a name="ln4001">    }</a>
<a name="ln4002">  }</a>
<a name="ln4003"> </a>
<a name="ln4004">  if ((int *)varp == &amp;curwin-&gt;w_p_arab) {</a>
<a name="ln4005">    if (curwin-&gt;w_p_arab) {</a>
<a name="ln4006">      /*</a>
<a name="ln4007">       * 'arabic' is set, handle various sub-settings.</a>
<a name="ln4008">       */</a>
<a name="ln4009">      if (!p_tbidi) {</a>
<a name="ln4010">        // set rightleft mode</a>
<a name="ln4011">        if (!curwin-&gt;w_p_rl) {</a>
<a name="ln4012">          curwin-&gt;w_p_rl = true;</a>
<a name="ln4013">          changed_window_setting();</a>
<a name="ln4014">        }</a>
<a name="ln4015"> </a>
<a name="ln4016">        // Enable Arabic shaping (major part of what Arabic requires)</a>
<a name="ln4017">        if (!p_arshape) {</a>
<a name="ln4018">          p_arshape = true;</a>
<a name="ln4019">          redraw_all_later(NOT_VALID);</a>
<a name="ln4020">        }</a>
<a name="ln4021">      }</a>
<a name="ln4022"> </a>
<a name="ln4023">      /* Arabic requires a utf-8 encoding, inform the user if its not</a>
<a name="ln4024">       * set. */</a>
<a name="ln4025">      if (STRCMP(p_enc, &quot;utf-8&quot;) != 0) {</a>
<a name="ln4026">        static char *w_arabic = N_(</a>
<a name="ln4027">            &quot;W17: Arabic requires UTF-8, do ':set encoding=utf-8'&quot;);</a>
<a name="ln4028"> </a>
<a name="ln4029">        msg_source(HL_ATTR(HLF_W));</a>
<a name="ln4030">        msg_attr(_(w_arabic), HL_ATTR(HLF_W));</a>
<a name="ln4031">        set_vim_var_string(VV_WARNINGMSG, _(w_arabic), -1);</a>
<a name="ln4032">      }</a>
<a name="ln4033"> </a>
<a name="ln4034">      // set 'delcombine'</a>
<a name="ln4035">      p_deco = true;</a>
<a name="ln4036"> </a>
<a name="ln4037">      // Force-set the necessary keymap for arabic.</a>
<a name="ln4038">      set_option_value(&quot;keymap&quot;, 0L, &quot;arabic&quot;, OPT_LOCAL);</a>
<a name="ln4039">    } else {</a>
<a name="ln4040">      /*</a>
<a name="ln4041">       * 'arabic' is reset, handle various sub-settings.</a>
<a name="ln4042">       */</a>
<a name="ln4043">      if (!p_tbidi) {</a>
<a name="ln4044">        // reset rightleft mode</a>
<a name="ln4045">        if (curwin-&gt;w_p_rl) {</a>
<a name="ln4046">          curwin-&gt;w_p_rl = false;</a>
<a name="ln4047">          changed_window_setting();</a>
<a name="ln4048">        }</a>
<a name="ln4049"> </a>
<a name="ln4050">        /* 'arabicshape' isn't reset, it is a global option and</a>
<a name="ln4051">         * another window may still need it &quot;on&quot;. */</a>
<a name="ln4052">      }</a>
<a name="ln4053"> </a>
<a name="ln4054">      /* 'delcombine' isn't reset, it is a global option and another</a>
<a name="ln4055">       * window may still want it &quot;on&quot;. */</a>
<a name="ln4056"> </a>
<a name="ln4057">      // Revert to the default keymap</a>
<a name="ln4058">      curbuf-&gt;b_p_iminsert = B_IMODE_NONE;</a>
<a name="ln4059">      curbuf-&gt;b_p_imsearch = B_IMODE_USE_INSERT;</a>
<a name="ln4060">    }</a>
<a name="ln4061">  }</a>
<a name="ln4062"> </a>
<a name="ln4063"> </a>
<a name="ln4064">  /*</a>
<a name="ln4065">   * End of handling side effects for bool options.</a>
<a name="ln4066">   */</a>
<a name="ln4067"> </a>
<a name="ln4068">  // after handling side effects, call autocommand</a>
<a name="ln4069"> </a>
<a name="ln4070">  options[opt_idx].flags |= P_WAS_SET;</a>
<a name="ln4071"> </a>
<a name="ln4072">  // Don't do this while starting up or recursively.</a>
<a name="ln4073">  if (!starting &amp;&amp; *get_vim_var_str(VV_OPTION_TYPE) == NUL) {</a>
<a name="ln4074">    char buf_old[2];</a>
<a name="ln4075">    char buf_new[2];</a>
<a name="ln4076">    char buf_type[7];</a>
<a name="ln4077">    vim_snprintf(buf_old, ARRAY_SIZE(buf_old), &quot;%d&quot;,</a>
<a name="ln4078">                 old_value ? true: false);</a>
<a name="ln4079">    vim_snprintf(buf_new, ARRAY_SIZE(buf_new), &quot;%d&quot;,</a>
<a name="ln4080">                 value ? true: false);</a>
<a name="ln4081">    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), &quot;%s&quot;,</a>
<a name="ln4082">                 (opt_flags &amp; OPT_LOCAL) ? &quot;local&quot; : &quot;global&quot;);</a>
<a name="ln4083">    set_vim_var_string(VV_OPTION_NEW, buf_new, -1);</a>
<a name="ln4084">    set_vim_var_string(VV_OPTION_OLD, buf_old, -1);</a>
<a name="ln4085">    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);</a>
<a name="ln4086">    apply_autocmds(EVENT_OPTIONSET,</a>
<a name="ln4087">                   (char_u *) options[opt_idx].fullname,</a>
<a name="ln4088">                   NULL, false, NULL);</a>
<a name="ln4089">    reset_v_option_vars();</a>
<a name="ln4090">  }</a>
<a name="ln4091"> </a>
<a name="ln4092">  if (options[opt_idx].flags &amp; P_UI_OPTION) {</a>
<a name="ln4093">    ui_call_option_set(cstr_as_string(options[opt_idx].fullname),</a>
<a name="ln4094">                       BOOLEAN_OBJ(value));</a>
<a name="ln4095">  }</a>
<a name="ln4096"> </a>
<a name="ln4097">  comp_col();                       // in case 'ruler' or 'showcmd' changed</a>
<a name="ln4098">  if (curwin-&gt;w_curswant != MAXCOL</a>
<a name="ln4099">      &amp;&amp; (options[opt_idx].flags &amp; (P_CURSWANT | P_RALL)) != 0) {</a>
<a name="ln4100">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln4101">  }</a>
<a name="ln4102">  check_redraw(options[opt_idx].flags);</a>
<a name="ln4103"> </a>
<a name="ln4104">  return NULL;</a>
<a name="ln4105">}</a>
<a name="ln4106"> </a>
<a name="ln4107">/// Set the value of a number option, taking care of side effects</a>
<a name="ln4108">///</a>
<a name="ln4109">/// @param[in]  opt_idx  Option index in options[] table.</a>
<a name="ln4110">/// @param[out]  varp  Pointer to the option variable.</a>
<a name="ln4111">/// @param[in]  value  New value.</a>
<a name="ln4112">/// @param  errbuf  Buffer for error messages.</a>
<a name="ln4113">/// @param[in]  errbuflen  Length of `errbuf`.</a>
<a name="ln4114">/// @param[in]  opt_flags  OPT_LOCAL, OPT_GLOBAL or OPT_MODELINE.</a>
<a name="ln4115">///</a>
<a name="ln4116">/// @return NULL on success, error message on error.</a>
<a name="ln4117">static char *set_num_option(int opt_idx, char_u *varp, long value,</a>
<a name="ln4118">                            char_u *errbuf, size_t errbuflen, int opt_flags)</a>
<a name="ln4119">{</a>
<a name="ln4120">  char_u      *errmsg = NULL;</a>
<a name="ln4121">  long old_value = *(long *)varp;</a>
<a name="ln4122">  long old_Rows = Rows;                 // remember old Rows</a>
<a name="ln4123">  long        *pp = (long *)varp;</a>
<a name="ln4124"> </a>
<a name="ln4125">  // Disallow changing some options from secure mode.</a>
<a name="ln4126">  if ((secure || sandbox != 0)</a>
<a name="ln4127">      &amp;&amp; (options[opt_idx].flags &amp; P_SECURE)) {</a>
<a name="ln4128">    return (char *)e_secure;</a>
<a name="ln4129">  }</a>
<a name="ln4130"> </a>
<a name="ln4131">  // Many number options assume their value is in the signed int range.</a>
<a name="ln4132">  if (value &lt; INT_MIN || value &gt; INT_MAX) {</a>
<a name="ln4133">      return (char *)e_invarg;</a>
<a name="ln4134">  }</a>
<a name="ln4135"> </a>
<a name="ln4136">  // Options that need some validation.</a>
<a name="ln4137">  if (pp == &amp;p_wh) {</a>
<a name="ln4138">    if (value &lt; 1) {</a>
<a name="ln4139">      errmsg = e_positive;</a>
<a name="ln4140">    } else if (p_wmh &gt; value) {</a>
<a name="ln4141">      errmsg = e_winheight;</a>
<a name="ln4142">    }</a>
<a name="ln4143">  } else if (pp == &amp;p_hh) {</a>
<a name="ln4144">    if (value &lt; 0) {</a>
<a name="ln4145">      errmsg = e_positive;</a>
<a name="ln4146">    }</a>
<a name="ln4147">  } else if (pp == &amp;p_wmh) {</a>
<a name="ln4148">    if (value &lt; 0) {</a>
<a name="ln4149">      errmsg = e_positive;</a>
<a name="ln4150">    } else if (value &gt; p_wh) {</a>
<a name="ln4151">      errmsg = e_winheight;</a>
<a name="ln4152">    }</a>
<a name="ln4153">  } else if (pp == &amp;p_wiw) {</a>
<a name="ln4154">    if (value &lt; 1) {</a>
<a name="ln4155">      errmsg = e_positive;</a>
<a name="ln4156">    } else if (p_wmw &gt; value) {</a>
<a name="ln4157">      errmsg = e_winwidth;</a>
<a name="ln4158">    }</a>
<a name="ln4159">  } else if (pp == &amp;p_wmw) {</a>
<a name="ln4160">    if (value &lt; 0) {</a>
<a name="ln4161">      errmsg = e_positive;</a>
<a name="ln4162">    } else if (value &gt; p_wiw) {</a>
<a name="ln4163">      errmsg = e_winwidth;</a>
<a name="ln4164">    }</a>
<a name="ln4165">  } else if (pp == &amp;p_mco) {</a>
<a name="ln4166">    value = MAX_MCO;</a>
<a name="ln4167">  } else if (pp == &amp;p_titlelen) {</a>
<a name="ln4168">    if (value &lt; 0) {</a>
<a name="ln4169">      errmsg = e_positive;</a>
<a name="ln4170">    }</a>
<a name="ln4171">  } else if (pp == &amp;p_uc) {</a>
<a name="ln4172">    if (value &lt; 0) {</a>
<a name="ln4173">      errmsg = e_positive;</a>
<a name="ln4174">    }</a>
<a name="ln4175">  } else if (pp == &amp;p_ch) {</a>
<a name="ln4176">    int minval = ui_has(kUIMessages) ? 0 : 1;</a>
<a name="ln4177">    if (value &lt; minval) {</a>
<a name="ln4178">      errmsg = e_positive;</a>
<a name="ln4179">    }</a>
<a name="ln4180">  } else if (pp == &amp;p_tm) {</a>
<a name="ln4181">    if (value &lt; 0) {</a>
<a name="ln4182">      errmsg = e_positive;</a>
<a name="ln4183">    }</a>
<a name="ln4184">  } else if (pp == &amp;p_hi) {</a>
<a name="ln4185">    if (value &lt; 0) {</a>
<a name="ln4186">      errmsg = e_positive;</a>
<a name="ln4187">    } else if (value &gt; 10000) {</a>
<a name="ln4188">      errmsg = e_invarg;</a>
<a name="ln4189">    }</a>
<a name="ln4190">  } else if (pp == &amp;p_re) {</a>
<a name="ln4191">    if (value &lt; 0 || value &gt; 2) {</a>
<a name="ln4192">      errmsg = e_invarg;</a>
<a name="ln4193">    }</a>
<a name="ln4194">  } else if (pp == &amp;p_report) {</a>
<a name="ln4195">    if (value &lt; 0) {</a>
<a name="ln4196">      errmsg = e_positive;</a>
<a name="ln4197">    }</a>
<a name="ln4198">  } else if (pp == &amp;p_so) {</a>
<a name="ln4199">    if (value &lt; 0 &amp;&amp; full_screen) {</a>
<a name="ln4200">      errmsg = e_positive;</a>
<a name="ln4201">    }</a>
<a name="ln4202">  } else if (pp == &amp;p_siso) {</a>
<a name="ln4203">    if (value &lt; 0 &amp;&amp; full_screen) {</a>
<a name="ln4204">      errmsg = e_positive;</a>
<a name="ln4205">    }</a>
<a name="ln4206">  } else if (pp == &amp;p_cwh) {</a>
<a name="ln4207">    if (value &lt; 1) {</a>
<a name="ln4208">      errmsg = e_positive;</a>
<a name="ln4209">    }</a>
<a name="ln4210">  } else if (pp == &amp;p_ut) {</a>
<a name="ln4211">    if (value &lt; 0) {</a>
<a name="ln4212">      errmsg = e_positive;</a>
<a name="ln4213">    }</a>
<a name="ln4214">  } else if (pp == &amp;p_ss) {</a>
<a name="ln4215">    if (value &lt; 0) {</a>
<a name="ln4216">      errmsg = e_positive;</a>
<a name="ln4217">    }</a>
<a name="ln4218">  } else if (pp == &amp;curwin-&gt;w_p_fdl || pp == &amp;curwin-&gt;w_allbuf_opt.wo_fdl) {</a>
<a name="ln4219">    if (value &lt; 0) {</a>
<a name="ln4220">      errmsg = e_positive;</a>
<a name="ln4221">    }</a>
<a name="ln4222">  } else if (pp == &amp;curwin-&gt;w_p_cole || pp == &amp;curwin-&gt;w_allbuf_opt.wo_cole) {</a>
<a name="ln4223">    if (value &lt; 0) {</a>
<a name="ln4224">      errmsg = e_positive;</a>
<a name="ln4225">    } else if (value &gt; 3) {</a>
<a name="ln4226">      errmsg = e_invarg;</a>
<a name="ln4227">    }</a>
<a name="ln4228">  } else if (pp == &amp;curwin-&gt;w_p_nuw || pp == &amp;curwin-&gt;w_allbuf_opt.wo_nuw) {</a>
<a name="ln4229">    if (value &lt; 1) {</a>
<a name="ln4230">      errmsg = e_positive;</a>
<a name="ln4231">    } else if (value &gt; 20) {</a>
<a name="ln4232">      errmsg = e_invarg;</a>
<a name="ln4233">    }</a>
<a name="ln4234">  } else if (pp == &amp;curbuf-&gt;b_p_iminsert || pp == &amp;p_iminsert) {</a>
<a name="ln4235">    if (value &lt; 0 || value &gt; B_IMODE_LAST) {</a>
<a name="ln4236">      errmsg = e_invarg;</a>
<a name="ln4237">    }</a>
<a name="ln4238">  } else if (pp == &amp;curbuf-&gt;b_p_imsearch || pp == &amp;p_imsearch) {</a>
<a name="ln4239">    if (value &lt; -1 || value &gt; B_IMODE_LAST) {</a>
<a name="ln4240">      errmsg = e_invarg;</a>
<a name="ln4241">    }</a>
<a name="ln4242">  } else if (pp == &amp;curbuf-&gt;b_p_channel || pp == &amp;p_channel) {</a>
<a name="ln4243">    errmsg = e_invarg;</a>
<a name="ln4244">  } else if (pp == &amp;curbuf-&gt;b_p_scbk || pp == &amp;p_scbk) {</a>
<a name="ln4245">    if (value &lt; -1 || value &gt; SB_MAX) {</a>
<a name="ln4246">      errmsg = e_invarg;</a>
<a name="ln4247">    }</a>
<a name="ln4248">  } else if (pp == &amp;curbuf-&gt;b_p_sw || pp == &amp;p_sw) {</a>
<a name="ln4249">    if (value &lt; 0) {</a>
<a name="ln4250">      errmsg = e_positive;</a>
<a name="ln4251">    }</a>
<a name="ln4252">  } else if (pp == &amp;curbuf-&gt;b_p_ts || pp == &amp;p_ts) {</a>
<a name="ln4253">    if (value &lt; 1) {</a>
<a name="ln4254">      errmsg = e_positive;</a>
<a name="ln4255">    }</a>
<a name="ln4256">  } else if (pp == &amp;curbuf-&gt;b_p_tw || pp == &amp;p_tw) {</a>
<a name="ln4257">    if (value &lt; 0) {</a>
<a name="ln4258">      errmsg = e_positive;</a>
<a name="ln4259">    }</a>
<a name="ln4260">  } else if (pp == &amp;p_wd) {</a>
<a name="ln4261">    if (value &lt; 0) {</a>
<a name="ln4262">      errmsg = e_positive;</a>
<a name="ln4263">    }</a>
<a name="ln4264">  }</a>
<a name="ln4265"> </a>
<a name="ln4266">  // Don't change the value and return early if validation failed.</a>
<a name="ln4267">  if (errmsg != NULL) {</a>
<a name="ln4268">    return (char *)errmsg;</a>
<a name="ln4269">  }</a>
<a name="ln4270"> </a>
<a name="ln4271">  *pp = value;</a>
<a name="ln4272">  // Remember where the option was set.</a>
<a name="ln4273">  set_option_sctx_idx(opt_idx, opt_flags, current_sctx);</a>
<a name="ln4274"> </a>
<a name="ln4275">  // For these options we want to fix some invalid values.</a>
<a name="ln4276">  if (pp == &amp;p_window) {</a>
<a name="ln4277">    if (p_window &lt; 1) {</a>
<a name="ln4278">      p_window = Rows - 1;</a>
<a name="ln4279">    } else if (p_window &gt;= Rows) {</a>
<a name="ln4280">      p_window = Rows - 1;</a>
<a name="ln4281">    }</a>
<a name="ln4282">  } else if (pp == &amp;p_ch) {</a>
<a name="ln4283">    if (ui_has(kUIMessages)) {</a>
<a name="ln4284">      p_ch = 0;</a>
<a name="ln4285">    }</a>
<a name="ln4286">    if (p_ch &gt; Rows - min_rows() + 1) {</a>
<a name="ln4287">      p_ch = Rows - min_rows() + 1;</a>
<a name="ln4288">    }</a>
<a name="ln4289">  }</a>
<a name="ln4290"> </a>
<a name="ln4291">  // Number options that need some action when changed</a>
<a name="ln4292">  if (pp == &amp;p_wh) {</a>
<a name="ln4293">    // 'winheight'</a>
<a name="ln4294">    if (!ONE_WINDOW &amp;&amp; curwin-&gt;w_height &lt; p_wh) {</a>
<a name="ln4295">      win_setheight((int)p_wh);</a>
<a name="ln4296">    }</a>
<a name="ln4297">  } else if (pp == &amp;p_hh) {</a>
<a name="ln4298">    // 'helpheight'</a>
<a name="ln4299">    if (!ONE_WINDOW &amp;&amp; curbuf-&gt;b_help &amp;&amp; curwin-&gt;w_height &lt; p_hh) {</a>
<a name="ln4300">      win_setheight((int)p_hh);</a>
<a name="ln4301">    }</a>
<a name="ln4302">  } else if (pp == &amp;p_wmh) {</a>
<a name="ln4303">    // 'winminheight'</a>
<a name="ln4304">    win_setminheight();</a>
<a name="ln4305">  } else if (pp == &amp;p_wiw) {</a>
<a name="ln4306">    // 'winwidth'</a>
<a name="ln4307">    if (!ONE_WINDOW &amp;&amp; curwin-&gt;w_width &lt; p_wiw) {</a>
<a name="ln4308">      win_setwidth((int)p_wiw);</a>
<a name="ln4309">    }</a>
<a name="ln4310">  } else if (pp == &amp;p_wmw) {</a>
<a name="ln4311">    // 'winminwidth'</a>
<a name="ln4312">    win_setminwidth();</a>
<a name="ln4313">  } else if (pp == &amp;p_ls) {</a>
<a name="ln4314">    last_status(false);  // (re)set last window status line.</a>
<a name="ln4315">  } else if (pp == &amp;p_stal) {</a>
<a name="ln4316">    // (re)set tab page line</a>
<a name="ln4317">    shell_new_rows();   // recompute window positions and heights</a>
<a name="ln4318">  } else if (pp == &amp;curwin-&gt;w_p_fdl) {</a>
<a name="ln4319">    newFoldLevel();</a>
<a name="ln4320">  } else if (pp == &amp;curwin-&gt;w_p_fml) {</a>
<a name="ln4321">    foldUpdateAll(curwin);</a>
<a name="ln4322">  } else if (pp == &amp;curwin-&gt;w_p_fdn) {</a>
<a name="ln4323">    if (foldmethodIsSyntax(curwin) || foldmethodIsIndent(curwin)) {</a>
<a name="ln4324">      foldUpdateAll(curwin);</a>
<a name="ln4325">    }</a>
<a name="ln4326">  } else if (pp == &amp;curbuf-&gt;b_p_sw || pp == &amp;curbuf-&gt;b_p_ts) {</a>
<a name="ln4327">    // 'shiftwidth' or 'tabstop'</a>
<a name="ln4328">    if (foldmethodIsIndent(curwin)) {</a>
<a name="ln4329">      foldUpdateAll(curwin);</a>
<a name="ln4330">    }</a>
<a name="ln4331">    // When 'shiftwidth' changes, or it's zero and 'tabstop' changes:</a>
<a name="ln4332">    // parse 'cinoptions'.</a>
<a name="ln4333">    if (pp == &amp;curbuf-&gt;b_p_sw || curbuf-&gt;b_p_sw == 0) {</a>
<a name="ln4334">      parse_cino(curbuf);</a>
<a name="ln4335">    }</a>
<a name="ln4336">  } else if (pp == &amp;curbuf-&gt;b_p_iminsert) {</a>
<a name="ln4337">    showmode();</a>
<a name="ln4338">    // Show/unshow value of 'keymap' in status lines.</a>
<a name="ln4339">    status_redraw_curbuf();</a>
<a name="ln4340">  } else if (pp == &amp;p_titlelen) {</a>
<a name="ln4341">    // if 'titlelen' has changed, redraw the title</a>
<a name="ln4342">    if (starting != NO_SCREEN &amp;&amp; old_value != p_titlelen) {</a>
<a name="ln4343">      need_maketitle = true;</a>
<a name="ln4344">    }</a>
<a name="ln4345">  } else if (pp == &amp;p_ch) {</a>
<a name="ln4346">    // if p_ch changed value, change the command line height</a>
<a name="ln4347">    // Only compute the new window layout when startup has been</a>
<a name="ln4348">    // completed. Otherwise the frame sizes may be wrong.</a>
<a name="ln4349">    if (p_ch != old_value &amp;&amp; full_screen) {</a>
<a name="ln4350">      command_height();</a>
<a name="ln4351">    }</a>
<a name="ln4352">  } else if (pp == &amp;p_uc) {</a>
<a name="ln4353">    // when 'updatecount' changes from zero to non-zero, open swap files</a>
<a name="ln4354">    if (p_uc &amp;&amp; !old_value) {</a>
<a name="ln4355">      ml_open_files();</a>
<a name="ln4356">    }</a>
<a name="ln4357">  } else if (pp == &amp;p_pb) {</a>
<a name="ln4358">    p_pb = MAX(MIN(p_pb, 100), 0);</a>
<a name="ln4359">    hl_invalidate_blends();</a>
<a name="ln4360">    pum_grid.blending = (p_pb &gt; 0);</a>
<a name="ln4361">    if (pum_drawn()) {</a>
<a name="ln4362">      pum_redraw();</a>
<a name="ln4363">    }</a>
<a name="ln4364">  } else if (pp == &amp;p_pyx) {</a>
<a name="ln4365">    if (p_pyx != 0 &amp;&amp; p_pyx != 2 &amp;&amp; p_pyx != 3) {</a>
<a name="ln4366">      errmsg = e_invarg;</a>
<a name="ln4367">    }</a>
<a name="ln4368">  } else if (pp == &amp;p_ul || pp == &amp;curbuf-&gt;b_p_ul) {</a>
<a name="ln4369">    // sync undo before 'undolevels' changes</a>
<a name="ln4370">    // use the old value, otherwise u_sync() may not work properly</a>
<a name="ln4371">    *pp = old_value;</a>
<a name="ln4372">    u_sync(true);</a>
<a name="ln4373">    *pp = value;</a>
<a name="ln4374">  } else if (pp == &amp;curbuf-&gt;b_p_tw) {</a>
<a name="ln4375">    FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln4376">      check_colorcolumn(wp);</a>
<a name="ln4377">    }</a>
<a name="ln4378">  } else if (pp == &amp;curbuf-&gt;b_p_scbk || pp == &amp;p_scbk) {</a>
<a name="ln4379">    if (curbuf-&gt;terminal) {</a>
<a name="ln4380">      // Force the scrollback to take effect.</a>
<a name="ln4381">      terminal_check_size(curbuf-&gt;terminal);</a>
<a name="ln4382">    }</a>
<a name="ln4383">  } else if (pp == &amp;curwin-&gt;w_p_nuw) {</a>
<a name="ln4384">    curwin-&gt;w_nrwidth_line_count = 0;</a>
<a name="ln4385">  } else if (pp == &amp;curwin-&gt;w_p_winbl &amp;&amp; value != old_value) {</a>
<a name="ln4386">    // 'floatblend'</a>
<a name="ln4387">    curwin-&gt;w_p_winbl = MAX(MIN(curwin-&gt;w_p_winbl, 100), 0);</a>
<a name="ln4388">    curwin-&gt;w_hl_needs_update = true;</a>
<a name="ln4389">    check_blending(curwin);</a>
<a name="ln4390">  }</a>
<a name="ln4391"> </a>
<a name="ln4392"> </a>
<a name="ln4393">  // Check the (new) bounds for Rows and Columns here.</a>
<a name="ln4394">  if (p_lines &lt; min_rows() &amp;&amp; full_screen) {</a>
<a name="ln4395">    if (errbuf != NULL) {</a>
<a name="ln4396">      vim_snprintf((char *)errbuf, errbuflen,</a>
<a name="ln4397">          _(&quot;E593: Need at least %d lines&quot;), min_rows());</a>
<a name="ln4398">      errmsg = errbuf;</a>
<a name="ln4399">    }</a>
<a name="ln4400">    p_lines = min_rows();</a>
<a name="ln4401">  }</a>
<a name="ln4402">  if (p_columns &lt; MIN_COLUMNS &amp;&amp; full_screen) {</a>
<a name="ln4403">    if (errbuf != NULL) {</a>
<a name="ln4404">      vim_snprintf((char *)errbuf, errbuflen,</a>
<a name="ln4405">          _(&quot;E594: Need at least %d columns&quot;), MIN_COLUMNS);</a>
<a name="ln4406">      errmsg = errbuf;</a>
<a name="ln4407">    }</a>
<a name="ln4408">    p_columns = MIN_COLUMNS;</a>
<a name="ln4409">  }</a>
<a name="ln4410"> </a>
<a name="ln4411">  // True max size is defined by check_shellsize()</a>
<a name="ln4412">  p_lines = MIN(p_lines, INT_MAX);</a>
<a name="ln4413">  p_columns = MIN(p_columns, INT_MAX);</a>
<a name="ln4414"> </a>
<a name="ln4415">  // If the screen (shell) height has been changed, assume it is the</a>
<a name="ln4416">  // physical screenheight.</a>
<a name="ln4417">  if (p_lines != Rows || p_columns != Columns) {</a>
<a name="ln4418">    // Changing the screen size is not allowed while updating the screen.</a>
<a name="ln4419">    if (updating_screen) {</a>
<a name="ln4420">      *pp = old_value;</a>
<a name="ln4421">    } else if (full_screen) {</a>
<a name="ln4422">      screen_resize((int)p_columns, (int)p_lines);</a>
<a name="ln4423">    } else {</a>
<a name="ln4424">      // TODO(bfredl): is this branch ever needed?</a>
<a name="ln4425">      // Postpone the resizing; check the size and cmdline position for</a>
<a name="ln4426">      // messages.</a>
<a name="ln4427">      Rows = (int)p_lines;</a>
<a name="ln4428">      Columns = (int)p_columns;</a>
<a name="ln4429">      check_shellsize();</a>
<a name="ln4430">      if (cmdline_row &gt; Rows - p_ch &amp;&amp; Rows &gt; p_ch) {</a>
<a name="ln4431">        assert(p_ch &gt;= 0 &amp;&amp; Rows - p_ch &lt;= INT_MAX);</a>
<a name="ln4432">        cmdline_row = (int)(Rows - p_ch);</a>
<a name="ln4433">      }</a>
<a name="ln4434">    }</a>
<a name="ln4435">    if (p_window &gt;= Rows || !option_was_set(&quot;window&quot;)) {</a>
<a name="ln4436">      p_window = Rows - 1;</a>
<a name="ln4437">    }</a>
<a name="ln4438">  }</a>
<a name="ln4439"> </a>
<a name="ln4440">  if ((curwin-&gt;w_p_scr &lt;= 0</a>
<a name="ln4441">       || (curwin-&gt;w_p_scr &gt; curwin-&gt;w_height</a>
<a name="ln4442">           &amp;&amp; curwin-&gt;w_height &gt; 0))</a>
<a name="ln4443">      &amp;&amp; full_screen) {</a>
<a name="ln4444">    if (pp == &amp;(curwin-&gt;w_p_scr)) {</a>
<a name="ln4445">      if (curwin-&gt;w_p_scr != 0) {</a>
<a name="ln4446">        errmsg = e_scroll;</a>
<a name="ln4447">      }</a>
<a name="ln4448">      win_comp_scroll(curwin);</a>
<a name="ln4449">    } else if (curwin-&gt;w_p_scr &lt;= 0) {</a>
<a name="ln4450">    // If 'scroll' became invalid because of a side effect silently adjust it.</a>
<a name="ln4451">      curwin-&gt;w_p_scr = 1;</a>
<a name="ln4452">    } else {  // curwin-&gt;w_p_scr &gt; curwin-&gt;w_height</a>
<a name="ln4453">      curwin-&gt;w_p_scr = curwin-&gt;w_height;</a>
<a name="ln4454">    }</a>
<a name="ln4455">  }</a>
<a name="ln4456">  if ((p_sj &lt; -100 || p_sj &gt;= Rows) &amp;&amp; full_screen) {</a>
<a name="ln4457">    if (Rows != old_Rows) {     // Rows changed, just adjust p_sj</a>
<a name="ln4458">      p_sj = Rows / 2;</a>
<a name="ln4459">    } else {</a>
<a name="ln4460">      errmsg = e_scroll;</a>
<a name="ln4461">      p_sj = 1;</a>
<a name="ln4462">    }</a>
<a name="ln4463">  }</a>
<a name="ln4464"> </a>
<a name="ln4465">  // May set global value for local option.</a>
<a name="ln4466">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln4467">    *(long *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL) = *pp;</a>
<a name="ln4468">  }</a>
<a name="ln4469"> </a>
<a name="ln4470">  options[opt_idx].flags |= P_WAS_SET;</a>
<a name="ln4471"> </a>
<a name="ln4472">  // Don't do this while starting up, failure or recursively.</a>
<a name="ln4473">  if (!starting &amp;&amp; errmsg == NULL &amp;&amp; *get_vim_var_str(VV_OPTION_TYPE) == NUL) {</a>
<a name="ln4474">    char buf_old[NUMBUFLEN];</a>
<a name="ln4475">    char buf_new[NUMBUFLEN];</a>
<a name="ln4476">    char buf_type[7];</a>
<a name="ln4477"> </a>
<a name="ln4478">    vim_snprintf(buf_old, ARRAY_SIZE(buf_old), &quot;%ld&quot;, old_value);</a>
<a name="ln4479">    vim_snprintf(buf_new, ARRAY_SIZE(buf_new), &quot;%ld&quot;, value);</a>
<a name="ln4480">    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), &quot;%s&quot;,</a>
<a name="ln4481">                 (opt_flags &amp; OPT_LOCAL) ? &quot;local&quot; : &quot;global&quot;);</a>
<a name="ln4482">    set_vim_var_string(VV_OPTION_NEW, buf_new, -1);</a>
<a name="ln4483">    set_vim_var_string(VV_OPTION_OLD, buf_old, -1);</a>
<a name="ln4484">    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);</a>
<a name="ln4485">    apply_autocmds(EVENT_OPTIONSET,</a>
<a name="ln4486">                   (char_u *) options[opt_idx].fullname,</a>
<a name="ln4487">                   NULL, false, NULL);</a>
<a name="ln4488">    reset_v_option_vars();</a>
<a name="ln4489">  }</a>
<a name="ln4490"> </a>
<a name="ln4491">  if (errmsg == NULL &amp;&amp; options[opt_idx].flags &amp; P_UI_OPTION) {</a>
<a name="ln4492">    ui_call_option_set(cstr_as_string(options[opt_idx].fullname),</a>
<a name="ln4493">                       INTEGER_OBJ(value));</a>
<a name="ln4494">  }</a>
<a name="ln4495"> </a>
<a name="ln4496">  comp_col();                       // in case 'columns' or 'ls' changed</a>
<a name="ln4497">  if (curwin-&gt;w_curswant != MAXCOL</a>
<a name="ln4498">      &amp;&amp; (options[opt_idx].flags &amp; (P_CURSWANT | P_RALL)) != 0) {</a>
<a name="ln4499">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln4500">  }</a>
<a name="ln4501">  check_redraw(options[opt_idx].flags);</a>
<a name="ln4502"> </a>
<a name="ln4503">  return (char *)errmsg;</a>
<a name="ln4504">}</a>
<a name="ln4505"> </a>
<a name="ln4506">static void trigger_optionsset_string(int opt_idx, int opt_flags,</a>
<a name="ln4507">                                      char *oldval, char *newval)</a>
<a name="ln4508">{</a>
<a name="ln4509">  // Don't do this recursively.</a>
<a name="ln4510">  if (oldval != NULL</a>
<a name="ln4511">      &amp;&amp; newval != NULL</a>
<a name="ln4512">      &amp;&amp; *get_vim_var_str(VV_OPTION_TYPE) == NUL) {</a>
<a name="ln4513">    char buf_type[7];</a>
<a name="ln4514"> </a>
<a name="ln4515">    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), &quot;%s&quot;,</a>
<a name="ln4516">                 (opt_flags &amp; OPT_LOCAL) ? &quot;local&quot; : &quot;global&quot;);</a>
<a name="ln4517">    set_vim_var_string(VV_OPTION_OLD, oldval, -1);</a>
<a name="ln4518">    set_vim_var_string(VV_OPTION_NEW, newval, -1);</a>
<a name="ln4519">    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);</a>
<a name="ln4520">    apply_autocmds(EVENT_OPTIONSET,</a>
<a name="ln4521">                   (char_u *)options[opt_idx].fullname, NULL, false, NULL);</a>
<a name="ln4522">    reset_v_option_vars();</a>
<a name="ln4523">  }</a>
<a name="ln4524">}</a>
<a name="ln4525"> </a>
<a name="ln4526">/// Called after an option changed: check if something needs to be redrawn.</a>
<a name="ln4527">static void check_redraw(uint32_t flags)</a>
<a name="ln4528">{</a>
<a name="ln4529">  // Careful: P_RCLR and P_RALL are a combination of other P_ flags</a>
<a name="ln4530">  bool doclear = (flags &amp; P_RCLR) == P_RCLR;</a>
<a name="ln4531">  bool all = ((flags &amp; P_RALL) == P_RALL || doclear);</a>
<a name="ln4532"> </a>
<a name="ln4533">  if ((flags &amp; P_RSTAT) || all) {  // mark all status lines dirty</a>
<a name="ln4534">    status_redraw_all();</a>
<a name="ln4535">  }</a>
<a name="ln4536"> </a>
<a name="ln4537">  if ((flags &amp; P_RBUF) || (flags &amp; P_RWIN) || all) {</a>
<a name="ln4538">    changed_window_setting();</a>
<a name="ln4539">  }</a>
<a name="ln4540">  if (flags &amp; P_RBUF) {</a>
<a name="ln4541">    redraw_curbuf_later(NOT_VALID);</a>
<a name="ln4542">  }</a>
<a name="ln4543">  if (flags &amp; P_RWINONLY) {</a>
<a name="ln4544">    redraw_later(curwin, NOT_VALID);</a>
<a name="ln4545">  }</a>
<a name="ln4546">  if (doclear) {</a>
<a name="ln4547">    redraw_all_later(CLEAR);</a>
<a name="ln4548">  } else if (all) {</a>
<a name="ln4549">    redraw_all_later(NOT_VALID);</a>
<a name="ln4550">  }</a>
<a name="ln4551">}</a>
<a name="ln4552"> </a>
<a name="ln4553">/// Find index for named option</a>
<a name="ln4554">///</a>
<a name="ln4555">/// @param[in]  arg  Option to find index for.</a>
<a name="ln4556">/// @param[in]  len  Length of the option.</a>
<a name="ln4557">///</a>
<a name="ln4558">/// @return Index of the option or -1 if option was not found.</a>
<a name="ln4559">int findoption_len(const char *const arg, const size_t len)</a>
<a name="ln4560">{</a>
<a name="ln4561">  const char *s;</a>
<a name="ln4562">  const char *p;</a>
<a name="ln4563">  static int quick_tab[27] = { 0, 0 };  // quick access table</a>
<a name="ln4564"> </a>
<a name="ln4565">  // For first call: Initialize the quick-access table.</a>
<a name="ln4566">  // It contains the index for the first option that starts with a certain</a>
<a name="ln4567">  // letter.  There are 26 letters, plus the first &quot;t_&quot; option.</a>
<a name="ln4568">  if (quick_tab[1] == 0) {</a>
<a name="ln4569">    p = options[0].fullname;</a>
<a name="ln4570">    for (short int i = 1; (s = options[i].fullname) != NULL; i++) {</a>
<a name="ln4571">      if (s[0] != p[0]) {</a>
<a name="ln4572">        if (s[0] == 't' &amp;&amp; s[1] == '_') {</a>
<a name="ln4573">          quick_tab[26] = i;</a>
<a name="ln4574">        } else {</a>
<a name="ln4575">          quick_tab[CharOrdLow(s[0])] = i;</a>
<a name="ln4576">        }</a>
<a name="ln4577">      }</a>
<a name="ln4578">      p = s;</a>
<a name="ln4579">    }</a>
<a name="ln4580">  }</a>
<a name="ln4581"> </a>
<a name="ln4582">  // Check for name starting with an illegal character.</a>
<a name="ln4583">  if (len == 0 || arg[0] &lt; 'a' || arg[0] &gt; 'z') {</a>
<a name="ln4584">    return -1;</a>
<a name="ln4585">  }</a>
<a name="ln4586"> </a>
<a name="ln4587">  int opt_idx;</a>
<a name="ln4588">  const bool is_term_opt = (len &gt; 2 &amp;&amp; arg[0] == 't' &amp;&amp; arg[1] == '_');</a>
<a name="ln4589">  if (is_term_opt) {</a>
<a name="ln4590">    opt_idx = quick_tab[26];</a>
<a name="ln4591">  } else {</a>
<a name="ln4592">    opt_idx = quick_tab[CharOrdLow(arg[0])];</a>
<a name="ln4593">  }</a>
<a name="ln4594">  // Match full name</a>
<a name="ln4595">  for (; (s = options[opt_idx].fullname) != NULL; opt_idx++) {</a>
<a name="ln4596">    if (strncmp(arg, s, len) == 0 &amp;&amp; s[len] == NUL) {</a>
<a name="ln4597">      break;</a>
<a name="ln4598">    }</a>
<a name="ln4599">  }</a>
<a name="ln4600">  if (s == NULL &amp;&amp; !is_term_opt) {</a>
<a name="ln4601">    opt_idx = quick_tab[CharOrdLow(arg[0])];</a>
<a name="ln4602">    // Match short name</a>
<a name="ln4603">    for (; options[opt_idx].fullname != NULL; opt_idx++) {</a>
<a name="ln4604">      s = options[opt_idx].shortname;</a>
<a name="ln4605">      if (s != NULL &amp;&amp; strncmp(arg, s, len) == 0 &amp;&amp; s[len] == NUL) {</a>
<a name="ln4606">        break;</a>
<a name="ln4607">      }</a>
<a name="ln4608">      s = NULL;</a>
<a name="ln4609">    }</a>
<a name="ln4610">  }</a>
<a name="ln4611">  if (s == NULL) {</a>
<a name="ln4612">    opt_idx = -1;</a>
<a name="ln4613">  } else {</a>
<a name="ln4614">    // Nvim: handle option aliases.</a>
<a name="ln4615">    if (STRNCMP(options[opt_idx].fullname, &quot;viminfo&quot;, 7) == 0) {</a>
<a name="ln4616">      if (STRLEN(options[opt_idx].fullname) == 7) {</a>
<a name="ln4617">        return findoption_len(&quot;shada&quot;, 5);</a>
<a name="ln4618">      }</a>
<a name="ln4619">      assert(STRCMP(options[opt_idx].fullname, &quot;viminfofile&quot;) == 0);</a>
<a name="ln4620">      return findoption_len(&quot;shadafile&quot;, 9);</a>
<a name="ln4621">    }</a>
<a name="ln4622">  }</a>
<a name="ln4623">  return opt_idx;</a>
<a name="ln4624">}</a>
<a name="ln4625"> </a>
<a name="ln4626">bool is_tty_option(const char *name)</a>
<a name="ln4627">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4628">{</a>
<a name="ln4629">  return (name[0] == 't' &amp;&amp; name[1] == '_')</a>
<a name="ln4630">    || strequal(name, &quot;term&quot;)</a>
<a name="ln4631">    || strequal(name, &quot;ttytype&quot;);</a>
<a name="ln4632">}</a>
<a name="ln4633"> </a>
<a name="ln4634">#define TCO_BUFFER_SIZE 8</a>
<a name="ln4635">/// @param name TUI-related option</a>
<a name="ln4636">/// @param[out,allocated] value option string value</a>
<a name="ln4637">bool get_tty_option(const char *name, char **value)</a>
<a name="ln4638">{</a>
<a name="ln4639">  if (strequal(name, &quot;t_Co&quot;)) {</a>
<a name="ln4640">    if (value) {</a>
<a name="ln4641">      if (t_colors &lt;= 1) {</a>
<a name="ln4642">        *value = xstrdup(&quot;&quot;);</a>
<a name="ln4643">      } else {</a>
<a name="ln4644">        *value = xmalloc(TCO_BUFFER_SIZE);</a>
<a name="ln4645">        snprintf(*value, TCO_BUFFER_SIZE, &quot;%d&quot;, t_colors);</a>
<a name="ln4646">      }</a>
<a name="ln4647">    }</a>
<a name="ln4648">    return true;</a>
<a name="ln4649">  }</a>
<a name="ln4650"> </a>
<a name="ln4651">  if (strequal(name, &quot;term&quot;)) {</a>
<a name="ln4652">    if (value) {</a>
<a name="ln4653">      *value = p_term ? xstrdup(p_term) : xstrdup(&quot;nvim&quot;);</a>
<a name="ln4654">    }</a>
<a name="ln4655">    return true;</a>
<a name="ln4656">  }</a>
<a name="ln4657"> </a>
<a name="ln4658">  if (strequal(name, &quot;ttytype&quot;)) {</a>
<a name="ln4659">    if (value) {</a>
<a name="ln4660">      *value = p_ttytype ? xstrdup(p_ttytype) : xstrdup(&quot;nvim&quot;);</a>
<a name="ln4661">    }</a>
<a name="ln4662">    return true;</a>
<a name="ln4663">  }</a>
<a name="ln4664"> </a>
<a name="ln4665">  if (is_tty_option(name)) {</a>
<a name="ln4666">    if (value) {</a>
<a name="ln4667">      // XXX: All other t_* options were removed in 3baba1e7.</a>
<a name="ln4668">      *value = xstrdup(&quot;&quot;);</a>
<a name="ln4669">    }</a>
<a name="ln4670">    return true;</a>
<a name="ln4671">  }</a>
<a name="ln4672"> </a>
<a name="ln4673">  return false;</a>
<a name="ln4674">}</a>
<a name="ln4675"> </a>
<a name="ln4676">bool set_tty_option(const char *name, char *value)</a>
<a name="ln4677">{</a>
<a name="ln4678">  if (strequal(name, &quot;term&quot;)) {</a>
<a name="ln4679">    if (p_term) {</a>
<a name="ln4680">      xfree(p_term);</a>
<a name="ln4681">    }</a>
<a name="ln4682">    p_term = value;</a>
<a name="ln4683">    return true;</a>
<a name="ln4684">  }</a>
<a name="ln4685"> </a>
<a name="ln4686">  if (strequal(name, &quot;ttytype&quot;)) {</a>
<a name="ln4687">    if (p_ttytype) {</a>
<a name="ln4688">      xfree(p_ttytype);</a>
<a name="ln4689">    }</a>
<a name="ln4690">    p_ttytype = value;</a>
<a name="ln4691">    return true;</a>
<a name="ln4692">  }</a>
<a name="ln4693"> </a>
<a name="ln4694">  return false;</a>
<a name="ln4695">}</a>
<a name="ln4696"> </a>
<a name="ln4697">/// Find index for an option</a>
<a name="ln4698">///</a>
<a name="ln4699">/// @param[in]  arg  Option name.</a>
<a name="ln4700">///</a>
<a name="ln4701">/// @return Option index or -1 if option was not found.</a>
<a name="ln4702">static int findoption(const char *const arg)</a>
<a name="ln4703">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4704">{</a>
<a name="ln4705">  return findoption_len(arg, strlen(arg));</a>
<a name="ln4706">}</a>
<a name="ln4707"> </a>
<a name="ln4708">/// Gets the value for an option.</a>
<a name="ln4709">///</a>
<a name="ln4710">/// @returns:</a>
<a name="ln4711">/// Number or Toggle option: 1, *numval gets value.</a>
<a name="ln4712">///           String option: 0, *stringval gets allocated string.</a>
<a name="ln4713">/// Hidden Number or Toggle option: -1.</a>
<a name="ln4714">///           hidden String option: -2.</a>
<a name="ln4715">///                 unknown option: -3.</a>
<a name="ln4716">int get_option_value(</a>
<a name="ln4717">    const char *name,</a>
<a name="ln4718">    long *numval,</a>
<a name="ln4719">    char_u **stringval,            ///&lt; NULL when only checking existence</a>
<a name="ln4720">    int opt_flags</a>
<a name="ln4721">)</a>
<a name="ln4722">{</a>
<a name="ln4723">  if (get_tty_option(name, (char **)stringval)) {</a>
<a name="ln4724">    return 0;</a>
<a name="ln4725">  }</a>
<a name="ln4726"> </a>
<a name="ln4727">  int opt_idx = findoption(name);</a>
<a name="ln4728">  if (opt_idx &lt; 0) {  // Unknown option.</a>
<a name="ln4729">    return -3;</a>
<a name="ln4730">  }</a>
<a name="ln4731"> </a>
<a name="ln4732">  char_u *varp = get_varp_scope(&amp;(options[opt_idx]), opt_flags);</a>
<a name="ln4733"> </a>
<a name="ln4734">  if (options[opt_idx].flags &amp; P_STRING) {</a>
<a name="ln4735">    if (varp == NULL) {  // hidden option</a>
<a name="ln4736">      return -2;</a>
<a name="ln4737">    }</a>
<a name="ln4738">    if (stringval != NULL) {</a>
<a name="ln4739">      *stringval = vim_strsave(*(char_u **)(varp));</a>
<a name="ln4740">    }</a>
<a name="ln4741">    return 0;</a>
<a name="ln4742">  }</a>
<a name="ln4743"> </a>
<a name="ln4744">  if (varp == NULL) {  // hidden option</a>
<a name="ln4745">    return -1;</a>
<a name="ln4746">  }</a>
<a name="ln4747">  if (options[opt_idx].flags &amp; P_NUM) {</a>
<a name="ln4748">    *numval = *(long *)varp;</a>
<a name="ln4749">  } else {</a>
<a name="ln4750">    // Special case: 'modified' is b_changed, but we also want to consider</a>
<a name="ln4751">    // it set when 'ff' or 'fenc' changed.</a>
<a name="ln4752">    if ((int *)varp == &amp;curbuf-&gt;b_changed) {</a>
<a name="ln4753">      *numval = curbufIsChanged();</a>
<a name="ln4754">    } else {</a>
<a name="ln4755">      *numval = (long) *(int *)varp;  // NOLINT(whitespace/cast)</a>
<a name="ln4756">    }</a>
<a name="ln4757">  }</a>
<a name="ln4758">  return 1;</a>
<a name="ln4759">}</a>
<a name="ln4760"> </a>
<a name="ln4761">// Returns the option attributes and its value. Unlike the above function it</a>
<a name="ln4762">// will return either global value or local value of the option depending on</a>
<a name="ln4763">// what was requested, but it will never return global value if it was</a>
<a name="ln4764">// requested to return local one and vice versa. Neither it will return</a>
<a name="ln4765">// buffer-local value if it was requested to return window-local one.</a>
<a name="ln4766">//</a>
<a name="ln4767">// Pretends that option is absent if it is not present in the requested scope</a>
<a name="ln4768">// (i.e. has no global, window-local or buffer-local value depending on</a>
<a name="ln4769">// opt_type).</a>
<a name="ln4770">//</a>
<a name="ln4771">// Returned flags:</a>
<a name="ln4772">//       0 hidden or unknown option, also option that does not have requested</a>
<a name="ln4773">//         type (see SREQ_* in option_defs.h)</a>
<a name="ln4774">//  see SOPT_* in option_defs.h for other flags</a>
<a name="ln4775">//</a>
<a name="ln4776">// Possible opt_type values: see SREQ_* in option_defs.h</a>
<a name="ln4777">int get_option_value_strict(char *name,</a>
<a name="ln4778">                            int64_t *numval,</a>
<a name="ln4779">                            char **stringval,</a>
<a name="ln4780">                            int opt_type,</a>
<a name="ln4781">                            void *from)</a>
<a name="ln4782">{</a>
<a name="ln4783">  if (get_tty_option(name, stringval)) {</a>
<a name="ln4784">    return SOPT_STRING | SOPT_GLOBAL;</a>
<a name="ln4785">  }</a>
<a name="ln4786"> </a>
<a name="ln4787">  char_u *varp = NULL;</a>
<a name="ln4788">  int rv = 0;</a>
<a name="ln4789">  int opt_idx = findoption(name);</a>
<a name="ln4790">  if (opt_idx &lt; 0) {</a>
<a name="ln4791">    return 0;</a>
<a name="ln4792">  }</a>
<a name="ln4793"> </a>
<a name="ln4794">  vimoption_T *p = &amp;options[opt_idx];</a>
<a name="ln4795"> </a>
<a name="ln4796">  // Hidden option</a>
<a name="ln4797">  if (p-&gt;var == NULL) {</a>
<a name="ln4798">    return 0;</a>
<a name="ln4799">  }</a>
<a name="ln4800"> </a>
<a name="ln4801">  if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln4802">    rv |= SOPT_BOOL;</a>
<a name="ln4803">  } else if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln4804">    rv |= SOPT_NUM;</a>
<a name="ln4805">  } else if (p-&gt;flags &amp; P_STRING) {</a>
<a name="ln4806">    rv |= SOPT_STRING;</a>
<a name="ln4807">  }</a>
<a name="ln4808"> </a>
<a name="ln4809">  if (p-&gt;indir == PV_NONE) {</a>
<a name="ln4810">    if (opt_type == SREQ_GLOBAL) {</a>
<a name="ln4811">      rv |= SOPT_GLOBAL;</a>
<a name="ln4812">    } else {</a>
<a name="ln4813">      return 0;  // Did not request global-only option</a>
<a name="ln4814">    }</a>
<a name="ln4815">  } else {</a>
<a name="ln4816">    if (p-&gt;indir &amp; PV_BOTH) {</a>
<a name="ln4817">      rv |= SOPT_GLOBAL;</a>
<a name="ln4818">    }</a>
<a name="ln4819"> </a>
<a name="ln4820">    if (p-&gt;indir &amp; PV_WIN) {</a>
<a name="ln4821">      if (opt_type == SREQ_BUF) {</a>
<a name="ln4822">        return 0;  // Requested buffer-local, not window-local option</a>
<a name="ln4823">      } else {</a>
<a name="ln4824">        rv |= SOPT_WIN;</a>
<a name="ln4825">      }</a>
<a name="ln4826">    } else if (p-&gt;indir &amp; PV_BUF) {</a>
<a name="ln4827">      if (opt_type == SREQ_WIN) {</a>
<a name="ln4828">        return 0;  // Requested window-local, not buffer-local option</a>
<a name="ln4829">      } else {</a>
<a name="ln4830">        rv |= SOPT_BUF;</a>
<a name="ln4831">      }</a>
<a name="ln4832">    }</a>
<a name="ln4833">  }</a>
<a name="ln4834"> </a>
<a name="ln4835">  if (stringval == NULL) {</a>
<a name="ln4836">    return rv;</a>
<a name="ln4837">  }</a>
<a name="ln4838"> </a>
<a name="ln4839">  if (opt_type == SREQ_GLOBAL) {</a>
<a name="ln4840">    if (p-&gt;var == VAR_WIN) {</a>
<a name="ln4841">      return 0;</a>
<a name="ln4842">    } else {</a>
<a name="ln4843">      varp = p-&gt;var;</a>
<a name="ln4844">    }</a>
<a name="ln4845">  } else {</a>
<a name="ln4846">    if (opt_type == SREQ_BUF) {</a>
<a name="ln4847">      // Special case: 'modified' is b_changed, but we also want to</a>
<a name="ln4848">      // consider it set when 'ff' or 'fenc' changed.</a>
<a name="ln4849">      if (p-&gt;indir == PV_MOD) {</a>
<a name="ln4850">        *numval = bufIsChanged((buf_T *)from);</a>
<a name="ln4851">        varp = NULL;</a>
<a name="ln4852">      } else {</a>
<a name="ln4853">        buf_T *save_curbuf = curbuf;</a>
<a name="ln4854"> </a>
<a name="ln4855">        // only getting a pointer, no need to use aucmd_prepbuf()</a>
<a name="ln4856">        curbuf = (buf_T *)from;</a>
<a name="ln4857">        curwin-&gt;w_buffer = curbuf;</a>
<a name="ln4858">        varp = get_varp(p);</a>
<a name="ln4859">        curbuf = save_curbuf;</a>
<a name="ln4860">        curwin-&gt;w_buffer = curbuf;</a>
<a name="ln4861">      }</a>
<a name="ln4862">    } else if (opt_type == SREQ_WIN) {</a>
<a name="ln4863">      win_T *save_curwin = curwin;</a>
<a name="ln4864">      curwin = (win_T *)from;</a>
<a name="ln4865">      curbuf = curwin-&gt;w_buffer;</a>
<a name="ln4866">      varp = get_varp(p);</a>
<a name="ln4867">      curwin = save_curwin;</a>
<a name="ln4868">      curbuf = curwin-&gt;w_buffer;</a>
<a name="ln4869">    }</a>
<a name="ln4870"> </a>
<a name="ln4871">    if (varp == p-&gt;var) {</a>
<a name="ln4872">      return (rv | SOPT_UNSET);</a>
<a name="ln4873">    }</a>
<a name="ln4874">  }</a>
<a name="ln4875"> </a>
<a name="ln4876">  if (varp != NULL) {</a>
<a name="ln4877">    if (p-&gt;flags &amp; P_STRING) {</a>
<a name="ln4878">      *stringval = xstrdup(*(char **)(varp));</a>
<a name="ln4879">    } else if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln4880">      *numval = *(long *) varp;</a>
<a name="ln4881">    } else {</a>
<a name="ln4882">      *numval = *(int *)varp;</a>
<a name="ln4883">    }</a>
<a name="ln4884">  }</a>
<a name="ln4885"> </a>
<a name="ln4886">  return rv;</a>
<a name="ln4887">}</a>
<a name="ln4888"> </a>
<a name="ln4889">/// Set the value of an option</a>
<a name="ln4890">///</a>
<a name="ln4891">/// @param[in]  name  Option name.</a>
<a name="ln4892">/// @param[in]  number  New value for the number or boolean option.</a>
<a name="ln4893">/// @param[in]  string  New value for string option.</a>
<a name="ln4894">/// @param[in]  opt_flags  Flags: OPT_LOCAL, OPT_GLOBAL, or 0 (both).</a>
<a name="ln4895">///</a>
<a name="ln4896">/// @return NULL on success, error message on error.</a>
<a name="ln4897">char *set_option_value(const char *const name, const long number,</a>
<a name="ln4898">                       const char *const string, const int opt_flags)</a>
<a name="ln4899">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln4900">{</a>
<a name="ln4901">  if (is_tty_option(name)) {</a>
<a name="ln4902">    return NULL;  // Fail silently; many old vimrcs set t_xx options.</a>
<a name="ln4903">  }</a>
<a name="ln4904"> </a>
<a name="ln4905">  int opt_idx;</a>
<a name="ln4906">  char_u      *varp;</a>
<a name="ln4907"> </a>
<a name="ln4908">  opt_idx = findoption(name);</a>
<a name="ln4909">  if (opt_idx &lt; 0) {</a>
<a name="ln4910">    EMSG2(_(&quot;E355: Unknown option: %s&quot;), name);</a>
<a name="ln4911">  } else {</a>
<a name="ln4912">    uint32_t flags = options[opt_idx].flags;</a>
<a name="ln4913">    // Disallow changing some options in the sandbox</a>
<a name="ln4914">    if (sandbox &gt; 0 &amp;&amp; (flags &amp; P_SECURE)) {</a>
<a name="ln4915">      EMSG(_(e_sandbox));</a>
<a name="ln4916">      return NULL;</a>
<a name="ln4917">    }</a>
<a name="ln4918">    if (flags &amp; P_STRING) {</a>
<a name="ln4919">      const char *s = string;</a>
<a name="ln4920">      if (s == NULL) {</a>
<a name="ln4921">        s = &quot;&quot;;</a>
<a name="ln4922">      }</a>
<a name="ln4923">      return set_string_option(opt_idx, s, opt_flags);</a>
<a name="ln4924">    } else {</a>
<a name="ln4925">      varp = get_varp_scope(&amp;(options[opt_idx]), opt_flags);</a>
<a name="ln4926">      if (varp != NULL) {       // hidden option is not changed</a>
<a name="ln4927">        if (number == 0 &amp;&amp; string != NULL) {</a>
<a name="ln4928">          int idx;</a>
<a name="ln4929"> </a>
<a name="ln4930">          // Either we are given a string or we are setting option</a>
<a name="ln4931">          // to zero.</a>
<a name="ln4932">          for (idx = 0; string[idx] == '0'; idx++) {}</a>
<a name="ln4933">          if (string[idx] != NUL || idx == 0) {</a>
<a name="ln4934">            // There's another character after zeros or the string</a>
<a name="ln4935">            // is empty.  In both cases, we are trying to set a</a>
<a name="ln4936">            // num option using a string.</a>
<a name="ln4937">            EMSG3(_(&quot;E521: Number required: &amp;%s = '%s'&quot;),</a>
<a name="ln4938">                  name, string);</a>
<a name="ln4939">            return NULL;  // do nothing as we hit an error</a>
<a name="ln4940">          }</a>
<a name="ln4941">        }</a>
<a name="ln4942">        if (flags &amp; P_NUM) {</a>
<a name="ln4943">          return set_num_option(opt_idx, varp, number, NULL, 0, opt_flags);</a>
<a name="ln4944">        } else {</a>
<a name="ln4945">          return set_bool_option(opt_idx, varp, (int)number, opt_flags);</a>
<a name="ln4946">        }</a>
<a name="ln4947">      }</a>
<a name="ln4948">    }</a>
<a name="ln4949">  }</a>
<a name="ln4950">  return NULL;</a>
<a name="ln4951">}</a>
<a name="ln4952"> </a>
<a name="ln4953">// Translate a string like &quot;t_xx&quot;, &quot;&lt;t_xx&gt;&quot; or &quot;&lt;S-Tab&gt;&quot; to a key number.</a>
<a name="ln4954">// When &quot;has_lt&quot; is true there is a '&lt;' before &quot;*arg_arg&quot;.</a>
<a name="ln4955">// Returns 0 when the key is not recognized.</a>
<a name="ln4956">int find_key_option_len(const char_u *arg_arg, size_t len, bool has_lt)</a>
<a name="ln4957">{</a>
<a name="ln4958">  int key = 0;</a>
<a name="ln4959">  int modifiers;</a>
<a name="ln4960">  const char_u *arg = arg_arg;</a>
<a name="ln4961"> </a>
<a name="ln4962">  // Don't use get_special_key_code() for t_xx, we don't want it to call</a>
<a name="ln4963">  // add_termcap_entry().</a>
<a name="ln4964">  if (len &gt;= 4 &amp;&amp; arg[0] == 't' &amp;&amp; arg[1] == '_') {</a>
<a name="ln4965">    key = TERMCAP2KEY(arg[2], arg[3]);</a>
<a name="ln4966">  } else if (has_lt)  {</a>
<a name="ln4967">    arg--;  // put arg at the '&lt;'</a>
<a name="ln4968">    modifiers = 0;</a>
<a name="ln4969">    key = find_special_key(&amp;arg, len + 1, &amp;modifiers, true, true, false);</a>
<a name="ln4970">    if (modifiers) {  // can't handle modifiers here</a>
<a name="ln4971">      key = 0;</a>
<a name="ln4972">    }</a>
<a name="ln4973">  }</a>
<a name="ln4974">  return key;</a>
<a name="ln4975">}</a>
<a name="ln4976"> </a>
<a name="ln4977">static int find_key_option(const char_u *arg, bool has_lt)</a>
<a name="ln4978">{</a>
<a name="ln4979">  return find_key_option_len(arg, STRLEN(arg), has_lt);</a>
<a name="ln4980">}</a>
<a name="ln4981"> </a>
<a name="ln4982">/// if 'all' == 0: show changed options</a>
<a name="ln4983">/// if 'all' == 1: show all normal options</a>
<a name="ln4984">static void</a>
<a name="ln4985">showoptions(</a>
<a name="ln4986">    int all,</a>
<a name="ln4987">    int opt_flags                  // OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln4988">)</a>
<a name="ln4989">{</a>
<a name="ln4990">  vimoption_T    *p;</a>
<a name="ln4991">  int col;</a>
<a name="ln4992">  char_u              *varp;</a>
<a name="ln4993">  int item_count;</a>
<a name="ln4994">  int run;</a>
<a name="ln4995">  int row, rows;</a>
<a name="ln4996">  int cols;</a>
<a name="ln4997">  int i;</a>
<a name="ln4998">  int len;</a>
<a name="ln4999"> </a>
<a name="ln5000">#define INC 20</a>
<a name="ln5001">#define GAP 3</a>
<a name="ln5002"> </a>
<a name="ln5003">  vimoption_T **items = xmalloc(sizeof(vimoption_T *) * PARAM_COUNT);</a>
<a name="ln5004"> </a>
<a name="ln5005">  // Highlight title</a>
<a name="ln5006">  if (opt_flags &amp; OPT_GLOBAL) {</a>
<a name="ln5007">    MSG_PUTS_TITLE(_(&quot;\n--- Global option values ---&quot;));</a>
<a name="ln5008">  } else if (opt_flags &amp; OPT_LOCAL) {</a>
<a name="ln5009">    MSG_PUTS_TITLE(_(&quot;\n--- Local option values ---&quot;));</a>
<a name="ln5010">  } else {</a>
<a name="ln5011">    MSG_PUTS_TITLE(_(&quot;\n--- Options ---&quot;));</a>
<a name="ln5012">  }</a>
<a name="ln5013"> </a>
<a name="ln5014">  // Do the loop two times:</a>
<a name="ln5015">  // 1. display the short items</a>
<a name="ln5016">  // 2. display the long items (only strings and numbers)</a>
<a name="ln5017">  for (run = 1; run &lt;= 2 &amp;&amp; !got_int; run++) {</a>
<a name="ln5018">    // collect the items in items[]</a>
<a name="ln5019">    item_count = 0;</a>
<a name="ln5020">    for (p = &amp;options[0]; p-&gt;fullname != NULL; p++) {</a>
<a name="ln5021">      // apply :filter /pat/</a>
<a name="ln5022">      if (message_filtered((char_u *)p-&gt;fullname)) {</a>
<a name="ln5023">        continue;</a>
<a name="ln5024">      }</a>
<a name="ln5025"> </a>
<a name="ln5026">      varp = NULL;</a>
<a name="ln5027">      if (opt_flags != 0) {</a>
<a name="ln5028">        if (p-&gt;indir != PV_NONE) {</a>
<a name="ln5029">          varp = get_varp_scope(p, opt_flags);</a>
<a name="ln5030">        }</a>
<a name="ln5031">      } else {</a>
<a name="ln5032">        varp = get_varp(p);</a>
<a name="ln5033">      }</a>
<a name="ln5034">      if (varp != NULL</a>
<a name="ln5035">          &amp;&amp; (all == 1 || (all == 0 &amp;&amp; !optval_default(p, varp)))) {</a>
<a name="ln5036">        if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln5037">          len = 1;                      //  a toggle option fits always</a>
<a name="ln5038">        } else {</a>
<a name="ln5039">          option_value2string(p, opt_flags);</a>
<a name="ln5040">          len = (int)STRLEN(p-&gt;fullname) + vim_strsize(NameBuff) + 1;</a>
<a name="ln5041">        }</a>
<a name="ln5042">        if ((len &lt;= INC - GAP &amp;&amp; run == 1)</a>
<a name="ln5043">            || (len &gt; INC - GAP &amp;&amp; run == 2)) {</a>
<a name="ln5044">          items[item_count++] = p;</a>
<a name="ln5045">        }</a>
<a name="ln5046">      }</a>
<a name="ln5047">    }</a>
<a name="ln5048"> </a>
<a name="ln5049">    /*</a>
<a name="ln5050">     * display the items</a>
<a name="ln5051">     */</a>
<a name="ln5052">    if (run == 1) {</a>
<a name="ln5053">      assert(Columns &lt;= INT_MAX - GAP</a>
<a name="ln5054">             &amp;&amp; Columns + GAP &gt;= INT_MIN + 3</a>
<a name="ln5055">             &amp;&amp; (Columns + GAP - 3) / INC &gt;= INT_MIN</a>
<a name="ln5056">             &amp;&amp; (Columns + GAP - 3) / INC &lt;= INT_MAX);</a>
<a name="ln5057">      cols = (int)((Columns + GAP - 3) / INC);</a>
<a name="ln5058">      if (cols == 0) {</a>
<a name="ln5059">        cols = 1;</a>
<a name="ln5060">      }</a>
<a name="ln5061">      rows = (item_count + cols - 1) / cols;</a>
<a name="ln5062">    } else {    // run == 2</a>
<a name="ln5063">      rows = item_count;</a>
<a name="ln5064">    }</a>
<a name="ln5065">    for (row = 0; row &lt; rows &amp;&amp; !got_int; row++) {</a>
<a name="ln5066">      msg_putchar('\n');                        // go to next line</a>
<a name="ln5067">      if (got_int) {                            // 'q' typed in more</a>
<a name="ln5068">        break;</a>
<a name="ln5069">      }</a>
<a name="ln5070">      col = 0;</a>
<a name="ln5071">      for (i = row; i &lt; item_count; i += rows) {</a>
<a name="ln5072">        msg_col = col;                          // make columns</a>
<a name="ln5073">        showoneopt(items[i], opt_flags);</a>
<a name="ln5074">        col += INC;</a>
<a name="ln5075">      }</a>
<a name="ln5076">      ui_flush();</a>
<a name="ln5077">      os_breakcheck();</a>
<a name="ln5078">    }</a>
<a name="ln5079">  }</a>
<a name="ln5080">  xfree(items);</a>
<a name="ln5081">}</a>
<a name="ln5082"> </a>
<a name="ln5083">/// Return true if option &quot;p&quot; has its default value.</a>
<a name="ln5084">static int optval_default(vimoption_T *p, char_u *varp)</a>
<a name="ln5085">{</a>
<a name="ln5086">  int dvi;</a>
<a name="ln5087"> </a>
<a name="ln5088">  if (varp == NULL) {</a>
<a name="ln5089">    return true;            // hidden option is always at default</a>
<a name="ln5090">  }</a>
<a name="ln5091">  dvi = (p-&gt;flags &amp; P_VI_DEF) ? VI_DEFAULT : VIM_DEFAULT;</a>
<a name="ln5092">  if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln5093">    return *(long *)varp == (long)(intptr_t)p-&gt;def_val[dvi];</a>
<a name="ln5094">  }</a>
<a name="ln5095">  if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln5096">    return *(int *)varp == (int)(intptr_t)p-&gt;def_val[dvi];</a>
<a name="ln5097">  }</a>
<a name="ln5098">  // P_STRING</a>
<a name="ln5099">  return STRCMP(*(char_u **)varp, p-&gt;def_val[dvi]) == 0;</a>
<a name="ln5100">}</a>
<a name="ln5101"> </a>
<a name="ln5102">/// Send update to UIs with values of UI relevant options</a>
<a name="ln5103">void ui_refresh_options(void)</a>
<a name="ln5104">{</a>
<a name="ln5105">  for (int opt_idx = 0; options[opt_idx].fullname; opt_idx++) {</a>
<a name="ln5106">    uint32_t flags = options[opt_idx].flags;</a>
<a name="ln5107">    if (!(flags &amp; P_UI_OPTION)) {</a>
<a name="ln5108">      continue;</a>
<a name="ln5109">    }</a>
<a name="ln5110">    String name = cstr_as_string(options[opt_idx].fullname);</a>
<a name="ln5111">    void *varp = options[opt_idx].var;</a>
<a name="ln5112">    Object value = OBJECT_INIT;</a>
<a name="ln5113">    if (flags &amp; P_BOOL) {</a>
<a name="ln5114">      value = BOOLEAN_OBJ(*(int *)varp);</a>
<a name="ln5115">    } else if (flags &amp; P_NUM) {</a>
<a name="ln5116">      value = INTEGER_OBJ(*(long *)varp);</a>
<a name="ln5117">    } else if (flags &amp; P_STRING) {</a>
<a name="ln5118">      // cstr_as_string handles NULL string</a>
<a name="ln5119">      value = STRING_OBJ(cstr_as_string(*(char **)varp));</a>
<a name="ln5120">    }</a>
<a name="ln5121">    ui_call_option_set(name, value);</a>
<a name="ln5122">  }</a>
<a name="ln5123">  if (p_mouse != NULL) {</a>
<a name="ln5124">    setmouse();</a>
<a name="ln5125">  }</a>
<a name="ln5126">}</a>
<a name="ln5127"> </a>
<a name="ln5128">/// showoneopt: show the value of one option</a>
<a name="ln5129">/// must not be called with a hidden option!</a>
<a name="ln5130">static void</a>
<a name="ln5131">showoneopt(</a>
<a name="ln5132">    vimoption_T *p,</a>
<a name="ln5133">    int opt_flags                          // OPT_LOCAL or OPT_GLOBAL</a>
<a name="ln5134">)</a>
<a name="ln5135">{</a>
<a name="ln5136">  char_u      *varp;</a>
<a name="ln5137">  int save_silent = silent_mode;</a>
<a name="ln5138"> </a>
<a name="ln5139">  silent_mode = false;</a>
<a name="ln5140">  info_message = true;          // use mch_msg(), not mch_errmsg()</a>
<a name="ln5141"> </a>
<a name="ln5142">  varp = get_varp_scope(p, opt_flags);</a>
<a name="ln5143"> </a>
<a name="ln5144">  // for 'modified' we also need to check if 'ff' or 'fenc' changed.</a>
<a name="ln5145">  if ((p-&gt;flags &amp; P_BOOL) &amp;&amp; ((int *)varp == &amp;curbuf-&gt;b_changed</a>
<a name="ln5146">                              ? !curbufIsChanged() : !*(int *)varp)) {</a>
<a name="ln5147">    MSG_PUTS(&quot;no&quot;);</a>
<a name="ln5148">  } else if ((p-&gt;flags &amp; P_BOOL) &amp;&amp; *(int *)varp &lt; 0) {</a>
<a name="ln5149">    MSG_PUTS(&quot;--&quot;);</a>
<a name="ln5150">  } else {</a>
<a name="ln5151">    MSG_PUTS(&quot;  &quot;);</a>
<a name="ln5152">  }</a>
<a name="ln5153">  MSG_PUTS(p-&gt;fullname);</a>
<a name="ln5154">  if (!(p-&gt;flags &amp; P_BOOL)) {</a>
<a name="ln5155">    msg_putchar('=');</a>
<a name="ln5156">    // put value string in NameBuff</a>
<a name="ln5157">    option_value2string(p, opt_flags);</a>
<a name="ln5158">    msg_outtrans(NameBuff);</a>
<a name="ln5159">  }</a>
<a name="ln5160"> </a>
<a name="ln5161">  silent_mode = save_silent;</a>
<a name="ln5162">  info_message = false;</a>
<a name="ln5163">}</a>
<a name="ln5164"> </a>
<a name="ln5165">/// Write modified options as &quot;:set&quot; commands to a file.</a>
<a name="ln5166">///</a>
<a name="ln5167">/// There are three values for &quot;opt_flags&quot;:</a>
<a name="ln5168">/// OPT_GLOBAL:         Write global option values and fresh values of</a>
<a name="ln5169">///             buffer-local options (used for start of a session</a>
<a name="ln5170">///             file).</a>
<a name="ln5171">/// OPT_GLOBAL + OPT_LOCAL: Idem, add fresh values of window-local options for</a>
<a name="ln5172">///             curwin (used for a vimrc file).</a>
<a name="ln5173">/// OPT_LOCAL:          Write buffer-local option values for curbuf, fresh</a>
<a name="ln5174">///             and local values for window-local options of</a>
<a name="ln5175">///             curwin.  Local values are also written when at the</a>
<a name="ln5176">///             default value, because a modeline or autocommand</a>
<a name="ln5177">///             may have set them when doing &quot;:edit file&quot; and the</a>
<a name="ln5178">///             user has set them back at the default or fresh</a>
<a name="ln5179">///             value.</a>
<a name="ln5180">///             When &quot;local_only&quot; is true, don't write fresh</a>
<a name="ln5181">///             values, only local values (for &quot;:mkview&quot;).</a>
<a name="ln5182">/// (fresh value = value used for a new buffer or window for a local option).</a>
<a name="ln5183">///</a>
<a name="ln5184">/// Return FAIL on error, OK otherwise.</a>
<a name="ln5185">int makeset(FILE *fd, int opt_flags, int local_only)</a>
<a name="ln5186">{</a>
<a name="ln5187">  vimoption_T    *p;</a>
<a name="ln5188">  char_u              *varp;                    // currently used value</a>
<a name="ln5189">  char_u              *varp_fresh;              // local value</a>
<a name="ln5190">  char_u              *varp_local = NULL;       // fresh value</a>
<a name="ln5191">  char                *cmd;</a>
<a name="ln5192">  int round;</a>
<a name="ln5193">  int pri;</a>
<a name="ln5194"> </a>
<a name="ln5195">  /*</a>
<a name="ln5196">   * Some options are never written:</a>
<a name="ln5197">   * - Options that don't have a default (terminal name, columns, lines).</a>
<a name="ln5198">   * - Terminal options.</a>
<a name="ln5199">   * - Hidden options.</a>
<a name="ln5200">   *</a>
<a name="ln5201">   * Do the loop over &quot;options[]&quot; twice: once for options with the</a>
<a name="ln5202">   * P_PRI_MKRC flag and once without.</a>
<a name="ln5203">   */</a>
<a name="ln5204">  for (pri = 1; pri &gt;= 0; pri--) {</a>
<a name="ln5205">    for (p = &amp;options[0]; p-&gt;fullname; p++) {</a>
<a name="ln5206">      if (!(p-&gt;flags &amp; P_NO_MKRC)</a>
<a name="ln5207">          &amp;&amp; ((pri == 1) == ((p-&gt;flags &amp; P_PRI_MKRC) != 0))) {</a>
<a name="ln5208">        // skip global option when only doing locals</a>
<a name="ln5209">        if (p-&gt;indir == PV_NONE &amp;&amp; !(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln5210">          continue;</a>
<a name="ln5211">        }</a>
<a name="ln5212"> </a>
<a name="ln5213">        /* Do not store options like 'bufhidden' and 'syntax' in a vimrc</a>
<a name="ln5214">         * file, they are always buffer-specific. */</a>
<a name="ln5215">        if ((opt_flags &amp; OPT_GLOBAL) &amp;&amp; (p-&gt;flags &amp; P_NOGLOB)) {</a>
<a name="ln5216">          continue;</a>
<a name="ln5217">        }</a>
<a name="ln5218"> </a>
<a name="ln5219">        varp = get_varp_scope(p, opt_flags);</a>
<a name="ln5220">        // Hidden options are never written.</a>
<a name="ln5221">        if (!varp) {</a>
<a name="ln5222">          continue;</a>
<a name="ln5223">        }</a>
<a name="ln5224">        // Global values are only written when not at the default value.</a>
<a name="ln5225">        if ((opt_flags &amp; OPT_GLOBAL) &amp;&amp; optval_default(p, varp)) {</a>
<a name="ln5226">          continue;</a>
<a name="ln5227">        }</a>
<a name="ln5228"> </a>
<a name="ln5229">        round = 2;</a>
<a name="ln5230">        if (p-&gt;indir != PV_NONE) {</a>
<a name="ln5231">          if (p-&gt;var == VAR_WIN) {</a>
<a name="ln5232">            // skip window-local option when only doing globals</a>
<a name="ln5233">            if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln5234">              continue;</a>
<a name="ln5235">            }</a>
<a name="ln5236">            // When fresh value of window-local option is not at the</a>
<a name="ln5237">            // default, need to write it too.</a>
<a name="ln5238">            if (!(opt_flags &amp; OPT_GLOBAL) &amp;&amp; !local_only) {</a>
<a name="ln5239">              varp_fresh = get_varp_scope(p, OPT_GLOBAL);</a>
<a name="ln5240">              if (!optval_default(p, varp_fresh)) {</a>
<a name="ln5241">                round = 1;</a>
<a name="ln5242">                varp_local = varp;</a>
<a name="ln5243">                varp = varp_fresh;</a>
<a name="ln5244">              }</a>
<a name="ln5245">            }</a>
<a name="ln5246">          }</a>
<a name="ln5247">        }</a>
<a name="ln5248"> </a>
<a name="ln5249">        /* Round 1: fresh value for window-local options.</a>
<a name="ln5250">         * Round 2: other values */</a>
<a name="ln5251">        for (; round &lt;= 2; varp = varp_local, round++) {</a>
<a name="ln5252">          if (round == 1 || (opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln5253">            cmd = &quot;set&quot;;</a>
<a name="ln5254">          } else {</a>
<a name="ln5255">            cmd = &quot;setlocal&quot;;</a>
<a name="ln5256">          }</a>
<a name="ln5257"> </a>
<a name="ln5258">          if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln5259">            if (put_setbool(fd, cmd, p-&gt;fullname, *(int *)varp) == FAIL) {</a>
<a name="ln5260">              return FAIL;</a>
<a name="ln5261">            }</a>
<a name="ln5262">          } else if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln5263">            if (put_setnum(fd, cmd, p-&gt;fullname, (long *)varp) == FAIL) {</a>
<a name="ln5264">              return FAIL;</a>
<a name="ln5265">            }</a>
<a name="ln5266">          } else {    // P_STRING</a>
<a name="ln5267">            int do_endif = false;</a>
<a name="ln5268"> </a>
<a name="ln5269">            // Don't set 'syntax' and 'filetype' again if the value is</a>
<a name="ln5270">            // already right, avoids reloading the syntax file.</a>
<a name="ln5271">            if (p-&gt;indir == PV_SYN || p-&gt;indir == PV_FT) {</a>
<a name="ln5272">              if (fprintf(fd, &quot;if &amp;%s != '%s'&quot;, p-&gt;fullname,</a>
<a name="ln5273">                          *(char_u **)(varp)) &lt; 0</a>
<a name="ln5274">                  || put_eol(fd) &lt; 0) {</a>
<a name="ln5275">                return FAIL;</a>
<a name="ln5276">              }</a>
<a name="ln5277">              do_endif = true;</a>
<a name="ln5278">            }</a>
<a name="ln5279">            if (put_setstring(fd, cmd, p-&gt;fullname, (char_u **)varp,</a>
<a name="ln5280">                              p-&gt;flags) == FAIL) {</a>
<a name="ln5281">              return FAIL;</a>
<a name="ln5282">            }</a>
<a name="ln5283">            if (do_endif) {</a>
<a name="ln5284">              if (put_line(fd, &quot;endif&quot;) == FAIL) {</a>
<a name="ln5285">                return FAIL;</a>
<a name="ln5286">              }</a>
<a name="ln5287">            }</a>
<a name="ln5288">          }</a>
<a name="ln5289">        }</a>
<a name="ln5290">      }</a>
<a name="ln5291">    }</a>
<a name="ln5292">  }</a>
<a name="ln5293">  return OK;</a>
<a name="ln5294">}</a>
<a name="ln5295"> </a>
<a name="ln5296">/// Generate set commands for the local fold options only.  Used when</a>
<a name="ln5297">/// 'sessionoptions' or 'viewoptions' contains &quot;folds&quot; but not &quot;options&quot;.</a>
<a name="ln5298">int makefoldset(FILE *fd)</a>
<a name="ln5299">{</a>
<a name="ln5300">  if (put_setstring(fd, &quot;setlocal&quot;, &quot;fdm&quot;, &amp;curwin-&gt;w_p_fdm, 0) == FAIL</a>
<a name="ln5301">      || put_setstring(fd, &quot;setlocal&quot;, &quot;fde&quot;, &amp;curwin-&gt;w_p_fde, 0)</a>
<a name="ln5302">      == FAIL</a>
<a name="ln5303">      || put_setstring(fd, &quot;setlocal&quot;, &quot;fmr&quot;, &amp;curwin-&gt;w_p_fmr, 0)</a>
<a name="ln5304">      == FAIL</a>
<a name="ln5305">      || put_setstring(fd, &quot;setlocal&quot;, &quot;fdi&quot;, &amp;curwin-&gt;w_p_fdi, 0)</a>
<a name="ln5306">      == FAIL</a>
<a name="ln5307">      || put_setnum(fd, &quot;setlocal&quot;, &quot;fdl&quot;, &amp;curwin-&gt;w_p_fdl) == FAIL</a>
<a name="ln5308">      || put_setnum(fd, &quot;setlocal&quot;, &quot;fml&quot;, &amp;curwin-&gt;w_p_fml) == FAIL</a>
<a name="ln5309">      || put_setnum(fd, &quot;setlocal&quot;, &quot;fdn&quot;, &amp;curwin-&gt;w_p_fdn) == FAIL</a>
<a name="ln5310">      || put_setbool(fd, &quot;setlocal&quot;, &quot;fen&quot;, curwin-&gt;w_p_fen) == FAIL</a>
<a name="ln5311">      ) {</a>
<a name="ln5312">    return FAIL;</a>
<a name="ln5313">  }</a>
<a name="ln5314"> </a>
<a name="ln5315">  return OK;</a>
<a name="ln5316">}</a>
<a name="ln5317"> </a>
<a name="ln5318">static int put_setstring(FILE *fd, char *cmd, char *name,</a>
<a name="ln5319">                         char_u **valuep, uint64_t flags)</a>
<a name="ln5320">{</a>
<a name="ln5321">  char_u      *s;</a>
<a name="ln5322">  char_u      *buf = NULL;</a>
<a name="ln5323">  char_u      *part = NULL;</a>
<a name="ln5324">  char_u      *p;</a>
<a name="ln5325"> </a>
<a name="ln5326">  if (fprintf(fd, &quot;%s %s=&quot;, cmd, name) &lt; 0) {</a>
<a name="ln5327">    return FAIL;</a>
<a name="ln5328">  }</a>
<a name="ln5329">  if (*valuep != NULL) {</a>
<a name="ln5330">    /* Output 'pastetoggle' as key names.  For other</a>
<a name="ln5331">     * options some characters have to be escaped with</a>
<a name="ln5332">     * CTRL-V or backslash */</a>
<a name="ln5333">    if (valuep == &amp;p_pt) {</a>
<a name="ln5334">      s = *valuep;</a>
<a name="ln5335">      while (*s != NUL) {</a>
<a name="ln5336">        if (put_escstr(fd, (char_u *)str2special((const char **)&amp;s, false,</a>
<a name="ln5337">                                                 false), 2)</a>
<a name="ln5338">            == FAIL) {</a>
<a name="ln5339">          return FAIL;</a>
<a name="ln5340">        }</a>
<a name="ln5341">      }</a>
<a name="ln5342">    } else if ((flags &amp; P_EXPAND) != 0) {</a>
<a name="ln5343">      size_t size = (size_t)STRLEN(*valuep) + 1;</a>
<a name="ln5344"> </a>
<a name="ln5345">      // replace home directory in the whole option value into &quot;buf&quot;</a>
<a name="ln5346">      buf = xmalloc(size);</a>
<a name="ln5347">      home_replace(NULL, *valuep, buf, size, false);</a>
<a name="ln5348"> </a>
<a name="ln5349">      // If the option value is longer than MAXPATHL, we need to append</a>
<a name="ln5350">      // earch comma separated part of the option sperately, so that it</a>
<a name="ln5351">      // can be expanded when read back.</a>
<a name="ln5352">      if (size &gt;= MAXPATHL &amp;&amp; (flags &amp; P_COMMA) != 0</a>
<a name="ln5353">          &amp;&amp; vim_strchr(*valuep, ',') != NULL) {</a>
<a name="ln5354">        part = xmalloc(size);</a>
<a name="ln5355"> </a>
<a name="ln5356">        // write line break to clear the option, e.g. ':set rtp='</a>
<a name="ln5357">        if (put_eol(fd) == FAIL) {</a>
<a name="ln5358">          goto fail;</a>
<a name="ln5359">        }</a>
<a name="ln5360">        p = buf;</a>
<a name="ln5361">        while (*p != NUL) {</a>
<a name="ln5362">            // for each comma seperated option part, append value to</a>
<a name="ln5363">            // the option, :set rtp+=value</a>
<a name="ln5364">            if (fprintf(fd, &quot;%s %s+=&quot;, cmd, name) &lt; 0) {</a>
<a name="ln5365">              goto fail;</a>
<a name="ln5366">            }</a>
<a name="ln5367">            (void)copy_option_part(&amp;p, part, size, &quot;,&quot;);</a>
<a name="ln5368">            if (put_escstr(fd, part, 2) == FAIL || put_eol(fd) == FAIL) {</a>
<a name="ln5369">              goto fail;</a>
<a name="ln5370">            }</a>
<a name="ln5371">        }</a>
<a name="ln5372">        xfree(buf);</a>
<a name="ln5373">        xfree(part);</a>
<a name="ln5374">        return OK;</a>
<a name="ln5375">      }</a>
<a name="ln5376">      if (put_escstr(fd, buf, 2) == FAIL) {</a>
<a name="ln5377">        xfree(buf);</a>
<a name="ln5378">        return FAIL;</a>
<a name="ln5379">      }</a>
<a name="ln5380">      xfree(buf);</a>
<a name="ln5381">    } else if (put_escstr(fd, *valuep, 2) == FAIL) {</a>
<a name="ln5382">      return FAIL;</a>
<a name="ln5383">    }</a>
<a name="ln5384">  }</a>
<a name="ln5385">  if (put_eol(fd) &lt; 0) {</a>
<a name="ln5386">    return FAIL;</a>
<a name="ln5387">  }</a>
<a name="ln5388">  return OK;</a>
<a name="ln5389">fail:</a>
<a name="ln5390">  xfree(buf);</a>
<a name="ln5391">  xfree(part);</a>
<a name="ln5392">  return FAIL;</a>
<a name="ln5393">}</a>
<a name="ln5394"> </a>
<a name="ln5395">static int put_setnum(FILE *fd, char *cmd, char *name, long *valuep)</a>
<a name="ln5396">{</a>
<a name="ln5397">  long wc;</a>
<a name="ln5398"> </a>
<a name="ln5399">  if (fprintf(fd, &quot;%s %s=&quot;, cmd, name) &lt; 0) {</a>
<a name="ln5400">    return FAIL;</a>
<a name="ln5401">  }</a>
<a name="ln5402">  if (wc_use_keyname((char_u *)valuep, &amp;wc)) {</a>
<a name="ln5403">    // print 'wildchar' and 'wildcharm' as a key name</a>
<a name="ln5404">    if (fputs((char *)get_special_key_name((int)wc, 0), fd) &lt; 0) {</a>
<a name="ln5405">      return FAIL;</a>
<a name="ln5406">    }</a>
<a name="ln5407">  } else if (fprintf(fd, &quot;%&quot; PRId64, (int64_t)(*valuep)) &lt; 0) {</a>
<a name="ln5408">    return FAIL;</a>
<a name="ln5409">  }</a>
<a name="ln5410">  if (put_eol(fd) &lt; 0) {</a>
<a name="ln5411">    return FAIL;</a>
<a name="ln5412">  }</a>
<a name="ln5413">  return OK;</a>
<a name="ln5414">}</a>
<a name="ln5415"> </a>
<a name="ln5416">static int put_setbool(FILE *fd, char *cmd, char *name, int value)</a>
<a name="ln5417">{</a>
<a name="ln5418">  if (value &lt; 0) {      // global/local option using global value</a>
<a name="ln5419">    return OK;</a>
<a name="ln5420">  }</a>
<a name="ln5421">  if (fprintf(fd, &quot;%s %s%s&quot;, cmd, value ? &quot;&quot; : &quot;no&quot;, name) &lt; 0</a>
<a name="ln5422">      || put_eol(fd) &lt; 0) {</a>
<a name="ln5423">    return FAIL;</a>
<a name="ln5424">  }</a>
<a name="ln5425">  return OK;</a>
<a name="ln5426">}</a>
<a name="ln5427"> </a>
<a name="ln5428">/// Compute columns for ruler and shown command. 'sc_col' is also used to</a>
<a name="ln5429">/// decide what the maximum length of a message on the status line can be.</a>
<a name="ln5430">/// If there is a status line for the last window, 'sc_col' is independent</a>
<a name="ln5431">/// of 'ru_col'.</a>
<a name="ln5432"> </a>
<a name="ln5433">#define COL_RULER 17        // columns needed by standard ruler</a>
<a name="ln5434"> </a>
<a name="ln5435">void comp_col(void)</a>
<a name="ln5436">{</a>
<a name="ln5437">  int last_has_status = (p_ls == 2 || (p_ls == 1 &amp;&amp; !ONE_WINDOW));</a>
<a name="ln5438"> </a>
<a name="ln5439">  sc_col = 0;</a>
<a name="ln5440">  ru_col = 0;</a>
<a name="ln5441">  if (p_ru) {</a>
<a name="ln5442">    ru_col = (ru_wid ? ru_wid : COL_RULER) + 1;</a>
<a name="ln5443">    // no last status line, adjust sc_col</a>
<a name="ln5444">    if (!last_has_status) {</a>
<a name="ln5445">      sc_col = ru_col;</a>
<a name="ln5446">    }</a>
<a name="ln5447">  }</a>
<a name="ln5448">  if (p_sc) {</a>
<a name="ln5449">    sc_col += SHOWCMD_COLS;</a>
<a name="ln5450">    if (!p_ru || last_has_status) {         // no need for separating space</a>
<a name="ln5451">      sc_col++;</a>
<a name="ln5452">    }</a>
<a name="ln5453">  }</a>
<a name="ln5454">  assert(sc_col &gt;= 0</a>
<a name="ln5455">         &amp;&amp; INT_MIN + sc_col &lt;= Columns</a>
<a name="ln5456">         &amp;&amp; Columns - sc_col &lt;= INT_MAX);</a>
<a name="ln5457">  sc_col = (int)(Columns - sc_col);</a>
<a name="ln5458">  assert(ru_col &gt;= 0</a>
<a name="ln5459">         &amp;&amp; INT_MIN + ru_col &lt;= Columns</a>
<a name="ln5460">         &amp;&amp; Columns - ru_col &lt;= INT_MAX);</a>
<a name="ln5461">  ru_col = (int)(Columns - ru_col);</a>
<a name="ln5462">  if (sc_col &lt;= 0) {            // screen too narrow, will become a mess</a>
<a name="ln5463">    sc_col = 1;</a>
<a name="ln5464">  }</a>
<a name="ln5465">  if (ru_col &lt;= 0) {</a>
<a name="ln5466">    ru_col = 1;</a>
<a name="ln5467">  }</a>
<a name="ln5468">  set_vim_var_nr(VV_ECHOSPACE, sc_col - 1);</a>
<a name="ln5469">}</a>
<a name="ln5470"> </a>
<a name="ln5471">// Unset local option value, similar to &quot;:set opt&lt;&quot;.</a>
<a name="ln5472">void unset_global_local_option(char *name, void *from)</a>
<a name="ln5473">{</a>
<a name="ln5474">  vimoption_T *p;</a>
<a name="ln5475">  buf_T *buf = (buf_T *)from;</a>
<a name="ln5476"> </a>
<a name="ln5477">  int opt_idx = findoption(name);</a>
<a name="ln5478">  if (opt_idx &lt; 0) {</a>
<a name="ln5479">    EMSG2(_(&quot;E355: Unknown option: %s&quot;), name);</a>
<a name="ln5480">    return;</a>
<a name="ln5481">  }</a>
<a name="ln5482">  p = &amp;(options[opt_idx]);</a>
<a name="ln5483"> </a>
<a name="ln5484">  switch ((int)p-&gt;indir)</a>
<a name="ln5485">  {</a>
<a name="ln5486">    // global option with local value: use local value if it's been set</a>
<a name="ln5487">    case PV_EP:</a>
<a name="ln5488">      clear_string_option(&amp;buf-&gt;b_p_ep);</a>
<a name="ln5489">      break;</a>
<a name="ln5490">    case PV_KP:</a>
<a name="ln5491">      clear_string_option(&amp;buf-&gt;b_p_kp);</a>
<a name="ln5492">      break;</a>
<a name="ln5493">    case PV_PATH:</a>
<a name="ln5494">      clear_string_option(&amp;buf-&gt;b_p_path);</a>
<a name="ln5495">      break;</a>
<a name="ln5496">    case PV_AR:</a>
<a name="ln5497">      buf-&gt;b_p_ar = -1;</a>
<a name="ln5498">      break;</a>
<a name="ln5499">    case PV_BKC:</a>
<a name="ln5500">      clear_string_option(&amp;buf-&gt;b_p_bkc);</a>
<a name="ln5501">      buf-&gt;b_bkc_flags = 0;</a>
<a name="ln5502">      break;</a>
<a name="ln5503">    case PV_TAGS:</a>
<a name="ln5504">      clear_string_option(&amp;buf-&gt;b_p_tags);</a>
<a name="ln5505">      break;</a>
<a name="ln5506">    case PV_TC:</a>
<a name="ln5507">      clear_string_option(&amp;buf-&gt;b_p_tc);</a>
<a name="ln5508">      buf-&gt;b_tc_flags = 0;</a>
<a name="ln5509">      break;</a>
<a name="ln5510">    case PV_SISO:</a>
<a name="ln5511">      curwin-&gt;w_p_siso = -1;</a>
<a name="ln5512">      break;</a>
<a name="ln5513">    case PV_SO:</a>
<a name="ln5514">      curwin-&gt;w_p_so = -1;</a>
<a name="ln5515">      break;</a>
<a name="ln5516">    case PV_DEF:</a>
<a name="ln5517">      clear_string_option(&amp;buf-&gt;b_p_def);</a>
<a name="ln5518">      break;</a>
<a name="ln5519">    case PV_INC:</a>
<a name="ln5520">      clear_string_option(&amp;buf-&gt;b_p_inc);</a>
<a name="ln5521">      break;</a>
<a name="ln5522">    case PV_DICT:</a>
<a name="ln5523">      clear_string_option(&amp;buf-&gt;b_p_dict);</a>
<a name="ln5524">      break;</a>
<a name="ln5525">    case PV_TSR:</a>
<a name="ln5526">      clear_string_option(&amp;buf-&gt;b_p_tsr);</a>
<a name="ln5527">      break;</a>
<a name="ln5528">    case PV_FP:</a>
<a name="ln5529">      clear_string_option(&amp;buf-&gt;b_p_fp);</a>
<a name="ln5530">      break;</a>
<a name="ln5531">    case PV_EFM:</a>
<a name="ln5532">      clear_string_option(&amp;buf-&gt;b_p_efm);</a>
<a name="ln5533">      break;</a>
<a name="ln5534">    case PV_GP:</a>
<a name="ln5535">      clear_string_option(&amp;buf-&gt;b_p_gp);</a>
<a name="ln5536">      break;</a>
<a name="ln5537">    case PV_MP:</a>
<a name="ln5538">      clear_string_option(&amp;buf-&gt;b_p_mp);</a>
<a name="ln5539">      break;</a>
<a name="ln5540">    case PV_STL:</a>
<a name="ln5541">      clear_string_option(&amp;((win_T *)from)-&gt;w_p_stl);</a>
<a name="ln5542">      break;</a>
<a name="ln5543">    case PV_UL:</a>
<a name="ln5544">      buf-&gt;b_p_ul = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln5545">      break;</a>
<a name="ln5546">    case PV_LW:</a>
<a name="ln5547">      clear_string_option(&amp;buf-&gt;b_p_lw);</a>
<a name="ln5548">      break;</a>
<a name="ln5549">    case PV_MENC:</a>
<a name="ln5550">      clear_string_option(&amp;buf-&gt;b_p_menc);</a>
<a name="ln5551">      break;</a>
<a name="ln5552">    case PV_LCS:</a>
<a name="ln5553">      clear_string_option(&amp;((win_T *)from)-&gt;w_p_lcs);</a>
<a name="ln5554">      set_chars_option((win_T *)from, &amp;((win_T *)from)-&gt;w_p_lcs, true);</a>
<a name="ln5555">      redraw_later((win_T *)from, NOT_VALID);</a>
<a name="ln5556">      break;</a>
<a name="ln5557">    case PV_FCS:</a>
<a name="ln5558">      clear_string_option(&amp;((win_T *)from)-&gt;w_p_fcs);</a>
<a name="ln5559">      set_chars_option((win_T *)from, &amp;((win_T *)from)-&gt;w_p_fcs, true);</a>
<a name="ln5560">      redraw_later((win_T *)from, NOT_VALID);</a>
<a name="ln5561">      break;</a>
<a name="ln5562">  }</a>
<a name="ln5563">}</a>
<a name="ln5564"> </a>
<a name="ln5565">/// Get pointer to option variable, depending on local or global scope.</a>
<a name="ln5566">static char_u *get_varp_scope(vimoption_T *p, int opt_flags)</a>
<a name="ln5567">{</a>
<a name="ln5568">  if ((opt_flags &amp; OPT_GLOBAL) &amp;&amp; p-&gt;indir != PV_NONE) {</a>
<a name="ln5569">    if (p-&gt;var == VAR_WIN) {</a>
<a name="ln5570">      return (char_u *)GLOBAL_WO(get_varp(p));</a>
<a name="ln5571">    }</a>
<a name="ln5572">    return p-&gt;var;</a>
<a name="ln5573">  }</a>
<a name="ln5574">  if ((opt_flags &amp; OPT_LOCAL) &amp;&amp; ((int)p-&gt;indir &amp; PV_BOTH)) {</a>
<a name="ln5575">    switch ((int)p-&gt;indir) {</a>
<a name="ln5576">    case PV_FP:   return (char_u *)&amp;(curbuf-&gt;b_p_fp);</a>
<a name="ln5577">    case PV_EFM:  return (char_u *)&amp;(curbuf-&gt;b_p_efm);</a>
<a name="ln5578">    case PV_GP:   return (char_u *)&amp;(curbuf-&gt;b_p_gp);</a>
<a name="ln5579">    case PV_MP:   return (char_u *)&amp;(curbuf-&gt;b_p_mp);</a>
<a name="ln5580">    case PV_EP:   return (char_u *)&amp;(curbuf-&gt;b_p_ep);</a>
<a name="ln5581">    case PV_KP:   return (char_u *)&amp;(curbuf-&gt;b_p_kp);</a>
<a name="ln5582">    case PV_PATH: return (char_u *)&amp;(curbuf-&gt;b_p_path);</a>
<a name="ln5583">    case PV_AR:   return (char_u *)&amp;(curbuf-&gt;b_p_ar);</a>
<a name="ln5584">    case PV_TAGS: return (char_u *)&amp;(curbuf-&gt;b_p_tags);</a>
<a name="ln5585">    case PV_TC:   return (char_u *)&amp;(curbuf-&gt;b_p_tc);</a>
<a name="ln5586">    case PV_SISO: return (char_u *)&amp;(curwin-&gt;w_p_siso);</a>
<a name="ln5587">    case PV_SO:   return (char_u *)&amp;(curwin-&gt;w_p_so);</a>
<a name="ln5588">    case PV_DEF:  return (char_u *)&amp;(curbuf-&gt;b_p_def);</a>
<a name="ln5589">    case PV_INC:  return (char_u *)&amp;(curbuf-&gt;b_p_inc);</a>
<a name="ln5590">    case PV_DICT: return (char_u *)&amp;(curbuf-&gt;b_p_dict);</a>
<a name="ln5591">    case PV_TSR:  return (char_u *)&amp;(curbuf-&gt;b_p_tsr);</a>
<a name="ln5592">    case PV_TFU:  return (char_u *)&amp;(curbuf-&gt;b_p_tfu);</a>
<a name="ln5593">    case PV_STL:  return (char_u *)&amp;(curwin-&gt;w_p_stl);</a>
<a name="ln5594">    case PV_UL:   return (char_u *)&amp;(curbuf-&gt;b_p_ul);</a>
<a name="ln5595">    case PV_LW:   return (char_u *)&amp;(curbuf-&gt;b_p_lw);</a>
<a name="ln5596">    case PV_BKC:  return (char_u *)&amp;(curbuf-&gt;b_p_bkc);</a>
<a name="ln5597">    case PV_MENC: return (char_u *)&amp;(curbuf-&gt;b_p_menc);</a>
<a name="ln5598">    case PV_FCS:  return (char_u *)&amp;(curwin-&gt;w_p_fcs);</a>
<a name="ln5599">    case PV_LCS:  return (char_u *)&amp;(curwin-&gt;w_p_lcs);</a>
<a name="ln5600">    }</a>
<a name="ln5601">    return NULL;     // &quot;cannot happen&quot;</a>
<a name="ln5602">  }</a>
<a name="ln5603">  return get_varp(p);</a>
<a name="ln5604">}</a>
<a name="ln5605"> </a>
<a name="ln5606">/// Get pointer to option variable.</a>
<a name="ln5607">static char_u *get_varp(vimoption_T *p)</a>
<a name="ln5608">{</a>
<a name="ln5609">  // hidden option, always return NULL</a>
<a name="ln5610">  if (p-&gt;var == NULL) {</a>
<a name="ln5611">    return NULL;</a>
<a name="ln5612">  }</a>
<a name="ln5613"> </a>
<a name="ln5614">  switch ((int)p-&gt;indir) {</a>
<a name="ln5615">  case PV_NONE:   return p-&gt;var;</a>
<a name="ln5616"> </a>
<a name="ln5617">  // global option with local value: use local value if it's been set</a>
<a name="ln5618">  case PV_EP:     return *curbuf-&gt;b_p_ep != NUL</a>
<a name="ln5619">           ? (char_u *)&amp;curbuf-&gt;b_p_ep : p-&gt;var;</a>
<a name="ln5620">  case PV_KP:     return *curbuf-&gt;b_p_kp != NUL</a>
<a name="ln5621">           ? (char_u *)&amp;curbuf-&gt;b_p_kp : p-&gt;var;</a>
<a name="ln5622">  case PV_PATH:   return *curbuf-&gt;b_p_path != NUL</a>
<a name="ln5623">           ? (char_u *)&amp;(curbuf-&gt;b_p_path) : p-&gt;var;</a>
<a name="ln5624">  case PV_AR:     return curbuf-&gt;b_p_ar &gt;= 0</a>
<a name="ln5625">           ? (char_u *)&amp;(curbuf-&gt;b_p_ar) : p-&gt;var;</a>
<a name="ln5626">  case PV_TAGS:   return *curbuf-&gt;b_p_tags != NUL</a>
<a name="ln5627">           ? (char_u *)&amp;(curbuf-&gt;b_p_tags) : p-&gt;var;</a>
<a name="ln5628">  case PV_TC:     return *curbuf-&gt;b_p_tc != NUL</a>
<a name="ln5629">           ? (char_u *)&amp;(curbuf-&gt;b_p_tc) : p-&gt;var;</a>
<a name="ln5630">  case PV_SISO:   return curwin-&gt;w_p_siso &gt;= 0</a>
<a name="ln5631">           ? (char_u *)&amp;(curwin-&gt;w_p_siso) : p-&gt;var;</a>
<a name="ln5632">  case PV_SO:     return curwin-&gt;w_p_so &gt;= 0</a>
<a name="ln5633">           ? (char_u *)&amp;(curwin-&gt;w_p_so) : p-&gt;var;</a>
<a name="ln5634">  case PV_BKC:    return *curbuf-&gt;b_p_bkc != NUL</a>
<a name="ln5635">           ? (char_u *)&amp;(curbuf-&gt;b_p_bkc) : p-&gt;var;</a>
<a name="ln5636">  case PV_DEF:    return *curbuf-&gt;b_p_def != NUL</a>
<a name="ln5637">           ? (char_u *)&amp;(curbuf-&gt;b_p_def) : p-&gt;var;</a>
<a name="ln5638">  case PV_INC:    return *curbuf-&gt;b_p_inc != NUL</a>
<a name="ln5639">           ? (char_u *)&amp;(curbuf-&gt;b_p_inc) : p-&gt;var;</a>
<a name="ln5640">  case PV_DICT:   return *curbuf-&gt;b_p_dict != NUL</a>
<a name="ln5641">           ? (char_u *)&amp;(curbuf-&gt;b_p_dict) : p-&gt;var;</a>
<a name="ln5642">  case PV_TSR:    return *curbuf-&gt;b_p_tsr != NUL</a>
<a name="ln5643">           ? (char_u *)&amp;(curbuf-&gt;b_p_tsr) : p-&gt;var;</a>
<a name="ln5644">  case PV_FP: return *curbuf-&gt;b_p_fp != NUL</a>
<a name="ln5645">           ? (char_u *)&amp;(curbuf-&gt;b_p_fp) : p-&gt;var;</a>
<a name="ln5646">  case PV_EFM:    return *curbuf-&gt;b_p_efm != NUL</a>
<a name="ln5647">           ? (char_u *)&amp;(curbuf-&gt;b_p_efm) : p-&gt;var;</a>
<a name="ln5648">  case PV_GP:     return *curbuf-&gt;b_p_gp != NUL</a>
<a name="ln5649">           ? (char_u *)&amp;(curbuf-&gt;b_p_gp) : p-&gt;var;</a>
<a name="ln5650">  case PV_MP:     return *curbuf-&gt;b_p_mp != NUL</a>
<a name="ln5651">           ? (char_u *)&amp;(curbuf-&gt;b_p_mp) : p-&gt;var;</a>
<a name="ln5652">  case PV_STL:    return *curwin-&gt;w_p_stl != NUL</a>
<a name="ln5653">           ? (char_u *)&amp;(curwin-&gt;w_p_stl) : p-&gt;var;</a>
<a name="ln5654">  case PV_UL:     return curbuf-&gt;b_p_ul != NO_LOCAL_UNDOLEVEL</a>
<a name="ln5655">           ? (char_u *)&amp;(curbuf-&gt;b_p_ul) : p-&gt;var;</a>
<a name="ln5656">  case PV_LW:   return *curbuf-&gt;b_p_lw != NUL</a>
<a name="ln5657">           ? (char_u *)&amp;(curbuf-&gt;b_p_lw) : p-&gt;var;</a>
<a name="ln5658">  case PV_MENC: return *curbuf-&gt;b_p_menc != NUL</a>
<a name="ln5659">           ? (char_u *)&amp;(curbuf-&gt;b_p_menc) : p-&gt;var;</a>
<a name="ln5660">  case PV_FCS:    return *curwin-&gt;w_p_fcs != NUL</a>
<a name="ln5661">           ? (char_u *)&amp;(curwin-&gt;w_p_fcs) : p-&gt;var;</a>
<a name="ln5662">  case PV_LCS:    return *curwin-&gt;w_p_lcs != NUL</a>
<a name="ln5663">           ? (char_u *)&amp;(curwin-&gt;w_p_lcs) : p-&gt;var;</a>
<a name="ln5664"> </a>
<a name="ln5665">  case PV_ARAB:   return (char_u *)&amp;(curwin-&gt;w_p_arab);</a>
<a name="ln5666">  case PV_LIST:   return (char_u *)&amp;(curwin-&gt;w_p_list);</a>
<a name="ln5667">  case PV_SPELL:  return (char_u *)&amp;(curwin-&gt;w_p_spell);</a>
<a name="ln5668">  case PV_CUC:    return (char_u *)&amp;(curwin-&gt;w_p_cuc);</a>
<a name="ln5669">  case PV_CUL:    return (char_u *)&amp;(curwin-&gt;w_p_cul);</a>
<a name="ln5670">  case PV_CC:     return (char_u *)&amp;(curwin-&gt;w_p_cc);</a>
<a name="ln5671">  case PV_DIFF:   return (char_u *)&amp;(curwin-&gt;w_p_diff);</a>
<a name="ln5672">  case PV_FDC:    return (char_u *)&amp;(curwin-&gt;w_p_fdc);</a>
<a name="ln5673">  case PV_FEN:    return (char_u *)&amp;(curwin-&gt;w_p_fen);</a>
<a name="ln5674">  case PV_FDI:    return (char_u *)&amp;(curwin-&gt;w_p_fdi);</a>
<a name="ln5675">  case PV_FDL:    return (char_u *)&amp;(curwin-&gt;w_p_fdl);</a>
<a name="ln5676">  case PV_FDM:    return (char_u *)&amp;(curwin-&gt;w_p_fdm);</a>
<a name="ln5677">  case PV_FML:    return (char_u *)&amp;(curwin-&gt;w_p_fml);</a>
<a name="ln5678">  case PV_FDN:    return (char_u *)&amp;(curwin-&gt;w_p_fdn);</a>
<a name="ln5679">  case PV_FDE:    return (char_u *)&amp;(curwin-&gt;w_p_fde);</a>
<a name="ln5680">  case PV_FDT:    return (char_u *)&amp;(curwin-&gt;w_p_fdt);</a>
<a name="ln5681">  case PV_FMR:    return (char_u *)&amp;(curwin-&gt;w_p_fmr);</a>
<a name="ln5682">  case PV_NU:     return (char_u *)&amp;(curwin-&gt;w_p_nu);</a>
<a name="ln5683">  case PV_RNU:    return (char_u *)&amp;(curwin-&gt;w_p_rnu);</a>
<a name="ln5684">  case PV_NUW:    return (char_u *)&amp;(curwin-&gt;w_p_nuw);</a>
<a name="ln5685">  case PV_WFH:    return (char_u *)&amp;(curwin-&gt;w_p_wfh);</a>
<a name="ln5686">  case PV_WFW:    return (char_u *)&amp;(curwin-&gt;w_p_wfw);</a>
<a name="ln5687">  case PV_PVW:    return (char_u *)&amp;(curwin-&gt;w_p_pvw);</a>
<a name="ln5688">  case PV_RL:     return (char_u *)&amp;(curwin-&gt;w_p_rl);</a>
<a name="ln5689">  case PV_RLC:    return (char_u *)&amp;(curwin-&gt;w_p_rlc);</a>
<a name="ln5690">  case PV_SCROLL: return (char_u *)&amp;(curwin-&gt;w_p_scr);</a>
<a name="ln5691">  case PV_WRAP:   return (char_u *)&amp;(curwin-&gt;w_p_wrap);</a>
<a name="ln5692">  case PV_LBR:    return (char_u *)&amp;(curwin-&gt;w_p_lbr);</a>
<a name="ln5693">  case PV_BRI:    return (char_u *)&amp;(curwin-&gt;w_p_bri);</a>
<a name="ln5694">  case PV_BRIOPT: return (char_u *)&amp;(curwin-&gt;w_p_briopt);</a>
<a name="ln5695">  case PV_SCBIND: return (char_u *)&amp;(curwin-&gt;w_p_scb);</a>
<a name="ln5696">  case PV_CRBIND: return (char_u *)&amp;(curwin-&gt;w_p_crb);</a>
<a name="ln5697">  case PV_COCU:    return (char_u *)&amp;(curwin-&gt;w_p_cocu);</a>
<a name="ln5698">  case PV_COLE:    return (char_u *)&amp;(curwin-&gt;w_p_cole);</a>
<a name="ln5699"> </a>
<a name="ln5700">  case PV_AI:     return (char_u *)&amp;(curbuf-&gt;b_p_ai);</a>
<a name="ln5701">  case PV_BIN:    return (char_u *)&amp;(curbuf-&gt;b_p_bin);</a>
<a name="ln5702">  case PV_BOMB:   return (char_u *)&amp;(curbuf-&gt;b_p_bomb);</a>
<a name="ln5703">  case PV_BH:     return (char_u *)&amp;(curbuf-&gt;b_p_bh);</a>
<a name="ln5704">  case PV_BT:     return (char_u *)&amp;(curbuf-&gt;b_p_bt);</a>
<a name="ln5705">  case PV_BL:     return (char_u *)&amp;(curbuf-&gt;b_p_bl);</a>
<a name="ln5706">  case PV_CHANNEL:return (char_u *)&amp;(curbuf-&gt;b_p_channel);</a>
<a name="ln5707">  case PV_CI:     return (char_u *)&amp;(curbuf-&gt;b_p_ci);</a>
<a name="ln5708">  case PV_CIN:    return (char_u *)&amp;(curbuf-&gt;b_p_cin);</a>
<a name="ln5709">  case PV_CINK:   return (char_u *)&amp;(curbuf-&gt;b_p_cink);</a>
<a name="ln5710">  case PV_CINO:   return (char_u *)&amp;(curbuf-&gt;b_p_cino);</a>
<a name="ln5711">  case PV_CINW:   return (char_u *)&amp;(curbuf-&gt;b_p_cinw);</a>
<a name="ln5712">  case PV_COM:    return (char_u *)&amp;(curbuf-&gt;b_p_com);</a>
<a name="ln5713">  case PV_CMS:    return (char_u *)&amp;(curbuf-&gt;b_p_cms);</a>
<a name="ln5714">  case PV_CPT:    return (char_u *)&amp;(curbuf-&gt;b_p_cpt);</a>
<a name="ln5715"># ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5716">  case PV_CSL:    return (char_u *)&amp;(curbuf-&gt;b_p_csl);</a>
<a name="ln5717"># endif</a>
<a name="ln5718">  case PV_CFU:    return (char_u *)&amp;(curbuf-&gt;b_p_cfu);</a>
<a name="ln5719">  case PV_OFU:    return (char_u *)&amp;(curbuf-&gt;b_p_ofu);</a>
<a name="ln5720">  case PV_EOL:    return (char_u *)&amp;(curbuf-&gt;b_p_eol);</a>
<a name="ln5721">  case PV_FIXEOL: return (char_u *)&amp;(curbuf-&gt;b_p_fixeol);</a>
<a name="ln5722">  case PV_ET:     return (char_u *)&amp;(curbuf-&gt;b_p_et);</a>
<a name="ln5723">  case PV_FENC:   return (char_u *)&amp;(curbuf-&gt;b_p_fenc);</a>
<a name="ln5724">  case PV_FF:     return (char_u *)&amp;(curbuf-&gt;b_p_ff);</a>
<a name="ln5725">  case PV_FT:     return (char_u *)&amp;(curbuf-&gt;b_p_ft);</a>
<a name="ln5726">  case PV_FO:     return (char_u *)&amp;(curbuf-&gt;b_p_fo);</a>
<a name="ln5727">  case PV_FLP:    return (char_u *)&amp;(curbuf-&gt;b_p_flp);</a>
<a name="ln5728">  case PV_IMI:    return (char_u *)&amp;(curbuf-&gt;b_p_iminsert);</a>
<a name="ln5729">  case PV_IMS:    return (char_u *)&amp;(curbuf-&gt;b_p_imsearch);</a>
<a name="ln5730">  case PV_INF:    return (char_u *)&amp;(curbuf-&gt;b_p_inf);</a>
<a name="ln5731">  case PV_ISK:    return (char_u *)&amp;(curbuf-&gt;b_p_isk);</a>
<a name="ln5732">  case PV_INEX:   return (char_u *)&amp;(curbuf-&gt;b_p_inex);</a>
<a name="ln5733">  case PV_INDE:   return (char_u *)&amp;(curbuf-&gt;b_p_inde);</a>
<a name="ln5734">  case PV_INDK:   return (char_u *)&amp;(curbuf-&gt;b_p_indk);</a>
<a name="ln5735">  case PV_FEX:    return (char_u *)&amp;(curbuf-&gt;b_p_fex);</a>
<a name="ln5736">  case PV_LISP:   return (char_u *)&amp;(curbuf-&gt;b_p_lisp);</a>
<a name="ln5737">  case PV_ML:     return (char_u *)&amp;(curbuf-&gt;b_p_ml);</a>
<a name="ln5738">  case PV_MPS:    return (char_u *)&amp;(curbuf-&gt;b_p_mps);</a>
<a name="ln5739">  case PV_MA:     return (char_u *)&amp;(curbuf-&gt;b_p_ma);</a>
<a name="ln5740">  case PV_MOD:    return (char_u *)&amp;(curbuf-&gt;b_changed);</a>
<a name="ln5741">  case PV_NF:     return (char_u *)&amp;(curbuf-&gt;b_p_nf);</a>
<a name="ln5742">  case PV_PI:     return (char_u *)&amp;(curbuf-&gt;b_p_pi);</a>
<a name="ln5743">  case PV_QE:     return (char_u *)&amp;(curbuf-&gt;b_p_qe);</a>
<a name="ln5744">  case PV_RO:     return (char_u *)&amp;(curbuf-&gt;b_p_ro);</a>
<a name="ln5745">  case PV_SCBK:   return (char_u *)&amp;(curbuf-&gt;b_p_scbk);</a>
<a name="ln5746">  case PV_SI:     return (char_u *)&amp;(curbuf-&gt;b_p_si);</a>
<a name="ln5747">  case PV_STS:    return (char_u *)&amp;(curbuf-&gt;b_p_sts);</a>
<a name="ln5748">  case PV_SUA:    return (char_u *)&amp;(curbuf-&gt;b_p_sua);</a>
<a name="ln5749">  case PV_SWF:    return (char_u *)&amp;(curbuf-&gt;b_p_swf);</a>
<a name="ln5750">  case PV_SMC:    return (char_u *)&amp;(curbuf-&gt;b_p_smc);</a>
<a name="ln5751">  case PV_SYN:    return (char_u *)&amp;(curbuf-&gt;b_p_syn);</a>
<a name="ln5752">  case PV_SPC:    return (char_u *)&amp;(curwin-&gt;w_s-&gt;b_p_spc);</a>
<a name="ln5753">  case PV_SPF:    return (char_u *)&amp;(curwin-&gt;w_s-&gt;b_p_spf);</a>
<a name="ln5754">  case PV_SPL:    return (char_u *)&amp;(curwin-&gt;w_s-&gt;b_p_spl);</a>
<a name="ln5755">  case PV_SPO:    return (char_u *)&amp;(curwin-&gt;w_s-&gt;b_p_spo);</a>
<a name="ln5756">  case PV_SW:     return (char_u *)&amp;(curbuf-&gt;b_p_sw);</a>
<a name="ln5757">  case PV_TFU:    return (char_u *)&amp;(curbuf-&gt;b_p_tfu);</a>
<a name="ln5758">  case PV_TS:     return (char_u *)&amp;(curbuf-&gt;b_p_ts);</a>
<a name="ln5759">  case PV_TW:     return (char_u *)&amp;(curbuf-&gt;b_p_tw);</a>
<a name="ln5760">  case PV_UDF:    return (char_u *)&amp;(curbuf-&gt;b_p_udf);</a>
<a name="ln5761">  case PV_WM:     return (char_u *)&amp;(curbuf-&gt;b_p_wm);</a>
<a name="ln5762">  case PV_VSTS:   return (char_u *)&amp;(curbuf-&gt;b_p_vsts);</a>
<a name="ln5763">  case PV_VTS:    return (char_u *)&amp;(curbuf-&gt;b_p_vts);</a>
<a name="ln5764">  case PV_KMAP:   return (char_u *)&amp;(curbuf-&gt;b_p_keymap);</a>
<a name="ln5765">  case PV_SCL:    return (char_u *)&amp;(curwin-&gt;w_p_scl);</a>
<a name="ln5766">  case PV_WINHL:  return (char_u *)&amp;(curwin-&gt;w_p_winhl);</a>
<a name="ln5767">  case PV_WINBL:  return (char_u *)&amp;(curwin-&gt;w_p_winbl);</a>
<a name="ln5768">  default:        IEMSG(_(&quot;E356: get_varp ERROR&quot;));</a>
<a name="ln5769">  }</a>
<a name="ln5770">  // always return a valid pointer to avoid a crash!</a>
<a name="ln5771">  return (char_u *)&amp;(curbuf-&gt;b_p_wm);</a>
<a name="ln5772">}</a>
<a name="ln5773"> </a>
<a name="ln5774">/// Get the value of 'equalprg', either the buffer-local one or the global one.</a>
<a name="ln5775">char_u *get_equalprg(void)</a>
<a name="ln5776">{</a>
<a name="ln5777">  if (*curbuf-&gt;b_p_ep == NUL) {</a>
<a name="ln5778">    return p_ep;</a>
<a name="ln5779">  }</a>
<a name="ln5780">  return curbuf-&gt;b_p_ep;</a>
<a name="ln5781">}</a>
<a name="ln5782"> </a>
<a name="ln5783">/// Copy options from one window to another.</a>
<a name="ln5784">/// Used when splitting a window.</a>
<a name="ln5785">void win_copy_options(win_T *wp_from, win_T *wp_to)</a>
<a name="ln5786">{</a>
<a name="ln5787">  copy_winopt(&amp;wp_from-&gt;w_onebuf_opt, &amp;wp_to-&gt;w_onebuf_opt);</a>
<a name="ln5788">  copy_winopt(&amp;wp_from-&gt;w_allbuf_opt, &amp;wp_to-&gt;w_allbuf_opt);</a>
<a name="ln5789">}</a>
<a name="ln5790"> </a>
<a name="ln5791">/// Copy the options from one winopt_T to another.</a>
<a name="ln5792">/// Doesn't free the old option values in &quot;to&quot;, use clear_winopt() for that.</a>
<a name="ln5793">/// The 'scroll' option is not copied, because it depends on the window height.</a>
<a name="ln5794">/// The 'previewwindow' option is reset, there can be only one preview window.</a>
<a name="ln5795">void copy_winopt(winopt_T *from, winopt_T *to)</a>
<a name="ln5796">{</a>
<a name="ln5797">  to-&gt;wo_arab = from-&gt;wo_arab;</a>
<a name="ln5798">  to-&gt;wo_list = from-&gt;wo_list;</a>
<a name="ln5799">  to-&gt;wo_nu = from-&gt;wo_nu;</a>
<a name="ln5800">  to-&gt;wo_rnu = from-&gt;wo_rnu;</a>
<a name="ln5801">  to-&gt;wo_nuw = from-&gt;wo_nuw;</a>
<a name="ln5802">  to-&gt;wo_rl  = from-&gt;wo_rl;</a>
<a name="ln5803">  to-&gt;wo_rlc = vim_strsave(from-&gt;wo_rlc);</a>
<a name="ln5804">  to-&gt;wo_stl = vim_strsave(from-&gt;wo_stl);</a>
<a name="ln5805">  to-&gt;wo_wrap = from-&gt;wo_wrap;</a>
<a name="ln5806">  to-&gt;wo_wrap_save = from-&gt;wo_wrap_save;</a>
<a name="ln5807">  to-&gt;wo_lbr = from-&gt;wo_lbr;</a>
<a name="ln5808">  to-&gt;wo_bri = from-&gt;wo_bri;</a>
<a name="ln5809">  to-&gt;wo_briopt = vim_strsave(from-&gt;wo_briopt);</a>
<a name="ln5810">  to-&gt;wo_scb = from-&gt;wo_scb;</a>
<a name="ln5811">  to-&gt;wo_scb_save = from-&gt;wo_scb_save;</a>
<a name="ln5812">  to-&gt;wo_crb = from-&gt;wo_crb;</a>
<a name="ln5813">  to-&gt;wo_crb_save = from-&gt;wo_crb_save;</a>
<a name="ln5814">  to-&gt;wo_spell = from-&gt;wo_spell;</a>
<a name="ln5815">  to-&gt;wo_cuc = from-&gt;wo_cuc;</a>
<a name="ln5816">  to-&gt;wo_cul = from-&gt;wo_cul;</a>
<a name="ln5817">  to-&gt;wo_cc = vim_strsave(from-&gt;wo_cc);</a>
<a name="ln5818">  to-&gt;wo_diff = from-&gt;wo_diff;</a>
<a name="ln5819">  to-&gt;wo_diff_saved = from-&gt;wo_diff_saved;</a>
<a name="ln5820">  to-&gt;wo_cocu = vim_strsave(from-&gt;wo_cocu);</a>
<a name="ln5821">  to-&gt;wo_cole = from-&gt;wo_cole;</a>
<a name="ln5822">  to-&gt;wo_fdc = vim_strsave(from-&gt;wo_fdc);</a>
<a name="ln5823">  to-&gt;wo_fdc_save = from-&gt;wo_diff_saved</a>
<a name="ln5824">                    ? vim_strsave(from-&gt;wo_fdc_save) : empty_option;</a>
<a name="ln5825">  to-&gt;wo_fen = from-&gt;wo_fen;</a>
<a name="ln5826">  to-&gt;wo_fen_save = from-&gt;wo_fen_save;</a>
<a name="ln5827">  to-&gt;wo_fdi = vim_strsave(from-&gt;wo_fdi);</a>
<a name="ln5828">  to-&gt;wo_fml = from-&gt;wo_fml;</a>
<a name="ln5829">  to-&gt;wo_fdl = from-&gt;wo_fdl;</a>
<a name="ln5830">  to-&gt;wo_fdl_save = from-&gt;wo_fdl_save;</a>
<a name="ln5831">  to-&gt;wo_fdm = vim_strsave(from-&gt;wo_fdm);</a>
<a name="ln5832">  to-&gt;wo_fdm_save = from-&gt;wo_diff_saved</a>
<a name="ln5833">                    ? vim_strsave(from-&gt;wo_fdm_save) : empty_option;</a>
<a name="ln5834">  to-&gt;wo_fdn = from-&gt;wo_fdn;</a>
<a name="ln5835">  to-&gt;wo_fde = vim_strsave(from-&gt;wo_fde);</a>
<a name="ln5836">  to-&gt;wo_fdt = vim_strsave(from-&gt;wo_fdt);</a>
<a name="ln5837">  to-&gt;wo_fmr = vim_strsave(from-&gt;wo_fmr);</a>
<a name="ln5838">  to-&gt;wo_scl = vim_strsave(from-&gt;wo_scl);</a>
<a name="ln5839">  to-&gt;wo_winhl = vim_strsave(from-&gt;wo_winhl);</a>
<a name="ln5840">  to-&gt;wo_fcs = vim_strsave(from-&gt;wo_fcs);</a>
<a name="ln5841">  to-&gt;wo_lcs = vim_strsave(from-&gt;wo_lcs);</a>
<a name="ln5842">  to-&gt;wo_winbl = from-&gt;wo_winbl;</a>
<a name="ln5843">  check_winopt(to);             // don't want NULL pointers</a>
<a name="ln5844">}</a>
<a name="ln5845"> </a>
<a name="ln5846">/// Check string options in a window for a NULL value.</a>
<a name="ln5847">void check_win_options(win_T *win)</a>
<a name="ln5848">{</a>
<a name="ln5849">  check_winopt(&amp;win-&gt;w_onebuf_opt);</a>
<a name="ln5850">  check_winopt(&amp;win-&gt;w_allbuf_opt);</a>
<a name="ln5851">}</a>
<a name="ln5852"> </a>
<a name="ln5853">/// Check for NULL pointers in a winopt_T and replace them with empty_option.</a>
<a name="ln5854">static void check_winopt(winopt_T *wop)</a>
<a name="ln5855">{</a>
<a name="ln5856">  check_string_option(&amp;wop-&gt;wo_fdc);</a>
<a name="ln5857">  check_string_option(&amp;wop-&gt;wo_fdc_save);</a>
<a name="ln5858">  check_string_option(&amp;wop-&gt;wo_fdi);</a>
<a name="ln5859">  check_string_option(&amp;wop-&gt;wo_fdm);</a>
<a name="ln5860">  check_string_option(&amp;wop-&gt;wo_fdm_save);</a>
<a name="ln5861">  check_string_option(&amp;wop-&gt;wo_fde);</a>
<a name="ln5862">  check_string_option(&amp;wop-&gt;wo_fdt);</a>
<a name="ln5863">  check_string_option(&amp;wop-&gt;wo_fmr);</a>
<a name="ln5864">  check_string_option(&amp;wop-&gt;wo_scl);</a>
<a name="ln5865">  check_string_option(&amp;wop-&gt;wo_rlc);</a>
<a name="ln5866">  check_string_option(&amp;wop-&gt;wo_stl);</a>
<a name="ln5867">  check_string_option(&amp;wop-&gt;wo_cc);</a>
<a name="ln5868">  check_string_option(&amp;wop-&gt;wo_cocu);</a>
<a name="ln5869">  check_string_option(&amp;wop-&gt;wo_briopt);</a>
<a name="ln5870">  check_string_option(&amp;wop-&gt;wo_winhl);</a>
<a name="ln5871">  check_string_option(&amp;wop-&gt;wo_fcs);</a>
<a name="ln5872">  check_string_option(&amp;wop-&gt;wo_lcs);</a>
<a name="ln5873">}</a>
<a name="ln5874"> </a>
<a name="ln5875">/// Free the allocated memory inside a winopt_T.</a>
<a name="ln5876">void clear_winopt(winopt_T *wop)</a>
<a name="ln5877">{</a>
<a name="ln5878">  clear_string_option(&amp;wop-&gt;wo_fdc);</a>
<a name="ln5879">  clear_string_option(&amp;wop-&gt;wo_fdc_save);</a>
<a name="ln5880">  clear_string_option(&amp;wop-&gt;wo_fdi);</a>
<a name="ln5881">  clear_string_option(&amp;wop-&gt;wo_fdm);</a>
<a name="ln5882">  clear_string_option(&amp;wop-&gt;wo_fdm_save);</a>
<a name="ln5883">  clear_string_option(&amp;wop-&gt;wo_fde);</a>
<a name="ln5884">  clear_string_option(&amp;wop-&gt;wo_fdt);</a>
<a name="ln5885">  clear_string_option(&amp;wop-&gt;wo_fmr);</a>
<a name="ln5886">  clear_string_option(&amp;wop-&gt;wo_scl);</a>
<a name="ln5887">  clear_string_option(&amp;wop-&gt;wo_rlc);</a>
<a name="ln5888">  clear_string_option(&amp;wop-&gt;wo_stl);</a>
<a name="ln5889">  clear_string_option(&amp;wop-&gt;wo_cc);</a>
<a name="ln5890">  clear_string_option(&amp;wop-&gt;wo_cocu);</a>
<a name="ln5891">  clear_string_option(&amp;wop-&gt;wo_briopt);</a>
<a name="ln5892">  clear_string_option(&amp;wop-&gt;wo_winhl);</a>
<a name="ln5893">  clear_string_option(&amp;wop-&gt;wo_fcs);</a>
<a name="ln5894">  clear_string_option(&amp;wop-&gt;wo_lcs);</a>
<a name="ln5895">}</a>
<a name="ln5896"> </a>
<a name="ln5897">void didset_window_options(win_T *wp)</a>
<a name="ln5898">{</a>
<a name="ln5899">  check_colorcolumn(wp);</a>
<a name="ln5900">  briopt_check(wp);</a>
<a name="ln5901">  set_chars_option(wp, &amp;wp-&gt;w_p_fcs, true);</a>
<a name="ln5902">  set_chars_option(wp, &amp;wp-&gt;w_p_lcs, true);</a>
<a name="ln5903">  parse_winhl_opt(wp);  // sets w_hl_needs_update also for w_p_winbl</a>
<a name="ln5904">  check_blending(wp);</a>
<a name="ln5905">  wp-&gt;w_grid_alloc.blending = wp-&gt;w_p_winbl &gt; 0;</a>
<a name="ln5906">}</a>
<a name="ln5907"> </a>
<a name="ln5908"> </a>
<a name="ln5909">/// Copy global option values to local options for one buffer.</a>
<a name="ln5910">/// Used when creating a new buffer and sometimes when entering a buffer.</a>
<a name="ln5911">/// flags:</a>
<a name="ln5912">/// BCO_ENTER    We will enter the buf buffer.</a>
<a name="ln5913">/// BCO_ALWAYS   Always copy the options, but only set b_p_initialized when</a>
<a name="ln5914">///      appropriate.</a>
<a name="ln5915">/// BCO_NOHELP   Don't copy the values to a help buffer.</a>
<a name="ln5916">void buf_copy_options(buf_T *buf, int flags)</a>
<a name="ln5917">{</a>
<a name="ln5918">  int should_copy = true;</a>
<a name="ln5919">  char_u      *save_p_isk = NULL;           // init for GCC</a>
<a name="ln5920">  int dont_do_help;</a>
<a name="ln5921">  int did_isk = false;</a>
<a name="ln5922"> </a>
<a name="ln5923">  /*</a>
<a name="ln5924">   * Skip this when the option defaults have not been set yet.  Happens when</a>
<a name="ln5925">   * main() allocates the first buffer.</a>
<a name="ln5926">   */</a>
<a name="ln5927">  if (p_cpo != NULL) {</a>
<a name="ln5928">    //</a>
<a name="ln5929">    // Always copy when entering and 'cpo' contains 'S'.</a>
<a name="ln5930">    // Don't copy when already initialized.</a>
<a name="ln5931">    // Don't copy when 'cpo' contains 's' and not entering.</a>
<a name="ln5932">    //    'S'      BCO_ENTER  initialized  's'  should_copy</a>
<a name="ln5933">    //    yes        yes          X         X      true</a>
<a name="ln5934">    //    yes        no          yes        X      false</a>
<a name="ln5935">    //    no          X          yes        X      false</a>
<a name="ln5936">    //     X         no          no        yes     false</a>
<a name="ln5937">    //     X         no          no        no      true</a>
<a name="ln5938">    //    no         yes         no         X      true</a>
<a name="ln5939">    ///</a>
<a name="ln5940">    if ((vim_strchr(p_cpo, CPO_BUFOPTGLOB) == NULL || !(flags &amp; BCO_ENTER))</a>
<a name="ln5941">        &amp;&amp; (buf-&gt;b_p_initialized</a>
<a name="ln5942">            || (!(flags &amp; BCO_ENTER)</a>
<a name="ln5943">                &amp;&amp; vim_strchr(p_cpo, CPO_BUFOPT) != NULL))) {</a>
<a name="ln5944">      should_copy = false;</a>
<a name="ln5945">    }</a>
<a name="ln5946"> </a>
<a name="ln5947">    if (should_copy || (flags &amp; BCO_ALWAYS)) {</a>
<a name="ln5948">      /* Don't copy the options specific to a help buffer when</a>
<a name="ln5949">      * BCO_NOHELP is given or the options were initialized already</a>
<a name="ln5950">      * (jumping back to a help file with CTRL-T or CTRL-O) */</a>
<a name="ln5951">      dont_do_help = ((flags &amp; BCO_NOHELP) &amp;&amp; buf-&gt;b_help)</a>
<a name="ln5952">                     || buf-&gt;b_p_initialized;</a>
<a name="ln5953">      if (dont_do_help) {               // don't free b_p_isk</a>
<a name="ln5954">        save_p_isk = buf-&gt;b_p_isk;</a>
<a name="ln5955">        buf-&gt;b_p_isk = NULL;</a>
<a name="ln5956">      }</a>
<a name="ln5957">      // Always free the allocated strings.  If not already initialized,</a>
<a name="ln5958">      // reset 'readonly' and copy 'fileformat'.</a>
<a name="ln5959">      if (!buf-&gt;b_p_initialized) {</a>
<a name="ln5960">        free_buf_options(buf, true);</a>
<a name="ln5961">        buf-&gt;b_p_ro = false;                    // don't copy readonly</a>
<a name="ln5962">        buf-&gt;b_p_fenc = vim_strsave(p_fenc);</a>
<a name="ln5963">        switch (*p_ffs) {</a>
<a name="ln5964">          case 'm': {</a>
<a name="ln5965">            buf-&gt;b_p_ff = vim_strsave((char_u *)FF_MAC);</a>
<a name="ln5966">            break;</a>
<a name="ln5967">          }</a>
<a name="ln5968">          case 'd': {</a>
<a name="ln5969">            buf-&gt;b_p_ff = vim_strsave((char_u *)FF_DOS);</a>
<a name="ln5970">            break;</a>
<a name="ln5971">          }</a>
<a name="ln5972">          case 'u': {</a>
<a name="ln5973">            buf-&gt;b_p_ff = vim_strsave((char_u *)FF_UNIX);</a>
<a name="ln5974">            break;</a>
<a name="ln5975">          }</a>
<a name="ln5976">          default: {</a>
<a name="ln5977">            buf-&gt;b_p_ff = vim_strsave(p_ff);</a>
<a name="ln5978">            break;</a>
<a name="ln5979">          }</a>
<a name="ln5980">        }</a>
<a name="ln5981">        buf-&gt;b_p_bh = empty_option;</a>
<a name="ln5982">        buf-&gt;b_p_bt = empty_option;</a>
<a name="ln5983">      } else {</a>
<a name="ln5984">        free_buf_options(buf, false);</a>
<a name="ln5985">      }</a>
<a name="ln5986"> </a>
<a name="ln5987">      buf-&gt;b_p_ai = p_ai;</a>
<a name="ln5988">      buf-&gt;b_p_ai_nopaste = p_ai_nopaste;</a>
<a name="ln5989">      buf-&gt;b_p_sw = p_sw;</a>
<a name="ln5990">      buf-&gt;b_p_scbk = p_scbk;</a>
<a name="ln5991">      buf-&gt;b_p_tw = p_tw;</a>
<a name="ln5992">      buf-&gt;b_p_tw_nopaste = p_tw_nopaste;</a>
<a name="ln5993">      buf-&gt;b_p_tw_nobin = p_tw_nobin;</a>
<a name="ln5994">      buf-&gt;b_p_wm = p_wm;</a>
<a name="ln5995">      buf-&gt;b_p_wm_nopaste = p_wm_nopaste;</a>
<a name="ln5996">      buf-&gt;b_p_wm_nobin = p_wm_nobin;</a>
<a name="ln5997">      buf-&gt;b_p_bin = p_bin;</a>
<a name="ln5998">      buf-&gt;b_p_bomb = p_bomb;</a>
<a name="ln5999">      buf-&gt;b_p_et = p_et;</a>
<a name="ln6000">      buf-&gt;b_p_fixeol = p_fixeol;</a>
<a name="ln6001">      buf-&gt;b_p_et_nobin = p_et_nobin;</a>
<a name="ln6002">      buf-&gt;b_p_et_nopaste = p_et_nopaste;</a>
<a name="ln6003">      buf-&gt;b_p_ml = p_ml;</a>
<a name="ln6004">      buf-&gt;b_p_ml_nobin = p_ml_nobin;</a>
<a name="ln6005">      buf-&gt;b_p_inf = p_inf;</a>
<a name="ln6006">      buf-&gt;b_p_swf = cmdmod.noswapfile ? false : p_swf;</a>
<a name="ln6007">      buf-&gt;b_p_cpt = vim_strsave(p_cpt);</a>
<a name="ln6008"># ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln6009">      buf-&gt;b_p_csl = vim_strsave(p_csl);</a>
<a name="ln6010"># endif</a>
<a name="ln6011">      buf-&gt;b_p_cfu = vim_strsave(p_cfu);</a>
<a name="ln6012">      buf-&gt;b_p_ofu = vim_strsave(p_ofu);</a>
<a name="ln6013">      buf-&gt;b_p_tfu = vim_strsave(p_tfu);</a>
<a name="ln6014">      buf-&gt;b_p_sts = p_sts;</a>
<a name="ln6015">      buf-&gt;b_p_sts_nopaste = p_sts_nopaste;</a>
<a name="ln6016">      buf-&gt;b_p_vsts = vim_strsave(p_vsts);</a>
<a name="ln6017">      if (p_vsts &amp;&amp; p_vsts != empty_option) {</a>
<a name="ln6018">        tabstop_set(p_vsts, &amp;buf-&gt;b_p_vsts_array);</a>
<a name="ln6019">      } else {</a>
<a name="ln6020">        buf-&gt;b_p_vsts_array = 0;</a>
<a name="ln6021">      }</a>
<a name="ln6022">      buf-&gt;b_p_vsts_nopaste = p_vsts_nopaste</a>
<a name="ln6023">                                ? vim_strsave(p_vsts_nopaste)</a>
<a name="ln6024">                                : NULL;</a>
<a name="ln6025">      buf-&gt;b_p_com = vim_strsave(p_com);</a>
<a name="ln6026">      buf-&gt;b_p_cms = vim_strsave(p_cms);</a>
<a name="ln6027">      buf-&gt;b_p_fo = vim_strsave(p_fo);</a>
<a name="ln6028">      buf-&gt;b_p_flp = vim_strsave(p_flp);</a>
<a name="ln6029">      buf-&gt;b_p_nf = vim_strsave(p_nf);</a>
<a name="ln6030">      buf-&gt;b_p_mps = vim_strsave(p_mps);</a>
<a name="ln6031">      buf-&gt;b_p_si = p_si;</a>
<a name="ln6032">      buf-&gt;b_p_channel = 0;</a>
<a name="ln6033">      buf-&gt;b_p_ci = p_ci;</a>
<a name="ln6034">      buf-&gt;b_p_cin = p_cin;</a>
<a name="ln6035">      buf-&gt;b_p_cink = vim_strsave(p_cink);</a>
<a name="ln6036">      buf-&gt;b_p_cino = vim_strsave(p_cino);</a>
<a name="ln6037">      // Don't copy 'filetype', it must be detected</a>
<a name="ln6038">      buf-&gt;b_p_ft = empty_option;</a>
<a name="ln6039">      buf-&gt;b_p_pi = p_pi;</a>
<a name="ln6040">      buf-&gt;b_p_cinw = vim_strsave(p_cinw);</a>
<a name="ln6041">      buf-&gt;b_p_lisp = p_lisp;</a>
<a name="ln6042">      // Don't copy 'syntax', it must be set</a>
<a name="ln6043">      buf-&gt;b_p_syn = empty_option;</a>
<a name="ln6044">      buf-&gt;b_p_smc = p_smc;</a>
<a name="ln6045">      buf-&gt;b_s.b_syn_isk = empty_option;</a>
<a name="ln6046">      buf-&gt;b_s.b_p_spc = vim_strsave(p_spc);</a>
<a name="ln6047">      (void)compile_cap_prog(&amp;buf-&gt;b_s);</a>
<a name="ln6048">      buf-&gt;b_s.b_p_spf = vim_strsave(p_spf);</a>
<a name="ln6049">      buf-&gt;b_s.b_p_spl = vim_strsave(p_spl);</a>
<a name="ln6050">      buf-&gt;b_s.b_p_spo = vim_strsave(p_spo);</a>
<a name="ln6051">      buf-&gt;b_p_inde = vim_strsave(p_inde);</a>
<a name="ln6052">      buf-&gt;b_p_indk = vim_strsave(p_indk);</a>
<a name="ln6053">      buf-&gt;b_p_fp = empty_option;</a>
<a name="ln6054">      buf-&gt;b_p_fex = vim_strsave(p_fex);</a>
<a name="ln6055">      buf-&gt;b_p_sua = vim_strsave(p_sua);</a>
<a name="ln6056">      buf-&gt;b_p_keymap = vim_strsave(p_keymap);</a>
<a name="ln6057">      buf-&gt;b_kmap_state |= KEYMAP_INIT;</a>
<a name="ln6058">      /* This isn't really an option, but copying the langmap and IME</a>
<a name="ln6059">      * state from the current buffer is better than resetting it. */</a>
<a name="ln6060">      buf-&gt;b_p_iminsert = p_iminsert;</a>
<a name="ln6061">      buf-&gt;b_p_imsearch = p_imsearch;</a>
<a name="ln6062"> </a>
<a name="ln6063">      /* options that are normally global but also have a local value</a>
<a name="ln6064">       * are not copied, start using the global value */</a>
<a name="ln6065">      buf-&gt;b_p_ar = -1;</a>
<a name="ln6066">      buf-&gt;b_p_ul = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln6067">      buf-&gt;b_p_bkc = empty_option;</a>
<a name="ln6068">      buf-&gt;b_bkc_flags = 0;</a>
<a name="ln6069">      buf-&gt;b_p_gp = empty_option;</a>
<a name="ln6070">      buf-&gt;b_p_mp = empty_option;</a>
<a name="ln6071">      buf-&gt;b_p_efm = empty_option;</a>
<a name="ln6072">      buf-&gt;b_p_ep = empty_option;</a>
<a name="ln6073">      buf-&gt;b_p_kp = empty_option;</a>
<a name="ln6074">      buf-&gt;b_p_path = empty_option;</a>
<a name="ln6075">      buf-&gt;b_p_tags = empty_option;</a>
<a name="ln6076">      buf-&gt;b_p_tc = empty_option;</a>
<a name="ln6077">      buf-&gt;b_tc_flags = 0;</a>
<a name="ln6078">      buf-&gt;b_p_def = empty_option;</a>
<a name="ln6079">      buf-&gt;b_p_inc = empty_option;</a>
<a name="ln6080">      buf-&gt;b_p_inex = vim_strsave(p_inex);</a>
<a name="ln6081">      buf-&gt;b_p_dict = empty_option;</a>
<a name="ln6082">      buf-&gt;b_p_tsr = empty_option;</a>
<a name="ln6083">      buf-&gt;b_p_qe = vim_strsave(p_qe);</a>
<a name="ln6084">      buf-&gt;b_p_udf = p_udf;</a>
<a name="ln6085">      buf-&gt;b_p_lw = empty_option;</a>
<a name="ln6086">      buf-&gt;b_p_menc = empty_option;</a>
<a name="ln6087"> </a>
<a name="ln6088">      /*</a>
<a name="ln6089">       * Don't copy the options set by ex_help(), use the saved values,</a>
<a name="ln6090">       * when going from a help buffer to a non-help buffer.</a>
<a name="ln6091">       * Don't touch these at all when BCO_NOHELP is used and going from</a>
<a name="ln6092">       * or to a help buffer.</a>
<a name="ln6093">       */</a>
<a name="ln6094">      if (dont_do_help) {</a>
<a name="ln6095">        buf-&gt;b_p_isk = save_p_isk;</a>
<a name="ln6096">        if (p_vts &amp;&amp; p_vts != empty_option &amp;&amp; !buf-&gt;b_p_vts_array) {</a>
<a name="ln6097">          tabstop_set(p_vts, &amp;buf-&gt;b_p_vts_array);</a>
<a name="ln6098">        } else {</a>
<a name="ln6099">          buf-&gt;b_p_vts_array = NULL;</a>
<a name="ln6100">        }</a>
<a name="ln6101">      } else {</a>
<a name="ln6102">        buf-&gt;b_p_isk = vim_strsave(p_isk);</a>
<a name="ln6103">        did_isk = true;</a>
<a name="ln6104">        buf-&gt;b_p_ts = p_ts;</a>
<a name="ln6105">        buf-&gt;b_p_vts = vim_strsave(p_vts);</a>
<a name="ln6106">        if (p_vts &amp;&amp; p_vts != empty_option &amp;&amp; !buf-&gt;b_p_vts_array) {</a>
<a name="ln6107">          tabstop_set(p_vts, &amp;buf-&gt;b_p_vts_array);</a>
<a name="ln6108">        } else {</a>
<a name="ln6109">          buf-&gt;b_p_vts_array = NULL;</a>
<a name="ln6110">        }</a>
<a name="ln6111">        buf-&gt;b_help = false;</a>
<a name="ln6112">        if (buf-&gt;b_p_bt[0] == 'h') {</a>
<a name="ln6113">          clear_string_option(&amp;buf-&gt;b_p_bt);</a>
<a name="ln6114">        }</a>
<a name="ln6115">        buf-&gt;b_p_ma = p_ma;</a>
<a name="ln6116">      }</a>
<a name="ln6117">    }</a>
<a name="ln6118"> </a>
<a name="ln6119">    /*</a>
<a name="ln6120">     * When the options should be copied (ignoring BCO_ALWAYS), set the</a>
<a name="ln6121">     * flag that indicates that the options have been initialized.</a>
<a name="ln6122">     */</a>
<a name="ln6123">    if (should_copy) {</a>
<a name="ln6124">      buf-&gt;b_p_initialized = true;</a>
<a name="ln6125">    }</a>
<a name="ln6126">  }</a>
<a name="ln6127"> </a>
<a name="ln6128">  check_buf_options(buf);           // make sure we don't have NULLs</a>
<a name="ln6129">  if (did_isk) {</a>
<a name="ln6130">    (void)buf_init_chartab(buf, false);</a>
<a name="ln6131">  }</a>
<a name="ln6132">}</a>
<a name="ln6133"> </a>
<a name="ln6134">/// Reset the 'modifiable' option and its default value.</a>
<a name="ln6135">void reset_modifiable(void)</a>
<a name="ln6136">{</a>
<a name="ln6137">  int opt_idx;</a>
<a name="ln6138"> </a>
<a name="ln6139">  curbuf-&gt;b_p_ma = false;</a>
<a name="ln6140">  p_ma = false;</a>
<a name="ln6141">  opt_idx = findoption(&quot;ma&quot;);</a>
<a name="ln6142">  if (opt_idx &gt;= 0) {</a>
<a name="ln6143">    options[opt_idx].def_val[VI_DEFAULT] = false;</a>
<a name="ln6144">  }</a>
<a name="ln6145">}</a>
<a name="ln6146"> </a>
<a name="ln6147">/// Set the global value for 'iminsert' to the local value.</a>
<a name="ln6148">void set_iminsert_global(void)</a>
<a name="ln6149">{</a>
<a name="ln6150">  p_iminsert = curbuf-&gt;b_p_iminsert;</a>
<a name="ln6151">}</a>
<a name="ln6152"> </a>
<a name="ln6153">/// Set the global value for 'imsearch' to the local value.</a>
<a name="ln6154">void set_imsearch_global(void)</a>
<a name="ln6155">{</a>
<a name="ln6156">  p_imsearch = curbuf-&gt;b_p_imsearch;</a>
<a name="ln6157">}</a>
<a name="ln6158"> </a>
<a name="ln6159">static int expand_option_idx = -1;</a>
<a name="ln6160">static char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};</a>
<a name="ln6161">static int expand_option_flags = 0;</a>
<a name="ln6162"> </a>
<a name="ln6163">void</a>
<a name="ln6164">set_context_in_set_cmd(</a>
<a name="ln6165">    expand_T *xp,</a>
<a name="ln6166">    char_u *arg,</a>
<a name="ln6167">    int opt_flags                  // OPT_GLOBAL and/or OPT_LOCAL</a>
<a name="ln6168">)</a>
<a name="ln6169">{</a>
<a name="ln6170">  char_u nextchar;</a>
<a name="ln6171">  uint32_t flags = 0;           // init for GCC</a>
<a name="ln6172">  int opt_idx = 0;              // init for GCC</a>
<a name="ln6173">  char_u      *p;</a>
<a name="ln6174">  char_u      *s;</a>
<a name="ln6175">  int is_term_option = false;</a>
<a name="ln6176">  int key;</a>
<a name="ln6177"> </a>
<a name="ln6178">  expand_option_flags = opt_flags;</a>
<a name="ln6179"> </a>
<a name="ln6180">  xp-&gt;xp_context = EXPAND_SETTINGS;</a>
<a name="ln6181">  if (*arg == NUL) {</a>
<a name="ln6182">    xp-&gt;xp_pattern = arg;</a>
<a name="ln6183">    return;</a>
<a name="ln6184">  }</a>
<a name="ln6185">  p = arg + STRLEN(arg) - 1;</a>
<a name="ln6186">  if (*p == ' ' &amp;&amp; *(p - 1) != '\\') {</a>
<a name="ln6187">    xp-&gt;xp_pattern = p + 1;</a>
<a name="ln6188">    return;</a>
<a name="ln6189">  }</a>
<a name="ln6190">  while (p &gt; arg) {</a>
<a name="ln6191">    s = p;</a>
<a name="ln6192">    // count number of backslashes before ' ' or ','</a>
<a name="ln6193">    if (*p == ' ' || *p == ',') {</a>
<a name="ln6194">      while (s &gt; arg &amp;&amp; *(s - 1) == '\\') {</a>
<a name="ln6195">        s--;</a>
<a name="ln6196">      }</a>
<a name="ln6197">    }</a>
<a name="ln6198">    // break at a space with an even number of backslashes</a>
<a name="ln6199">    if (*p == ' ' &amp;&amp; ((p - s) &amp; 1) == 0) {</a>
<a name="ln6200">      p++;</a>
<a name="ln6201">      break;</a>
<a name="ln6202">    }</a>
<a name="ln6203">    p--;</a>
<a name="ln6204">  }</a>
<a name="ln6205">  if (STRNCMP(p, &quot;no&quot;, 2) == 0) {</a>
<a name="ln6206">    xp-&gt;xp_context = EXPAND_BOOL_SETTINGS;</a>
<a name="ln6207">    p += 2;</a>
<a name="ln6208">  }</a>
<a name="ln6209">  if (STRNCMP(p, &quot;inv&quot;, 3) == 0) {</a>
<a name="ln6210">    xp-&gt;xp_context = EXPAND_BOOL_SETTINGS;</a>
<a name="ln6211">    p += 3;</a>
<a name="ln6212">  }</a>
<a name="ln6213">  xp-&gt;xp_pattern = arg = p;</a>
<a name="ln6214">  if (*arg == '&lt;') {</a>
<a name="ln6215">    while (*p != '&gt;') {</a>
<a name="ln6216">      if (*p++ == NUL) {            // expand terminal option name</a>
<a name="ln6217">        return;</a>
<a name="ln6218">      }</a>
<a name="ln6219">    }</a>
<a name="ln6220">    key = get_special_key_code(arg + 1);</a>
<a name="ln6221">    if (key == 0) {                 // unknown name</a>
<a name="ln6222">      xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln6223">      return;</a>
<a name="ln6224">    }</a>
<a name="ln6225">    nextchar = *++p;</a>
<a name="ln6226">    is_term_option = true;</a>
<a name="ln6227">    expand_option_name[2] = (char_u)KEY2TERMCAP0(key);</a>
<a name="ln6228">    expand_option_name[3] = KEY2TERMCAP1(key);</a>
<a name="ln6229">  } else {</a>
<a name="ln6230">    if (p[0] == 't' &amp;&amp; p[1] == '_') {</a>
<a name="ln6231">      p += 2;</a>
<a name="ln6232">      if (*p != NUL) {</a>
<a name="ln6233">        p++;</a>
<a name="ln6234">      }</a>
<a name="ln6235">      if (*p == NUL) {</a>
<a name="ln6236">        return;                 // expand option name</a>
<a name="ln6237">      }</a>
<a name="ln6238">      nextchar = *++p;</a>
<a name="ln6239">      is_term_option = true;</a>
<a name="ln6240">      expand_option_name[2] = p[-2];</a>
<a name="ln6241">      expand_option_name[3] = p[-1];</a>
<a name="ln6242">    } else {</a>
<a name="ln6243">      // Allow * wildcard.</a>
<a name="ln6244">      while (ASCII_ISALNUM(*p) || *p == '_' || *p == '*') {</a>
<a name="ln6245">        p++;</a>
<a name="ln6246">      }</a>
<a name="ln6247">      if (*p == NUL) {</a>
<a name="ln6248">        return;</a>
<a name="ln6249">      }</a>
<a name="ln6250">      nextchar = *p;</a>
<a name="ln6251">      opt_idx = findoption_len((const char *)arg, (size_t)(p - arg));</a>
<a name="ln6252">      if (opt_idx == -1 || options[opt_idx].var == NULL) {</a>
<a name="ln6253">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln6254">        return;</a>
<a name="ln6255">      }</a>
<a name="ln6256">      flags = options[opt_idx].flags;</a>
<a name="ln6257">      if (flags &amp; P_BOOL) {</a>
<a name="ln6258">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln6259">        return;</a>
<a name="ln6260">      }</a>
<a name="ln6261">    }</a>
<a name="ln6262">  }</a>
<a name="ln6263">  // handle &quot;-=&quot; and &quot;+=&quot;</a>
<a name="ln6264">  if ((nextchar == '-' || nextchar == '+' || nextchar == '^') &amp;&amp; p[1] == '=') {</a>
<a name="ln6265">    p++;</a>
<a name="ln6266">    nextchar = '=';</a>
<a name="ln6267">  }</a>
<a name="ln6268">  if ((nextchar != '=' &amp;&amp; nextchar != ':')</a>
<a name="ln6269">      || xp-&gt;xp_context == EXPAND_BOOL_SETTINGS) {</a>
<a name="ln6270">    xp-&gt;xp_context = EXPAND_UNSUCCESSFUL;</a>
<a name="ln6271">    return;</a>
<a name="ln6272">  }</a>
<a name="ln6273">  if (p[1] == NUL) {</a>
<a name="ln6274">    xp-&gt;xp_context = EXPAND_OLD_SETTING;</a>
<a name="ln6275">    if (is_term_option) {</a>
<a name="ln6276">      expand_option_idx = -1;</a>
<a name="ln6277">    } else {</a>
<a name="ln6278">      expand_option_idx = opt_idx;</a>
<a name="ln6279">    }</a>
<a name="ln6280">    xp-&gt;xp_pattern = p + 1;</a>
<a name="ln6281">    return;</a>
<a name="ln6282">  }</a>
<a name="ln6283">  xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln6284">  if (is_term_option || (flags &amp; P_NUM)) {</a>
<a name="ln6285">    return;</a>
<a name="ln6286">  }</a>
<a name="ln6287"> </a>
<a name="ln6288">  xp-&gt;xp_pattern = p + 1;</a>
<a name="ln6289"> </a>
<a name="ln6290">  if (flags &amp; P_EXPAND) {</a>
<a name="ln6291">    p = options[opt_idx].var;</a>
<a name="ln6292">    if (p == (char_u *)&amp;p_bdir</a>
<a name="ln6293">        || p == (char_u *)&amp;p_dir</a>
<a name="ln6294">        || p == (char_u *)&amp;p_path</a>
<a name="ln6295">        || p == (char_u *)&amp;p_pp</a>
<a name="ln6296">        || p == (char_u *)&amp;p_rtp</a>
<a name="ln6297">        || p == (char_u *)&amp;p_cdpath</a>
<a name="ln6298">        || p == (char_u *)&amp;p_vdir</a>
<a name="ln6299">        ) {</a>
<a name="ln6300">      xp-&gt;xp_context = EXPAND_DIRECTORIES;</a>
<a name="ln6301">      if (p == (char_u *)&amp;p_path</a>
<a name="ln6302">          || p == (char_u *)&amp;p_cdpath</a>
<a name="ln6303">          )</a>
<a name="ln6304">        xp-&gt;xp_backslash = XP_BS_THREE;</a>
<a name="ln6305">      else</a>
<a name="ln6306">        xp-&gt;xp_backslash = XP_BS_ONE;</a>
<a name="ln6307">    } else if (p == (char_u *)&amp;p_ft) {</a>
<a name="ln6308">      xp-&gt;xp_context = EXPAND_FILETYPE;</a>
<a name="ln6309">    } else {</a>
<a name="ln6310">      xp-&gt;xp_context = EXPAND_FILES;</a>
<a name="ln6311">      // for 'tags' need three backslashes for a space</a>
<a name="ln6312">      if (p == (char_u *)&amp;p_tags) {</a>
<a name="ln6313">        xp-&gt;xp_backslash = XP_BS_THREE;</a>
<a name="ln6314">      } else {</a>
<a name="ln6315">        xp-&gt;xp_backslash = XP_BS_ONE;</a>
<a name="ln6316">      }</a>
<a name="ln6317">    }</a>
<a name="ln6318">  }</a>
<a name="ln6319"> </a>
<a name="ln6320">  /* For an option that is a list of file names, find the start of the</a>
<a name="ln6321">   * last file name. */</a>
<a name="ln6322">  for (p = arg + STRLEN(arg) - 1; p &gt; xp-&gt;xp_pattern; p--) {</a>
<a name="ln6323">    // count number of backslashes before ' ' or ','</a>
<a name="ln6324">    if (*p == ' ' || *p == ',') {</a>
<a name="ln6325">      s = p;</a>
<a name="ln6326">      while (s &gt; xp-&gt;xp_pattern &amp;&amp; *(s - 1) == '\\') {</a>
<a name="ln6327">        s--;</a>
<a name="ln6328">      }</a>
<a name="ln6329">      if ((*p == ' ' &amp;&amp; (xp-&gt;xp_backslash == XP_BS_THREE &amp;&amp; (p - s) &lt; 3))</a>
<a name="ln6330">          || (*p == ',' &amp;&amp; (flags &amp; P_COMMA) &amp;&amp; ((p - s) &amp; 1) == 0)) {</a>
<a name="ln6331">        xp-&gt;xp_pattern = p + 1;</a>
<a name="ln6332">        break;</a>
<a name="ln6333">      }</a>
<a name="ln6334">    }</a>
<a name="ln6335"> </a>
<a name="ln6336">    // for 'spellsuggest' start at &quot;file:&quot;</a>
<a name="ln6337">    if (options[opt_idx].var == (char_u *)&amp;p_sps</a>
<a name="ln6338">        &amp;&amp; STRNCMP(p, &quot;file:&quot;, 5) == 0) {</a>
<a name="ln6339">      xp-&gt;xp_pattern = p + 5;</a>
<a name="ln6340">      break;</a>
<a name="ln6341">    }</a>
<a name="ln6342">  }</a>
<a name="ln6343"> </a>
<a name="ln6344">  return;</a>
<a name="ln6345">}</a>
<a name="ln6346"> </a>
<a name="ln6347">int ExpandSettings(expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file)</a>
<a name="ln6348">{</a>
<a name="ln6349">  int num_normal = 0;  // Nr of matching non-term-code settings</a>
<a name="ln6350">  int match;</a>
<a name="ln6351">  int count = 0;</a>
<a name="ln6352">  char_u      *str;</a>
<a name="ln6353">  int loop;</a>
<a name="ln6354">  static char *(names[]) = { &quot;all&quot; };</a>
<a name="ln6355">  int ic = regmatch-&gt;rm_ic;  // remember the ignore-case flag</a>
<a name="ln6356"> </a>
<a name="ln6357">  /* do this loop twice:</a>
<a name="ln6358">   * loop == 0: count the number of matching options</a>
<a name="ln6359">   * loop == 1: copy the matching options into allocated memory</a>
<a name="ln6360">   */</a>
<a name="ln6361">  for (loop = 0; loop &lt;= 1; loop++) {</a>
<a name="ln6362">    regmatch-&gt;rm_ic = ic;</a>
<a name="ln6363">    if (xp-&gt;xp_context != EXPAND_BOOL_SETTINGS) {</a>
<a name="ln6364">      for (match = 0; match &lt; (int)ARRAY_SIZE(names);</a>
<a name="ln6365">           match++) {</a>
<a name="ln6366">        if (vim_regexec(regmatch, (char_u *)names[match], (colnr_T)0)) {</a>
<a name="ln6367">          if (loop == 0) {</a>
<a name="ln6368">            num_normal++;</a>
<a name="ln6369">          } else {</a>
<a name="ln6370">            (*file)[count++] = vim_strsave((char_u *)names[match]);</a>
<a name="ln6371">          }</a>
<a name="ln6372">        }</a>
<a name="ln6373">      }</a>
<a name="ln6374">    }</a>
<a name="ln6375">    for (size_t opt_idx = 0; (str = (char_u *)options[opt_idx].fullname) != NULL;</a>
<a name="ln6376">         opt_idx++) {</a>
<a name="ln6377">      if (options[opt_idx].var == NULL) {</a>
<a name="ln6378">        continue;</a>
<a name="ln6379">      }</a>
<a name="ln6380">      if (xp-&gt;xp_context == EXPAND_BOOL_SETTINGS</a>
<a name="ln6381">          &amp;&amp; !(options[opt_idx].flags &amp; P_BOOL)) {</a>
<a name="ln6382">        continue;</a>
<a name="ln6383">      }</a>
<a name="ln6384">      match = false;</a>
<a name="ln6385">      if (vim_regexec(regmatch, str, (colnr_T)0)</a>
<a name="ln6386">          || (options[opt_idx].shortname != NULL</a>
<a name="ln6387">              &amp;&amp; vim_regexec(regmatch,</a>
<a name="ln6388">                             (char_u *)options[opt_idx].shortname,</a>
<a name="ln6389">                             (colnr_T)0))) {</a>
<a name="ln6390">        match = true;</a>
<a name="ln6391">      }</a>
<a name="ln6392"> </a>
<a name="ln6393">      if (match) {</a>
<a name="ln6394">        if (loop == 0) {</a>
<a name="ln6395">          num_normal++;</a>
<a name="ln6396">        } else</a>
<a name="ln6397">          (*file)[count++] = vim_strsave(str);</a>
<a name="ln6398">      }</a>
<a name="ln6399">    }</a>
<a name="ln6400"> </a>
<a name="ln6401">    if (loop == 0) {</a>
<a name="ln6402">      if (num_normal &gt; 0) {</a>
<a name="ln6403">        *num_file = num_normal;</a>
<a name="ln6404">      } else {</a>
<a name="ln6405">        return OK;</a>
<a name="ln6406">      }</a>
<a name="ln6407">      *file = (char_u **)xmalloc((size_t)(*num_file) * sizeof(char_u *));</a>
<a name="ln6408">    }</a>
<a name="ln6409">  }</a>
<a name="ln6410">  return OK;</a>
<a name="ln6411">}</a>
<a name="ln6412"> </a>
<a name="ln6413">void ExpandOldSetting(int *num_file, char_u ***file)</a>
<a name="ln6414">{</a>
<a name="ln6415">  char_u *var = NULL;</a>
<a name="ln6416"> </a>
<a name="ln6417">  *num_file = 0;</a>
<a name="ln6418">  *file = (char_u **)xmalloc(sizeof(char_u *));</a>
<a name="ln6419"> </a>
<a name="ln6420">  /*</a>
<a name="ln6421">   * For a terminal key code expand_option_idx is &lt; 0.</a>
<a name="ln6422">   */</a>
<a name="ln6423">  if (expand_option_idx &lt; 0) {</a>
<a name="ln6424">    expand_option_idx = findoption((const char *)expand_option_name);</a>
<a name="ln6425">  }</a>
<a name="ln6426"> </a>
<a name="ln6427">  if (expand_option_idx &gt;= 0) {</a>
<a name="ln6428">    // Put string of option value in NameBuff.</a>
<a name="ln6429">    option_value2string(&amp;options[expand_option_idx], expand_option_flags);</a>
<a name="ln6430">    var = NameBuff;</a>
<a name="ln6431">  } else {</a>
<a name="ln6432">    var = (char_u *)&quot;&quot;;</a>
<a name="ln6433">  }</a>
<a name="ln6434"> </a>
<a name="ln6435">  // A backslash is required before some characters.  This is the reverse of</a>
<a name="ln6436">  // what happens in do_set().</a>
<a name="ln6437">  char_u *buf = vim_strsave_escaped(var, escape_chars);</a>
<a name="ln6438"> </a>
<a name="ln6439">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln6440">  /* For MS-Windows et al. we don't double backslashes at the start and</a>
<a name="ln6441">   * before a file name character. */</a>
<a name="ln6442">  for (var = buf; *var != NUL; MB_PTR_ADV(var)) {</a>
<a name="ln6443">    if (var[0] == '\\' &amp;&amp; var[1] == '\\'</a>
<a name="ln6444">        &amp;&amp; expand_option_idx &gt;= 0</a>
<a name="ln6445">        &amp;&amp; (options[expand_option_idx].flags &amp; P_EXPAND)</a>
<a name="ln6446">        &amp;&amp; vim_isfilec(var[2])</a>
<a name="ln6447">        &amp;&amp; (var[2] != '\\' || (var == buf &amp;&amp; var[4] != '\\'))) {</a>
<a name="ln6448">      STRMOVE(var, var + 1);</a>
<a name="ln6449">    }</a>
<a name="ln6450">  }</a>
<a name="ln6451">#endif</a>
<a name="ln6452"> </a>
<a name="ln6453">  *file[0] = buf;</a>
<a name="ln6454">  *num_file = 1;</a>
<a name="ln6455">}</a>
<a name="ln6456"> </a>
<a name="ln6457">/// Get the value for the numeric or string option///opp in a nice format into</a>
<a name="ln6458">/// NameBuff[].  Must not be called with a hidden option!</a>
<a name="ln6459">static void</a>
<a name="ln6460">option_value2string(</a>
<a name="ln6461">    vimoption_T *opp,</a>
<a name="ln6462">    int opt_flags                          // OPT_GLOBAL and/or OPT_LOCAL</a>
<a name="ln6463">)</a>
<a name="ln6464">{</a>
<a name="ln6465">  char_u      *varp;</a>
<a name="ln6466"> </a>
<a name="ln6467">  varp = get_varp_scope(opp, opt_flags);</a>
<a name="ln6468"> </a>
<a name="ln6469">  if (opp-&gt;flags &amp; P_NUM) {</a>
<a name="ln6470">    long wc = 0;</a>
<a name="ln6471"> </a>
<a name="ln6472">    if (wc_use_keyname(varp, &amp;wc)) {</a>
<a name="ln6473">      STRLCPY(NameBuff, get_special_key_name((int)wc, 0), sizeof(NameBuff));</a>
<a name="ln6474">    } else if (wc != 0) {</a>
<a name="ln6475">      STRLCPY(NameBuff, transchar((int)wc), sizeof(NameBuff));</a>
<a name="ln6476">    } else {</a>
<a name="ln6477">      snprintf((char *)NameBuff,</a>
<a name="ln6478">               sizeof(NameBuff),</a>
<a name="ln6479">               &quot;%&quot; PRId64,</a>
<a name="ln6480">               (int64_t)*(long *)varp);</a>
<a name="ln6481">    }</a>
<a name="ln6482">  } else {  // P_STRING</a>
<a name="ln6483">    varp = *(char_u **)(varp);</a>
<a name="ln6484">    if (varp == NULL) {  // Just in case.</a>
<a name="ln6485">      NameBuff[0] = NUL;</a>
<a name="ln6486">    } else if (opp-&gt;flags &amp; P_EXPAND) {</a>
<a name="ln6487">      home_replace(NULL, varp, NameBuff, MAXPATHL, false);</a>
<a name="ln6488">    // Translate 'pastetoggle' into special key names.</a>
<a name="ln6489">    } else if ((char_u **)opp-&gt;var == &amp;p_pt) {</a>
<a name="ln6490">      str2specialbuf((const char *)p_pt, (char *)NameBuff, MAXPATHL);</a>
<a name="ln6491">    } else {</a>
<a name="ln6492">      STRLCPY(NameBuff, varp, MAXPATHL);</a>
<a name="ln6493">    }</a>
<a name="ln6494">  }</a>
<a name="ln6495">}</a>
<a name="ln6496"> </a>
<a name="ln6497">/// Return true if &quot;varp&quot; points to 'wildchar' or 'wildcharm' and it can be</a>
<a name="ln6498">/// printed as a keyname.</a>
<a name="ln6499">/// &quot;*wcp&quot; is set to the value of the option if it's 'wildchar' or 'wildcharm'.</a>
<a name="ln6500">static int wc_use_keyname(char_u *varp, long *wcp)</a>
<a name="ln6501">{</a>
<a name="ln6502">  if (((long *)varp == &amp;p_wc) || ((long *)varp == &amp;p_wcm)) {</a>
<a name="ln6503">    *wcp = *(long *)varp;</a>
<a name="ln6504">    if (IS_SPECIAL(*wcp) || find_special_key_in_table((int)(*wcp)) &gt;= 0) {</a>
<a name="ln6505">      return true;</a>
<a name="ln6506">    }</a>
<a name="ln6507">  }</a>
<a name="ln6508">  return false;</a>
<a name="ln6509">}</a>
<a name="ln6510"> </a>
<a name="ln6511">/// Any character has an equivalent 'langmap' character.  This is used for</a>
<a name="ln6512">/// keyboards that have a special language mode that sends characters above</a>
<a name="ln6513">/// 128 (although other characters can be translated too).  The &quot;to&quot; field is a</a>
<a name="ln6514">/// Vim command character.  This avoids having to switch the keyboard back to</a>
<a name="ln6515">/// ASCII mode when leaving Insert mode.</a>
<a name="ln6516">///</a>
<a name="ln6517">/// langmap_mapchar[] maps any of 256 chars to an ASCII char used for Vim</a>
<a name="ln6518">/// commands.</a>
<a name="ln6519">/// langmap_mapga.ga_data is a sorted table of langmap_entry_T.</a>
<a name="ln6520">/// This does the same as langmap_mapchar[] for characters &gt;= 256.</a>
<a name="ln6521">///</a>
<a name="ln6522">/// With multi-byte support use growarray for 'langmap' chars &gt;= 256</a>
<a name="ln6523">typedef struct {</a>
<a name="ln6524">  int from;</a>
<a name="ln6525">  int to;</a>
<a name="ln6526">} langmap_entry_T;</a>
<a name="ln6527"> </a>
<a name="ln6528">static garray_T langmap_mapga = GA_EMPTY_INIT_VALUE;</a>
<a name="ln6529"> </a>
<a name="ln6530">/// Search for an entry in &quot;langmap_mapga&quot; for &quot;from&quot;.  If found set the &quot;to&quot;</a>
<a name="ln6531">/// field.  If not found insert a new entry at the appropriate location.</a>
<a name="ln6532">static void langmap_set_entry(int from, int to)</a>
<a name="ln6533">{</a>
<a name="ln6534">  langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);</a>
<a name="ln6535">  unsigned int a = 0;</a>
<a name="ln6536">  assert(langmap_mapga.ga_len &gt;= 0);</a>
<a name="ln6537">  unsigned int b = (unsigned int)langmap_mapga.ga_len;</a>
<a name="ln6538"> </a>
<a name="ln6539">  // Do a binary search for an existing entry.</a>
<a name="ln6540">  while (a != b) {</a>
<a name="ln6541">    unsigned int i = (a + b) / 2;</a>
<a name="ln6542">    int d = entries[i].from - from;</a>
<a name="ln6543"> </a>
<a name="ln6544">    if (d == 0) {</a>
<a name="ln6545">      entries[i].to = to;</a>
<a name="ln6546">      return;</a>
<a name="ln6547">    }</a>
<a name="ln6548">    if (d &lt; 0) {</a>
<a name="ln6549">      a = i + 1;</a>
<a name="ln6550">    } else {</a>
<a name="ln6551">      b = i;</a>
<a name="ln6552">    }</a>
<a name="ln6553">  }</a>
<a name="ln6554"> </a>
<a name="ln6555">  ga_grow(&amp;langmap_mapga, 1);</a>
<a name="ln6556"> </a>
<a name="ln6557">  // insert new entry at position &quot;a&quot;</a>
<a name="ln6558">  entries = (langmap_entry_T *)(langmap_mapga.ga_data) + a;</a>
<a name="ln6559">  memmove(entries + 1, entries,</a>
<a name="ln6560">          ((unsigned int)langmap_mapga.ga_len - a) * sizeof(langmap_entry_T));</a>
<a name="ln6561">  langmap_mapga.ga_len++;</a>
<a name="ln6562">  entries[0].from = from;</a>
<a name="ln6563">  entries[0].to = to;</a>
<a name="ln6564">}</a>
<a name="ln6565"> </a>
<a name="ln6566">/// Apply 'langmap' to multi-byte character &quot;c&quot; and return the result.</a>
<a name="ln6567">int langmap_adjust_mb(int c)</a>
<a name="ln6568">{</a>
<a name="ln6569">  langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);</a>
<a name="ln6570">  int a = 0;</a>
<a name="ln6571">  int b = langmap_mapga.ga_len;</a>
<a name="ln6572"> </a>
<a name="ln6573">  while (a != b) {</a>
<a name="ln6574">    int i = (a + b) / 2;</a>
<a name="ln6575">    int d = entries[i].from - c;</a>
<a name="ln6576"> </a>
<a name="ln6577">    if (d == 0) {</a>
<a name="ln6578">      return entries[i].to;        // found matching entry</a>
<a name="ln6579">    }</a>
<a name="ln6580">    if (d &lt; 0) {</a>
<a name="ln6581">      a = i + 1;</a>
<a name="ln6582">    } else {</a>
<a name="ln6583">      b = i;</a>
<a name="ln6584">    }</a>
<a name="ln6585">  }</a>
<a name="ln6586">  return c;    // no entry found, return &quot;c&quot; unmodified</a>
<a name="ln6587">}</a>
<a name="ln6588"> </a>
<a name="ln6589">static void langmap_init(void)</a>
<a name="ln6590">{</a>
<a name="ln6591">  for (int i = 0; i &lt; 256; i++) {</a>
<a name="ln6592">    langmap_mapchar[i] = (char_u)i;      // we init with a one-to-one map</a>
<a name="ln6593">  }</a>
<a name="ln6594">  ga_init(&amp;langmap_mapga, sizeof(langmap_entry_T), 8);</a>
<a name="ln6595">}</a>
<a name="ln6596"> </a>
<a name="ln6597">/// Called when langmap option is set; the language map can be</a>
<a name="ln6598">/// changed at any time!</a>
<a name="ln6599">static void langmap_set(void)</a>
<a name="ln6600">{</a>
<a name="ln6601">  char_u  *p;</a>
<a name="ln6602">  char_u  *p2;</a>
<a name="ln6603">  int from, to;</a>
<a name="ln6604"> </a>
<a name="ln6605">  ga_clear(&amp;langmap_mapga);                 // clear the previous map first</a>
<a name="ln6606">  langmap_init();                           // back to one-to-one map</a>
<a name="ln6607"> </a>
<a name="ln6608">  for (p = p_langmap; p[0] != NUL; ) {</a>
<a name="ln6609">    for (p2 = p; p2[0] != NUL &amp;&amp; p2[0] != ',' &amp;&amp; p2[0] != ';';</a>
<a name="ln6610">         MB_PTR_ADV(p2)) {</a>
<a name="ln6611">      if (p2[0] == '\\' &amp;&amp; p2[1] != NUL) {</a>
<a name="ln6612">        p2++;</a>
<a name="ln6613">      }</a>
<a name="ln6614">    }</a>
<a name="ln6615">    if (p2[0] == ';') {</a>
<a name="ln6616">      p2++;                 // abcd;ABCD form, p2 points to A</a>
<a name="ln6617">    } else {</a>
<a name="ln6618">      p2 = NULL;            // aAbBcCdD form, p2 is NULL</a>
<a name="ln6619">    }</a>
<a name="ln6620">    while (p[0]) {</a>
<a name="ln6621">      if (p[0] == ',') {</a>
<a name="ln6622">        p++;</a>
<a name="ln6623">        break;</a>
<a name="ln6624">      }</a>
<a name="ln6625">      if (p[0] == '\\' &amp;&amp; p[1] != NUL) {</a>
<a name="ln6626">        p++;</a>
<a name="ln6627">      }</a>
<a name="ln6628">      from = utf_ptr2char(p);</a>
<a name="ln6629">      to = NUL;</a>
<a name="ln6630">      if (p2 == NULL) {</a>
<a name="ln6631">        MB_PTR_ADV(p);</a>
<a name="ln6632">        if (p[0] != ',') {</a>
<a name="ln6633">          if (p[0] == '\\') {</a>
<a name="ln6634">            p++;</a>
<a name="ln6635">          }</a>
<a name="ln6636">          to = utf_ptr2char(p);</a>
<a name="ln6637">        }</a>
<a name="ln6638">      } else {</a>
<a name="ln6639">        if (p2[0] != ',') {</a>
<a name="ln6640">          if (p2[0] == '\\') {</a>
<a name="ln6641">            p2++;</a>
<a name="ln6642">          }</a>
<a name="ln6643">          to = utf_ptr2char(p2);</a>
<a name="ln6644">        }</a>
<a name="ln6645">      }</a>
<a name="ln6646">      if (to == NUL) {</a>
<a name="ln6647">        EMSG2(_(&quot;E357: 'langmap': Matching character missing for %s&quot;),</a>
<a name="ln6648">            transchar(from));</a>
<a name="ln6649">        return;</a>
<a name="ln6650">      }</a>
<a name="ln6651"> </a>
<a name="ln6652">      if (from &gt;= 256) {</a>
<a name="ln6653">        langmap_set_entry(from, to);</a>
<a name="ln6654">      } else {</a>
<a name="ln6655">        assert(to &lt;= UCHAR_MAX);</a>
<a name="ln6656">        langmap_mapchar[from &amp; 255] = (char_u)to;</a>
<a name="ln6657">      }</a>
<a name="ln6658"> </a>
<a name="ln6659">      // Advance to next pair</a>
<a name="ln6660">      MB_PTR_ADV(p);</a>
<a name="ln6661">      if (p2 != NULL) {</a>
<a name="ln6662">        MB_PTR_ADV(p2);</a>
<a name="ln6663">        if (*p == ';') {</a>
<a name="ln6664">          p = p2;</a>
<a name="ln6665">          if (p[0] != NUL) {</a>
<a name="ln6666">            if (p[0] != ',') {</a>
<a name="ln6667">              EMSG2(_(</a>
<a name="ln6668">                      &quot;E358: 'langmap': Extra characters after semicolon: %s&quot;),</a>
<a name="ln6669">                  p);</a>
<a name="ln6670">              return;</a>
<a name="ln6671">            }</a>
<a name="ln6672">            p++;</a>
<a name="ln6673">          }</a>
<a name="ln6674">          break;</a>
<a name="ln6675">        }</a>
<a name="ln6676">      }</a>
<a name="ln6677">    }</a>
<a name="ln6678">  }</a>
<a name="ln6679">}</a>
<a name="ln6680"> </a>
<a name="ln6681">/// Return true if format option 'x' is in effect.</a>
<a name="ln6682">/// Take care of no formatting when 'paste' is set.</a>
<a name="ln6683">bool has_format_option(int x)</a>
<a name="ln6684">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6685">{</a>
<a name="ln6686">  if (p_paste) {</a>
<a name="ln6687">    return false;</a>
<a name="ln6688">  }</a>
<a name="ln6689">  return vim_strchr(curbuf-&gt;b_p_fo, x) != NULL;</a>
<a name="ln6690">}</a>
<a name="ln6691"> </a>
<a name="ln6692">/// @returns true if &quot;x&quot; is present in 'shortmess' option, or</a>
<a name="ln6693">/// 'shortmess' contains 'a' and &quot;x&quot; is present in SHM_ALL_ABBREVIATIONS.</a>
<a name="ln6694">bool shortmess(int x)</a>
<a name="ln6695">{</a>
<a name="ln6696">  return (p_shm != NULL</a>
<a name="ln6697">          &amp;&amp; (vim_strchr(p_shm, x) != NULL</a>
<a name="ln6698">              || (vim_strchr(p_shm, 'a') != NULL</a>
<a name="ln6699">                  &amp;&amp; vim_strchr((char_u *)SHM_ALL_ABBREVIATIONS, x) != NULL)));</a>
<a name="ln6700">}</a>
<a name="ln6701"> </a>
<a name="ln6702">/// paste_option_changed() - Called after p_paste was set or reset.</a>
<a name="ln6703">static void paste_option_changed(void)</a>
<a name="ln6704">{</a>
<a name="ln6705">  static int old_p_paste = false;</a>
<a name="ln6706">  static int save_sm = 0;</a>
<a name="ln6707">  static int save_sta = 0;</a>
<a name="ln6708">  static int save_ru = 0;</a>
<a name="ln6709">  static int save_ri = 0;</a>
<a name="ln6710">  static int save_hkmap = 0;</a>
<a name="ln6711"> </a>
<a name="ln6712">  if (p_paste) {</a>
<a name="ln6713">    /*</a>
<a name="ln6714">     * Paste switched from off to on.</a>
<a name="ln6715">     * Save the current values, so they can be restored later.</a>
<a name="ln6716">     */</a>
<a name="ln6717">    if (!old_p_paste) {</a>
<a name="ln6718">      // save options for each buffer</a>
<a name="ln6719">      FOR_ALL_BUFFERS(buf) {</a>
<a name="ln6720">        buf-&gt;b_p_tw_nopaste = buf-&gt;b_p_tw;</a>
<a name="ln6721">        buf-&gt;b_p_wm_nopaste = buf-&gt;b_p_wm;</a>
<a name="ln6722">        buf-&gt;b_p_sts_nopaste = buf-&gt;b_p_sts;</a>
<a name="ln6723">        buf-&gt;b_p_ai_nopaste = buf-&gt;b_p_ai;</a>
<a name="ln6724">        buf-&gt;b_p_et_nopaste = buf-&gt;b_p_et;</a>
<a name="ln6725">        if (buf-&gt;b_p_vsts_nopaste) {</a>
<a name="ln6726">          xfree(buf-&gt;b_p_vsts_nopaste);</a>
<a name="ln6727">        }</a>
<a name="ln6728">        buf-&gt;b_p_vsts_nopaste = buf-&gt;b_p_vsts &amp;&amp; buf-&gt;b_p_vsts != empty_option</a>
<a name="ln6729">                                    ? vim_strsave(buf-&gt;b_p_vsts)</a>
<a name="ln6730">                                    : NULL;</a>
<a name="ln6731">      }</a>
<a name="ln6732"> </a>
<a name="ln6733">      // save global options</a>
<a name="ln6734">      save_sm = p_sm;</a>
<a name="ln6735">      save_sta = p_sta;</a>
<a name="ln6736">      save_ru = p_ru;</a>
<a name="ln6737">      save_ri = p_ri;</a>
<a name="ln6738">      save_hkmap = p_hkmap;</a>
<a name="ln6739">      // save global values for local buffer options</a>
<a name="ln6740">      p_ai_nopaste = p_ai;</a>
<a name="ln6741">      p_et_nopaste = p_et;</a>
<a name="ln6742">      p_sts_nopaste = p_sts;</a>
<a name="ln6743">      p_tw_nopaste = p_tw;</a>
<a name="ln6744">      p_wm_nopaste = p_wm;</a>
<a name="ln6745">      if (p_vsts_nopaste) {</a>
<a name="ln6746">        xfree(p_vsts_nopaste);</a>
<a name="ln6747">      }</a>
<a name="ln6748">      p_vsts_nopaste = p_vsts &amp;&amp; p_vsts != empty_option</a>
<a name="ln6749">                          ? vim_strsave(p_vsts)</a>
<a name="ln6750">                          : NULL;</a>
<a name="ln6751">    }</a>
<a name="ln6752"> </a>
<a name="ln6753">    // Always set the option values, also when 'paste' is set when it is</a>
<a name="ln6754">    // already on.</a>
<a name="ln6755">    // set options for each buffer</a>
<a name="ln6756">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln6757">      buf-&gt;b_p_tw = 0;              // textwidth is 0</a>
<a name="ln6758">      buf-&gt;b_p_wm = 0;              // wrapmargin is 0</a>
<a name="ln6759">      buf-&gt;b_p_sts = 0;             // softtabstop is 0</a>
<a name="ln6760">      buf-&gt;b_p_ai = 0;              // no auto-indent</a>
<a name="ln6761">      buf-&gt;b_p_et = 0;              // no expandtab</a>
<a name="ln6762">      if (buf-&gt;b_p_vsts) {</a>
<a name="ln6763">        free_string_option(buf-&gt;b_p_vsts);</a>
<a name="ln6764">      }</a>
<a name="ln6765">      buf-&gt;b_p_vsts = empty_option;</a>
<a name="ln6766">      if (buf-&gt;b_p_vsts_array) {</a>
<a name="ln6767">        xfree(buf-&gt;b_p_vsts_array);</a>
<a name="ln6768">      }</a>
<a name="ln6769">      buf-&gt;b_p_vsts_array = 0;</a>
<a name="ln6770">    }</a>
<a name="ln6771"> </a>
<a name="ln6772">    // set global options</a>
<a name="ln6773">    p_sm = 0;                       // no showmatch</a>
<a name="ln6774">    p_sta = 0;                      // no smarttab</a>
<a name="ln6775">    if (p_ru) {</a>
<a name="ln6776">      status_redraw_all();          // redraw to remove the ruler</a>
<a name="ln6777">    }</a>
<a name="ln6778">    p_ru = 0;                       // no ruler</a>
<a name="ln6779">    p_ri = 0;                       // no reverse insert</a>
<a name="ln6780">    p_hkmap = 0;                    // no Hebrew keyboard</a>
<a name="ln6781">    // set global values for local buffer options</a>
<a name="ln6782">    p_tw = 0;</a>
<a name="ln6783">    p_wm = 0;</a>
<a name="ln6784">    p_sts = 0;</a>
<a name="ln6785">    p_ai = 0;</a>
<a name="ln6786">    if (p_vsts) {</a>
<a name="ln6787">      free_string_option(p_vsts);</a>
<a name="ln6788">    }</a>
<a name="ln6789">    p_vsts = empty_option;</a>
<a name="ln6790">  } else if (old_p_paste) {</a>
<a name="ln6791">    // Paste switched from on to off: Restore saved values.</a>
<a name="ln6792"> </a>
<a name="ln6793">    // restore options for each buffer</a>
<a name="ln6794">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln6795">      buf-&gt;b_p_tw = buf-&gt;b_p_tw_nopaste;</a>
<a name="ln6796">      buf-&gt;b_p_wm = buf-&gt;b_p_wm_nopaste;</a>
<a name="ln6797">      buf-&gt;b_p_sts = buf-&gt;b_p_sts_nopaste;</a>
<a name="ln6798">      buf-&gt;b_p_ai = buf-&gt;b_p_ai_nopaste;</a>
<a name="ln6799">      buf-&gt;b_p_et = buf-&gt;b_p_et_nopaste;</a>
<a name="ln6800">      if (buf-&gt;b_p_vsts) {</a>
<a name="ln6801">        free_string_option(buf-&gt;b_p_vsts);</a>
<a name="ln6802">      }</a>
<a name="ln6803">      buf-&gt;b_p_vsts = buf-&gt;b_p_vsts_nopaste</a>
<a name="ln6804">                        ? vim_strsave(buf-&gt;b_p_vsts_nopaste)</a>
<a name="ln6805">                        : empty_option;</a>
<a name="ln6806">      if (buf-&gt;b_p_vsts_array) {</a>
<a name="ln6807">        xfree(buf-&gt;b_p_vsts_array);</a>
<a name="ln6808">      }</a>
<a name="ln6809">      if (buf-&gt;b_p_vsts &amp;&amp; buf-&gt;b_p_vsts != empty_option) {</a>
<a name="ln6810">        tabstop_set(buf-&gt;b_p_vsts, &amp;buf-&gt;b_p_vsts_array);</a>
<a name="ln6811">      } else {</a>
<a name="ln6812">        buf-&gt;b_p_vsts_array = 0;</a>
<a name="ln6813">      }</a>
<a name="ln6814">    }</a>
<a name="ln6815"> </a>
<a name="ln6816">    // restore global options</a>
<a name="ln6817">    p_sm = save_sm;</a>
<a name="ln6818">    p_sta = save_sta;</a>
<a name="ln6819">    if (p_ru != save_ru) {</a>
<a name="ln6820">      status_redraw_all();          // redraw to draw the ruler</a>
<a name="ln6821">    }</a>
<a name="ln6822">    p_ru = save_ru;</a>
<a name="ln6823">    p_ri = save_ri;</a>
<a name="ln6824">    p_hkmap = save_hkmap;</a>
<a name="ln6825">    // set global values for local buffer options</a>
<a name="ln6826">    p_ai = p_ai_nopaste;</a>
<a name="ln6827">    p_et = p_et_nopaste;</a>
<a name="ln6828">    p_sts = p_sts_nopaste;</a>
<a name="ln6829">    p_tw = p_tw_nopaste;</a>
<a name="ln6830">    p_wm = p_wm_nopaste;</a>
<a name="ln6831">    if (p_vsts) {</a>
<a name="ln6832">      free_string_option(p_vsts);</a>
<a name="ln6833">    }</a>
<a name="ln6834">    p_vsts = p_vsts_nopaste ? vim_strsave(p_vsts_nopaste) : empty_option;</a>
<a name="ln6835">  }</a>
<a name="ln6836"> </a>
<a name="ln6837">  old_p_paste = p_paste;</a>
<a name="ln6838">}</a>
<a name="ln6839"> </a>
<a name="ln6840">/// vimrc_found() - Called when a vimrc or &quot;VIMINIT&quot; has been found.</a>
<a name="ln6841">///</a>
<a name="ln6842">/// Set the values for options that didn't get set yet to the Vim defaults.</a>
<a name="ln6843">/// When &quot;fname&quot; is not NULL, use it to set $&quot;envname&quot; when it wasn't set yet.</a>
<a name="ln6844">void vimrc_found(char_u *fname, char_u *envname)</a>
<a name="ln6845">{</a>
<a name="ln6846">  if (fname != NULL &amp;&amp; envname != NULL) {</a>
<a name="ln6847">    char *p = vim_getenv((char *)envname);</a>
<a name="ln6848">    if (p == NULL) {</a>
<a name="ln6849">      // Set $MYVIMRC to the first vimrc file found.</a>
<a name="ln6850">      p = FullName_save((char *)fname, false);</a>
<a name="ln6851">      if (p != NULL) {</a>
<a name="ln6852">        os_setenv((char *)envname, p, 1);</a>
<a name="ln6853">        xfree(p);</a>
<a name="ln6854">      }</a>
<a name="ln6855">    } else {</a>
<a name="ln6856">      xfree(p);</a>
<a name="ln6857">    }</a>
<a name="ln6858">  }</a>
<a name="ln6859">}</a>
<a name="ln6860"> </a>
<a name="ln6861">/// Check whether global option has been set</a>
<a name="ln6862">///</a>
<a name="ln6863">/// @param[in]  name  Option name.</a>
<a name="ln6864">///</a>
<a name="ln6865">/// @return True if it was set.</a>
<a name="ln6866">bool option_was_set(const char *name)</a>
<a name="ln6867">{</a>
<a name="ln6868">  int idx;</a>
<a name="ln6869"> </a>
<a name="ln6870">  idx = findoption(name);</a>
<a name="ln6871">  if (idx &lt; 0) {  // Unknown option.</a>
<a name="ln6872">    return false;</a>
<a name="ln6873">  } else if (options[idx].flags &amp; P_WAS_SET) {</a>
<a name="ln6874">    return true;</a>
<a name="ln6875">  }</a>
<a name="ln6876">  return false;</a>
<a name="ln6877">}</a>
<a name="ln6878"> </a>
<a name="ln6879">/// Reset the flag indicating option &quot;name&quot; was set.</a>
<a name="ln6880">///</a>
<a name="ln6881">/// @param[in]  name  Option name.</a>
<a name="ln6882">void reset_option_was_set(const char *name)</a>
<a name="ln6883">{</a>
<a name="ln6884">  const int idx = findoption(name);</a>
<a name="ln6885"> </a>
<a name="ln6886">  if (idx &gt;= 0) {</a>
<a name="ln6887">    options[idx].flags &amp;= ~P_WAS_SET;</a>
<a name="ln6888">  }</a>
<a name="ln6889">}</a>
<a name="ln6890"> </a>
<a name="ln6891">/// fill_breakat_flags() -- called when 'breakat' changes value.</a>
<a name="ln6892">static void fill_breakat_flags(void)</a>
<a name="ln6893">{</a>
<a name="ln6894">  char_u      *p;</a>
<a name="ln6895">  int i;</a>
<a name="ln6896"> </a>
<a name="ln6897">  for (i = 0; i &lt; 256; i++) {</a>
<a name="ln6898">    breakat_flags[i] = false;</a>
<a name="ln6899">  }</a>
<a name="ln6900"> </a>
<a name="ln6901">  if (p_breakat != NULL) {</a>
<a name="ln6902">    for (p = p_breakat; *p; p++) {</a>
<a name="ln6903">      breakat_flags[*p] = true;</a>
<a name="ln6904">    }</a>
<a name="ln6905">  }</a>
<a name="ln6906">}</a>
<a name="ln6907"> </a>
<a name="ln6908">/// Check an option that can be a range of string values.</a>
<a name="ln6909">///</a>
<a name="ln6910">/// Return OK for correct value, FAIL otherwise.</a>
<a name="ln6911">/// Empty is always OK.</a>
<a name="ln6912">static int check_opt_strings(</a>
<a name="ln6913">    char_u *val,</a>
<a name="ln6914">    char **values,</a>
<a name="ln6915">    int list                   // when true: accept a list of values</a>
<a name="ln6916">)</a>
<a name="ln6917">{</a>
<a name="ln6918">  return opt_strings_flags(val, values, NULL, list);</a>
<a name="ln6919">}</a>
<a name="ln6920"> </a>
<a name="ln6921">/// Handle an option that can be a range of string values.</a>
<a name="ln6922">/// Set a flag in &quot;*flagp&quot; for each string present.</a>
<a name="ln6923">///</a>
<a name="ln6924">/// Return OK for correct value, FAIL otherwise.</a>
<a name="ln6925">/// Empty is always OK.</a>
<a name="ln6926">static int opt_strings_flags(</a>
<a name="ln6927">    char_u *val,             // new value</a>
<a name="ln6928">    char **values,           // array of valid string values</a>
<a name="ln6929">    unsigned *flagp,</a>
<a name="ln6930">    bool list                // when true: accept a list of values</a>
<a name="ln6931">)</a>
<a name="ln6932">{</a>
<a name="ln6933">  unsigned int new_flags = 0;</a>
<a name="ln6934"> </a>
<a name="ln6935">  while (*val) {</a>
<a name="ln6936">    for (unsigned int i = 0;; i++) {</a>
<a name="ln6937">      if (values[i] == NULL) {          // val not found in values[]</a>
<a name="ln6938">        return FAIL;</a>
<a name="ln6939">      }</a>
<a name="ln6940"> </a>
<a name="ln6941">      size_t len = STRLEN(values[i]);</a>
<a name="ln6942">      if (STRNCMP(values[i], val, len) == 0</a>
<a name="ln6943">          &amp;&amp; ((list &amp;&amp; val[len] == ',') || val[len] == NUL)) {</a>
<a name="ln6944">        val += len + (val[len] == ',');</a>
<a name="ln6945">        assert(i &lt; sizeof(1U) * 8);</a>
<a name="ln6946">        new_flags |= (1U &lt;&lt; i);</a>
<a name="ln6947">        break;                  // check next item in val list</a>
<a name="ln6948">      }</a>
<a name="ln6949">    }</a>
<a name="ln6950">  }</a>
<a name="ln6951">  if (flagp != NULL) {</a>
<a name="ln6952">    *flagp = new_flags;</a>
<a name="ln6953">  }</a>
<a name="ln6954"> </a>
<a name="ln6955">  return OK;</a>
<a name="ln6956">}</a>
<a name="ln6957"> </a>
<a name="ln6958">/// Read the 'wildmode' option, fill wim_flags[].</a>
<a name="ln6959">static int check_opt_wim(void)</a>
<a name="ln6960">{</a>
<a name="ln6961">  char_u new_wim_flags[4];</a>
<a name="ln6962">  char_u      *p;</a>
<a name="ln6963">  int i;</a>
<a name="ln6964">  int idx = 0;</a>
<a name="ln6965"> </a>
<a name="ln6966">  for (i = 0; i &lt; 4; i++) {</a>
<a name="ln6967">    new_wim_flags[i] = 0;</a>
<a name="ln6968">  }</a>
<a name="ln6969"> </a>
<a name="ln6970">  for (p = p_wim; *p; p++) {</a>
<a name="ln6971">    for (i = 0; ASCII_ISALPHA(p[i]); i++) {}</a>
<a name="ln6972">    if (p[i] != NUL &amp;&amp; p[i] != ',' &amp;&amp; p[i] != ':') {</a>
<a name="ln6973">      return FAIL;</a>
<a name="ln6974">    }</a>
<a name="ln6975">    if (i == 7 &amp;&amp; STRNCMP(p, &quot;longest&quot;, 7) == 0) {</a>
<a name="ln6976">      new_wim_flags[idx] |= WIM_LONGEST;</a>
<a name="ln6977">    } else if (i == 4 &amp;&amp; STRNCMP(p, &quot;full&quot;, 4) == 0) {</a>
<a name="ln6978">      new_wim_flags[idx] |= WIM_FULL;</a>
<a name="ln6979">    } else if (i == 4 &amp;&amp; STRNCMP(p, &quot;list&quot;, 4) == 0) {</a>
<a name="ln6980">      new_wim_flags[idx] |= WIM_LIST;</a>
<a name="ln6981">    } else if (i == 8 &amp;&amp; STRNCMP(p, &quot;lastused&quot;, 8) == 0) {</a>
<a name="ln6982">      new_wim_flags[idx] |= WIM_BUFLASTUSED;</a>
<a name="ln6983">    } else {</a>
<a name="ln6984">      return FAIL;</a>
<a name="ln6985">    }</a>
<a name="ln6986">    p += i;</a>
<a name="ln6987">    if (*p == NUL) {</a>
<a name="ln6988">      break;</a>
<a name="ln6989">    }</a>
<a name="ln6990">    if (*p == ',') {</a>
<a name="ln6991">      if (idx == 3) {</a>
<a name="ln6992">        return FAIL;</a>
<a name="ln6993">      }</a>
<a name="ln6994">      idx++;</a>
<a name="ln6995">    }</a>
<a name="ln6996">  }</a>
<a name="ln6997"> </a>
<a name="ln6998">  // fill remaining entries with last flag</a>
<a name="ln6999">  while (idx &lt; 3) {</a>
<a name="ln7000">    new_wim_flags[idx + 1] = new_wim_flags[idx];</a>
<a name="ln7001">    idx++;</a>
<a name="ln7002">  }</a>
<a name="ln7003"> </a>
<a name="ln7004">  // only when there are no errors, wim_flags[] is changed</a>
<a name="ln7005">  for (i = 0; i &lt; 4; i++) {</a>
<a name="ln7006">    wim_flags[i] = new_wim_flags[i];</a>
<a name="ln7007">  }</a>
<a name="ln7008">  return OK;</a>
<a name="ln7009">}</a>
<a name="ln7010"> </a>
<a name="ln7011">/// Check if backspacing over something is allowed.</a>
<a name="ln7012">/// @param  what  BS_INDENT, BS_EOL, BS_START, or BS_NOSTOP</a>
<a name="ln7013">bool can_bs(int what)</a>
<a name="ln7014">{</a>
<a name="ln7015">  if (what == BS_START &amp;&amp; bt_prompt(curbuf)) {</a>
<a name="ln7016">    return false;</a>
<a name="ln7017">  }</a>
<a name="ln7018">  switch (*p_bs) {</a>
<a name="ln7019">    case '3':       return true;</a>
<a name="ln7020">    case '2':       return what != BS_NOSTOP;</a>
<a name="ln7021">    case '1':       return what != BS_START;</a>
<a name="ln7022">    case '0':       return false;</a>
<a name="ln7023">  }</a>
<a name="ln7024">  return vim_strchr(p_bs, what) != NULL;</a>
<a name="ln7025">}</a>
<a name="ln7026"> </a>
<a name="ln7027">/// Save the current values of 'fileformat' and 'fileencoding', so that we know</a>
<a name="ln7028">/// the file must be considered changed when the value is different.</a>
<a name="ln7029">void save_file_ff(buf_T *buf)</a>
<a name="ln7030">{</a>
<a name="ln7031">  buf-&gt;b_start_ffc = *buf-&gt;b_p_ff;</a>
<a name="ln7032">  buf-&gt;b_start_eol = buf-&gt;b_p_eol;</a>
<a name="ln7033">  buf-&gt;b_start_bomb = buf-&gt;b_p_bomb;</a>
<a name="ln7034"> </a>
<a name="ln7035">  // Only use free/alloc when necessary, they take time.</a>
<a name="ln7036">  if (buf-&gt;b_start_fenc == NULL</a>
<a name="ln7037">      || STRCMP(buf-&gt;b_start_fenc, buf-&gt;b_p_fenc) != 0) {</a>
<a name="ln7038">    xfree(buf-&gt;b_start_fenc);</a>
<a name="ln7039">    buf-&gt;b_start_fenc = vim_strsave(buf-&gt;b_p_fenc);</a>
<a name="ln7040">  }</a>
<a name="ln7041">}</a>
<a name="ln7042"> </a>
<a name="ln7043">/// Return true if 'fileformat' and/or 'fileencoding' has a different value</a>
<a name="ln7044">/// from when editing started (save_file_ff() called).</a>
<a name="ln7045">/// Also when 'endofline' was changed and 'binary' is set, or when 'bomb' was</a>
<a name="ln7046">/// changed and 'binary' is not set.</a>
<a name="ln7047">/// Also when 'endofline' was changed and 'fixeol' is not set.</a>
<a name="ln7048">/// When &quot;ignore_empty&quot; is true don't consider a new, empty buffer to be</a>
<a name="ln7049">/// changed.</a>
<a name="ln7050">bool file_ff_differs(buf_T *buf, bool ignore_empty)</a>
<a name="ln7051">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7052">{</a>
<a name="ln7053">  // In a buffer that was never loaded the options are not valid.</a>
<a name="ln7054">  if (buf-&gt;b_flags &amp; BF_NEVERLOADED) {</a>
<a name="ln7055">    return false;</a>
<a name="ln7056">  }</a>
<a name="ln7057">  if (ignore_empty</a>
<a name="ln7058">      &amp;&amp; (buf-&gt;b_flags &amp; BF_NEW)</a>
<a name="ln7059">      &amp;&amp; buf-&gt;b_ml.ml_line_count == 1</a>
<a name="ln7060">      &amp;&amp; *ml_get_buf(buf, (linenr_T)1, false) == NUL) {</a>
<a name="ln7061">    return false;</a>
<a name="ln7062">  }</a>
<a name="ln7063">  if (buf-&gt;b_start_ffc != *buf-&gt;b_p_ff) {</a>
<a name="ln7064">    return true;</a>
<a name="ln7065">  }</a>
<a name="ln7066">  if ((buf-&gt;b_p_bin || !buf-&gt;b_p_fixeol) &amp;&amp; buf-&gt;b_start_eol != buf-&gt;b_p_eol) {</a>
<a name="ln7067">    return true;</a>
<a name="ln7068">  }</a>
<a name="ln7069">  if (!buf-&gt;b_p_bin &amp;&amp; buf-&gt;b_start_bomb != buf-&gt;b_p_bomb) {</a>
<a name="ln7070">    return true;</a>
<a name="ln7071">  }</a>
<a name="ln7072">  if (buf-&gt;b_start_fenc == NULL) {</a>
<a name="ln7073">    return *buf-&gt;b_p_fenc != NUL;</a>
<a name="ln7074">  }</a>
<a name="ln7075">  return STRCMP(buf-&gt;b_start_fenc, buf-&gt;b_p_fenc) != 0;</a>
<a name="ln7076">}</a>
<a name="ln7077"> </a>
<a name="ln7078">/// return OK if &quot;p&quot; is a valid fileformat name, FAIL otherwise.</a>
<a name="ln7079">int check_ff_value(char_u *p)</a>
<a name="ln7080">{</a>
<a name="ln7081">  return check_opt_strings(p, p_ff_values, false);</a>
<a name="ln7082">}</a>
<a name="ln7083"> </a>
<a name="ln7084">// Set the integer values corresponding to the string setting of 'vartabstop'.</a>
<a name="ln7085">// &quot;array&quot; will be set, caller must free it if needed.</a>
<a name="ln7086">bool tabstop_set(char_u *var, long **array)</a>
<a name="ln7087">{</a>
<a name="ln7088">  long valcount = 1;</a>
<a name="ln7089">  int t;</a>
<a name="ln7090">  char_u *cp;</a>
<a name="ln7091"> </a>
<a name="ln7092">  if (var[0] == NUL || (var[0] == '0' &amp;&amp; var[1] == NUL)) {</a>
<a name="ln7093">    *array = NULL;</a>
<a name="ln7094">    return true;</a>
<a name="ln7095">  }</a>
<a name="ln7096"> </a>
<a name="ln7097">  for (cp = var; *cp != NUL; cp++) {</a>
<a name="ln7098">    if (cp == var || cp[-1] == ',') {</a>
<a name="ln7099">      char_u *end;</a>
<a name="ln7100"> </a>
<a name="ln7101">      if (strtol((char *)cp, (char **)&amp;end, 10) &lt;= 0) {</a>
<a name="ln7102">        if (cp != end) {</a>
<a name="ln7103">          EMSG(_(e_positive));</a>
<a name="ln7104">        } else {</a>
<a name="ln7105">          EMSG(_(e_invarg));</a>
<a name="ln7106">        }</a>
<a name="ln7107">        return false;</a>
<a name="ln7108">      }</a>
<a name="ln7109">    }</a>
<a name="ln7110"> </a>
<a name="ln7111">    if (ascii_isdigit(*cp)) {</a>
<a name="ln7112">      continue;</a>
<a name="ln7113">    }</a>
<a name="ln7114">    if (cp[0] == ',' &amp;&amp; cp &gt; var &amp;&amp; cp[-1] != ',' &amp;&amp; cp[1] != NUL) {</a>
<a name="ln7115">      valcount++;</a>
<a name="ln7116">      continue;</a>
<a name="ln7117">    }</a>
<a name="ln7118">    EMSG(_(e_invarg));</a>
<a name="ln7119">    return false;</a>
<a name="ln7120">  }</a>
<a name="ln7121"> </a>
<a name="ln7122">  *array = (long *)xmalloc((unsigned)(valcount + 1) * sizeof(long));</a>
<a name="ln7123">  (*array)[0] = valcount;</a>
<a name="ln7124"> </a>
<a name="ln7125">  t = 1;</a>
<a name="ln7126">  for (cp = var; *cp != NUL;) {</a>
<a name="ln7127">    (*array)[t++] = atoi((char *)cp);</a>
<a name="ln7128">    while (*cp  != NUL &amp;&amp; *cp != ',') {</a>
<a name="ln7129">      cp++;</a>
<a name="ln7130">    }</a>
<a name="ln7131">    if (*cp != NUL) {</a>
<a name="ln7132">      cp++;</a>
<a name="ln7133">    }</a>
<a name="ln7134">  }</a>
<a name="ln7135"> </a>
<a name="ln7136">  return true;</a>
<a name="ln7137">}</a>
<a name="ln7138"> </a>
<a name="ln7139">// Calculate the number of screen spaces a tab will occupy.</a>
<a name="ln7140">// If &quot;vts&quot; is set then the tab widths are taken from that array,</a>
<a name="ln7141">// otherwise the value of ts is used.</a>
<a name="ln7142">int tabstop_padding(colnr_T col, long ts_arg, long *vts)</a>
<a name="ln7143">{</a>
<a name="ln7144">  long ts = ts_arg == 0 ? 8 : ts_arg;</a>
<a name="ln7145">  colnr_T tabcol = 0;</a>
<a name="ln7146">  int t;</a>
<a name="ln7147">  long padding = 0;</a>
<a name="ln7148"> </a>
<a name="ln7149">  if (vts == NULL || vts[0] == 0) {</a>
<a name="ln7150">    return (int)(ts - (col % ts));</a>
<a name="ln7151">  }</a>
<a name="ln7152"> </a>
<a name="ln7153">  const long tabcount = vts[0];</a>
<a name="ln7154"> </a>
<a name="ln7155">  for (t = 1; t &lt;= tabcount; t++) {</a>
<a name="ln7156">    tabcol += (colnr_T)vts[t];</a>
<a name="ln7157">    if (tabcol &gt; col) {</a>
<a name="ln7158">      padding = tabcol - col;</a>
<a name="ln7159">      break;</a>
<a name="ln7160">    }</a>
<a name="ln7161">  }</a>
<a name="ln7162">  if (t &gt; tabcount) {</a>
<a name="ln7163">    padding = vts[tabcount] - ((col - tabcol) % vts[tabcount]);</a>
<a name="ln7164">  }</a>
<a name="ln7165"> </a>
<a name="ln7166">  return (int)padding;</a>
<a name="ln7167">}</a>
<a name="ln7168"> </a>
<a name="ln7169">// Find the size of the tab that covers a particular column.</a>
<a name="ln7170">int tabstop_at(colnr_T col, long ts, long *vts)</a>
<a name="ln7171">{</a>
<a name="ln7172">  colnr_T tabcol = 0;</a>
<a name="ln7173">  int t;</a>
<a name="ln7174">  long tab_size = 0;</a>
<a name="ln7175"> </a>
<a name="ln7176">  if (vts == NULL || vts[0] == 0) {</a>
<a name="ln7177">    return (int)ts;</a>
<a name="ln7178">  }</a>
<a name="ln7179"> </a>
<a name="ln7180">  const long tabcount = vts[0];</a>
<a name="ln7181">  for (t = 1; t &lt;= tabcount; t++) {</a>
<a name="ln7182">    tabcol += (colnr_T)vts[t];</a>
<a name="ln7183">    if (tabcol &gt; col) {</a>
<a name="ln7184">      tab_size = vts[t];</a>
<a name="ln7185">      break;</a>
<a name="ln7186">    }</a>
<a name="ln7187">  }</a>
<a name="ln7188">  if (t &gt; tabcount) {</a>
<a name="ln7189">    tab_size = vts[tabcount];</a>
<a name="ln7190">  }</a>
<a name="ln7191"> </a>
<a name="ln7192">  return (int)tab_size;</a>
<a name="ln7193">}</a>
<a name="ln7194"> </a>
<a name="ln7195">// Find the column on which a tab starts.</a>
<a name="ln7196">colnr_T tabstop_start(colnr_T col, long ts, long *vts)</a>
<a name="ln7197">{</a>
<a name="ln7198">  colnr_T tabcol = 0;</a>
<a name="ln7199">  int t;</a>
<a name="ln7200"> </a>
<a name="ln7201">  if (vts == NULL || vts[0] == 0) {</a>
<a name="ln7202">    return (int)((col / ts) * ts);</a>
<a name="ln7203">  }</a>
<a name="ln7204"> </a>
<a name="ln7205">  const long tabcount = vts[0];</a>
<a name="ln7206">  for (t = 1; t &lt;= tabcount; t++) {</a>
<a name="ln7207">    tabcol += (colnr_T)vts[t];</a>
<a name="ln7208">    if (tabcol &gt; col) {</a>
<a name="ln7209">      return (int)(tabcol - vts[t]);</a>
<a name="ln7210">    }</a>
<a name="ln7211">  }</a>
<a name="ln7212"> </a>
<a name="ln7213">  const int excess = (int)(tabcol % vts[tabcount]);</a>
<a name="ln7214">  return (int)(excess + ((col - excess) / vts[tabcount]) * vts[tabcount]);</a>
<a name="ln7215">}</a>
<a name="ln7216"> </a>
<a name="ln7217">// Find the number of tabs and spaces necessary to get from one column</a>
<a name="ln7218">// to another.</a>
<a name="ln7219">void tabstop_fromto(colnr_T start_col,</a>
<a name="ln7220">                    colnr_T end_col,</a>
<a name="ln7221">                    long ts_arg,</a>
<a name="ln7222">                    long *vts,</a>
<a name="ln7223">                    int *ntabs,</a>
<a name="ln7224">                    int *nspcs)</a>
<a name="ln7225">{</a>
<a name="ln7226">  int spaces = end_col - start_col;</a>
<a name="ln7227">  colnr_T tabcol = 0;</a>
<a name="ln7228">  long padding = 0;</a>
<a name="ln7229">  int t;</a>
<a name="ln7230">  long ts = ts_arg == 0 ? curbuf-&gt;b_p_ts : ts_arg;</a>
<a name="ln7231"> </a>
<a name="ln7232">  if (vts == NULL || vts[0] == 0) {</a>
<a name="ln7233">    int tabs = 0;</a>
<a name="ln7234"> </a>
<a name="ln7235">    const int initspc = (int)(ts - (start_col % ts));</a>
<a name="ln7236">    if (spaces &gt;= initspc) {</a>
<a name="ln7237">      spaces -= initspc;</a>
<a name="ln7238">      tabs++;</a>
<a name="ln7239">    }</a>
<a name="ln7240">    tabs += (int)(spaces / ts);</a>
<a name="ln7241">    spaces -= (int)((spaces / ts) * ts);</a>
<a name="ln7242"> </a>
<a name="ln7243">    *ntabs = tabs;</a>
<a name="ln7244">    *nspcs = spaces;</a>
<a name="ln7245">    return;</a>
<a name="ln7246">  }</a>
<a name="ln7247"> </a>
<a name="ln7248">  // Find the padding needed to reach the next tabstop.</a>
<a name="ln7249">  const long tabcount = vts[0];</a>
<a name="ln7250">  for (t = 1; t &lt;= tabcount; t++) {</a>
<a name="ln7251">    tabcol += (colnr_T)vts[t];</a>
<a name="ln7252">    if (tabcol &gt; start_col) {</a>
<a name="ln7253">      padding = tabcol - start_col;</a>
<a name="ln7254">      break;</a>
<a name="ln7255">    }</a>
<a name="ln7256">  }</a>
<a name="ln7257">  if (t &gt; tabcount) {</a>
<a name="ln7258">    padding = vts[tabcount] - ((start_col - tabcol) % vts[tabcount]);</a>
<a name="ln7259">  }</a>
<a name="ln7260"> </a>
<a name="ln7261">  // If the space needed is less than the padding no tabs can be used.</a>
<a name="ln7262">  if (spaces &lt; padding) {</a>
<a name="ln7263">    *ntabs = 0;</a>
<a name="ln7264">    *nspcs = spaces;</a>
<a name="ln7265">    return;</a>
<a name="ln7266">  }</a>
<a name="ln7267"> </a>
<a name="ln7268">  *ntabs = 1;</a>
<a name="ln7269">  spaces -= (int)padding;</a>
<a name="ln7270"> </a>
<a name="ln7271">  // At least one tab has been used. See if any more will fit.</a>
<a name="ln7272">  while (spaces != 0 &amp;&amp; ++t &lt;= tabcount) {</a>
<a name="ln7273">    padding = vts[t];</a>
<a name="ln7274">    if (spaces &lt; padding) {</a>
<a name="ln7275">      *nspcs = spaces;</a>
<a name="ln7276">      return;</a>
<a name="ln7277">    }</a>
<a name="ln7278">    *ntabs += 1;</a>
<a name="ln7279">    spaces -= (int)padding;</a>
<a name="ln7280">  }</a>
<a name="ln7281"> </a>
<a name="ln7282">  *ntabs += spaces / (int)vts[tabcount];</a>
<a name="ln7283">  *nspcs = spaces % (int)vts[tabcount];</a>
<a name="ln7284">}</a>
<a name="ln7285"> </a>
<a name="ln7286">// See if two tabstop arrays contain the same values.</a>
<a name="ln7287">bool tabstop_eq(long *ts1, long *ts2)</a>
<a name="ln7288">{</a>
<a name="ln7289">  int t;</a>
<a name="ln7290"> </a>
<a name="ln7291">  if ((ts1 == 0 &amp;&amp; ts2) || (ts1 &amp;&amp; ts2 == 0)) {</a>
<a name="ln7292">    return false;</a>
<a name="ln7293">  }</a>
<a name="ln7294">  if (ts1 == ts2) {</a>
<a name="ln7295">    return true;</a>
<a name="ln7296">  }</a>
<a name="ln7297">  if (ts1[0] != ts2[0]) {</a>
<a name="ln7298">    return false;</a>
<a name="ln7299">  }</a>
<a name="ln7300"> </a>
<a name="ln7301">  for (t = 1; t &lt;= ts1[0]; t++) {</a>
<a name="ln7302">    if (ts1[t] != ts2[t]) {</a>
<a name="ln7303">      return false;</a>
<a name="ln7304">    }</a>
<a name="ln7305">  }</a>
<a name="ln7306"> </a>
<a name="ln7307">  return true;</a>
<a name="ln7308">}</a>
<a name="ln7309"> </a>
<a name="ln7310">// Copy a tabstop array, allocating space for the new array.</a>
<a name="ln7311">int *tabstop_copy(long *oldts)</a>
<a name="ln7312">{</a>
<a name="ln7313">  long *newts;</a>
<a name="ln7314">  int t;</a>
<a name="ln7315"> </a>
<a name="ln7316">  if (oldts == 0) {</a>
<a name="ln7317">    return 0;</a>
<a name="ln7318">  }</a>
<a name="ln7319"> </a>
<a name="ln7320">  newts = xmalloc((unsigned)(oldts[0] + 1) * sizeof(long));</a>
<a name="ln7321">  for (t = 0; t &lt;= oldts[0]; t++) {</a>
<a name="ln7322">    newts[t] = oldts[t];</a>
<a name="ln7323">  }</a>
<a name="ln7324"> </a>
<a name="ln7325">  return (int *)newts;</a>
<a name="ln7326">}</a>
<a name="ln7327"> </a>
<a name="ln7328">// Return a count of the number of tabstops.</a>
<a name="ln7329">int tabstop_count(long *ts)</a>
<a name="ln7330">{</a>
<a name="ln7331">  return ts != NULL ? (int)ts[0] : 0;</a>
<a name="ln7332">}</a>
<a name="ln7333"> </a>
<a name="ln7334">// Return the first tabstop, or 8 if there are no tabstops defined.</a>
<a name="ln7335">int tabstop_first(long *ts)</a>
<a name="ln7336">{</a>
<a name="ln7337">  return ts != NULL ? (int)ts[1] : 8;</a>
<a name="ln7338">}</a>
<a name="ln7339"> </a>
<a name="ln7340">/// Return the effective shiftwidth value for current buffer, using the</a>
<a name="ln7341">/// 'tabstop' value when 'shiftwidth' is zero.</a>
<a name="ln7342">int get_sw_value(buf_T *buf)</a>
<a name="ln7343">{</a>
<a name="ln7344">  long result = get_sw_value_col(buf, 0);</a>
<a name="ln7345">  assert(result &gt;= 0 &amp;&amp; result &lt;= INT_MAX);</a>
<a name="ln7346">  return (int)result;</a>
<a name="ln7347">}</a>
<a name="ln7348"> </a>
<a name="ln7349">// Idem, using the first non-black in the current line.</a>
<a name="ln7350">long get_sw_value_indent(buf_T *buf)</a>
<a name="ln7351">{</a>
<a name="ln7352">  pos_T pos = curwin-&gt;w_cursor;</a>
<a name="ln7353"> </a>
<a name="ln7354">  pos.col = (colnr_T)getwhitecols_curline();</a>
<a name="ln7355">  return get_sw_value_pos(buf, &amp;pos);</a>
<a name="ln7356">}</a>
<a name="ln7357"> </a>
<a name="ln7358">// Idem, using &quot;pos&quot;.</a>
<a name="ln7359">long get_sw_value_pos(buf_T *buf, pos_T *pos)</a>
<a name="ln7360">{</a>
<a name="ln7361">  pos_T save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln7362">  long sw_value;</a>
<a name="ln7363"> </a>
<a name="ln7364">  curwin-&gt;w_cursor = *pos;</a>
<a name="ln7365">  sw_value = get_sw_value_col(buf, get_nolist_virtcol());</a>
<a name="ln7366">  curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln7367">  return sw_value;</a>
<a name="ln7368">}</a>
<a name="ln7369"> </a>
<a name="ln7370">// Idem, using virtual column &quot;col&quot;.</a>
<a name="ln7371">long get_sw_value_col(buf_T *buf, colnr_T col)</a>
<a name="ln7372">{</a>
<a name="ln7373">  return buf-&gt;b_p_sw ? buf-&gt;b_p_sw</a>
<a name="ln7374">                     : tabstop_at(col, buf-&gt;b_p_ts, buf-&gt;b_p_vts_array);</a>
<a name="ln7375">}</a>
<a name="ln7376"> </a>
<a name="ln7377">/// Return the effective softtabstop value for the current buffer,</a>
<a name="ln7378">/// using the shiftwidth  value when 'softtabstop' is negative.</a>
<a name="ln7379">int get_sts_value(void)</a>
<a name="ln7380">{</a>
<a name="ln7381">  long result = curbuf-&gt;b_p_sts &lt; 0 ? get_sw_value(curbuf) : curbuf-&gt;b_p_sts;</a>
<a name="ln7382">  assert(result &gt;= 0 &amp;&amp; result &lt;= INT_MAX);</a>
<a name="ln7383">  return (int)result;</a>
<a name="ln7384">}</a>
<a name="ln7385"> </a>
<a name="ln7386">/// This is called when 'breakindentopt' is changed and when a window is</a>
<a name="ln7387">/// initialized</a>
<a name="ln7388">static bool briopt_check(win_T *wp)</a>
<a name="ln7389">{</a>
<a name="ln7390">  int bri_shift = 0;</a>
<a name="ln7391">  int bri_min = 20;</a>
<a name="ln7392">  bool bri_sbr = false;</a>
<a name="ln7393"> </a>
<a name="ln7394">  char_u *p = wp-&gt;w_p_briopt;</a>
<a name="ln7395">  while (*p != NUL)</a>
<a name="ln7396">  {</a>
<a name="ln7397">    if (STRNCMP(p, &quot;shift:&quot;, 6) == 0</a>
<a name="ln7398">        &amp;&amp; ((p[6] == '-' &amp;&amp; ascii_isdigit(p[7])) || ascii_isdigit(p[6])))</a>
<a name="ln7399">    {</a>
<a name="ln7400">      p += 6;</a>
<a name="ln7401">      bri_shift = getdigits_int(&amp;p, true, 0);</a>
<a name="ln7402">    }</a>
<a name="ln7403">    else if (STRNCMP(p, &quot;min:&quot;, 4) == 0 &amp;&amp; ascii_isdigit(p[4]))</a>
<a name="ln7404">    {</a>
<a name="ln7405">      p += 4;</a>
<a name="ln7406">      bri_min = getdigits_int(&amp;p, true, 0);</a>
<a name="ln7407">    }</a>
<a name="ln7408">    else if (STRNCMP(p, &quot;sbr&quot;, 3) == 0)</a>
<a name="ln7409">    {</a>
<a name="ln7410">      p += 3;</a>
<a name="ln7411">      bri_sbr = true;</a>
<a name="ln7412">    }</a>
<a name="ln7413">    if (*p != ',' &amp;&amp; *p != NUL) {</a>
<a name="ln7414">      return false;</a>
<a name="ln7415">    }</a>
<a name="ln7416">    if (*p == ',') {</a>
<a name="ln7417">      p++;</a>
<a name="ln7418">    }</a>
<a name="ln7419">  }</a>
<a name="ln7420"> </a>
<a name="ln7421">  wp-&gt;w_briopt_shift = bri_shift;</a>
<a name="ln7422">  wp-&gt;w_briopt_min = bri_min;</a>
<a name="ln7423">  wp-&gt;w_briopt_sbr = bri_sbr;</a>
<a name="ln7424"> </a>
<a name="ln7425">  return true;</a>
<a name="ln7426">}</a>
<a name="ln7427"> </a>
<a name="ln7428">/// Get the local or global value of 'backupcopy'.</a>
<a name="ln7429">///</a>
<a name="ln7430">/// @param buf The buffer.</a>
<a name="ln7431">unsigned int get_bkc_value(buf_T *buf)</a>
<a name="ln7432">{</a>
<a name="ln7433">  return buf-&gt;b_bkc_flags ? buf-&gt;b_bkc_flags : bkc_flags;</a>
<a name="ln7434">}</a>
<a name="ln7435"> </a>
<a name="ln7436">/// Return the current end-of-line type: EOL_DOS, EOL_UNIX or EOL_MAC.</a>
<a name="ln7437">int get_fileformat(const buf_T *buf)</a>
<a name="ln7438">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7439">{</a>
<a name="ln7440">  int c = *buf-&gt;b_p_ff;</a>
<a name="ln7441"> </a>
<a name="ln7442">  if (buf-&gt;b_p_bin || c == 'u') {</a>
<a name="ln7443">    return EOL_UNIX;</a>
<a name="ln7444">  }</a>
<a name="ln7445">  if (c == 'm') {</a>
<a name="ln7446">    return EOL_MAC;</a>
<a name="ln7447">  }</a>
<a name="ln7448">  return EOL_DOS;</a>
<a name="ln7449">}</a>
<a name="ln7450"> </a>
<a name="ln7451">/// Like get_fileformat(), but override 'fileformat' with &quot;p&quot; for &quot;++opt=val&quot;</a>
<a name="ln7452">/// argument.</a>
<a name="ln7453">///</a>
<a name="ln7454">/// @param eap  can be NULL!</a>
<a name="ln7455">int get_fileformat_force(const buf_T *buf, const exarg_T *eap)</a>
<a name="ln7456">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln7457">{</a>
<a name="ln7458">  int c;</a>
<a name="ln7459"> </a>
<a name="ln7460">  if (eap != NULL &amp;&amp; eap-&gt;force_ff != 0) {</a>
<a name="ln7461">    c = eap-&gt;force_ff;</a>
<a name="ln7462">  } else {</a>
<a name="ln7463">    if ((eap != NULL &amp;&amp; eap-&gt;force_bin != 0)</a>
<a name="ln7464">        ? (eap-&gt;force_bin == FORCE_BIN) : buf-&gt;b_p_bin) {</a>
<a name="ln7465">      return EOL_UNIX;</a>
<a name="ln7466">    }</a>
<a name="ln7467">    c = *buf-&gt;b_p_ff;</a>
<a name="ln7468">  }</a>
<a name="ln7469">  if (c == 'u') {</a>
<a name="ln7470">    return EOL_UNIX;</a>
<a name="ln7471">  }</a>
<a name="ln7472">  if (c == 'm') {</a>
<a name="ln7473">    return EOL_MAC;</a>
<a name="ln7474">  }</a>
<a name="ln7475">  return EOL_DOS;</a>
<a name="ln7476">}</a>
<a name="ln7477"> </a>
<a name="ln7478">/// Return the default fileformat from 'fileformats'.</a>
<a name="ln7479">int default_fileformat(void)</a>
<a name="ln7480">{</a>
<a name="ln7481">  switch (*p_ffs) {</a>
<a name="ln7482">  case 'm':   return EOL_MAC;</a>
<a name="ln7483">  case 'd':   return EOL_DOS;</a>
<a name="ln7484">  }</a>
<a name="ln7485">  return EOL_UNIX;</a>
<a name="ln7486">}</a>
<a name="ln7487"> </a>
<a name="ln7488">/// Set the current end-of-line type to EOL_UNIX, EOL_MAC, or EOL_DOS.</a>
<a name="ln7489">///</a>
<a name="ln7490">/// Sets 'fileformat'.</a>
<a name="ln7491">///</a>
<a name="ln7492">/// @param eol_style End-of-line style.</a>
<a name="ln7493">/// @param opt_flags OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln7494">void set_fileformat(int eol_style, int opt_flags)</a>
<a name="ln7495">{</a>
<a name="ln7496">  char *p = NULL;</a>
<a name="ln7497"> </a>
<a name="ln7498">  switch (eol_style) {</a>
<a name="ln7499">      case EOL_UNIX:</a>
<a name="ln7500">          p = FF_UNIX;</a>
<a name="ln7501">          break;</a>
<a name="ln7502">      case EOL_MAC:</a>
<a name="ln7503">          p = FF_MAC;</a>
<a name="ln7504">          break;</a>
<a name="ln7505">      case EOL_DOS:</a>
<a name="ln7506">          p = FF_DOS;</a>
<a name="ln7507">          break;</a>
<a name="ln7508">  }</a>
<a name="ln7509"> </a>
<a name="ln7510">  // p is NULL if &quot;eol_style&quot; is EOL_UNKNOWN.</a>
<a name="ln7511">  if (p != NULL) {</a>
<a name="ln7512">    set_string_option_direct(&quot;ff&quot;,</a>
<a name="ln7513">                             -1,</a>
<a name="ln7514">                             (char_u *)p,</a>
<a name="ln7515">                             OPT_FREE | opt_flags,</a>
<a name="ln7516">                             0);</a>
<a name="ln7517">  }</a>
<a name="ln7518"> </a>
<a name="ln7519">  // This may cause the buffer to become (un)modified.</a>
<a name="ln7520">  check_status(curbuf);</a>
<a name="ln7521">  redraw_tabline = true;</a>
<a name="ln7522">  need_maketitle = true;  // Set window title later.</a>
<a name="ln7523">}</a>
<a name="ln7524"> </a>
<a name="ln7525">/// Skip to next part of an option argument: skip space and comma</a>
<a name="ln7526">char_u *skip_to_option_part(const char_u *p)</a>
<a name="ln7527">{</a>
<a name="ln7528">  if (*p == ',') {</a>
<a name="ln7529">    p++;</a>
<a name="ln7530">  }</a>
<a name="ln7531">  while (*p == ' ') {</a>
<a name="ln7532">    p++;</a>
<a name="ln7533">  }</a>
<a name="ln7534">  return (char_u *)p;</a>
<a name="ln7535">}</a>
<a name="ln7536"> </a>
<a name="ln7537">/// Isolate one part of a string option separated by `sep_chars`.</a>
<a name="ln7538">///</a>
<a name="ln7539">/// @param[in,out]  option    advanced to the next part</a>
<a name="ln7540">/// @param[in,out]  buf       copy of the isolated part</a>
<a name="ln7541">/// @param[in]      maxlen    length of `buf`</a>
<a name="ln7542">/// @param[in]      sep_chars chars that separate the option parts</a>
<a name="ln7543">///</a>
<a name="ln7544">/// @return length of `*option`</a>
<a name="ln7545">size_t copy_option_part(char_u **option, char_u *buf, size_t maxlen,</a>
<a name="ln7546">                        char *sep_chars)</a>
<a name="ln7547">{</a>
<a name="ln7548">  size_t len = 0;</a>
<a name="ln7549">  char_u  *p = *option;</a>
<a name="ln7550"> </a>
<a name="ln7551">  // skip '.' at start of option part, for 'suffixes'</a>
<a name="ln7552">  if (*p == '.') {</a>
<a name="ln7553">    buf[len++] = *p++;</a>
<a name="ln7554">  }</a>
<a name="ln7555">  while (*p != NUL &amp;&amp; vim_strchr((char_u *)sep_chars, *p) == NULL) {</a>
<a name="ln7556">    // Skip backslash before a separator character and space.</a>
<a name="ln7557">    if (p[0] == '\\' &amp;&amp; vim_strchr((char_u *)sep_chars, p[1]) != NULL) {</a>
<a name="ln7558">      p++;</a>
<a name="ln7559">    }</a>
<a name="ln7560">    if (len &lt; maxlen - 1) {</a>
<a name="ln7561">      buf[len++] = *p;</a>
<a name="ln7562">    }</a>
<a name="ln7563">    p++;</a>
<a name="ln7564">  }</a>
<a name="ln7565">  buf[len] = NUL;</a>
<a name="ln7566"> </a>
<a name="ln7567">  if (*p != NUL &amp;&amp; *p != ',') {  // skip non-standard separator</a>
<a name="ln7568">    p++;</a>
<a name="ln7569">  }</a>
<a name="ln7570">  p = skip_to_option_part(p);    // p points to next file name</a>
<a name="ln7571"> </a>
<a name="ln7572">  *option = p;</a>
<a name="ln7573">  return len;</a>
<a name="ln7574">}</a>
<a name="ln7575"> </a>
<a name="ln7576">/// Return true when 'shell' has &quot;csh&quot; in the tail.</a>
<a name="ln7577">int csh_like_shell(void)</a>
<a name="ln7578">{</a>
<a name="ln7579">  return strstr((char *)path_tail(p_sh), &quot;csh&quot;) != NULL;</a>
<a name="ln7580">}</a>
<a name="ln7581"> </a>
<a name="ln7582">/// Return the number of requested sign columns, based on current</a>
<a name="ln7583">/// buffer signs and on user configuration.</a>
<a name="ln7584">int win_signcol_count(win_T *wp)</a>
<a name="ln7585">{</a>
<a name="ln7586">  return win_signcol_configured(wp, NULL);</a>
<a name="ln7587">}</a>
<a name="ln7588"> </a>
<a name="ln7589">/// Return the number of requested sign columns, based on user / configuration.</a>
<a name="ln7590">int win_signcol_configured(win_T *wp, int *is_fixed)</a>
<a name="ln7591">{</a>
<a name="ln7592">  int minimum = 0, maximum = 1, needed_signcols;</a>
<a name="ln7593">  const char *scl = (const char *)wp-&gt;w_p_scl;</a>
<a name="ln7594"> </a>
<a name="ln7595">  if (is_fixed) {</a>
<a name="ln7596">    *is_fixed = 1;</a>
<a name="ln7597">  }</a>
<a name="ln7598"> </a>
<a name="ln7599">  // Note: It checks &quot;no&quot; or &quot;number&quot; in 'signcolumn' option</a>
<a name="ln7600">  if (*scl == 'n'</a>
<a name="ln7601">      &amp;&amp; (*(scl + 1) == 'o' || (*(scl + 1) == 'u'</a>
<a name="ln7602">                                &amp;&amp; (wp-&gt;w_p_nu || wp-&gt;w_p_rnu)))) {</a>
<a name="ln7603">    return 0;</a>
<a name="ln7604">  }</a>
<a name="ln7605">  needed_signcols = buf_signcols(wp-&gt;w_buffer);</a>
<a name="ln7606"> </a>
<a name="ln7607">  // yes or yes</a>
<a name="ln7608">  if (!strncmp(scl, &quot;yes:&quot;, 4)) {</a>
<a name="ln7609">    // Fixed amount of columns</a>
<a name="ln7610">    return scl[4] - '0';</a>
<a name="ln7611">  }</a>
<a name="ln7612">  if (*scl == 'y') {</a>
<a name="ln7613">    return 1;</a>
<a name="ln7614">  }</a>
<a name="ln7615"> </a>
<a name="ln7616">  if (is_fixed) {</a>
<a name="ln7617">    // auto or auto:&lt;NUM&gt;</a>
<a name="ln7618">    *is_fixed = 0;</a>
<a name="ln7619">  }</a>
<a name="ln7620"> </a>
<a name="ln7621">  if (!strncmp(scl, &quot;auto:&quot;, 5)) {</a>
<a name="ln7622">    // Variable depending on a configuration</a>
<a name="ln7623">    maximum = scl[5] - '0';</a>
<a name="ln7624">    // auto:&lt;NUM&gt;-&lt;NUM&gt;</a>
<a name="ln7625">    if (strlen(scl) == 8 &amp;&amp; *(scl + 6) == '-') {</a>
<a name="ln7626">      minimum = maximum;</a>
<a name="ln7627">      maximum = scl[7] - '0';</a>
<a name="ln7628">    }</a>
<a name="ln7629">  }</a>
<a name="ln7630"> </a>
<a name="ln7631">  int ret = MAX(minimum, MIN(maximum, needed_signcols));</a>
<a name="ln7632">  assert(ret &lt;= SIGN_SHOW_MAX);</a>
<a name="ln7633">  return ret;</a>
<a name="ln7634">}</a>
<a name="ln7635"> </a>
<a name="ln7636">/// Get window or buffer local options</a>
<a name="ln7637">dict_T *get_winbuf_options(const int bufopt)</a>
<a name="ln7638">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7639">{</a>
<a name="ln7640">  dict_T *const d = tv_dict_alloc();</a>
<a name="ln7641"> </a>
<a name="ln7642">  for (int opt_idx = 0; options[opt_idx].fullname; opt_idx++) {</a>
<a name="ln7643">    struct vimoption *opt = &amp;options[opt_idx];</a>
<a name="ln7644"> </a>
<a name="ln7645">    if ((bufopt &amp;&amp; (opt-&gt;indir &amp; PV_BUF))</a>
<a name="ln7646">        || (!bufopt &amp;&amp; (opt-&gt;indir &amp; PV_WIN))) {</a>
<a name="ln7647">      char_u *varp = get_varp(opt);</a>
<a name="ln7648"> </a>
<a name="ln7649">      if (varp != NULL) {</a>
<a name="ln7650">        if (opt-&gt;flags &amp; P_STRING) {</a>
<a name="ln7651">          tv_dict_add_str(d, opt-&gt;fullname, strlen(opt-&gt;fullname),</a>
<a name="ln7652">                          *(const char **)varp);</a>
<a name="ln7653">        } else if (opt-&gt;flags &amp; P_NUM) {</a>
<a name="ln7654">          tv_dict_add_nr(d, opt-&gt;fullname, strlen(opt-&gt;fullname),</a>
<a name="ln7655">                         *(long *)varp);</a>
<a name="ln7656">        } else {</a>
<a name="ln7657">          tv_dict_add_nr(d, opt-&gt;fullname, strlen(opt-&gt;fullname), *(int *)varp);</a>
<a name="ln7658">        }</a>
<a name="ln7659">      }</a>
<a name="ln7660">    }</a>
<a name="ln7661">  }</a>
<a name="ln7662"> </a>
<a name="ln7663">  return d;</a>
<a name="ln7664">}</a>
<a name="ln7665"> </a>
<a name="ln7666">/// Return the effective 'scrolloff' value for the current window, using the</a>
<a name="ln7667">/// global value when appropriate.</a>
<a name="ln7668">long get_scrolloff_value(win_T *wp)</a>
<a name="ln7669">{</a>
<a name="ln7670">  // Disallow scrolloff in terminal-mode. #11915</a>
<a name="ln7671">  if (State &amp; TERM_FOCUS) {</a>
<a name="ln7672">    return 0;</a>
<a name="ln7673">  }</a>
<a name="ln7674">  return wp-&gt;w_p_so &lt; 0 ? p_so : wp-&gt;w_p_so;</a>
<a name="ln7675">}</a>
<a name="ln7676"> </a>
<a name="ln7677">/// Return the effective 'sidescrolloff' value for the current window, using the</a>
<a name="ln7678">/// global value when appropriate.</a>
<a name="ln7679">long get_sidescrolloff_value(win_T *wp)</a>
<a name="ln7680">{</a>
<a name="ln7681">  return wp-&gt;w_p_siso &lt; 0 ? p_siso : wp-&gt;w_p_siso;</a>
<a name="ln7682">}</a>
<a name="ln7683"> </a>
<a name="ln7684">Dictionary get_vimoption(String name, Error *err)</a>
<a name="ln7685">{</a>
<a name="ln7686">  int opt_idx = findoption_len((const char *)name.data, name.size);</a>
<a name="ln7687">  if (opt_idx &lt; 0) {</a>
<a name="ln7688">    api_set_error(err, kErrorTypeValidation, &quot;no such option: '%s'&quot;, name.data);</a>
<a name="ln7689">    return (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln7690">  }</a>
<a name="ln7691">  return vimoption2dict(&amp;options[opt_idx]);</a>
<a name="ln7692">}</a>
<a name="ln7693"> </a>
<a name="ln7694">Dictionary get_all_vimoptions(void)</a>
<a name="ln7695">{</a>
<a name="ln7696">  Dictionary retval = ARRAY_DICT_INIT;</a>
<a name="ln7697">  for (size_t i = 0; i &lt; PARAM_COUNT; i++) {</a>
<a name="ln7698">    Dictionary opt_dict = vimoption2dict(&amp;options[i]);</a>
<a name="ln7699">    PUT(retval, options[i].fullname, DICTIONARY_OBJ(opt_dict));</a>
<a name="ln7700">  }</a>
<a name="ln7701">  return retval;</a>
<a name="ln7702">}</a>
<a name="ln7703"> </a>
<a name="ln7704">static Dictionary vimoption2dict(vimoption_T *opt)</a>
<a name="ln7705">{</a>
<a name="ln7706">    Dictionary dict = ARRAY_DICT_INIT;</a>
<a name="ln7707"> </a>
<a name="ln7708">    PUT(dict, &quot;name&quot;, CSTR_TO_OBJ(opt-&gt;fullname));</a>
<a name="ln7709">    PUT(dict, &quot;shortname&quot;, CSTR_TO_OBJ(opt-&gt;shortname));</a>
<a name="ln7710"> </a>
<a name="ln7711">    const char *scope;</a>
<a name="ln7712">    if (opt-&gt;indir &amp; PV_BUF) {</a>
<a name="ln7713">      scope = &quot;buf&quot;;</a>
<a name="ln7714">    } else if (opt-&gt;indir &amp; PV_WIN) {</a>
<a name="ln7715">      scope = &quot;win&quot;;</a>
<a name="ln7716">    } else {</a>
<a name="ln7717">      scope = &quot;global&quot;;</a>
<a name="ln7718">    }</a>
<a name="ln7719"> </a>
<a name="ln7720">    PUT(dict, &quot;scope&quot;, CSTR_TO_OBJ(scope));</a>
<a name="ln7721"> </a>
<a name="ln7722">    // welcome to the jungle</a>
<a name="ln7723">    PUT(dict, &quot;global_local&quot;, BOOL(opt-&gt;indir &amp; PV_BOTH));</a>
<a name="ln7724">    PUT(dict, &quot;commalist&quot;, BOOL(opt-&gt;flags &amp; P_COMMA));</a>
<a name="ln7725">    PUT(dict, &quot;flaglist&quot;, BOOL(opt-&gt;flags &amp; P_FLAGLIST));</a>
<a name="ln7726"> </a>
<a name="ln7727">    PUT(dict, &quot;was_set&quot;, BOOL(opt-&gt;flags &amp; P_WAS_SET));</a>
<a name="ln7728"> </a>
<a name="ln7729">    PUT(dict, &quot;last_set_sid&quot;, INTEGER_OBJ(opt-&gt;last_set.script_ctx.sc_sid));</a>
<a name="ln7730">    PUT(dict, &quot;last_set_linenr&quot;, INTEGER_OBJ(opt-&gt;last_set.script_ctx.sc_lnum));</a>
<a name="ln7731">    PUT(dict, &quot;last_set_chan&quot;, INTEGER_OBJ((int64_t)opt-&gt;last_set.channel_id));</a>
<a name="ln7732"> </a>
<a name="ln7733">    const char *type;</a>
<a name="ln7734">    Object def;</a>
<a name="ln7735">    // TODO(bfredl): do you even nocp?</a>
<a name="ln7736">    char_u *def_val = opt-&gt;def_val[(opt-&gt;flags &amp; P_VI_DEF)</a>
<a name="ln7737">                                   ? VI_DEFAULT : VIM_DEFAULT];</a>
<a name="ln7738">    if (opt-&gt;flags &amp; P_STRING) {</a>
<a name="ln7739">      type = &quot;string&quot;;</a>
<a name="ln7740">      def = CSTR_TO_OBJ(def_val ? (char *)def_val : &quot;&quot;);</a>
<a name="ln7741">    } else if (opt-&gt;flags &amp; P_NUM) {</a>
<a name="ln7742">      type = &quot;number&quot;;</a>
<a name="ln7743">      def = INTEGER_OBJ((Integer)(intptr_t)def_val);</a>
<a name="ln7744">    } else if (opt-&gt;flags &amp; P_BOOL) {</a>
<a name="ln7745">      type = &quot;boolean&quot;;</a>
<a name="ln7746">      def = BOOL((intptr_t)def_val);</a>
<a name="ln7747">    } else {</a>
<a name="ln7748">      type = &quot;&quot;; def = NIL;</a>
<a name="ln7749">    }</a>
<a name="ln7750">    PUT(dict, &quot;type&quot;, CSTR_TO_OBJ(type));</a>
<a name="ln7751">    PUT(dict, &quot;default&quot;, def);</a>
<a name="ln7752"> </a>
<a name="ln7753">    return dict;</a>
<a name="ln7754">}</a>

</code></pre>
<div class="balloon" rel="4077"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="4079"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="4081"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="4478"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="4479"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="4480"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="4515"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
