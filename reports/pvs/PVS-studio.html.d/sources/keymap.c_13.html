
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>keymap.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;assert.h&gt;</a>
<a name="ln5">#include &lt;inttypes.h&gt;</a>
<a name="ln6">#include &lt;limits.h&gt;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;nvim/vim.h&quot;</a>
<a name="ln9">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln10">#include &quot;nvim/keymap.h&quot;</a>
<a name="ln11">#include &quot;nvim/charset.h&quot;</a>
<a name="ln12">#include &quot;nvim/memory.h&quot;</a>
<a name="ln13">#include &quot;nvim/edit.h&quot;</a>
<a name="ln14">#include &quot;nvim/eval.h&quot;</a>
<a name="ln15">#include &quot;nvim/message.h&quot;</a>
<a name="ln16">#include &quot;nvim/strings.h&quot;</a>
<a name="ln17">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln18"> </a>
<a name="ln19">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln20"># include &quot;keymap.c.generated.h&quot;</a>
<a name="ln21">#endif</a>
<a name="ln22"> </a>
<a name="ln23">/*</a>
<a name="ln24"> * Some useful tables.</a>
<a name="ln25"> */</a>
<a name="ln26"> </a>
<a name="ln27">static const struct modmasktable {</a>
<a name="ln28">  uint16_t mod_mask;  ///&lt; Bit-mask for particular key modifier.</a>
<a name="ln29">  uint16_t mod_flag;  ///&lt; Bit(s) for particular key modifier.</a>
<a name="ln30">  char_u name;  ///&lt; Single letter name of modifier.</a>
<a name="ln31">} mod_mask_table[] = {</a>
<a name="ln32">  { MOD_MASK_ALT,              MOD_MASK_ALT,           (char_u)'M' },</a>
<a name="ln33">  { MOD_MASK_META,             MOD_MASK_META,          (char_u)'T' },</a>
<a name="ln34">  { MOD_MASK_CTRL,             MOD_MASK_CTRL,          (char_u)'C' },</a>
<a name="ln35">  { MOD_MASK_SHIFT,            MOD_MASK_SHIFT,         (char_u)'S' },</a>
<a name="ln36">  { MOD_MASK_MULTI_CLICK,      MOD_MASK_2CLICK,        (char_u)'2' },</a>
<a name="ln37">  { MOD_MASK_MULTI_CLICK,      MOD_MASK_3CLICK,        (char_u)'3' },</a>
<a name="ln38">  { MOD_MASK_MULTI_CLICK,      MOD_MASK_4CLICK,        (char_u)'4' },</a>
<a name="ln39">  { MOD_MASK_CMD,              MOD_MASK_CMD,           (char_u)'D' },</a>
<a name="ln40">  // 'A' must be the last one</a>
<a name="ln41">  { MOD_MASK_ALT,              MOD_MASK_ALT,           (char_u)'A' },</a>
<a name="ln42">  { 0, 0, NUL }</a>
<a name="ln43">  // NOTE: when adding an entry, update MAX_KEY_NAME_LEN!</a>
<a name="ln44">};</a>
<a name="ln45"> </a>
<a name="ln46">/*</a>
<a name="ln47"> * Shifted key terminal codes and their unshifted equivalent.</a>
<a name="ln48"> * Don't add mouse codes here, they are handled separately!</a>
<a name="ln49"> */</a>
<a name="ln50">#define MOD_KEYS_ENTRY_SIZE 5</a>
<a name="ln51"> </a>
<a name="ln52">static char_u modifier_keys_table[] =</a>
<a name="ln53">{</a>
<a name="ln54">  /*  mod mask	    with modifier		without modifier */</a>
<a name="ln55">  MOD_MASK_SHIFT, '&amp;', '9',                   '@', '1',         /* begin */</a>
<a name="ln56">  MOD_MASK_SHIFT, '&amp;', '0',                   '@', '2',         /* cancel */</a>
<a name="ln57">  MOD_MASK_SHIFT, '*', '1',                   '@', '4',         /* command */</a>
<a name="ln58">  MOD_MASK_SHIFT, '*', '2',                   '@', '5',         /* copy */</a>
<a name="ln59">  MOD_MASK_SHIFT, '*', '3',                   '@', '6',         /* create */</a>
<a name="ln60">  MOD_MASK_SHIFT, '*', '4',                   'k', 'D',         /* delete char */</a>
<a name="ln61">  MOD_MASK_SHIFT, '*', '5',                   'k', 'L',         /* delete line */</a>
<a name="ln62">  MOD_MASK_SHIFT, '*', '7',                   '@', '7',         /* end */</a>
<a name="ln63">  MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_END,    '@', '7',         /* end */</a>
<a name="ln64">  MOD_MASK_SHIFT, '*', '9',                   '@', '9',         /* exit */</a>
<a name="ln65">  MOD_MASK_SHIFT, '*', '0',                   '@', '0',         /* find */</a>
<a name="ln66">  MOD_MASK_SHIFT, '#', '1',                   '%', '1',         /* help */</a>
<a name="ln67">  MOD_MASK_SHIFT, '#', '2',                   'k', 'h',         /* home */</a>
<a name="ln68">  MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_HOME,   'k', 'h',         /* home */</a>
<a name="ln69">  MOD_MASK_SHIFT, '#', '3',                   'k', 'I',         /* insert */</a>
<a name="ln70">  MOD_MASK_SHIFT, '#', '4',                   'k', 'l',         /* left arrow */</a>
<a name="ln71">  MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_LEFT,   'k', 'l',         /* left arrow */</a>
<a name="ln72">  MOD_MASK_SHIFT, '%', 'a',                   '%', '3',         /* message */</a>
<a name="ln73">  MOD_MASK_SHIFT, '%', 'b',                   '%', '4',         /* move */</a>
<a name="ln74">  MOD_MASK_SHIFT, '%', 'c',                   '%', '5',         /* next */</a>
<a name="ln75">  MOD_MASK_SHIFT, '%', 'd',                   '%', '7',         /* options */</a>
<a name="ln76">  MOD_MASK_SHIFT, '%', 'e',                   '%', '8',         /* previous */</a>
<a name="ln77">  MOD_MASK_SHIFT, '%', 'f',                   '%', '9',         /* print */</a>
<a name="ln78">  MOD_MASK_SHIFT, '%', 'g',                   '%', '0',         /* redo */</a>
<a name="ln79">  MOD_MASK_SHIFT, '%', 'h',                   '&amp;', '3',         /* replace */</a>
<a name="ln80">  MOD_MASK_SHIFT, '%', 'i',                   'k', 'r',         /* right arr. */</a>
<a name="ln81">  MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_RIGHT,  'k', 'r',         /* right arr. */</a>
<a name="ln82">  MOD_MASK_SHIFT, '%', 'j',                   '&amp;', '5',         /* resume */</a>
<a name="ln83">  MOD_MASK_SHIFT, '!', '1',                   '&amp;', '6',         /* save */</a>
<a name="ln84">  MOD_MASK_SHIFT, '!', '2',                   '&amp;', '7',         /* suspend */</a>
<a name="ln85">  MOD_MASK_SHIFT, '!', '3',                   '&amp;', '8',         /* undo */</a>
<a name="ln86">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_UP,     'k', 'u',         /* up arrow */</a>
<a name="ln87">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_DOWN,   'k', 'd',         /* down arrow */</a>
<a name="ln88"> </a>
<a name="ln89">  /* vt100 F1 */</a>
<a name="ln90">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF1,    KS_EXTRA, (int)KE_XF1,</a>
<a name="ln91">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF2,    KS_EXTRA, (int)KE_XF2,</a>
<a name="ln92">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF3,    KS_EXTRA, (int)KE_XF3,</a>
<a name="ln93">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF4,    KS_EXTRA, (int)KE_XF4,</a>
<a name="ln94"> </a>
<a name="ln95">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F1,     'k', '1',         /* F1 */</a>
<a name="ln96">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F2,     'k', '2',</a>
<a name="ln97">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F3,     'k', '3',</a>
<a name="ln98">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F4,     'k', '4',</a>
<a name="ln99">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F5,     'k', '5',</a>
<a name="ln100">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F6,     'k', '6',</a>
<a name="ln101">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F7,     'k', '7',</a>
<a name="ln102">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F8,     'k', '8',</a>
<a name="ln103">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F9,     'k', '9',</a>
<a name="ln104">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F10,    'k', ';',         /* F10 */</a>
<a name="ln105"> </a>
<a name="ln106">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F11,    'F', '1',</a>
<a name="ln107">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F12,    'F', '2',</a>
<a name="ln108">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F13,    'F', '3',</a>
<a name="ln109">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F14,    'F', '4',</a>
<a name="ln110">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F15,    'F', '5',</a>
<a name="ln111">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F16,    'F', '6',</a>
<a name="ln112">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F17,    'F', '7',</a>
<a name="ln113">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F18,    'F', '8',</a>
<a name="ln114">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F19,    'F', '9',</a>
<a name="ln115">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F20,    'F', 'A',</a>
<a name="ln116"> </a>
<a name="ln117">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F21,    'F', 'B',</a>
<a name="ln118">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F22,    'F', 'C',</a>
<a name="ln119">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F23,    'F', 'D',</a>
<a name="ln120">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F24,    'F', 'E',</a>
<a name="ln121">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F25,    'F', 'F',</a>
<a name="ln122">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F26,    'F', 'G',</a>
<a name="ln123">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F27,    'F', 'H',</a>
<a name="ln124">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F28,    'F', 'I',</a>
<a name="ln125">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F29,    'F', 'J',</a>
<a name="ln126">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F30,    'F', 'K',</a>
<a name="ln127"> </a>
<a name="ln128">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F31,    'F', 'L',</a>
<a name="ln129">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F32,    'F', 'M',</a>
<a name="ln130">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F33,    'F', 'N',</a>
<a name="ln131">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F34,    'F', 'O',</a>
<a name="ln132">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F35,    'F', 'P',</a>
<a name="ln133">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F36,    'F', 'Q',</a>
<a name="ln134">  MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F37,    'F', 'R',</a>
<a name="ln135"> </a>
<a name="ln136">  /* TAB pseudo code*/</a>
<a name="ln137">  MOD_MASK_SHIFT, 'k', 'B',                   KS_EXTRA, (int)KE_TAB,</a>
<a name="ln138"> </a>
<a name="ln139">  NUL</a>
<a name="ln140">};</a>
<a name="ln141"> </a>
<a name="ln142">static const struct key_name_entry {</a>
<a name="ln143">  int key;              // Special key code or ascii value</a>
<a name="ln144">  const char *name;           // Name of key</a>
<a name="ln145">} key_names_table[] = {</a>
<a name="ln146">  { ' ',               &quot;Space&quot; },</a>
<a name="ln147">  { TAB,               &quot;Tab&quot; },</a>
<a name="ln148">  { K_TAB,             &quot;Tab&quot; },</a>
<a name="ln149">  { NL,                &quot;NL&quot; },</a>
<a name="ln150">  { NL,                &quot;NewLine&quot; },     // Alternative name</a>
<a name="ln151">  { NL,                &quot;LineFeed&quot; },    // Alternative name</a>
<a name="ln152">  { NL,                &quot;LF&quot; },          // Alternative name</a>
<a name="ln153">  { CAR,               &quot;CR&quot; },</a>
<a name="ln154">  { CAR,               &quot;Return&quot; },      // Alternative name</a>
<a name="ln155">  { CAR,               &quot;Enter&quot; },       // Alternative name</a>
<a name="ln156">  { K_BS,              &quot;BS&quot; },</a>
<a name="ln157">  { K_BS,              &quot;BackSpace&quot; },   // Alternative name</a>
<a name="ln158">  { ESC,               &quot;Esc&quot; },</a>
<a name="ln159">  { ESC,               &quot;Escape&quot; },      // Alternative name</a>
<a name="ln160">  { CSI,               &quot;CSI&quot; },</a>
<a name="ln161">  { K_CSI,             &quot;xCSI&quot; },</a>
<a name="ln162">  { '|',               &quot;Bar&quot; },</a>
<a name="ln163">  { '\\',              &quot;Bslash&quot; },</a>
<a name="ln164">  { K_DEL,             &quot;Del&quot; },</a>
<a name="ln165">  { K_DEL,             &quot;Delete&quot; },      // Alternative name</a>
<a name="ln166">  { K_KDEL,            &quot;kDel&quot; },</a>
<a name="ln167">  { K_KDEL,            &quot;KPPeriod&quot; },    // libtermkey name</a>
<a name="ln168">  { K_UP,              &quot;Up&quot; },</a>
<a name="ln169">  { K_DOWN,            &quot;Down&quot; },</a>
<a name="ln170">  { K_LEFT,            &quot;Left&quot; },</a>
<a name="ln171">  { K_RIGHT,           &quot;Right&quot; },</a>
<a name="ln172">  { K_XUP,             &quot;xUp&quot; },</a>
<a name="ln173">  { K_XDOWN,           &quot;xDown&quot; },</a>
<a name="ln174">  { K_XLEFT,           &quot;xLeft&quot; },</a>
<a name="ln175">  { K_XRIGHT,          &quot;xRight&quot; },</a>
<a name="ln176">  { K_KUP,             &quot;kUp&quot; },</a>
<a name="ln177">  { K_KUP,             &quot;KP8&quot; },</a>
<a name="ln178">  { K_KDOWN,           &quot;kDown&quot; },</a>
<a name="ln179">  { K_KDOWN,           &quot;KP2&quot; },</a>
<a name="ln180">  { K_KLEFT,           &quot;kLeft&quot; },</a>
<a name="ln181">  { K_KLEFT,           &quot;KP4&quot; },</a>
<a name="ln182">  { K_KRIGHT,          &quot;kRight&quot; },</a>
<a name="ln183">  { K_KRIGHT,          &quot;KP6&quot; },</a>
<a name="ln184"> </a>
<a name="ln185">  { K_F1,              &quot;F1&quot; },</a>
<a name="ln186">  { K_F2,              &quot;F2&quot; },</a>
<a name="ln187">  { K_F3,              &quot;F3&quot; },</a>
<a name="ln188">  { K_F4,              &quot;F4&quot; },</a>
<a name="ln189">  { K_F5,              &quot;F5&quot; },</a>
<a name="ln190">  { K_F6,              &quot;F6&quot; },</a>
<a name="ln191">  { K_F7,              &quot;F7&quot; },</a>
<a name="ln192">  { K_F8,              &quot;F8&quot; },</a>
<a name="ln193">  { K_F9,              &quot;F9&quot; },</a>
<a name="ln194">  { K_F10,             &quot;F10&quot; },</a>
<a name="ln195"> </a>
<a name="ln196">  { K_F11,             &quot;F11&quot; },</a>
<a name="ln197">  { K_F12,             &quot;F12&quot; },</a>
<a name="ln198">  { K_F13,             &quot;F13&quot; },</a>
<a name="ln199">  { K_F14,             &quot;F14&quot; },</a>
<a name="ln200">  { K_F15,             &quot;F15&quot; },</a>
<a name="ln201">  { K_F16,             &quot;F16&quot; },</a>
<a name="ln202">  { K_F17,             &quot;F17&quot; },</a>
<a name="ln203">  { K_F18,             &quot;F18&quot; },</a>
<a name="ln204">  { K_F19,             &quot;F19&quot; },</a>
<a name="ln205">  { K_F20,             &quot;F20&quot; },</a>
<a name="ln206"> </a>
<a name="ln207">  { K_F21,             &quot;F21&quot; },</a>
<a name="ln208">  { K_F22,             &quot;F22&quot; },</a>
<a name="ln209">  { K_F23,             &quot;F23&quot; },</a>
<a name="ln210">  { K_F24,             &quot;F24&quot; },</a>
<a name="ln211">  { K_F25,             &quot;F25&quot; },</a>
<a name="ln212">  { K_F26,             &quot;F26&quot; },</a>
<a name="ln213">  { K_F27,             &quot;F27&quot; },</a>
<a name="ln214">  { K_F28,             &quot;F28&quot; },</a>
<a name="ln215">  { K_F29,             &quot;F29&quot; },</a>
<a name="ln216">  { K_F30,             &quot;F30&quot; },</a>
<a name="ln217"> </a>
<a name="ln218">  { K_F31,             &quot;F31&quot; },</a>
<a name="ln219">  { K_F32,             &quot;F32&quot; },</a>
<a name="ln220">  { K_F33,             &quot;F33&quot; },</a>
<a name="ln221">  { K_F34,             &quot;F34&quot; },</a>
<a name="ln222">  { K_F35,             &quot;F35&quot; },</a>
<a name="ln223">  { K_F36,             &quot;F36&quot; },</a>
<a name="ln224">  { K_F37,             &quot;F37&quot; },</a>
<a name="ln225"> </a>
<a name="ln226">  { K_XF1,             &quot;xF1&quot; },</a>
<a name="ln227">  { K_XF2,             &quot;xF2&quot; },</a>
<a name="ln228">  { K_XF3,             &quot;xF3&quot; },</a>
<a name="ln229">  { K_XF4,             &quot;xF4&quot; },</a>
<a name="ln230"> </a>
<a name="ln231">  { K_HELP,            &quot;Help&quot; },</a>
<a name="ln232">  { K_UNDO,            &quot;Undo&quot; },</a>
<a name="ln233">  { K_INS,             &quot;Insert&quot; },</a>
<a name="ln234">  { K_INS,             &quot;Ins&quot; },         // Alternative name</a>
<a name="ln235">  { K_KINS,            &quot;kInsert&quot; },</a>
<a name="ln236">  { K_KINS,            &quot;KP0&quot; },</a>
<a name="ln237">  { K_HOME,            &quot;Home&quot; },</a>
<a name="ln238">  { K_KHOME,           &quot;kHome&quot; },</a>
<a name="ln239">  { K_KHOME,           &quot;KP7&quot; },</a>
<a name="ln240">  { K_XHOME,           &quot;xHome&quot; },</a>
<a name="ln241">  { K_ZHOME,           &quot;zHome&quot; },</a>
<a name="ln242">  { K_END,             &quot;End&quot; },</a>
<a name="ln243">  { K_KEND,            &quot;kEnd&quot; },</a>
<a name="ln244">  { K_KEND,            &quot;KP1&quot; },</a>
<a name="ln245">  { K_XEND,            &quot;xEnd&quot; },</a>
<a name="ln246">  { K_ZEND,            &quot;zEnd&quot; },</a>
<a name="ln247">  { K_PAGEUP,          &quot;PageUp&quot; },</a>
<a name="ln248">  { K_PAGEDOWN,        &quot;PageDown&quot; },</a>
<a name="ln249">  { K_KPAGEUP,         &quot;kPageUp&quot; },</a>
<a name="ln250">  { K_KPAGEUP,         &quot;KP9&quot; },</a>
<a name="ln251">  { K_KPAGEDOWN,       &quot;kPageDown&quot; },</a>
<a name="ln252">  { K_KPAGEDOWN,       &quot;KP3&quot; },</a>
<a name="ln253">  { K_KORIGIN,         &quot;kOrigin&quot; },</a>
<a name="ln254">  { K_KORIGIN,         &quot;KP5&quot; },</a>
<a name="ln255"> </a>
<a name="ln256">  { K_KPLUS,           &quot;kPlus&quot; },</a>
<a name="ln257">  { K_KPLUS,           &quot;KPPlus&quot; },</a>
<a name="ln258">  { K_KMINUS,          &quot;kMinus&quot; },</a>
<a name="ln259">  { K_KMINUS,          &quot;KPMinus&quot; },</a>
<a name="ln260">  { K_KDIVIDE,         &quot;kDivide&quot; },</a>
<a name="ln261">  { K_KDIVIDE,         &quot;KPDiv&quot; },</a>
<a name="ln262">  { K_KMULTIPLY,       &quot;kMultiply&quot; },</a>
<a name="ln263">  { K_KMULTIPLY,       &quot;KPMult&quot; },</a>
<a name="ln264">  { K_KENTER,          &quot;kEnter&quot; },</a>
<a name="ln265">  { K_KENTER,          &quot;KPEnter&quot; },</a>
<a name="ln266">  { K_KPOINT,          &quot;kPoint&quot; },</a>
<a name="ln267">  { K_KCOMMA,          &quot;kComma&quot; },</a>
<a name="ln268">  { K_KCOMMA,          &quot;KPComma&quot; },</a>
<a name="ln269">  { K_KEQUAL,          &quot;kEqual&quot; },</a>
<a name="ln270">  { K_KEQUAL,          &quot;KPEquals&quot; },</a>
<a name="ln271"> </a>
<a name="ln272">  { K_K0,              &quot;k0&quot; },</a>
<a name="ln273">  { K_K1,              &quot;k1&quot; },</a>
<a name="ln274">  { K_K2,              &quot;k2&quot; },</a>
<a name="ln275">  { K_K3,              &quot;k3&quot; },</a>
<a name="ln276">  { K_K4,              &quot;k4&quot; },</a>
<a name="ln277">  { K_K5,              &quot;k5&quot; },</a>
<a name="ln278">  { K_K6,              &quot;k6&quot; },</a>
<a name="ln279">  { K_K7,              &quot;k7&quot; },</a>
<a name="ln280">  { K_K8,              &quot;k8&quot; },</a>
<a name="ln281">  { K_K9,              &quot;k9&quot; },</a>
<a name="ln282"> </a>
<a name="ln283">  { '&lt;',               &quot;lt&quot; },</a>
<a name="ln284"> </a>
<a name="ln285">  { K_MOUSE,           &quot;Mouse&quot; },</a>
<a name="ln286">  { K_LEFTMOUSE,       &quot;LeftMouse&quot; },</a>
<a name="ln287">  { K_LEFTMOUSE_NM,    &quot;LeftMouseNM&quot; },</a>
<a name="ln288">  { K_LEFTDRAG,        &quot;LeftDrag&quot; },</a>
<a name="ln289">  { K_LEFTRELEASE,     &quot;LeftRelease&quot; },</a>
<a name="ln290">  { K_LEFTRELEASE_NM,  &quot;LeftReleaseNM&quot; },</a>
<a name="ln291">  { K_MIDDLEMOUSE,     &quot;MiddleMouse&quot; },</a>
<a name="ln292">  { K_MIDDLEDRAG,      &quot;MiddleDrag&quot; },</a>
<a name="ln293">  { K_MIDDLERELEASE,   &quot;MiddleRelease&quot; },</a>
<a name="ln294">  { K_RIGHTMOUSE,      &quot;RightMouse&quot; },</a>
<a name="ln295">  { K_RIGHTDRAG,       &quot;RightDrag&quot; },</a>
<a name="ln296">  { K_RIGHTRELEASE,    &quot;RightRelease&quot; },</a>
<a name="ln297">  { K_MOUSEDOWN,       &quot;ScrollWheelUp&quot; },</a>
<a name="ln298">  { K_MOUSEUP,         &quot;ScrollWheelDown&quot; },</a>
<a name="ln299">  { K_MOUSELEFT,       &quot;ScrollWheelRight&quot; },</a>
<a name="ln300">  { K_MOUSERIGHT,      &quot;ScrollWheelLeft&quot; },</a>
<a name="ln301">  { K_MOUSEDOWN,       &quot;MouseDown&quot; },   // OBSOLETE: Use</a>
<a name="ln302">  { K_MOUSEUP,         &quot;MouseUp&quot; },     // ScrollWheelXXX instead</a>
<a name="ln303">  { K_X1MOUSE,         &quot;X1Mouse&quot; },</a>
<a name="ln304">  { K_X1DRAG,          &quot;X1Drag&quot; },</a>
<a name="ln305">  { K_X1RELEASE,       &quot;X1Release&quot; },</a>
<a name="ln306">  { K_X2MOUSE,         &quot;X2Mouse&quot; },</a>
<a name="ln307">  { K_X2DRAG,          &quot;X2Drag&quot; },</a>
<a name="ln308">  { K_X2RELEASE,       &quot;X2Release&quot; },</a>
<a name="ln309">  { K_DROP,            &quot;Drop&quot; },</a>
<a name="ln310">  { K_ZERO,            &quot;Nul&quot; },</a>
<a name="ln311">  { K_SNR,             &quot;SNR&quot; },</a>
<a name="ln312">  { K_PLUG,            &quot;Plug&quot; },</a>
<a name="ln313">  { K_IGNORE,          &quot;Ignore&quot; },</a>
<a name="ln314">  { K_COMMAND,         &quot;Cmd&quot; },</a>
<a name="ln315">  { 0,                 NULL }</a>
<a name="ln316">  // NOTE: When adding a long name update MAX_KEY_NAME_LEN.</a>
<a name="ln317">};</a>
<a name="ln318"> </a>
<a name="ln319">static struct mousetable {</a>
<a name="ln320">  int pseudo_code;              /* Code for pseudo mouse event */</a>
<a name="ln321">  int button;                   /* Which mouse button is it? */</a>
<a name="ln322">  int is_click;                 /* Is it a mouse button click event? */</a>
<a name="ln323">  int is_drag;                  /* Is it a mouse drag event? */</a>
<a name="ln324">} mouse_table[] =</a>
<a name="ln325">{</a>
<a name="ln326">  {(int)KE_LEFTMOUSE,         MOUSE_LEFT,     TRUE,   FALSE},</a>
<a name="ln327">  {(int)KE_LEFTDRAG,          MOUSE_LEFT,     FALSE,  TRUE},</a>
<a name="ln328">  {(int)KE_LEFTRELEASE,       MOUSE_LEFT,     FALSE,  FALSE},</a>
<a name="ln329">  {(int)KE_MIDDLEMOUSE,       MOUSE_MIDDLE,   TRUE,   FALSE},</a>
<a name="ln330">  {(int)KE_MIDDLEDRAG,        MOUSE_MIDDLE,   FALSE,  TRUE},</a>
<a name="ln331">  {(int)KE_MIDDLERELEASE,     MOUSE_MIDDLE,   FALSE,  FALSE},</a>
<a name="ln332">  {(int)KE_RIGHTMOUSE,        MOUSE_RIGHT,    TRUE,   FALSE},</a>
<a name="ln333">  {(int)KE_RIGHTDRAG,         MOUSE_RIGHT,    FALSE,  TRUE},</a>
<a name="ln334">  {(int)KE_RIGHTRELEASE,      MOUSE_RIGHT,    FALSE,  FALSE},</a>
<a name="ln335">  {(int)KE_X1MOUSE,           MOUSE_X1,       TRUE,   FALSE},</a>
<a name="ln336">  {(int)KE_X1DRAG,            MOUSE_X1,       FALSE,  TRUE},</a>
<a name="ln337">  {(int)KE_X1RELEASE,         MOUSE_X1,       FALSE,  FALSE},</a>
<a name="ln338">  {(int)KE_X2MOUSE,           MOUSE_X2,       TRUE,   FALSE},</a>
<a name="ln339">  {(int)KE_X2DRAG,            MOUSE_X2,       FALSE,  TRUE},</a>
<a name="ln340">  {(int)KE_X2RELEASE,         MOUSE_X2,       FALSE,  FALSE},</a>
<a name="ln341">  /* DRAG without CLICK */</a>
<a name="ln342">  {(int)KE_IGNORE,            MOUSE_RELEASE,  FALSE,  TRUE},</a>
<a name="ln343">  /* RELEASE without CLICK */</a>
<a name="ln344">  {(int)KE_IGNORE,            MOUSE_RELEASE,  FALSE,  FALSE},</a>
<a name="ln345">  {0,                         0,              0,      0},</a>
<a name="ln346">};</a>
<a name="ln347"> </a>
<a name="ln348">/// Return the modifier mask bit (#MOD_MASK_*) corresponding to mod name</a>
<a name="ln349">///</a>
<a name="ln350">/// E.g. 'S' for shift, 'C' for ctrl.</a>
<a name="ln351">int name_to_mod_mask(int c)</a>
<a name="ln352">  FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln353">{</a>
<a name="ln354">  c = TOUPPER_ASC(c);</a>
<a name="ln355">  for (size_t i = 0; mod_mask_table[i].mod_mask != 0; i++) {</a>
<a name="ln356">    if (c == mod_mask_table[i].name) {</a>
<a name="ln357">      return mod_mask_table[i].mod_flag;</a>
<a name="ln358">    }</a>
<a name="ln359">  }</a>
<a name="ln360">  return 0;</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363">/// Check if there is a special key code for &quot;key&quot; with specified modifiers</a>
<a name="ln364">///</a>
<a name="ln365">/// @param[in]  key  Initial key code.</a>
<a name="ln366">/// @param[in,out]  modifiers  Initial modifiers, is adjusted to have simplified</a>
<a name="ln367">///                            modifiers.</a>
<a name="ln368">///</a>
<a name="ln369">/// @return Simplified key code.</a>
<a name="ln370">int simplify_key(const int key, int *modifiers)</a>
<a name="ln371">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln372">{</a>
<a name="ln373">  if (*modifiers &amp; (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT)) {</a>
<a name="ln374">    // TAB is a special case.</a>
<a name="ln375">    if (key == TAB &amp;&amp; (*modifiers &amp; MOD_MASK_SHIFT)) {</a>
<a name="ln376">      *modifiers &amp;= ~MOD_MASK_SHIFT;</a>
<a name="ln377">      return K_S_TAB;</a>
<a name="ln378">    }</a>
<a name="ln379">    const int key0 = KEY2TERMCAP0(key);</a>
<a name="ln380">    const int key1 = KEY2TERMCAP1(key);</a>
<a name="ln381">    for (int i = 0; modifier_keys_table[i] != NUL; i += MOD_KEYS_ENTRY_SIZE) {</a>
<a name="ln382">      if (key0 == modifier_keys_table[i + 3]</a>
<a name="ln383">          &amp;&amp; key1 == modifier_keys_table[i + 4]</a>
<a name="ln384">          &amp;&amp; (*modifiers &amp; modifier_keys_table[i])) {</a>
<a name="ln385">        *modifiers &amp;= ~modifier_keys_table[i];</a>
<a name="ln386">        return TERMCAP2KEY(modifier_keys_table[i + 1],</a>
<a name="ln387">                           modifier_keys_table[i + 2]);</a>
<a name="ln388">      }</a>
<a name="ln389">    }</a>
<a name="ln390">  }</a>
<a name="ln391">  return key;</a>
<a name="ln392">}</a>
<a name="ln393"> </a>
<a name="ln394">/// Change &lt;xKey&gt; to &lt;Key&gt;</a>
<a name="ln395">int handle_x_keys(const int key)</a>
<a name="ln396">  FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln397">{</a>
<a name="ln398">  switch (key) {</a>
<a name="ln399">    case K_XUP:     return K_UP;</a>
<a name="ln400">    case K_XDOWN:   return K_DOWN;</a>
<a name="ln401">    case K_XLEFT:   return K_LEFT;</a>
<a name="ln402">    case K_XRIGHT:  return K_RIGHT;</a>
<a name="ln403">    case K_XHOME:   return K_HOME;</a>
<a name="ln404">    case K_ZHOME:   return K_HOME;</a>
<a name="ln405">    case K_XEND:    return K_END;</a>
<a name="ln406">    case K_ZEND:    return K_END;</a>
<a name="ln407">    case K_XF1:     return K_F1;</a>
<a name="ln408">    case K_XF2:     return K_F2;</a>
<a name="ln409">    case K_XF3:     return K_F3;</a>
<a name="ln410">    case K_XF4:     return K_F4;</a>
<a name="ln411">    case K_S_XF1:   return K_S_F1;</a>
<a name="ln412">    case K_S_XF2:   return K_S_F2;</a>
<a name="ln413">    case K_S_XF3:   return K_S_F3;</a>
<a name="ln414">    case K_S_XF4:   return K_S_F4;</a>
<a name="ln415">  }</a>
<a name="ln416">  return key;</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419">/*</a>
<a name="ln420"> * Return a string which contains the name of the given key when the given</a>
<a name="ln421"> * modifiers are down.</a>
<a name="ln422"> */</a>
<a name="ln423">char_u *get_special_key_name(int c, int modifiers)</a>
<a name="ln424">{</a>
<a name="ln425">  static char_u string[MAX_KEY_NAME_LEN + 1];</a>
<a name="ln426"> </a>
<a name="ln427">  int i, idx;</a>
<a name="ln428">  int table_idx;</a>
<a name="ln429">  char_u  *s;</a>
<a name="ln430"> </a>
<a name="ln431">  string[0] = '&lt;';</a>
<a name="ln432">  idx = 1;</a>
<a name="ln433"> </a>
<a name="ln434">  /* Key that stands for a normal character. */</a>
<a name="ln435">  if (IS_SPECIAL(c) &amp;&amp; KEY2TERMCAP0(c) == KS_KEY)</a>
<a name="ln436">    c = KEY2TERMCAP1(c);</a>
<a name="ln437"> </a>
<a name="ln438">  /*</a>
<a name="ln439">   * Translate shifted special keys into unshifted keys and set modifier.</a>
<a name="ln440">   * Same for CTRL and ALT modifiers.</a>
<a name="ln441">   */</a>
<a name="ln442">  if (IS_SPECIAL(c)) {</a>
<a name="ln443">    for (i = 0; modifier_keys_table[i] != 0; i += MOD_KEYS_ENTRY_SIZE)</a>
<a name="ln444">      if (       KEY2TERMCAP0(c) == (int)modifier_keys_table[i + 1]</a>
<a name="ln445">                 &amp;&amp; (int)KEY2TERMCAP1(c) == (int)modifier_keys_table[i + 2]) {</a>
<a name="ln446">        modifiers |= modifier_keys_table[i];</a>
<a name="ln447">        c = TERMCAP2KEY(modifier_keys_table[i + 3],</a>
<a name="ln448">            modifier_keys_table[i + 4]);</a>
<a name="ln449">        break;</a>
<a name="ln450">      }</a>
<a name="ln451">  }</a>
<a name="ln452"> </a>
<a name="ln453">  /* try to find the key in the special key table */</a>
<a name="ln454">  table_idx = find_special_key_in_table(c);</a>
<a name="ln455"> </a>
<a name="ln456">  /*</a>
<a name="ln457">   * When not a known special key, and not a printable character, try to</a>
<a name="ln458">   * extract modifiers.</a>
<a name="ln459">   */</a>
<a name="ln460">  if (c &gt; 0</a>
<a name="ln461">      &amp;&amp; (*mb_char2len)(c) == 1</a>
<a name="ln462">      ) {</a>
<a name="ln463">    if (table_idx &lt; 0</a>
<a name="ln464">        &amp;&amp; (!vim_isprintc(c) || (c &amp; 0x7f) == ' ')</a>
<a name="ln465">        &amp;&amp; (c &amp; 0x80)) {</a>
<a name="ln466">      c &amp;= 0x7f;</a>
<a name="ln467">      modifiers |= MOD_MASK_ALT;</a>
<a name="ln468">      /* try again, to find the un-alted key in the special key table */</a>
<a name="ln469">      table_idx = find_special_key_in_table(c);</a>
<a name="ln470">    }</a>
<a name="ln471">    if (table_idx &lt; 0 &amp;&amp; !vim_isprintc(c) &amp;&amp; c &lt; ' ') {</a>
<a name="ln472">      c += '@';</a>
<a name="ln473">      modifiers |= MOD_MASK_CTRL;</a>
<a name="ln474">    }</a>
<a name="ln475">  }</a>
<a name="ln476"> </a>
<a name="ln477">  /* translate the modifier into a string */</a>
<a name="ln478">  for (i = 0; mod_mask_table[i].name != 'A'; i++)</a>
<a name="ln479">    if ((modifiers &amp; mod_mask_table[i].mod_mask)</a>
<a name="ln480">        == mod_mask_table[i].mod_flag) {</a>
<a name="ln481">      string[idx++] = mod_mask_table[i].name;</a>
<a name="ln482">      string[idx++] = (char_u)'-';</a>
<a name="ln483">    }</a>
<a name="ln484"> </a>
<a name="ln485">  if (table_idx &lt; 0) {          /* unknown special key, may output t_xx */</a>
<a name="ln486">    if (IS_SPECIAL(c)) {</a>
<a name="ln487">      string[idx++] = 't';</a>
<a name="ln488">      string[idx++] = '_';</a>
<a name="ln489">      string[idx++] = (char_u)KEY2TERMCAP0(c);</a>
<a name="ln490">      string[idx++] = KEY2TERMCAP1(c);</a>
<a name="ln491">    } else {</a>
<a name="ln492">      // Not a special key, only modifiers, output directly.</a>
<a name="ln493">      if (utf_char2len(c) &gt; 1) {</a>
<a name="ln494">        idx += utf_char2bytes(c, string + idx);</a>
<a name="ln495">      } else if (vim_isprintc(c)) {</a>
<a name="ln496">        string[idx++] = (char_u)c;</a>
<a name="ln497">      } else {</a>
<a name="ln498">        s = transchar(c);</a>
<a name="ln499">        while (*s)</a>
<a name="ln500">          string[idx++] = *s++;</a>
<a name="ln501">      }</a>
<a name="ln502">    }</a>
<a name="ln503">  } else {            // use name of special key</a>
<a name="ln504">    size_t len = STRLEN(key_names_table[table_idx].name);</a>
<a name="ln505"> </a>
<a name="ln506">    if ((int)len + idx + 2 &lt;= MAX_KEY_NAME_LEN) {</a>
<a name="ln507">        STRCPY(string + idx, key_names_table[table_idx].name);</a>
<a name="ln508">        idx += (int)len;</a>
<a name="ln509">    }</a>
<a name="ln510">  }</a>
<a name="ln511">  string[idx++] = '&gt;';</a>
<a name="ln512">  string[idx] = NUL;</a>
<a name="ln513">  return string;</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516">/// Try translating a &lt;&gt; name (&quot;keycode&quot;).</a>
<a name="ln517">///</a>
<a name="ln518">/// @param[in,out]  srcp  Source from which &lt;&gt; are translated. Is advanced to</a>
<a name="ln519">///                       after the &lt;&gt; name if there is a match.</a>
<a name="ln520">/// @param[in]  src_len  Length of the srcp.</a>
<a name="ln521">/// @param[out]  dst  Location where translation result will be kept. It must</a>
<a name="ln522">//                    be at least 19 bytes per &quot;&lt;x&gt;&quot; form.</a>
<a name="ln523">/// @param[in]  keycode  Prefer key code, e.g. K_DEL in place of DEL.</a>
<a name="ln524">/// @param[in]  in_string  Inside a double quoted string</a>
<a name="ln525">///</a>
<a name="ln526">/// @return Number of characters added to dst, zero for no match.</a>
<a name="ln527">unsigned int trans_special(const char_u **srcp, const size_t src_len,</a>
<a name="ln528">                           char_u *const dst, const bool keycode,</a>
<a name="ln529">                           const bool in_string)</a>
<a name="ln530">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln531">{</a>
<a name="ln532">  int modifiers = 0;</a>
<a name="ln533">  int key;</a>
<a name="ln534"> </a>
<a name="ln535">  key = find_special_key(srcp, src_len, &amp;modifiers, keycode, false, in_string);</a>
<a name="ln536">  if (key == 0) {</a>
<a name="ln537">    return 0;</a>
<a name="ln538">  }</a>
<a name="ln539"> </a>
<a name="ln540">  return special_to_buf(key, modifiers, keycode, dst);</a>
<a name="ln541">}</a>
<a name="ln542"> </a>
<a name="ln543">/// Put the character sequence for &quot;key&quot; with &quot;modifiers&quot; into &quot;dst&quot; and return</a>
<a name="ln544">/// the resulting length.</a>
<a name="ln545">/// When &quot;keycode&quot; is TRUE prefer key code, e.g. K_DEL instead of DEL.</a>
<a name="ln546">/// The sequence is not NUL terminated.</a>
<a name="ln547">/// This is how characters in a string are encoded.</a>
<a name="ln548">unsigned int special_to_buf(int key, int modifiers, bool keycode, char_u *dst)</a>
<a name="ln549">{</a>
<a name="ln550">  unsigned int dlen = 0;</a>
<a name="ln551"> </a>
<a name="ln552">  // Put the appropriate modifier in a string.</a>
<a name="ln553">  if (modifiers != 0) {</a>
<a name="ln554">    dst[dlen++] = K_SPECIAL;</a>
<a name="ln555">    dst[dlen++] = KS_MODIFIER;</a>
<a name="ln556">    dst[dlen++] = (char_u)modifiers;</a>
<a name="ln557">  }</a>
<a name="ln558"> </a>
<a name="ln559">  if (IS_SPECIAL(key)) {</a>
<a name="ln560">    dst[dlen++] = K_SPECIAL;</a>
<a name="ln561">    dst[dlen++] = (char_u)KEY2TERMCAP0(key);</a>
<a name="ln562">    dst[dlen++] = KEY2TERMCAP1(key);</a>
<a name="ln563">  } else if (!keycode) {</a>
<a name="ln564">    dlen += (unsigned int)utf_char2bytes(key, dst + dlen);</a>
<a name="ln565">  } else {</a>
<a name="ln566">    char_u *after = add_char2buf(key, dst + dlen);</a>
<a name="ln567">    assert(after &gt;= dst &amp;&amp; (uintmax_t)(after - dst) &lt;= UINT_MAX);</a>
<a name="ln568">    dlen = (unsigned int)(after - dst);</a>
<a name="ln569">  }</a>
<a name="ln570"> </a>
<a name="ln571">  return dlen;</a>
<a name="ln572">}</a>
<a name="ln573"> </a>
<a name="ln574">/// Try translating a &lt;&gt; name</a>
<a name="ln575">///</a>
<a name="ln576">/// @param[in,out]  srcp  Translated &lt;&gt; name. Is advanced to after the &lt;&gt; name.</a>
<a name="ln577">/// @param[in]  src_len  srcp length.</a>
<a name="ln578">/// @param[out]  modp  Location where information about modifiers is saved.</a>
<a name="ln579">/// @param[in]  keycode  Prefer key code, e.g. K_DEL in place of DEL.</a>
<a name="ln580">/// @param[in]  keep_x_key  Don’t translate xHome to Home key.</a>
<a name="ln581">/// @param[in]  in_string  In string, double quote is escaped</a>
<a name="ln582">///</a>
<a name="ln583">/// @return Key and modifiers or 0 if there is no match.</a>
<a name="ln584">int find_special_key(const char_u **srcp, const size_t src_len, int *const modp,</a>
<a name="ln585">                     const bool keycode, const bool keep_x_key,</a>
<a name="ln586">                     const bool in_string)</a>
<a name="ln587">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln588">{</a>
<a name="ln589">  const char_u *last_dash;</a>
<a name="ln590">  const char_u *end_of_name;</a>
<a name="ln591">  const char_u *src;</a>
<a name="ln592">  const char_u *bp;</a>
<a name="ln593">  const char_u *const end = *srcp + src_len - 1;</a>
<a name="ln594">  int modifiers;</a>
<a name="ln595">  int bit;</a>
<a name="ln596">  int key;</a>
<a name="ln597">  uvarnumber_T n;</a>
<a name="ln598">  int l;</a>
<a name="ln599"> </a>
<a name="ln600">  if (src_len == 0) {</a>
<a name="ln601">    return 0;</a>
<a name="ln602">  }</a>
<a name="ln603"> </a>
<a name="ln604">  src = *srcp;</a>
<a name="ln605">  if (src[0] != '&lt;') {</a>
<a name="ln606">    return 0;</a>
<a name="ln607">  }</a>
<a name="ln608"> </a>
<a name="ln609">  // Find end of modifier list</a>
<a name="ln610">  last_dash = src;</a>
<a name="ln611">  for (bp = src + 1; bp &lt;= end &amp;&amp; (*bp == '-' || ascii_isident(*bp)); bp++) {</a>
<a name="ln612">    if (*bp == '-') {</a>
<a name="ln613">      last_dash = bp;</a>
<a name="ln614">      if (bp + 1 &lt;= end) {</a>
<a name="ln615">        l = utfc_ptr2len_len(bp + 1, (int)(end - bp) + 1);</a>
<a name="ln616">        // Anything accepted, like &lt;C-?&gt;.</a>
<a name="ln617">        // &lt;C-&quot;&gt; or &lt;M-&quot;&gt; are not special in strings as &quot; is</a>
<a name="ln618">        // the string delimiter. With a backslash it works: &lt;M-\&quot;&gt;</a>
<a name="ln619">        if (end - bp &gt; l &amp;&amp; !(in_string &amp;&amp; bp[1] == '&quot;') &amp;&amp; bp[l+1] == '&gt;') {</a>
<a name="ln620">          bp += l;</a>
<a name="ln621">        } else if (end - bp &gt; 2 &amp;&amp; in_string &amp;&amp; bp[1] == '\\'</a>
<a name="ln622">                   &amp;&amp; bp[2] == '&quot;' &amp;&amp; bp[3] == '&gt;') {</a>
<a name="ln623">          bp += 2;</a>
<a name="ln624">        }</a>
<a name="ln625">      }</a>
<a name="ln626">    }</a>
<a name="ln627">    if (end - bp &gt; 3 &amp;&amp; bp[0] == 't' &amp;&amp; bp[1] == '_') {</a>
<a name="ln628">      bp += 3;  // skip t_xx, xx may be '-' or '&gt;'</a>
<a name="ln629">    } else if (end - bp &gt; 4 &amp;&amp; STRNICMP(bp, &quot;char-&quot;, 5) == 0) {</a>
<a name="ln630">      vim_str2nr(bp + 5, NULL, &amp;l, STR2NR_ALL, NULL, NULL, 0);</a>
<a name="ln631">      bp += l + 5;</a>
<a name="ln632">      break;</a>
<a name="ln633">    }</a>
<a name="ln634">  }</a>
<a name="ln635"> </a>
<a name="ln636">  if (bp &lt;= end &amp;&amp; *bp == '&gt;') {  // found matching '&gt;'</a>
<a name="ln637">    end_of_name = bp + 1;</a>
<a name="ln638"> </a>
<a name="ln639">    /* Which modifiers are given? */</a>
<a name="ln640">    modifiers = 0x0;</a>
<a name="ln641">    for (bp = src + 1; bp &lt; last_dash; bp++) {</a>
<a name="ln642">      if (*bp != '-') {</a>
<a name="ln643">        bit = name_to_mod_mask(*bp);</a>
<a name="ln644">        if (bit == 0x0) {</a>
<a name="ln645">          break;                // Illegal modifier name</a>
<a name="ln646">        }</a>
<a name="ln647">        modifiers |= bit;</a>
<a name="ln648">      }</a>
<a name="ln649">    }</a>
<a name="ln650"> </a>
<a name="ln651">    // Legal modifier name.</a>
<a name="ln652">    if (bp &gt;= last_dash) {</a>
<a name="ln653">      if (STRNICMP(last_dash + 1, &quot;char-&quot;, 5) == 0</a>
<a name="ln654">          &amp;&amp; ascii_isdigit(last_dash[6])) {</a>
<a name="ln655">        // &lt;Char-123&gt; or &lt;Char-033&gt; or &lt;Char-0x33&gt;</a>
<a name="ln656">        vim_str2nr(last_dash + 6, NULL, NULL, STR2NR_ALL, NULL, &amp;n, 0);</a>
<a name="ln657">        key = (int)n;</a>
<a name="ln658">      } else {</a>
<a name="ln659">        int off = 1;</a>
<a name="ln660"> </a>
<a name="ln661">        // Modifier with single letter, or special key name.</a>
<a name="ln662">        if (in_string &amp;&amp; last_dash[1] == '\\' &amp;&amp; last_dash[2] == '&quot;') {</a>
<a name="ln663">          // Special case for a double-quoted string</a>
<a name="ln664">          off = l = 2;</a>
<a name="ln665">        } else {</a>
<a name="ln666">          l = mb_ptr2len(last_dash + 1);</a>
<a name="ln667">        }</a>
<a name="ln668">        if (modifiers != 0 &amp;&amp; last_dash[l + 1] == '&gt;') {</a>
<a name="ln669">          key = PTR2CHAR(last_dash + off);</a>
<a name="ln670">        } else {</a>
<a name="ln671">          key = get_special_key_code(last_dash + off);</a>
<a name="ln672">          if (!keep_x_key) {</a>
<a name="ln673">            key = handle_x_keys(key);</a>
<a name="ln674">          }</a>
<a name="ln675">        }</a>
<a name="ln676">      }</a>
<a name="ln677"> </a>
<a name="ln678">      // get_special_key_code() may return NUL for invalid</a>
<a name="ln679">      // special key name.</a>
<a name="ln680">      if (key != NUL) {</a>
<a name="ln681">        // Only use a modifier when there is no special key code that</a>
<a name="ln682">        // includes the modifier.</a>
<a name="ln683">        key = simplify_key(key, &amp;modifiers);</a>
<a name="ln684"> </a>
<a name="ln685">        if (!keycode) {</a>
<a name="ln686">          // don't want keycode, use single byte code</a>
<a name="ln687">          if (key == K_BS) {</a>
<a name="ln688">            key = BS;</a>
<a name="ln689">          } else if (key == K_DEL || key == K_KDEL) {</a>
<a name="ln690">            key = DEL;</a>
<a name="ln691">          }</a>
<a name="ln692">        }</a>
<a name="ln693"> </a>
<a name="ln694">        // Normal Key with modifier:</a>
<a name="ln695">        // Try to make a single byte code (except for Alt/Meta modifiers).</a>
<a name="ln696">        if (!IS_SPECIAL(key)) {</a>
<a name="ln697">          key = extract_modifiers(key, &amp;modifiers);</a>
<a name="ln698">        }</a>
<a name="ln699"> </a>
<a name="ln700">        *modp = modifiers;</a>
<a name="ln701">        *srcp = end_of_name;</a>
<a name="ln702">        return key;</a>
<a name="ln703">      }  // else { ELOG(&quot;unknown key: '%s'&quot;, src); }</a>
<a name="ln704">    }</a>
<a name="ln705">  }</a>
<a name="ln706">  return 0;</a>
<a name="ln707">}</a>
<a name="ln708"> </a>
<a name="ln709">/// Try to include modifiers (except alt/meta) in the key.</a>
<a name="ln710">/// Changes &quot;Shift-a&quot; to 'A', &quot;Ctrl-@&quot; to &lt;Nul&gt;, etc.</a>
<a name="ln711">static int extract_modifiers(int key, int *modp)</a>
<a name="ln712">{</a>
<a name="ln713">  int modifiers = *modp;</a>
<a name="ln714"> </a>
<a name="ln715">  // Command-key and ctrl are special</a>
<a name="ln716">  if (!(modifiers &amp; MOD_MASK_CMD) &amp;&amp; !(modifiers &amp; MOD_MASK_CTRL)) {</a>
<a name="ln717">    if ((modifiers &amp; MOD_MASK_SHIFT) &amp;&amp; ASCII_ISALPHA(key)) {</a>
<a name="ln718">      key = TOUPPER_ASC(key);</a>
<a name="ln719">      modifiers &amp;= ~MOD_MASK_SHIFT;</a>
<a name="ln720">    }</a>
<a name="ln721">  }</a>
<a name="ln722">  if ((modifiers &amp; MOD_MASK_CTRL)</a>
<a name="ln723">      &amp;&amp; ((key &gt;= '?' &amp;&amp; key &lt;= '_') || ASCII_ISALPHA(key))) {</a>
<a name="ln724">    key = Ctrl_chr(key);</a>
<a name="ln725">    modifiers &amp;= ~MOD_MASK_CTRL;</a>
<a name="ln726">    if (key == 0) {  // &lt;C-@&gt; is &lt;Nul&gt;</a>
<a name="ln727">      key = K_ZERO;</a>
<a name="ln728">    }</a>
<a name="ln729">  }</a>
<a name="ln730"> </a>
<a name="ln731">  *modp = modifiers;</a>
<a name="ln732">  return key;</a>
<a name="ln733">}</a>
<a name="ln734"> </a>
<a name="ln735">/*</a>
<a name="ln736"> * Try to find key &quot;c&quot; in the special key table.</a>
<a name="ln737"> * Return the index when found, -1 when not found.</a>
<a name="ln738"> */</a>
<a name="ln739">int find_special_key_in_table(int c)</a>
<a name="ln740">{</a>
<a name="ln741">  int i;</a>
<a name="ln742"> </a>
<a name="ln743">  for (i = 0; key_names_table[i].name != NULL; i++) {</a>
<a name="ln744">    if (c == key_names_table[i].key) {</a>
<a name="ln745">      break;</a>
<a name="ln746">    }</a>
<a name="ln747">  }</a>
<a name="ln748">  if (key_names_table[i].name == NULL) {</a>
<a name="ln749">    i = -1;</a>
<a name="ln750">  }</a>
<a name="ln751">  return i;</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754">/// Find the special key with the given name</a>
<a name="ln755">///</a>
<a name="ln756">/// @param[in]  name  Name of the special. Does not have to end with NUL, it is</a>
<a name="ln757">///                   assumed to end before the first non-idchar. If name starts</a>
<a name="ln758">///                   with &quot;t_&quot; the next two characters are interpreted as</a>
<a name="ln759">///                   a termcap name.</a>
<a name="ln760">///</a>
<a name="ln761">/// @return Key code or 0 if not found.</a>
<a name="ln762">int get_special_key_code(const char_u *name)</a>
<a name="ln763">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln764">{</a>
<a name="ln765">  for (int i = 0; key_names_table[i].name != NULL; i++) {</a>
<a name="ln766">    const char *const table_name = key_names_table[i].name;</a>
<a name="ln767">    int j;</a>
<a name="ln768">    for (j = 0; ascii_isident(name[j]) &amp;&amp; table_name[j] != NUL; j++) {</a>
<a name="ln769">      if (TOLOWER_ASC(table_name[j]) != TOLOWER_ASC(name[j])) {</a>
<a name="ln770">        break;</a>
<a name="ln771">      }</a>
<a name="ln772">    }</a>
<a name="ln773">    if (!ascii_isident(name[j]) &amp;&amp; table_name[j] == NUL) {</a>
<a name="ln774">      return key_names_table[i].key;</a>
<a name="ln775">    }</a>
<a name="ln776">  }</a>
<a name="ln777"> </a>
<a name="ln778">  return 0;</a>
<a name="ln779">}</a>
<a name="ln780"> </a>
<a name="ln781">/*</a>
<a name="ln782"> * Look up the given mouse code to return the relevant information in the other</a>
<a name="ln783"> * arguments.  Return which button is down or was released.</a>
<a name="ln784"> */</a>
<a name="ln785">int get_mouse_button(int code, bool *is_click, bool *is_drag)</a>
<a name="ln786">{</a>
<a name="ln787">  int i;</a>
<a name="ln788"> </a>
<a name="ln789">  for (i = 0; mouse_table[i].pseudo_code; i++)</a>
<a name="ln790">    if (code == mouse_table[i].pseudo_code) {</a>
<a name="ln791">      *is_click = mouse_table[i].is_click;</a>
<a name="ln792">      *is_drag = mouse_table[i].is_drag;</a>
<a name="ln793">      return mouse_table[i].button;</a>
<a name="ln794">    }</a>
<a name="ln795">  return 0;         /* Shouldn't get here */</a>
<a name="ln796">}</a>
<a name="ln797"> </a>
<a name="ln798">/// Replace any terminal code strings with the equivalent internal</a>
<a name="ln799">/// representation</a>
<a name="ln800">///</a>
<a name="ln801">/// Used for the &quot;from&quot; and &quot;to&quot; part of a mapping, and the &quot;to&quot; part of</a>
<a name="ln802">/// a menu command. Any strings like &quot;&lt;C-UP&gt;&quot; are also replaced, unless</a>
<a name="ln803">/// `special` is false. K_SPECIAL by itself is replaced by K_SPECIAL</a>
<a name="ln804">/// KS_SPECIAL KE_FILLER.</a>
<a name="ln805">///</a>
<a name="ln806">/// @param[in]  from  What characters to replace.</a>
<a name="ln807">/// @param[in]  from_len  Length of the &quot;from&quot; argument.</a>
<a name="ln808">/// @param[out]  bufp  Location where results were saved in case of success</a>
<a name="ln809">///                    (allocated). Will be set to NULL in case of failure.</a>
<a name="ln810">/// @param[in]  do_lt  If true, also translate &lt;lt&gt;.</a>
<a name="ln811">/// @param[in]  from_part  If true, trailing &lt;C-v&gt; is included, otherwise it is</a>
<a name="ln812">///                        removed (to make &quot;:map xx ^V&quot; map xx to nothing).</a>
<a name="ln813">///                        When cpo_flags contains #FLAG_CPO_BSLASH, a backslash</a>
<a name="ln814">///                        can be used in place of &lt;C-v&gt;. All other &lt;C-v&gt;</a>
<a name="ln815">///                        characters are removed.</a>
<a name="ln816">/// @param[in]  special    Replace keycodes, e.g. &lt;CR&gt; becomes a &quot;\n&quot; char.</a>
<a name="ln817">/// @param[in]  cpo_flags  Relevant flags derived from p_cpo, see</a>
<a name="ln818">///                        #CPO_TO_CPO_FLAGS.</a>
<a name="ln819">///</a>
<a name="ln820">/// @return Pointer to an allocated memory in case of success, &quot;from&quot; in case of</a>
<a name="ln821">///         failure. In case of success returned pointer is also saved to</a>
<a name="ln822">///         &quot;bufp&quot;.</a>
<a name="ln823">char_u *replace_termcodes(const char_u *from, const size_t from_len,</a>
<a name="ln824">                          char_u **bufp, const bool from_part, const bool do_lt,</a>
<a name="ln825">                          const bool special, int cpo_flags)</a>
<a name="ln826">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln827">{</a>
<a name="ln828">  ssize_t i;</a>
<a name="ln829">  size_t slen;</a>
<a name="ln830">  char_u key;</a>
<a name="ln831">  size_t dlen = 0;</a>
<a name="ln832">  const char_u *src;</a>
<a name="ln833">  const char_u *const end = from + from_len - 1;</a>
<a name="ln834">  int do_backslash;             // backslash is a special character</a>
<a name="ln835">  char_u      *result;          // buffer for resulting string</a>
<a name="ln836"> </a>
<a name="ln837">  do_backslash = !(cpo_flags&amp;FLAG_CPO_BSLASH);</a>
<a name="ln838"> </a>
<a name="ln839">  // Allocate space for the translation.  Worst case a single character is</a>
<a name="ln840">  // replaced by 6 bytes (shifted special key), plus a NUL at the end.</a>
<a name="ln841">  const size_t buf_len = from_len * 6 + 1;</a>
<a name="ln842">  result = xmalloc(buf_len);</a>
<a name="ln843"> </a>
<a name="ln844">  src = from;</a>
<a name="ln845"> </a>
<a name="ln846">  // Check for #n at start only: function key n</a>
<a name="ln847">  if (from_part &amp;&amp; from_len &gt; 1 &amp;&amp; src[0] == '#'</a>
<a name="ln848">      &amp;&amp; ascii_isdigit(src[1])) {  // function key</a>
<a name="ln849">    result[dlen++] = K_SPECIAL;</a>
<a name="ln850">    result[dlen++] = 'k';</a>
<a name="ln851">    if (src[1] == '0') {</a>
<a name="ln852">      result[dlen++] = ';';     // #0 is F10 is &quot;k;&quot;</a>
<a name="ln853">    } else {</a>
<a name="ln854">      result[dlen++] = src[1];  // #3 is F3 is &quot;k3&quot;</a>
<a name="ln855">    }</a>
<a name="ln856">    src += 2;</a>
<a name="ln857">  }</a>
<a name="ln858"> </a>
<a name="ln859">  // Copy each byte from *from to result[dlen]</a>
<a name="ln860">  while (src &lt;= end) {</a>
<a name="ln861">    // Check for special &lt;&gt; keycodes, like &quot;&lt;C-S-LeftMouse&gt;&quot;</a>
<a name="ln862">    if (special &amp;&amp; (do_lt || ((end - src) &gt;= 3</a>
<a name="ln863">                              &amp;&amp; STRNCMP(src, &quot;&lt;lt&gt;&quot;, 4) != 0))) {</a>
<a name="ln864">      // Replace &lt;SID&gt; by K_SNR &lt;script-nr&gt; _.</a>
<a name="ln865">      // (room: 5 * 6 = 30 bytes; needed: 3 + &lt;nr&gt; + 1 &lt;= 14)</a>
<a name="ln866">      if (end - src &gt;= 4 &amp;&amp; STRNICMP(src, &quot;&lt;SID&gt;&quot;, 5) == 0) {</a>
<a name="ln867">        if (current_sctx.sc_sid &lt;= 0) {</a>
<a name="ln868">          EMSG(_(e_usingsid));</a>
<a name="ln869">        } else {</a>
<a name="ln870">          src += 5;</a>
<a name="ln871">          result[dlen++] = K_SPECIAL;</a>
<a name="ln872">          result[dlen++] = (int)KS_EXTRA;</a>
<a name="ln873">          result[dlen++] = (int)KE_SNR;</a>
<a name="ln874">          snprintf((char *)result + dlen, buf_len - dlen, &quot;%&quot; PRId64,</a>
<a name="ln875">                   (int64_t)current_sctx.sc_sid);</a>
<a name="ln876">          dlen += STRLEN(result + dlen);</a>
<a name="ln877">          result[dlen++] = '_';</a>
<a name="ln878">          continue;</a>
<a name="ln879">        }</a>
<a name="ln880">      }</a>
<a name="ln881"> </a>
<a name="ln882">      slen = trans_special(&amp;src, (size_t)(end - src) + 1, result + dlen, true,</a>
<a name="ln883">                           false);</a>
<a name="ln884">      if (slen) {</a>
<a name="ln885">        dlen += slen;</a>
<a name="ln886">        continue;</a>
<a name="ln887">      }</a>
<a name="ln888">    }</a>
<a name="ln889"> </a>
<a name="ln890">    if (special) {</a>
<a name="ln891">      char_u  *p, *s, len;</a>
<a name="ln892"> </a>
<a name="ln893">      // Replace &lt;Leader&gt; by the value of &quot;mapleader&quot;.</a>
<a name="ln894">      // Replace &lt;LocalLeader&gt; by the value of &quot;maplocalleader&quot;.</a>
<a name="ln895">      // If &quot;mapleader&quot; or &quot;maplocalleader&quot; isn't set use a backslash.</a>
<a name="ln896">      if (end - src &gt;= 7 &amp;&amp; STRNICMP(src, &quot;&lt;Leader&gt;&quot;, 8) == 0) {</a>
<a name="ln897">        len = 8;</a>
<a name="ln898">        p = get_var_value(&quot;g:mapleader&quot;);</a>
<a name="ln899">      } else if (end - src &gt;= 12 &amp;&amp; STRNICMP(src, &quot;&lt;LocalLeader&gt;&quot;, 13) == 0) {</a>
<a name="ln900">        len = 13;</a>
<a name="ln901">        p = get_var_value(&quot;g:maplocalleader&quot;);</a>
<a name="ln902">      } else {</a>
<a name="ln903">        len = 0;</a>
<a name="ln904">        p = NULL;</a>
<a name="ln905">      }</a>
<a name="ln906"> </a>
<a name="ln907">      if (len != 0) {</a>
<a name="ln908">        // Allow up to 8 * 6 characters for &quot;mapleader&quot;.</a>
<a name="ln909">        if (p == NULL || *p == NUL || STRLEN(p) &gt; 8 * 6) {</a>
<a name="ln910">          s = (char_u *)&quot;\\&quot;;</a>
<a name="ln911">        } else {</a>
<a name="ln912">          s = p;</a>
<a name="ln913">        }</a>
<a name="ln914">        while (*s != NUL) {</a>
<a name="ln915">          result[dlen++] = *s++;</a>
<a name="ln916">        }</a>
<a name="ln917">        src += len;</a>
<a name="ln918">        continue;</a>
<a name="ln919">      }</a>
<a name="ln920">    }</a>
<a name="ln921"> </a>
<a name="ln922">    // Remove CTRL-V and ignore the next character.</a>
<a name="ln923">    // For &quot;from&quot; side the CTRL-V at the end is included, for the &quot;to&quot;</a>
<a name="ln924">    // part it is removed.</a>
<a name="ln925">    // If 'cpoptions' does not contain 'B', also accept a backslash.</a>
<a name="ln926">    key = *src;</a>
<a name="ln927">    if (key == Ctrl_V || (do_backslash &amp;&amp; key == '\\')) {</a>
<a name="ln928">      src++;  // skip CTRL-V or backslash</a>
<a name="ln929">      if (src &gt; end) {</a>
<a name="ln930">        if (from_part) {</a>
<a name="ln931">          result[dlen++] = key;</a>
<a name="ln932">        }</a>
<a name="ln933">        break;</a>
<a name="ln934">      }</a>
<a name="ln935">    }</a>
<a name="ln936"> </a>
<a name="ln937">    // skip multibyte char correctly</a>
<a name="ln938">    for (i = utfc_ptr2len_len(src, (int)(end - src) + 1); i &gt; 0; i--) {</a>
<a name="ln939">      // If the character is K_SPECIAL, replace it with K_SPECIAL</a>
<a name="ln940">      // KS_SPECIAL KE_FILLER.</a>
<a name="ln941">      // If compiled with the GUI replace CSI with K_CSI.</a>
<a name="ln942">      if (*src == K_SPECIAL) {</a>
<a name="ln943">        result[dlen++] = K_SPECIAL;</a>
<a name="ln944">        result[dlen++] = KS_SPECIAL;</a>
<a name="ln945">        result[dlen++] = KE_FILLER;</a>
<a name="ln946">      } else {</a>
<a name="ln947">        result[dlen++] = *src;</a>
<a name="ln948">      }</a>
<a name="ln949">      ++src;</a>
<a name="ln950">    }</a>
<a name="ln951">  }</a>
<a name="ln952">  result[dlen] = NUL;</a>
<a name="ln953"> </a>
<a name="ln954">  *bufp = xrealloc(result, dlen + 1);</a>
<a name="ln955"> </a>
<a name="ln956">  return *bufp;</a>
<a name="ln957">}</a>
<a name="ln958"> </a>
<a name="ln959">/// Logs a single key as a human-readable keycode.</a>
<a name="ln960">void log_key(int log_level, int key)</a>
<a name="ln961">{</a>
<a name="ln962">  if (log_level &lt; MIN_LOG_LEVEL) {</a>
<a name="ln963">    return;</a>
<a name="ln964">  }</a>
<a name="ln965">  char *keyname = key == K_EVENT</a>
<a name="ln966">    ? &quot;K_EVENT&quot;</a>
<a name="ln967">    : (char *)get_special_key_name(key, mod_mask);</a>
<a name="ln968">  LOG(log_level, &quot;input: %s&quot;, keyname);</a>
<a name="ln969">}</a>

</code></pre>
<div class="balloon" rel="672"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'key' should be checked here.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
